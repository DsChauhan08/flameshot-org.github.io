{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flameshot developer docs # Thank you for your interest in developing flameshot. This developer documentation (hopefully) has an intuitive structure. It tries to describe what code is run when a user performs an action in Flameshot. Important Please read this entire page. It will make your life a whole lot easier when contributing to Flameshot. If you know exactly what you want to work on, you should look at FAQ Project structure # Flameshot is built on C++/Qt5 with CMake as its build system. The source code is located under src/ . The entrypoint is src/main.cpp . main.cpp # Flameshot provides both a GUI and a CLI (the latter currently works only on Linux and macOS). Build system # The main cmake file is CMakeLists.txt in the project root. It include s some files from the cmake/ directory as well. These files together control some more general aspects of the build process, like project information, packaging, caching etc. There is also the file src/CMakeLists.txt . It mostly defines how the source files are compiled into targets and how the external libraries are linked. It does some other stuff too. Currently, there isn't a clear separation of concerns between CMakeLists.txt and src/CMakeLists.txt . In the future we should refactor these files to make it more clear why each of them exists. What happens when I launch flameshot? # There are two ways to launch flameshot: daemon mode and single-action mode. In both modes, an instance of Flameshot is created via Flameshot::start() . Flameshot provides the high level API for interacting with flameshot; and its methods mimic the CLI subcommands a great deal. This object is a singleton, so it can only be created once. It is accessed as Flameshot::instance() . Note On Windows, only daemon mode is currently supported. Single-action mode (via command line interface) # Single-action mode (also called one-off mode) is triggered when flameshot is launched with a command line argument - for example as flameshot gui . As its name implies, it performs a single action, such as \"take a screenshot interactively by opening a GUI\" or \"take a screenshot of the entire screen\", etc. Afterwards, Flameshot quits. Daemon mode # This mode is triggered when the flameshot command is launched. In this mode, a flameshot process is started in the background. A system tray is displayed if the user hasn't disabled it in the config. In addition to Flameshot::start() , if the current process is the daemon, it also calls FlameshotDaemon::start() during initialization. The daemon has the following purposes: Run in the background, wait for the user to press a hotkey, and perform corresponding action. This is true for Windows and macOS , but not for Linux . On Linux, hotkeys are meant to be handled by the desktop environment or equivalent. Provide a system tray that the user can click to initiate actions via context menu Periodically check for updates and notify the user Act as a host for persistent phenomena. Example: On X11 (linux), when a program inserts content into the clipboard, it must keep running so the content persists in the clipboard. Note All of the above are user-configurable. FlameshotDaemon # The class FlameshotDaemon handles all communication with the daemon. The class provides public static methods that are designed so that the caller does not need to know if the current process is a flameshot daemon or a single-action invocation of Flameshot. If the current process is the daemon, then the static methods of FlameshotDaemon will call the corresponding instance methods of the singleton. If not, the current process will communicate with the daemon process via D-Bus. Then, within the daemon process, those D-Bus calls will be translated into FlameshotDaemon instance method calls. Configuration # The configuration is handled by ConfigHandler . It is decoupled from any user interface, so it serves the configuration for both the GUI and CLI. All configuration settings recognized by the config files are defined as getters in this class. There are also setters for each setting, named as per the usual convention. For example, the setting savePath has a getter named savePath and a setter named setSavePath . Before working on a new config setting for flameshot, please read this FAQ entry . Within the class, we use a bit of macro magic to save ourselves some work and avoid boilerplate code when defining getters and setters. The best way to understand what is going on is to see the source code of utils/confighandler.h and utils/confighandler.cpp . Conventions # Always use &Class::signal and &Class::slot instead of SIGNAL(signal()) and SLOT(slot()) . This usually provides better code introspection and makes refactoring easier and less error-prone.","title":"Overview"},{"location":"#flameshot-developer-docs","text":"Thank you for your interest in developing flameshot. This developer documentation (hopefully) has an intuitive structure. It tries to describe what code is run when a user performs an action in Flameshot. Important Please read this entire page. It will make your life a whole lot easier when contributing to Flameshot. If you know exactly what you want to work on, you should look at FAQ","title":"Flameshot developer docs"},{"location":"#project-structure","text":"Flameshot is built on C++/Qt5 with CMake as its build system. The source code is located under src/ . The entrypoint is src/main.cpp .","title":"Project structure"},{"location":"#maincpp","text":"Flameshot provides both a GUI and a CLI (the latter currently works only on Linux and macOS).","title":"main.cpp"},{"location":"#build-system","text":"The main cmake file is CMakeLists.txt in the project root. It include s some files from the cmake/ directory as well. These files together control some more general aspects of the build process, like project information, packaging, caching etc. There is also the file src/CMakeLists.txt . It mostly defines how the source files are compiled into targets and how the external libraries are linked. It does some other stuff too. Currently, there isn't a clear separation of concerns between CMakeLists.txt and src/CMakeLists.txt . In the future we should refactor these files to make it more clear why each of them exists.","title":"Build system"},{"location":"#what-happens-when-i-launch-flameshot","text":"There are two ways to launch flameshot: daemon mode and single-action mode. In both modes, an instance of Flameshot is created via Flameshot::start() . Flameshot provides the high level API for interacting with flameshot; and its methods mimic the CLI subcommands a great deal. This object is a singleton, so it can only be created once. It is accessed as Flameshot::instance() . Note On Windows, only daemon mode is currently supported.","title":"What happens when I launch flameshot?"},{"location":"#single-action-mode-via-command-line-interface","text":"Single-action mode (also called one-off mode) is triggered when flameshot is launched with a command line argument - for example as flameshot gui . As its name implies, it performs a single action, such as \"take a screenshot interactively by opening a GUI\" or \"take a screenshot of the entire screen\", etc. Afterwards, Flameshot quits.","title":"Single-action mode (via command line interface)"},{"location":"#daemon-mode","text":"This mode is triggered when the flameshot command is launched. In this mode, a flameshot process is started in the background. A system tray is displayed if the user hasn't disabled it in the config. In addition to Flameshot::start() , if the current process is the daemon, it also calls FlameshotDaemon::start() during initialization. The daemon has the following purposes: Run in the background, wait for the user to press a hotkey, and perform corresponding action. This is true for Windows and macOS , but not for Linux . On Linux, hotkeys are meant to be handled by the desktop environment or equivalent. Provide a system tray that the user can click to initiate actions via context menu Periodically check for updates and notify the user Act as a host for persistent phenomena. Example: On X11 (linux), when a program inserts content into the clipboard, it must keep running so the content persists in the clipboard. Note All of the above are user-configurable.","title":"Daemon mode"},{"location":"#flameshotdaemon","text":"The class FlameshotDaemon handles all communication with the daemon. The class provides public static methods that are designed so that the caller does not need to know if the current process is a flameshot daemon or a single-action invocation of Flameshot. If the current process is the daemon, then the static methods of FlameshotDaemon will call the corresponding instance methods of the singleton. If not, the current process will communicate with the daemon process via D-Bus. Then, within the daemon process, those D-Bus calls will be translated into FlameshotDaemon instance method calls.","title":"FlameshotDaemon"},{"location":"#configuration","text":"The configuration is handled by ConfigHandler . It is decoupled from any user interface, so it serves the configuration for both the GUI and CLI. All configuration settings recognized by the config files are defined as getters in this class. There are also setters for each setting, named as per the usual convention. For example, the setting savePath has a getter named savePath and a setter named setSavePath . Before working on a new config setting for flameshot, please read this FAQ entry . Within the class, we use a bit of macro magic to save ourselves some work and avoid boilerplate code when defining getters and setters. The best way to understand what is going on is to see the source code of utils/confighandler.h and utils/confighandler.cpp .","title":"Configuration"},{"location":"#conventions","text":"Always use &Class::signal and &Class::slot instead of SIGNAL(signal()) and SLOT(slot()) . This usually provides better code introspection and makes refactoring easier and less error-prone.","title":"Conventions"},{"location":"debugging/","text":"Debugging # FLAMESHOT_DEBUG_CAPTURE # With this cmake variable set to ON , the flameshot capture GUI window won't bypass the window manager. This allows you to manipulate the capture GUI window like any other window while debugging. This can be useful if a debugging breakpoint is triggered while flameshot is in full screen mode. Without this variable, you might have trouble inspecting the code due to a frozen full-screen window. Usage: cmake -DFLAMESHOT_DEBUG_CAPTURE=ON ...","title":"Debugging"},{"location":"debugging/#debugging","text":"","title":"Debugging"},{"location":"debugging/#flameshot_debug_capture","text":"With this cmake variable set to ON , the flameshot capture GUI window won't bypass the window manager. This allows you to manipulate the capture GUI window like any other window while debugging. This can be useful if a debugging breakpoint is triggered while flameshot is in full screen mode. Without this variable, you might have trouble inspecting the code due to a frozen full-screen window. Usage: cmake -DFLAMESHOT_DEBUG_CAPTURE=ON ...","title":"FLAMESHOT_DEBUG_CAPTURE"},{"location":"docs/","text":"Maintaining the documentation # The narrative documentation is written in markdown and built into HTML using MkDocs , particularly the MkDocs material theme . The source code documentation is generated using Doxygen and adapted for MkDocs using MkDoxy (a tweaked custom fork of the original). The source code of this documentation can be found here . Tip In order to edit a page from the documentation, click the button in the top right corner of the page. Serving locally # To serve the documentation locally, run the make serve target in the docs/dev directory. Notes and conventions # When you add new files or rename existing files or section names, be sure to edit the nav property of mkdocs.yml . Always insert links as reference style links . This will make the docs source code more readable and make broken links more easily detectable and replaceable. Post-processing # There are some tweaks we make to the generated HTML documentation. We do that in the make build target, by running the post-process.sh script. To see what post-processing we do, see that file. For this reason, the version of the documentation served locally using make serve will not match the generated HTML documentation 100%. But those inconsistencies are few and minor. Dependencies # pip install \\ mkdocs \\ mkdocs-material \\ git+https://github.com/veracioux/mkdoxy@v1.0.0 Note We use a forked version of mkdoxy that can be found here , that fixes some annoying things from the original. Deployment # The developer documentation is served from the official Flameshot website flameshot.org . Here's how. The official website itself is served from this repo . That repo contains the user documentation. It's deployed using GitHub pages -- the served files can be found on the gh-pages branch of that repo. To make the developer docs available on the official site, we use a custom GitHub action in the flameshot repo to build and deploy this documentation into the docs/dev subdirectory of the gh-pages branch. Todo Create the action and link to it above :D Todo Mention the post-process steps","title":"Maintaining the documentation"},{"location":"docs/#maintaining-the-documentation","text":"The narrative documentation is written in markdown and built into HTML using MkDocs , particularly the MkDocs material theme . The source code documentation is generated using Doxygen and adapted for MkDocs using MkDoxy (a tweaked custom fork of the original). The source code of this documentation can be found here . Tip In order to edit a page from the documentation, click the button in the top right corner of the page.","title":"Maintaining the documentation"},{"location":"docs/#serving-locally","text":"To serve the documentation locally, run the make serve target in the docs/dev directory.","title":"Serving locally"},{"location":"docs/#notes-and-conventions","text":"When you add new files or rename existing files or section names, be sure to edit the nav property of mkdocs.yml . Always insert links as reference style links . This will make the docs source code more readable and make broken links more easily detectable and replaceable.","title":"Notes and conventions"},{"location":"docs/#post-processing","text":"There are some tweaks we make to the generated HTML documentation. We do that in the make build target, by running the post-process.sh script. To see what post-processing we do, see that file. For this reason, the version of the documentation served locally using make serve will not match the generated HTML documentation 100%. But those inconsistencies are few and minor.","title":"Post-processing"},{"location":"docs/#dependencies","text":"pip install \\ mkdocs \\ mkdocs-material \\ git+https://github.com/veracioux/mkdoxy@v1.0.0 Note We use a forked version of mkdoxy that can be found here , that fixes some annoying things from the original.","title":"Dependencies"},{"location":"docs/#deployment","text":"The developer documentation is served from the official Flameshot website flameshot.org . Here's how. The official website itself is served from this repo . That repo contains the user documentation. It's deployed using GitHub pages -- the served files can be found on the gh-pages branch of that repo. To make the developer docs available on the official site, we use a custom GitHub action in the flameshot repo to build and deploy this documentation into the docs/dev subdirectory of the gh-pages branch. Todo Create the action and link to it above :D Todo Mention the post-process steps","title":"Deployment"},{"location":"faq/","text":"FAQ # Todo Incomplete page. How do I create a new subcommand? # How do I add a new tool? # How do I add a new config setting? # How do I add a new export action? (@borgmanJeremy @mehrad This is my preferred terminology over final action, need consensus) #","title":"FAQ"},{"location":"faq/#faq","text":"Todo Incomplete page.","title":"FAQ"},{"location":"faq/#how-do-i-create-a-new-subcommand","text":"","title":"How do I create a new subcommand?"},{"location":"faq/#how-do-i-add-a-new-tool","text":"","title":"How do I add a new tool?"},{"location":"faq/#how-do-i-add-a-new-config-setting","text":"","title":"How do I add a new config setting?"},{"location":"faq/#how-do-i-add-a-new-export-action-borgmanjeremy-mehrad-this-is-my-preferred-terminology-over-final-action-need-consensus","text":"","title":"How do I add a new export action? (@borgmanJeremy @mehrad This is my preferred terminology over final action, need consensus)"},{"location":"flameshot/annotated/","text":"Class List # Here are the classes, structs, unions and interfaces with brief descriptions: namespace @103 namespace @2 namespace @57 namespace @61 namespace @67 namespace @85 namespace @91 class AbstractActionTool class AbstractLogger A class that allows you to log events to where they need to go. class AbstractPathTool class AbstractTwoPointTool class AcceptTool class AppLauncher class AppLauncherWidget class ArrowTool class Bool class BoundedInt class ButtonHandler class ButtonList class ButtonListView class CaptureButton struct CaptureContext class CaptureLauncher class CaptureRequest class CaptureToolButton class CaptureToolObjects class CaptureWidget class CircleCountTool class CircleTool class ClickableLabel class Color class ColorGrabWidget class ColorPicker class ColorPickerEditMode class ColorPickerEditor class ColorPickerWidget namespace ColorUtils class CommandArgument class CommandLineParser struct Node class CommandOption struct CompareAppByName class ConfigErrorDetails class ConfigHandler class ConfigResolver class ConfigWindow class CopyTool struct DesktopAppData struct DesktopFileParser class DesktopInfo class DraggableWidgetMaker class ExistingDir class ExitTool class ExtendedSlider class FileNameEditor class FileNameHandler class FilenamePattern class Flameshot class FlameshotDBusAdapter class FlameshotDaemon class GeneralConf class GlobalShortcutFilter namespace GlobalValues class History struct HistoryFileName class HoverEventFilter class ImageLabel class ImgUploadDialog class ImgUploaderBase class ImgUploaderManager class ImgUploaderTool class ImgurUploader class InfoWindow class InvertTool class KeySequence class LauncherItemDelegate class LineTool class LoadSpinner class LowerBoundedInt class MagnifierWidget class MarkerTool class ModificationCommand class MoveTool class NotificationWidget class NotifierBox class OrgFreedesktopPortalRequestInterface class OrientablePushButton class OverlayMessage Overlay a message in capture mode. namespace PathInfo class PencilTool class PinTool class PinWidget class PixelateTool class QGuiAppCurrentScreen class QSharedPointer class RectangleTool class RedoTool class Region class SaveFileExtension class SaveTool class ScreenGrabber class SelectionTool class SelectionWidget class SetShortcutDialog class ShortcutsWidget class SidePanelWidget class SizeDecreaseTool class SizeIncreaseTool class StrftimeChooserWidget class String class StyleOverride class SystemNotification struct TerminalApp class TerminalLauncher class TextConfig class TextTool class TextWidget class ToolFactory class TrayIcon class UIcolorEditor namespace Ui class UndoTool class UpdateNotificationWidget class UploadHistory class UploadLineItem class UserColors class UtilityPanel class ValueHandler Handles the value of a configuration option (abstract class). class VisualsEditor class WaylandUtils struct WinLnkFileParser namespace org namespace freedesktop namespace portal namespace strfparse","title":"Class List"},{"location":"flameshot/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace @103 namespace @2 namespace @57 namespace @61 namespace @67 namespace @85 namespace @91 class AbstractActionTool class AbstractLogger A class that allows you to log events to where they need to go. class AbstractPathTool class AbstractTwoPointTool class AcceptTool class AppLauncher class AppLauncherWidget class ArrowTool class Bool class BoundedInt class ButtonHandler class ButtonList class ButtonListView class CaptureButton struct CaptureContext class CaptureLauncher class CaptureRequest class CaptureToolButton class CaptureToolObjects class CaptureWidget class CircleCountTool class CircleTool class ClickableLabel class Color class ColorGrabWidget class ColorPicker class ColorPickerEditMode class ColorPickerEditor class ColorPickerWidget namespace ColorUtils class CommandArgument class CommandLineParser struct Node class CommandOption struct CompareAppByName class ConfigErrorDetails class ConfigHandler class ConfigResolver class ConfigWindow class CopyTool struct DesktopAppData struct DesktopFileParser class DesktopInfo class DraggableWidgetMaker class ExistingDir class ExitTool class ExtendedSlider class FileNameEditor class FileNameHandler class FilenamePattern class Flameshot class FlameshotDBusAdapter class FlameshotDaemon class GeneralConf class GlobalShortcutFilter namespace GlobalValues class History struct HistoryFileName class HoverEventFilter class ImageLabel class ImgUploadDialog class ImgUploaderBase class ImgUploaderManager class ImgUploaderTool class ImgurUploader class InfoWindow class InvertTool class KeySequence class LauncherItemDelegate class LineTool class LoadSpinner class LowerBoundedInt class MagnifierWidget class MarkerTool class ModificationCommand class MoveTool class NotificationWidget class NotifierBox class OrgFreedesktopPortalRequestInterface class OrientablePushButton class OverlayMessage Overlay a message in capture mode. namespace PathInfo class PencilTool class PinTool class PinWidget class PixelateTool class QGuiAppCurrentScreen class QSharedPointer class RectangleTool class RedoTool class Region class SaveFileExtension class SaveTool class ScreenGrabber class SelectionTool class SelectionWidget class SetShortcutDialog class ShortcutsWidget class SidePanelWidget class SizeDecreaseTool class SizeIncreaseTool class StrftimeChooserWidget class String class StyleOverride class SystemNotification struct TerminalApp class TerminalLauncher class TextConfig class TextTool class TextWidget class ToolFactory class TrayIcon class UIcolorEditor namespace Ui class UndoTool class UpdateNotificationWidget class UploadHistory class UploadLineItem class UserColors class UtilityPanel class ValueHandler Handles the value of a configuration option (abstract class). class VisualsEditor class WaylandUtils struct WinLnkFileParser namespace org namespace freedesktop namespace portal namespace strfparse","title":"Class List"},{"location":"flameshot/files/","text":"File List # Here is a list of all files with brief descriptions: dir src dir cli file commandargument.cpp file commandargument.h file commandlineparser.cpp file commandlineparser.h file commandoption.cpp file commandoption.h dir config file buttonlistview.cpp file buttonlistview.h file cacheutils.cpp file cacheutils.h file clickablelabel.cpp file clickablelabel.h file colorpickereditmode.cpp file colorpickereditmode.h file colorpickereditor.cpp file colorpickereditor.h file configerrordetails.cpp file configerrordetails.h file configresolver.cpp file configresolver.h file configwindow.cpp file configwindow.h file extendedslider.cpp file extendedslider.h file filenameeditor.cpp file filenameeditor.h file generalconf.cpp file generalconf.h file setshortcutwidget.cpp file setshortcutwidget.h file shortcutswidget.cpp file shortcutswidget.h file strftimechooserwidget.cpp file strftimechooserwidget.h file styleoverride.cpp file styleoverride.h file uicoloreditor.cpp file uicoloreditor.h file visualseditor.cpp file visualseditor.h dir core file capturerequest.cpp file capturerequest.h file flameshot.cpp file flameshot.h file flameshotdaemon.cpp file flameshotdaemon.h file flameshotdbusadapter.cpp file flameshotdbusadapter.h file globalshortcutfilter.cpp file globalshortcutfilter.h file qguiappcurrentscreen.cpp file qguiappcurrentscreen.h file main.cpp dir tools file abstractactiontool.cpp file abstractactiontool.h file abstractpathtool.cpp file abstractpathtool.h file abstracttwopointtool.cpp file abstracttwopointtool.h dir accept file accepttool.cpp file accepttool.h dir arrow file arrowtool.cpp file arrowtool.h file capturecontext.cpp file capturecontext.h dir circle file circletool.cpp file circletool.h dir circlecount file circlecounttool.cpp file circlecounttool.h dir copy file copytool.cpp file copytool.h dir exit file exittool.cpp file exittool.h dir imgupload file imguploadermanager.cpp file imguploadermanager.h file imguploadertool.cpp file imguploadertool.h dir storages file imguploaderbase.cpp file imguploaderbase.h dir imgur file imguruploader.cpp file imguruploader.h dir invert file inverttool.cpp file inverttool.h dir launcher file applaunchertool.cpp file applaunchertool.h file applauncherwidget.cpp file applauncherwidget.h file launcheritemdelegate.cpp file launcheritemdelegate.h file openwithprogram.cpp file openwithprogram.h file terminallauncher.cpp file terminallauncher.h dir line file linetool.cpp file linetool.h dir marker file markertool.cpp file markertool.h dir move file movetool.cpp file movetool.h dir pencil file penciltool.cpp file penciltool.h dir pin file pintool.cpp file pintool.h file pinwidget.cpp file pinwidget.h dir pixelate file pixelatetool.cpp file pixelatetool.h dir rectangle file rectangletool.cpp file rectangletool.h dir redo file redotool.cpp file redotool.h dir save file savetool.cpp file savetool.h dir selection file selectiontool.cpp file selectiontool.h dir sizedecrease file sizedecreasetool.cpp file sizedecreasetool.h dir sizeincrease file sizeincreasetool.cpp file sizeincreasetool.h dir text file textconfig.cpp file textconfig.h file texttool.cpp file texttool.h file textwidget.cpp file textwidget.h file toolfactory.cpp file toolfactory.h dir undo file undotool.cpp file undotool.h dir utils file abstractlogger.cpp file abstractlogger.h file colorutils.cpp file colorutils.h file confighandler.cpp file confighandler.h file desktopfileparse.cpp file desktopfileparse.h file desktopinfo.cpp file desktopinfo.h file filenamehandler.cpp file filenamehandler.h file globalvalues.cpp file globalvalues.h file history.cpp file history.h file pathinfo.cpp file pathinfo.h file request.cpp file request.h file screengrabber.cpp file screengrabber.h file screenshotsaver.cpp file screenshotsaver.h file strfparse.cpp file strfparse.h file systemnotification.cpp file systemnotification.h file valuehandler.cpp file valuehandler.h file waylandutils.cpp file waylandutils.h file winlnkfileparse.cpp file winlnkfileparse.h dir widgets dir capture file buttonhandler.cpp file buttonhandler.h file capturebutton.cpp file capturebutton.h file capturetoolbutton.cpp file capturetoolbutton.h file capturetoolobjects.cpp file capturetoolobjects.h file capturewidget.cpp file capturewidget.h file colorpicker.cpp file colorpicker.h file hovereventfilter.cpp file hovereventfilter.h file magnifierwidget.cpp file magnifierwidget.h file modificationcommand.cpp file modificationcommand.h file notifierbox.cpp file notifierbox.h file overlaymessage.cpp file overlaymessage.h file selectionwidget.cpp file selectionwidget.h file capturelauncher.cpp file capturelauncher.h file colorpickerwidget.cpp file colorpickerwidget.h file draggablewidgetmaker.cpp file draggablewidgetmaker.h file imagelabel.cpp file imagelabel.h file imguploaddialog.cpp file imguploaddialog.h file infowindow.cpp file infowindow.h file loadspinner.cpp file loadspinner.h file notificationwidget.cpp file notificationwidget.h file orientablepushbutton.cpp file orientablepushbutton.h dir panel file colorgrabwidget.cpp file colorgrabwidget.h file sidepanelwidget.cpp file sidepanelwidget.h file utilitypanel.cpp file utilitypanel.h file trayicon.cpp file trayicon.h file updatenotificationwidget.cpp file updatenotificationwidget.h file uploadhistory.cpp file uploadhistory.h file uploadlineitem.cpp file uploadlineitem.h","title":"Files"},{"location":"flameshot/files/#file-list","text":"Here is a list of all files with brief descriptions: dir src dir cli file commandargument.cpp file commandargument.h file commandlineparser.cpp file commandlineparser.h file commandoption.cpp file commandoption.h dir config file buttonlistview.cpp file buttonlistview.h file cacheutils.cpp file cacheutils.h file clickablelabel.cpp file clickablelabel.h file colorpickereditmode.cpp file colorpickereditmode.h file colorpickereditor.cpp file colorpickereditor.h file configerrordetails.cpp file configerrordetails.h file configresolver.cpp file configresolver.h file configwindow.cpp file configwindow.h file extendedslider.cpp file extendedslider.h file filenameeditor.cpp file filenameeditor.h file generalconf.cpp file generalconf.h file setshortcutwidget.cpp file setshortcutwidget.h file shortcutswidget.cpp file shortcutswidget.h file strftimechooserwidget.cpp file strftimechooserwidget.h file styleoverride.cpp file styleoverride.h file uicoloreditor.cpp file uicoloreditor.h file visualseditor.cpp file visualseditor.h dir core file capturerequest.cpp file capturerequest.h file flameshot.cpp file flameshot.h file flameshotdaemon.cpp file flameshotdaemon.h file flameshotdbusadapter.cpp file flameshotdbusadapter.h file globalshortcutfilter.cpp file globalshortcutfilter.h file qguiappcurrentscreen.cpp file qguiappcurrentscreen.h file main.cpp dir tools file abstractactiontool.cpp file abstractactiontool.h file abstractpathtool.cpp file abstractpathtool.h file abstracttwopointtool.cpp file abstracttwopointtool.h dir accept file accepttool.cpp file accepttool.h dir arrow file arrowtool.cpp file arrowtool.h file capturecontext.cpp file capturecontext.h dir circle file circletool.cpp file circletool.h dir circlecount file circlecounttool.cpp file circlecounttool.h dir copy file copytool.cpp file copytool.h dir exit file exittool.cpp file exittool.h dir imgupload file imguploadermanager.cpp file imguploadermanager.h file imguploadertool.cpp file imguploadertool.h dir storages file imguploaderbase.cpp file imguploaderbase.h dir imgur file imguruploader.cpp file imguruploader.h dir invert file inverttool.cpp file inverttool.h dir launcher file applaunchertool.cpp file applaunchertool.h file applauncherwidget.cpp file applauncherwidget.h file launcheritemdelegate.cpp file launcheritemdelegate.h file openwithprogram.cpp file openwithprogram.h file terminallauncher.cpp file terminallauncher.h dir line file linetool.cpp file linetool.h dir marker file markertool.cpp file markertool.h dir move file movetool.cpp file movetool.h dir pencil file penciltool.cpp file penciltool.h dir pin file pintool.cpp file pintool.h file pinwidget.cpp file pinwidget.h dir pixelate file pixelatetool.cpp file pixelatetool.h dir rectangle file rectangletool.cpp file rectangletool.h dir redo file redotool.cpp file redotool.h dir save file savetool.cpp file savetool.h dir selection file selectiontool.cpp file selectiontool.h dir sizedecrease file sizedecreasetool.cpp file sizedecreasetool.h dir sizeincrease file sizeincreasetool.cpp file sizeincreasetool.h dir text file textconfig.cpp file textconfig.h file texttool.cpp file texttool.h file textwidget.cpp file textwidget.h file toolfactory.cpp file toolfactory.h dir undo file undotool.cpp file undotool.h dir utils file abstractlogger.cpp file abstractlogger.h file colorutils.cpp file colorutils.h file confighandler.cpp file confighandler.h file desktopfileparse.cpp file desktopfileparse.h file desktopinfo.cpp file desktopinfo.h file filenamehandler.cpp file filenamehandler.h file globalvalues.cpp file globalvalues.h file history.cpp file history.h file pathinfo.cpp file pathinfo.h file request.cpp file request.h file screengrabber.cpp file screengrabber.h file screenshotsaver.cpp file screenshotsaver.h file strfparse.cpp file strfparse.h file systemnotification.cpp file systemnotification.h file valuehandler.cpp file valuehandler.h file waylandutils.cpp file waylandutils.h file winlnkfileparse.cpp file winlnkfileparse.h dir widgets dir capture file buttonhandler.cpp file buttonhandler.h file capturebutton.cpp file capturebutton.h file capturetoolbutton.cpp file capturetoolbutton.h file capturetoolobjects.cpp file capturetoolobjects.h file capturewidget.cpp file capturewidget.h file colorpicker.cpp file colorpicker.h file hovereventfilter.cpp file hovereventfilter.h file magnifierwidget.cpp file magnifierwidget.h file modificationcommand.cpp file modificationcommand.h file notifierbox.cpp file notifierbox.h file overlaymessage.cpp file overlaymessage.h file selectionwidget.cpp file selectionwidget.h file capturelauncher.cpp file capturelauncher.h file colorpickerwidget.cpp file colorpickerwidget.h file draggablewidgetmaker.cpp file draggablewidgetmaker.h file imagelabel.cpp file imagelabel.h file imguploaddialog.cpp file imguploaddialog.h file infowindow.cpp file infowindow.h file loadspinner.cpp file loadspinner.h file notificationwidget.cpp file notificationwidget.h file orientablepushbutton.cpp file orientablepushbutton.h dir panel file colorgrabwidget.cpp file colorgrabwidget.h file sidepanelwidget.cpp file sidepanelwidget.h file utilitypanel.cpp file utilitypanel.h file trayicon.cpp file trayicon.h file updatenotificationwidget.cpp file updatenotificationwidget.h file uploadhistory.cpp file uploadhistory.h file uploadlineitem.cpp file uploadlineitem.h","title":"File List"},{"location":"flameshot/namespace_0d103/","text":"Namespace @103 # Namespace List > @103","title":"Namespace @103"},{"location":"flameshot/namespace_0d103/#namespace-103","text":"Namespace List > @103","title":"Namespace @103"},{"location":"flameshot/namespace_0d2/","text":"Namespace @2 # Namespace List > @2","title":"Namespace @2"},{"location":"flameshot/namespace_0d2/#namespace-2","text":"Namespace List > @2","title":"Namespace @2"},{"location":"flameshot/namespace_0d57/","text":"Namespace @57 # Namespace List > @57 Public Types # Type Name enum DIAG_UNIT enum UNIT Public Types Documentation # enum DIAG_UNIT # enum @57::DIAG_UNIT; enum UNIT # enum @57::UNIT;","title":"Namespace @57"},{"location":"flameshot/namespace_0d57/#namespace-57","text":"Namespace List > @57","title":"Namespace @57"},{"location":"flameshot/namespace_0d57/#public-types","text":"Type Name enum DIAG_UNIT enum UNIT","title":"Public Types"},{"location":"flameshot/namespace_0d57/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/namespace_0d57/#enum-diag_unit","text":"enum @57::DIAG_UNIT;","title":"enum DIAG_UNIT"},{"location":"flameshot/namespace_0d57/#enum-unit","text":"enum @57::UNIT;","title":"enum UNIT"},{"location":"flameshot/namespace_0d61/","text":"Namespace @61 # Namespace List > @61","title":"Namespace @61"},{"location":"flameshot/namespace_0d61/#namespace-61","text":"Namespace List > @61","title":"Namespace @61"},{"location":"flameshot/namespace_0d67/","text":"Namespace @67 # Namespace List > @67","title":"Namespace @67"},{"location":"flameshot/namespace_0d67/#namespace-67","text":"Namespace List > @67","title":"Namespace @67"},{"location":"flameshot/namespace_0d85/","text":"Namespace @85 # Namespace List > @85","title":"Namespace @85"},{"location":"flameshot/namespace_0d85/#namespace-85","text":"Namespace List > @85","title":"Namespace @85"},{"location":"flameshot/namespace_0d91/","text":"Namespace @91 # Namespace List > @91","title":"Namespace @91"},{"location":"flameshot/namespace_0d91/#namespace-91","text":"Namespace List > @91","title":"Namespace @91"},{"location":"flameshot/classAbstractActionTool/","text":"Class AbstractActionTool # ClassList > AbstractActionTool Inherits the following classes: CaptureTool Inherited by the following classes: AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SizeDecreaseTool , SizeIncreaseTool , UndoTool Public Functions # Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Public Functions Documentation # function AbstractActionTool # explicit AbstractActionTool::AbstractActionTool ( QObject * parent=nullptr ) function boundingRect # QRect AbstractActionTool::boundingRect () override const function isSelectable # bool AbstractActionTool::isSelectable () override const function isValid # bool AbstractActionTool::isValid () override const function paintMousePreview # void AbstractActionTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void AbstractActionTool::process ( QPainter & painter, const QPixmap & pixmap ) override function showMousePreview # bool AbstractActionTool::showMousePreview () override const","title":"Class AbstractActionTool"},{"location":"flameshot/classAbstractActionTool/#class-abstractactiontool","text":"ClassList > AbstractActionTool Inherits the following classes: CaptureTool Inherited by the following classes: AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SizeDecreaseTool , SizeIncreaseTool , UndoTool","title":"Class AbstractActionTool"},{"location":"flameshot/classAbstractActionTool/#public-functions","text":"Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions"},{"location":"flameshot/classAbstractActionTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAbstractActionTool/#function-abstractactiontool","text":"explicit AbstractActionTool::AbstractActionTool ( QObject * parent=nullptr )","title":"function AbstractActionTool"},{"location":"flameshot/classAbstractActionTool/#function-boundingrect","text":"QRect AbstractActionTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classAbstractActionTool/#function-isselectable","text":"bool AbstractActionTool::isSelectable () override const","title":"function isSelectable"},{"location":"flameshot/classAbstractActionTool/#function-isvalid","text":"bool AbstractActionTool::isValid () override const","title":"function isValid"},{"location":"flameshot/classAbstractActionTool/#function-paintmousepreview","text":"void AbstractActionTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classAbstractActionTool/#function-process","text":"void AbstractActionTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classAbstractActionTool/#function-showmousepreview","text":"bool AbstractActionTool::showMousePreview () override const","title":"function showMousePreview"},{"location":"flameshot/classAbstractLogger/","text":"Class AbstractLogger # ClassList > AbstractLogger A class that allows you to log events to where they need to go. #include <abstractlogger.h> Public Types # Type Name enum Channel enum Target Public Functions # Type Name AbstractLogger (Channel channel=Info, int targets=Default) AbstractLogger (QString & str, Channel channel, int additionalTargets= String ) Construct an AbstractLogger with output to a string. AbstractLogger & addOutputString (QString & str) AbstractLogger & attachNotificationPath (QString path) Attach a path to a notification so it can be dragged and dropped. AbstractLogger & enableMessageHeader (bool enable) Enable/disable message header (e.g. \"flameshot: info:\"). AbstractLogger & operator<< (QString msg) Send a message to the default channel of this logger. AbstractLogger & sendMessage (QString msg, Channel channel) ~AbstractLogger () Public Static Functions # Type Name AbstractLogger error (int targets=Default) AbstractLogger info (int targets=Default) AbstractLogger warning (int targets=Default) Public Types Documentation # enum Channel # enum AbstractLogger::Channel { Info, Warning, Error }; enum Target # enum AbstractLogger::Target { Notification = 0x01, Stderr = 0x02, LogFile = 0x08, String = 0x10, Stdout = 0x20, Default = Notification | LogFile | Stderr }; Public Functions Documentation # function AbstractLogger [1/2] # AbstractLogger::AbstractLogger ( Channel channel=Info, int targets=Default ) function AbstractLogger [2/2] # Construct an AbstractLogger with output to a string. AbstractLogger::AbstractLogger ( QString & str, Channel channel, int additionalTargets=String ) Parameters: additionalChannels Optional additional targets to output to. function addOutputString # AbstractLogger & AbstractLogger::addOutputString ( QString & str ) function attachNotificationPath # AbstractLogger & AbstractLogger::attachNotificationPath ( QString path ) function enableMessageHeader # AbstractLogger & AbstractLogger::enableMessageHeader ( bool enable ) function operator<< # Send a message to the default channel of this logger. AbstractLogger & AbstractLogger::operator<< ( QString msg ) Parameters: msg Returns: function sendMessage # AbstractLogger & AbstractLogger::sendMessage ( QString msg, Channel channel ) function ~AbstractLogger # AbstractLogger::~AbstractLogger () Public Static Functions Documentation # function error # static AbstractLogger AbstractLogger::error ( int targets=Default ) function info # static AbstractLogger AbstractLogger::info ( int targets=Default ) function warning # static AbstractLogger AbstractLogger::warning ( int targets=Default )","title":"Class AbstractLogger"},{"location":"flameshot/classAbstractLogger/#class-abstractlogger","text":"ClassList > AbstractLogger A class that allows you to log events to where they need to go. #include <abstractlogger.h>","title":"Class AbstractLogger"},{"location":"flameshot/classAbstractLogger/#public-types","text":"Type Name enum Channel enum Target","title":"Public Types"},{"location":"flameshot/classAbstractLogger/#public-functions","text":"Type Name AbstractLogger (Channel channel=Info, int targets=Default) AbstractLogger (QString & str, Channel channel, int additionalTargets= String ) Construct an AbstractLogger with output to a string. AbstractLogger & addOutputString (QString & str) AbstractLogger & attachNotificationPath (QString path) Attach a path to a notification so it can be dragged and dropped. AbstractLogger & enableMessageHeader (bool enable) Enable/disable message header (e.g. \"flameshot: info:\"). AbstractLogger & operator<< (QString msg) Send a message to the default channel of this logger. AbstractLogger & sendMessage (QString msg, Channel channel) ~AbstractLogger ()","title":"Public Functions"},{"location":"flameshot/classAbstractLogger/#public-static-functions","text":"Type Name AbstractLogger error (int targets=Default) AbstractLogger info (int targets=Default) AbstractLogger warning (int targets=Default)","title":"Public Static Functions"},{"location":"flameshot/classAbstractLogger/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classAbstractLogger/#enum-channel","text":"enum AbstractLogger::Channel { Info, Warning, Error };","title":"enum Channel"},{"location":"flameshot/classAbstractLogger/#enum-target","text":"enum AbstractLogger::Target { Notification = 0x01, Stderr = 0x02, LogFile = 0x08, String = 0x10, Stdout = 0x20, Default = Notification | LogFile | Stderr };","title":"enum Target"},{"location":"flameshot/classAbstractLogger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAbstractLogger/#function-abstractlogger-12","text":"AbstractLogger::AbstractLogger ( Channel channel=Info, int targets=Default )","title":"function AbstractLogger [1/2]"},{"location":"flameshot/classAbstractLogger/#function-abstractlogger-22","text":"Construct an AbstractLogger with output to a string. AbstractLogger::AbstractLogger ( QString & str, Channel channel, int additionalTargets=String ) Parameters: additionalChannels Optional additional targets to output to.","title":"function AbstractLogger [2/2]"},{"location":"flameshot/classAbstractLogger/#function-addoutputstring","text":"AbstractLogger & AbstractLogger::addOutputString ( QString & str )","title":"function addOutputString"},{"location":"flameshot/classAbstractLogger/#function-attachnotificationpath","text":"AbstractLogger & AbstractLogger::attachNotificationPath ( QString path )","title":"function attachNotificationPath"},{"location":"flameshot/classAbstractLogger/#function-enablemessageheader","text":"AbstractLogger & AbstractLogger::enableMessageHeader ( bool enable )","title":"function enableMessageHeader"},{"location":"flameshot/classAbstractLogger/#function-operator","text":"Send a message to the default channel of this logger. AbstractLogger & AbstractLogger::operator<< ( QString msg ) Parameters: msg Returns:","title":"function operator&lt;&lt;"},{"location":"flameshot/classAbstractLogger/#function-sendmessage","text":"AbstractLogger & AbstractLogger::sendMessage ( QString msg, Channel channel )","title":"function sendMessage"},{"location":"flameshot/classAbstractLogger/#function-abstractlogger","text":"AbstractLogger::~AbstractLogger ()","title":"function ~AbstractLogger"},{"location":"flameshot/classAbstractLogger/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classAbstractLogger/#function-error","text":"static AbstractLogger AbstractLogger::error ( int targets=Default )","title":"function error"},{"location":"flameshot/classAbstractLogger/#function-info","text":"static AbstractLogger AbstractLogger::info ( int targets=Default )","title":"function info"},{"location":"flameshot/classAbstractLogger/#function-warning","text":"static AbstractLogger AbstractLogger::warning ( int targets=Default )","title":"function warning"},{"location":"flameshot/classAbstractPathTool/","text":"Class AbstractPathTool # ClassList > AbstractPathTool Inherits the following classes: CaptureTool Inherited by the following classes: PencilTool Public Functions # Type Name AbstractPathTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes # Type Name QColor m_color int m_padding QRect m_pathArea QVector< QPoint > m_points QPoint m_pos Protected Functions # Type Name void addPoint (const QPoint & point) void copyParams (const AbstractPathTool * from, AbstractPathTool * to) Public Functions Documentation # function AbstractPathTool # explicit AbstractPathTool::AbstractPathTool ( QObject * parent=nullptr ) function boundingRect # QRect AbstractPathTool::boundingRect () override const function closeOnButtonPressed # bool AbstractPathTool::closeOnButtonPressed () override const function isSelectable # bool AbstractPathTool::isSelectable () override const function isValid # bool AbstractPathTool::isValid () override const function mousePreviewRect # QRect AbstractPathTool::mousePreviewRect ( const CaptureContext & context ) override const function move # void AbstractPathTool::move ( const QPoint & mousePos ) override function pos # const QPoint * AbstractPathTool::pos () override function showMousePreview # bool AbstractPathTool::showMousePreview () override const function size # inline int AbstractPathTool::size () override const Protected Attributes Documentation # variable m_color # QColor AbstractPathTool::m_color; variable m_padding # int AbstractPathTool::m_padding; variable m_pathArea # QRect AbstractPathTool::m_pathArea; variable m_points # QVector<QPoint> AbstractPathTool::m_points; variable m_pos # QPoint AbstractPathTool::m_pos; Protected Functions Documentation # function addPoint # void AbstractPathTool::addPoint ( const QPoint & point ) function copyParams # void AbstractPathTool::copyParams ( const AbstractPathTool * from, AbstractPathTool * to )","title":"Class AbstractPathTool"},{"location":"flameshot/classAbstractPathTool/#class-abstractpathtool","text":"ClassList > AbstractPathTool Inherits the following classes: CaptureTool Inherited by the following classes: PencilTool","title":"Class AbstractPathTool"},{"location":"flameshot/classAbstractPathTool/#public-functions","text":"Type Name AbstractPathTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions"},{"location":"flameshot/classAbstractPathTool/#protected-attributes","text":"Type Name QColor m_color int m_padding QRect m_pathArea QVector< QPoint > m_points QPoint m_pos","title":"Protected Attributes"},{"location":"flameshot/classAbstractPathTool/#protected-functions","text":"Type Name void addPoint (const QPoint & point) void copyParams (const AbstractPathTool * from, AbstractPathTool * to)","title":"Protected Functions"},{"location":"flameshot/classAbstractPathTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAbstractPathTool/#function-abstractpathtool","text":"explicit AbstractPathTool::AbstractPathTool ( QObject * parent=nullptr )","title":"function AbstractPathTool"},{"location":"flameshot/classAbstractPathTool/#function-boundingrect","text":"QRect AbstractPathTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classAbstractPathTool/#function-closeonbuttonpressed","text":"bool AbstractPathTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classAbstractPathTool/#function-isselectable","text":"bool AbstractPathTool::isSelectable () override const","title":"function isSelectable"},{"location":"flameshot/classAbstractPathTool/#function-isvalid","text":"bool AbstractPathTool::isValid () override const","title":"function isValid"},{"location":"flameshot/classAbstractPathTool/#function-mousepreviewrect","text":"QRect AbstractPathTool::mousePreviewRect ( const CaptureContext & context ) override const","title":"function mousePreviewRect"},{"location":"flameshot/classAbstractPathTool/#function-move","text":"void AbstractPathTool::move ( const QPoint & mousePos ) override","title":"function move"},{"location":"flameshot/classAbstractPathTool/#function-pos","text":"const QPoint * AbstractPathTool::pos () override","title":"function pos"},{"location":"flameshot/classAbstractPathTool/#function-showmousepreview","text":"bool AbstractPathTool::showMousePreview () override const","title":"function showMousePreview"},{"location":"flameshot/classAbstractPathTool/#function-size","text":"inline int AbstractPathTool::size () override const","title":"function size"},{"location":"flameshot/classAbstractPathTool/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"flameshot/classAbstractPathTool/#variable-m_color","text":"QColor AbstractPathTool::m_color;","title":"variable m_color"},{"location":"flameshot/classAbstractPathTool/#variable-m_padding","text":"int AbstractPathTool::m_padding;","title":"variable m_padding"},{"location":"flameshot/classAbstractPathTool/#variable-m_patharea","text":"QRect AbstractPathTool::m_pathArea;","title":"variable m_pathArea"},{"location":"flameshot/classAbstractPathTool/#variable-m_points","text":"QVector<QPoint> AbstractPathTool::m_points;","title":"variable m_points"},{"location":"flameshot/classAbstractPathTool/#variable-m_pos","text":"QPoint AbstractPathTool::m_pos;","title":"variable m_pos"},{"location":"flameshot/classAbstractPathTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classAbstractPathTool/#function-addpoint","text":"void AbstractPathTool::addPoint ( const QPoint & point )","title":"function addPoint"},{"location":"flameshot/classAbstractPathTool/#function-copyparams","text":"void AbstractPathTool::copyParams ( const AbstractPathTool * from, AbstractPathTool * to )","title":"function copyParams"},{"location":"flameshot/classAbstractTwoPointTool/","text":"Class AbstractTwoPointTool # ClassList > AbstractTwoPointTool Inherits the following classes: CaptureTool Inherited by the following classes: ArrowTool , CircleCountTool , CircleTool , InvertTool , LineTool , MarkerTool , PixelateTool , RectangleTool , SelectionTool Public Functions # Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes # Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function AbstractTwoPointTool # explicit AbstractTwoPointTool::AbstractTwoPointTool ( QObject * parent=nullptr ) function boundingRect # QRect AbstractTwoPointTool::boundingRect () override const function closeOnButtonPressed # bool AbstractTwoPointTool::closeOnButtonPressed () override const function color # inline const QColor & AbstractTwoPointTool::color () function isSelectable # bool AbstractTwoPointTool::isSelectable () override const function isValid # bool AbstractTwoPointTool::isValid () override const function mousePreviewRect # QRect AbstractTwoPointTool::mousePreviewRect ( const CaptureContext & context ) override const function move # void AbstractTwoPointTool::move ( const QPoint & pos ) override function paintMousePreview # void AbstractTwoPointTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function points # inline const QPair< QPoint, QPoint > AbstractTwoPointTool::points () const function pos # const QPoint * AbstractTwoPointTool::pos () override function showMousePreview # bool AbstractTwoPointTool::showMousePreview () override const function size # inline int AbstractTwoPointTool::size () override const Protected Attributes Documentation # variable m_supportsDiagonalAdj # bool AbstractTwoPointTool::m_supportsDiagonalAdj; variable m_supportsOrthogonalAdj # bool AbstractTwoPointTool::m_supportsOrthogonalAdj; Protected Functions Documentation # function copyParams # void AbstractTwoPointTool::copyParams ( const AbstractTwoPointTool * from, AbstractTwoPointTool * to ) function setPadding # inline void AbstractTwoPointTool::setPadding ( int padding )","title":"Class AbstractTwoPointTool"},{"location":"flameshot/classAbstractTwoPointTool/#class-abstracttwopointtool","text":"ClassList > AbstractTwoPointTool Inherits the following classes: CaptureTool Inherited by the following classes: ArrowTool , CircleCountTool , CircleTool , InvertTool , LineTool , MarkerTool , PixelateTool , RectangleTool , SelectionTool","title":"Class AbstractTwoPointTool"},{"location":"flameshot/classAbstractTwoPointTool/#public-functions","text":"Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions"},{"location":"flameshot/classAbstractTwoPointTool/#protected-attributes","text":"Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes"},{"location":"flameshot/classAbstractTwoPointTool/#protected-functions","text":"Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions"},{"location":"flameshot/classAbstractTwoPointTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAbstractTwoPointTool/#function-abstracttwopointtool","text":"explicit AbstractTwoPointTool::AbstractTwoPointTool ( QObject * parent=nullptr )","title":"function AbstractTwoPointTool"},{"location":"flameshot/classAbstractTwoPointTool/#function-boundingrect","text":"QRect AbstractTwoPointTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classAbstractTwoPointTool/#function-closeonbuttonpressed","text":"bool AbstractTwoPointTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classAbstractTwoPointTool/#function-color","text":"inline const QColor & AbstractTwoPointTool::color ()","title":"function color"},{"location":"flameshot/classAbstractTwoPointTool/#function-isselectable","text":"bool AbstractTwoPointTool::isSelectable () override const","title":"function isSelectable"},{"location":"flameshot/classAbstractTwoPointTool/#function-isvalid","text":"bool AbstractTwoPointTool::isValid () override const","title":"function isValid"},{"location":"flameshot/classAbstractTwoPointTool/#function-mousepreviewrect","text":"QRect AbstractTwoPointTool::mousePreviewRect ( const CaptureContext & context ) override const","title":"function mousePreviewRect"},{"location":"flameshot/classAbstractTwoPointTool/#function-move","text":"void AbstractTwoPointTool::move ( const QPoint & pos ) override","title":"function move"},{"location":"flameshot/classAbstractTwoPointTool/#function-paintmousepreview","text":"void AbstractTwoPointTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classAbstractTwoPointTool/#function-points","text":"inline const QPair< QPoint, QPoint > AbstractTwoPointTool::points () const","title":"function points"},{"location":"flameshot/classAbstractTwoPointTool/#function-pos","text":"const QPoint * AbstractTwoPointTool::pos () override","title":"function pos"},{"location":"flameshot/classAbstractTwoPointTool/#function-showmousepreview","text":"bool AbstractTwoPointTool::showMousePreview () override const","title":"function showMousePreview"},{"location":"flameshot/classAbstractTwoPointTool/#function-size","text":"inline int AbstractTwoPointTool::size () override const","title":"function size"},{"location":"flameshot/classAbstractTwoPointTool/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"flameshot/classAbstractTwoPointTool/#variable-m_supportsdiagonaladj","text":"bool AbstractTwoPointTool::m_supportsDiagonalAdj;","title":"variable m_supportsDiagonalAdj"},{"location":"flameshot/classAbstractTwoPointTool/#variable-m_supportsorthogonaladj","text":"bool AbstractTwoPointTool::m_supportsOrthogonalAdj;","title":"variable m_supportsOrthogonalAdj"},{"location":"flameshot/classAbstractTwoPointTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classAbstractTwoPointTool/#function-copyparams","text":"void AbstractTwoPointTool::copyParams ( const AbstractTwoPointTool * from, AbstractTwoPointTool * to )","title":"function copyParams"},{"location":"flameshot/classAbstractTwoPointTool/#function-setpadding","text":"inline void AbstractTwoPointTool::setPadding ( int padding )","title":"function setPadding"},{"location":"flameshot/classAcceptTool/","text":"Class AcceptTool # ClassList > AcceptTool Inherits the following classes: AbstractActionTool Public Functions # Type Name AcceptTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function AcceptTool # explicit AcceptTool::AcceptTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool AcceptTool::closeOnButtonPressed () override const function copy # CaptureTool * AcceptTool::copy ( QObject * parent=nullptr ) override function description # QString AcceptTool::description () override const function icon # QIcon AcceptTool::icon ( const QColor & background, bool inEditor ) override const function name # QString AcceptTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type AcceptTool::type () override const","title":"Class AcceptTool"},{"location":"flameshot/classAcceptTool/#class-accepttool","text":"ClassList > AcceptTool Inherits the following classes: AbstractActionTool","title":"Class AcceptTool"},{"location":"flameshot/classAcceptTool/#public-functions","text":"Type Name AcceptTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classAcceptTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classAcceptTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classAcceptTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAcceptTool/#function-accepttool","text":"explicit AcceptTool::AcceptTool ( QObject * parent=nullptr )","title":"function AcceptTool"},{"location":"flameshot/classAcceptTool/#function-closeonbuttonpressed","text":"bool AcceptTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classAcceptTool/#function-copy","text":"CaptureTool * AcceptTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classAcceptTool/#function-description","text":"QString AcceptTool::description () override const","title":"function description"},{"location":"flameshot/classAcceptTool/#function-icon","text":"QIcon AcceptTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classAcceptTool/#function-name","text":"QString AcceptTool::name () override const","title":"function name"},{"location":"flameshot/classAcceptTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classAcceptTool/#function-type","text":"CaptureTool::Type AcceptTool::type () override const","title":"function type"},{"location":"flameshot/classAppLauncher/","text":"Class AppLauncher # ClassList > AppLauncher Inherits the following classes: AbstractActionTool Public Functions # Type Name AppLauncher (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const QWidget * widget () override Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function AppLauncher # explicit AppLauncher::AppLauncher ( QObject * parent=nullptr ) function closeOnButtonPressed # bool AppLauncher::closeOnButtonPressed () override const function copy # CaptureTool * AppLauncher::copy ( QObject * parent=nullptr ) override function description # QString AppLauncher::description () override const function icon # QIcon AppLauncher::icon ( const QColor & background, bool inEditor ) override const function name # QString AppLauncher::name () override const function widget # QWidget * AppLauncher::widget () override Protected Functions Documentation # function type # CaptureTool::Type AppLauncher::type () override const","title":"Class AppLauncher"},{"location":"flameshot/classAppLauncher/#class-applauncher","text":"ClassList > AppLauncher Inherits the following classes: AbstractActionTool","title":"Class AppLauncher"},{"location":"flameshot/classAppLauncher/#public-functions","text":"Type Name AppLauncher (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const QWidget * widget () override","title":"Public Functions"},{"location":"flameshot/classAppLauncher/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classAppLauncher/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classAppLauncher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAppLauncher/#function-applauncher","text":"explicit AppLauncher::AppLauncher ( QObject * parent=nullptr )","title":"function AppLauncher"},{"location":"flameshot/classAppLauncher/#function-closeonbuttonpressed","text":"bool AppLauncher::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classAppLauncher/#function-copy","text":"CaptureTool * AppLauncher::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classAppLauncher/#function-description","text":"QString AppLauncher::description () override const","title":"function description"},{"location":"flameshot/classAppLauncher/#function-icon","text":"QIcon AppLauncher::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classAppLauncher/#function-name","text":"QString AppLauncher::name () override const","title":"function name"},{"location":"flameshot/classAppLauncher/#function-widget","text":"QWidget * AppLauncher::widget () override","title":"function widget"},{"location":"flameshot/classAppLauncher/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classAppLauncher/#function-type","text":"CaptureTool::Type AppLauncher::type () override const","title":"function type"},{"location":"flameshot/classAppLauncherWidget/","text":"Class AppLauncherWidget # ClassList > AppLauncherWidget Inherits the following classes: QWidget Public Functions # Type Name AppLauncherWidget (const QPixmap & p, QWidget * parent=nullptr) Public Functions Documentation # function AppLauncherWidget # explicit AppLauncherWidget::AppLauncherWidget ( const QPixmap & p, QWidget * parent=nullptr )","title":"Class AppLauncherWidget"},{"location":"flameshot/classAppLauncherWidget/#class-applauncherwidget","text":"ClassList > AppLauncherWidget Inherits the following classes: QWidget","title":"Class AppLauncherWidget"},{"location":"flameshot/classAppLauncherWidget/#public-functions","text":"Type Name AppLauncherWidget (const QPixmap & p, QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classAppLauncherWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classAppLauncherWidget/#function-applauncherwidget","text":"explicit AppLauncherWidget::AppLauncherWidget ( const QPixmap & p, QWidget * parent=nullptr )","title":"function AppLauncherWidget"},{"location":"flameshot/classArrowTool/","text":"Class ArrowTool # ClassList > ArrowTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name ArrowTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name void copyParams (const ArrowTool * from, ArrowTool * to) CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function ArrowTool # explicit ArrowTool::ArrowTool ( QObject * parent=nullptr ) function boundingRect # QRect ArrowTool::boundingRect () override const function copy # CaptureTool * ArrowTool::copy ( QObject * parent=nullptr ) override function description # QString ArrowTool::description () override const function icon # QIcon ArrowTool::icon ( const QColor & background, bool inEditor ) override const function name # QString ArrowTool::name () override const function process # void ArrowTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function copyParams # void ArrowTool::copyParams ( const ArrowTool * from, ArrowTool * to ) function type # CaptureTool::Type ArrowTool::type () override const","title":"Class ArrowTool"},{"location":"flameshot/classArrowTool/#class-arrowtool","text":"ClassList > ArrowTool Inherits the following classes: AbstractTwoPointTool","title":"Class ArrowTool"},{"location":"flameshot/classArrowTool/#public-functions","text":"Type Name ArrowTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classArrowTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classArrowTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classArrowTool/#protected-functions","text":"Type Name void copyParams (const ArrowTool * from, ArrowTool * to) CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classArrowTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classArrowTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classArrowTool/#function-arrowtool","text":"explicit ArrowTool::ArrowTool ( QObject * parent=nullptr )","title":"function ArrowTool"},{"location":"flameshot/classArrowTool/#function-boundingrect","text":"QRect ArrowTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classArrowTool/#function-copy","text":"CaptureTool * ArrowTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classArrowTool/#function-description","text":"QString ArrowTool::description () override const","title":"function description"},{"location":"flameshot/classArrowTool/#function-icon","text":"QIcon ArrowTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classArrowTool/#function-name","text":"QString ArrowTool::name () override const","title":"function name"},{"location":"flameshot/classArrowTool/#function-process","text":"void ArrowTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classArrowTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classArrowTool/#function-copyparams","text":"void ArrowTool::copyParams ( const ArrowTool * from, ArrowTool * to )","title":"function copyParams"},{"location":"flameshot/classArrowTool/#function-type","text":"CaptureTool::Type ArrowTool::type () override const","title":"function type"},{"location":"flameshot/classBool/","text":"Class Bool # ClassList > Bool Inherits the following classes: ValueHandler Public Functions # Type Name Bool (bool def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function Bool # Bool::Bool ( bool def ) function check # Check the value semantically. virtual bool Bool::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString Bool::expected () override Implements ValueHandler::expected function fallback # virtual QVariant Bool::fallback () override Implements ValueHandler::fallback","title":"Class Bool"},{"location":"flameshot/classBool/#class-bool","text":"ClassList > Bool Inherits the following classes: ValueHandler","title":"Class Bool"},{"location":"flameshot/classBool/#public-functions","text":"Type Name Bool (bool def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value).","title":"Public Functions"},{"location":"flameshot/classBool/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classBool/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classBool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classBool/#function-bool","text":"Bool::Bool ( bool def )","title":"function Bool"},{"location":"flameshot/classBool/#function-check","text":"Check the value semantically. virtual bool Bool::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classBool/#function-expected","text":"virtual QString Bool::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classBool/#function-fallback","text":"virtual QVariant Bool::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classBoundedInt/","text":"Class BoundedInt # ClassList > BoundedInt Inherits the following classes: ValueHandler Public Functions # Type Name BoundedInt (int min, int max, int def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function BoundedInt # BoundedInt::BoundedInt ( int min, int max, int def ) function check # Check the value semantically. virtual bool BoundedInt::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString BoundedInt::expected () override Implements ValueHandler::expected function fallback # virtual QVariant BoundedInt::fallback () override Implements ValueHandler::fallback","title":"Class BoundedInt"},{"location":"flameshot/classBoundedInt/#class-boundedint","text":"ClassList > BoundedInt Inherits the following classes: ValueHandler","title":"Class BoundedInt"},{"location":"flameshot/classBoundedInt/#public-functions","text":"Type Name BoundedInt (int min, int max, int def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value).","title":"Public Functions"},{"location":"flameshot/classBoundedInt/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classBoundedInt/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classBoundedInt/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classBoundedInt/#function-boundedint","text":"BoundedInt::BoundedInt ( int min, int max, int def )","title":"function BoundedInt"},{"location":"flameshot/classBoundedInt/#function-check","text":"Check the value semantically. virtual bool BoundedInt::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classBoundedInt/#function-expected","text":"virtual QString BoundedInt::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classBoundedInt/#function-fallback","text":"virtual QVariant BoundedInt::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classButtonHandler/","text":"Class ButtonHandler # ClassList > ButtonHandler Inherits the following classes: QObject Public Functions # Type Name ButtonHandler (const QVector< CaptureToolButton * > & v, QObject * parent=nullptr) ButtonHandler (QObject * parent=nullptr) bool buttonsAreInside () const bool contains (const QPoint & p) const void hideSectionUnderMouse (const QPoint & p) bool isVisible () const void setButtons (const QVector< CaptureToolButton * > v) size_t size () const void updateScreenRegions (const QVector< QRect > & rects) void updateScreenRegions (const QRect & rect) Public Functions Documentation # function ButtonHandler [1/2] # ButtonHandler::ButtonHandler ( const QVector< CaptureToolButton * > & v, QObject * parent=nullptr ) function ButtonHandler [2/2] # explicit ButtonHandler::ButtonHandler ( QObject * parent=nullptr ) function buttonsAreInside # bool ButtonHandler::buttonsAreInside () const function contains # bool ButtonHandler::contains ( const QPoint & p ) const function hideSectionUnderMouse # void ButtonHandler::hideSectionUnderMouse ( const QPoint & p ) function isVisible # bool ButtonHandler::isVisible () const function setButtons # void ButtonHandler::setButtons ( const QVector< CaptureToolButton * > v ) function size # size_t ButtonHandler::size () const function updateScreenRegions [1/2] # void ButtonHandler::updateScreenRegions ( const QVector< QRect > & rects ) function updateScreenRegions [2/2] # void ButtonHandler::updateScreenRegions ( const QRect & rect )","title":"Class ButtonHandler"},{"location":"flameshot/classButtonHandler/#class-buttonhandler","text":"ClassList > ButtonHandler Inherits the following classes: QObject","title":"Class ButtonHandler"},{"location":"flameshot/classButtonHandler/#public-functions","text":"Type Name ButtonHandler (const QVector< CaptureToolButton * > & v, QObject * parent=nullptr) ButtonHandler (QObject * parent=nullptr) bool buttonsAreInside () const bool contains (const QPoint & p) const void hideSectionUnderMouse (const QPoint & p) bool isVisible () const void setButtons (const QVector< CaptureToolButton * > v) size_t size () const void updateScreenRegions (const QVector< QRect > & rects) void updateScreenRegions (const QRect & rect)","title":"Public Functions"},{"location":"flameshot/classButtonHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classButtonHandler/#function-buttonhandler-12","text":"ButtonHandler::ButtonHandler ( const QVector< CaptureToolButton * > & v, QObject * parent=nullptr )","title":"function ButtonHandler [1/2]"},{"location":"flameshot/classButtonHandler/#function-buttonhandler-22","text":"explicit ButtonHandler::ButtonHandler ( QObject * parent=nullptr )","title":"function ButtonHandler [2/2]"},{"location":"flameshot/classButtonHandler/#function-buttonsareinside","text":"bool ButtonHandler::buttonsAreInside () const","title":"function buttonsAreInside"},{"location":"flameshot/classButtonHandler/#function-contains","text":"bool ButtonHandler::contains ( const QPoint & p ) const","title":"function contains"},{"location":"flameshot/classButtonHandler/#function-hidesectionundermouse","text":"void ButtonHandler::hideSectionUnderMouse ( const QPoint & p )","title":"function hideSectionUnderMouse"},{"location":"flameshot/classButtonHandler/#function-isvisible","text":"bool ButtonHandler::isVisible () const","title":"function isVisible"},{"location":"flameshot/classButtonHandler/#function-setbuttons","text":"void ButtonHandler::setButtons ( const QVector< CaptureToolButton * > v )","title":"function setButtons"},{"location":"flameshot/classButtonHandler/#function-size","text":"size_t ButtonHandler::size () const","title":"function size"},{"location":"flameshot/classButtonHandler/#function-updatescreenregions-12","text":"void ButtonHandler::updateScreenRegions ( const QVector< QRect > & rects )","title":"function updateScreenRegions [1/2]"},{"location":"flameshot/classButtonHandler/#function-updatescreenregions-22","text":"void ButtonHandler::updateScreenRegions ( const QRect & rect )","title":"function updateScreenRegions [2/2]"},{"location":"flameshot/classButtonList/","text":"Class ButtonList # ClassList > ButtonList Inherits the following classes: ValueHandler Public Functions # Type Name virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file. Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Public Static Functions # Type Name QList< CaptureTool::Type > fromIntList (const QList< int > & l) bool normalizeButtons (QList< int > & buttons) QList< int > toIntList (const QList< CaptureTool::Type > & l) Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function check # Check the value semantically. virtual bool ButtonList::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString ButtonList::expected () override Implements ValueHandler::expected function fallback # virtual QVariant ButtonList::fallback () override Implements ValueHandler::fallback function process # Process a value, presuming it is a valid QVariant . virtual QVariant ButtonList::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process function representation # Return the representation of the value in the config file. virtual QVariant ButtonList::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation Public Static Functions Documentation # function fromIntList # static QList< CaptureTool::Type > ButtonList::fromIntList ( const QList< int > & l ) function normalizeButtons # static bool ButtonList::normalizeButtons ( QList< int > & buttons ) function toIntList # static QList< int > ButtonList::toIntList ( const QList< CaptureTool::Type > & l )","title":"Class ButtonList"},{"location":"flameshot/classButtonList/#class-buttonlist","text":"ClassList > ButtonList Inherits the following classes: ValueHandler","title":"Class ButtonList"},{"location":"flameshot/classButtonList/#public-functions","text":"Type Name virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file.","title":"Public Functions"},{"location":"flameshot/classButtonList/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classButtonList/#public-static-functions","text":"Type Name QList< CaptureTool::Type > fromIntList (const QList< int > & l) bool normalizeButtons (QList< int > & buttons) QList< int > toIntList (const QList< CaptureTool::Type > & l)","title":"Public Static Functions"},{"location":"flameshot/classButtonList/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classButtonList/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classButtonList/#function-check","text":"Check the value semantically. virtual bool ButtonList::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classButtonList/#function-expected","text":"virtual QString ButtonList::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classButtonList/#function-fallback","text":"virtual QVariant ButtonList::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classButtonList/#function-process","text":"Process a value, presuming it is a valid QVariant . virtual QVariant ButtonList::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process","title":"function process"},{"location":"flameshot/classButtonList/#function-representation","text":"Return the representation of the value in the config file. virtual QVariant ButtonList::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"function representation"},{"location":"flameshot/classButtonList/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classButtonList/#function-fromintlist","text":"static QList< CaptureTool::Type > ButtonList::fromIntList ( const QList< int > & l )","title":"function fromIntList"},{"location":"flameshot/classButtonList/#function-normalizebuttons","text":"static bool ButtonList::normalizeButtons ( QList< int > & buttons )","title":"function normalizeButtons"},{"location":"flameshot/classButtonList/#function-tointlist","text":"static QList< int > ButtonList::toIntList ( const QList< CaptureTool::Type > & l )","title":"function toIntList"},{"location":"flameshot/classButtonListView/","text":"Class ButtonListView # ClassList > ButtonListView Inherits the following classes: QListWidget Public Functions # Type Name ButtonListView (QWidget * parent=nullptr) Protected Functions # Type Name void initButtonList () Public Functions Documentation # function ButtonListView # explicit ButtonListView::ButtonListView ( QWidget * parent=nullptr ) Protected Functions Documentation # function initButtonList # void ButtonListView::initButtonList ()","title":"Class ButtonListView"},{"location":"flameshot/classButtonListView/#class-buttonlistview","text":"ClassList > ButtonListView Inherits the following classes: QListWidget","title":"Class ButtonListView"},{"location":"flameshot/classButtonListView/#public-functions","text":"Type Name ButtonListView (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classButtonListView/#protected-functions","text":"Type Name void initButtonList ()","title":"Protected Functions"},{"location":"flameshot/classButtonListView/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classButtonListView/#function-buttonlistview","text":"explicit ButtonListView::ButtonListView ( QWidget * parent=nullptr )","title":"function ButtonListView"},{"location":"flameshot/classButtonListView/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classButtonListView/#function-initbuttonlist","text":"void ButtonListView::initButtonList ()","title":"function initButtonList"},{"location":"flameshot/classCaptureButton/","text":"Class CaptureButton # ClassList > CaptureButton Inherits the following classes: QPushButton Inherited by the following classes: CaptureToolButton , OrientablePushButton Public Functions # Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const Public Static Functions # Type Name QString globalStyleSheet () Public Functions Documentation # function CaptureButton [1/4] # CaptureButton::CaptureButton () = delete function CaptureButton [2/4] # CaptureButton::CaptureButton ( QWidget * parent=nullptr ) function CaptureButton [3/4] # CaptureButton::CaptureButton ( const QString & text, QWidget * parent=nullptr ) function CaptureButton [4/4] # CaptureButton::CaptureButton ( const QIcon & icon, const QString & text, QWidget * parent=nullptr ) function setColor # void CaptureButton::setColor ( const QColor & c ) function styleSheet # QString CaptureButton::styleSheet () const Public Static Functions Documentation # function globalStyleSheet # static QString CaptureButton::globalStyleSheet ()","title":"Class CaptureButton"},{"location":"flameshot/classCaptureButton/#class-capturebutton","text":"ClassList > CaptureButton Inherits the following classes: QPushButton Inherited by the following classes: CaptureToolButton , OrientablePushButton","title":"Class CaptureButton"},{"location":"flameshot/classCaptureButton/#public-functions","text":"Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const","title":"Public Functions"},{"location":"flameshot/classCaptureButton/#public-static-functions","text":"Type Name QString globalStyleSheet ()","title":"Public Static Functions"},{"location":"flameshot/classCaptureButton/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureButton/#function-capturebutton-14","text":"CaptureButton::CaptureButton () = delete","title":"function CaptureButton [1/4]"},{"location":"flameshot/classCaptureButton/#function-capturebutton-24","text":"CaptureButton::CaptureButton ( QWidget * parent=nullptr )","title":"function CaptureButton [2/4]"},{"location":"flameshot/classCaptureButton/#function-capturebutton-34","text":"CaptureButton::CaptureButton ( const QString & text, QWidget * parent=nullptr )","title":"function CaptureButton [3/4]"},{"location":"flameshot/classCaptureButton/#function-capturebutton-44","text":"CaptureButton::CaptureButton ( const QIcon & icon, const QString & text, QWidget * parent=nullptr )","title":"function CaptureButton [4/4]"},{"location":"flameshot/classCaptureButton/#function-setcolor","text":"void CaptureButton::setColor ( const QColor & c )","title":"function setColor"},{"location":"flameshot/classCaptureButton/#function-stylesheet","text":"QString CaptureButton::styleSheet () const","title":"function styleSheet"},{"location":"flameshot/classCaptureButton/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classCaptureButton/#function-globalstylesheet","text":"static QString CaptureButton::globalStyleSheet ()","title":"function globalStyleSheet"},{"location":"flameshot/structCaptureContext/","text":"Struct CaptureContext # ClassList > CaptureContext Public Attributes # Type Name int circleCount QColor color bool fullscreen QPoint mousePos QPixmap origScreenshot CaptureRequest request = = CaptureRequest::GRAPHICAL_MODE QString savePath QPixmap screenshot QRect selection int toolSize QPoint widgetOffset Public Functions # Type Name QPixmap selectedScreenshotArea () const Public Attributes Documentation # variable circleCount # int CaptureContext::circleCount; variable color # QColor CaptureContext::color; variable fullscreen # bool CaptureContext::fullscreen; variable mousePos # QPoint CaptureContext::mousePos; variable origScreenshot # QPixmap CaptureContext::origScreenshot; variable request # CaptureRequest CaptureContext::request; variable savePath # QString CaptureContext::savePath; variable screenshot # QPixmap CaptureContext::screenshot; variable selection # QRect CaptureContext::selection; variable toolSize # int CaptureContext::toolSize; variable widgetOffset # QPoint CaptureContext::widgetOffset; Public Functions Documentation # function selectedScreenshotArea # QPixmap CaptureContext::selectedScreenshotArea () const","title":"Struct CaptureContext"},{"location":"flameshot/structCaptureContext/#struct-capturecontext","text":"ClassList > CaptureContext","title":"Struct CaptureContext"},{"location":"flameshot/structCaptureContext/#public-attributes","text":"Type Name int circleCount QColor color bool fullscreen QPoint mousePos QPixmap origScreenshot CaptureRequest request = = CaptureRequest::GRAPHICAL_MODE QString savePath QPixmap screenshot QRect selection int toolSize QPoint widgetOffset","title":"Public Attributes"},{"location":"flameshot/structCaptureContext/#public-functions","text":"Type Name QPixmap selectedScreenshotArea () const","title":"Public Functions"},{"location":"flameshot/structCaptureContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/structCaptureContext/#variable-circlecount","text":"int CaptureContext::circleCount;","title":"variable circleCount"},{"location":"flameshot/structCaptureContext/#variable-color","text":"QColor CaptureContext::color;","title":"variable color"},{"location":"flameshot/structCaptureContext/#variable-fullscreen","text":"bool CaptureContext::fullscreen;","title":"variable fullscreen"},{"location":"flameshot/structCaptureContext/#variable-mousepos","text":"QPoint CaptureContext::mousePos;","title":"variable mousePos"},{"location":"flameshot/structCaptureContext/#variable-origscreenshot","text":"QPixmap CaptureContext::origScreenshot;","title":"variable origScreenshot"},{"location":"flameshot/structCaptureContext/#variable-request","text":"CaptureRequest CaptureContext::request;","title":"variable request"},{"location":"flameshot/structCaptureContext/#variable-savepath","text":"QString CaptureContext::savePath;","title":"variable savePath"},{"location":"flameshot/structCaptureContext/#variable-screenshot","text":"QPixmap CaptureContext::screenshot;","title":"variable screenshot"},{"location":"flameshot/structCaptureContext/#variable-selection","text":"QRect CaptureContext::selection;","title":"variable selection"},{"location":"flameshot/structCaptureContext/#variable-toolsize","text":"int CaptureContext::toolSize;","title":"variable toolSize"},{"location":"flameshot/structCaptureContext/#variable-widgetoffset","text":"QPoint CaptureContext::widgetOffset;","title":"variable widgetOffset"},{"location":"flameshot/structCaptureContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structCaptureContext/#function-selectedscreenshotarea","text":"QPixmap CaptureContext::selectedScreenshotArea () const","title":"function selectedScreenshotArea"},{"location":"flameshot/classCaptureLauncher/","text":"Class CaptureLauncher # ClassList > CaptureLauncher Inherits the following classes: QDialog Public Functions # Type Name CaptureLauncher (QDialog * parent=nullptr) ~CaptureLauncher () Public Functions Documentation # function CaptureLauncher # explicit CaptureLauncher::CaptureLauncher ( QDialog * parent=nullptr ) function ~CaptureLauncher # CaptureLauncher::~CaptureLauncher ()","title":"Class CaptureLauncher"},{"location":"flameshot/classCaptureLauncher/#class-capturelauncher","text":"ClassList > CaptureLauncher Inherits the following classes: QDialog","title":"Class CaptureLauncher"},{"location":"flameshot/classCaptureLauncher/#public-functions","text":"Type Name CaptureLauncher (QDialog * parent=nullptr) ~CaptureLauncher ()","title":"Public Functions"},{"location":"flameshot/classCaptureLauncher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureLauncher/#function-capturelauncher","text":"explicit CaptureLauncher::CaptureLauncher ( QDialog * parent=nullptr )","title":"function CaptureLauncher"},{"location":"flameshot/classCaptureLauncher/#function-capturelauncher_1","text":"CaptureLauncher::~CaptureLauncher ()","title":"function ~CaptureLauncher"},{"location":"flameshot/classCaptureRequest/","text":"Class CaptureRequest # ClassList > CaptureRequest Public Types # Type Name enum CaptureMode enum ExportTask Public Functions # Type Name CaptureRequest (CaptureMode mode, const uint delay=0, QVariant data=QVariant(), ExportTask tasks=NO_TASK) void addPinTask (const QRect & pinWindowGeometry) void addSaveTask (const QString & path=QString()) void addTask (ExportTask task) CaptureMode captureMode () const QVariant data () const uint delay () const uint id () const QRect initialSelection () const QString path () const void removeTask (ExportTask task) void setInitialSelection (const QRect & selection) void setStaticID (uint id) ExportTask tasks () const Public Types Documentation # enum CaptureMode # enum CaptureRequest::CaptureMode { FULLSCREEN_MODE, GRAPHICAL_MODE, SCREEN_MODE }; enum ExportTask # enum CaptureRequest::ExportTask { NO_TASK = 0, COPY = 1, SAVE = 2, PRINT_RAW = 4, PRINT_GEOMETRY = 8, PIN = 16, UPLOAD = 32, ACCEPT_ON_SELECT = 64 }; Public Functions Documentation # function CaptureRequest [1/2] # CaptureRequest::CaptureRequest ( CaptureMode mode, const uint delay=0, QVariant data=QVariant(), ExportTask tasks=NO_TASK ) function addPinTask # void CaptureRequest::addPinTask ( const QRect & pinWindowGeometry ) function addSaveTask # void CaptureRequest::addSaveTask ( const QString & path=QString() ) function addTask # void CaptureRequest::addTask ( ExportTask task ) function captureMode # CaptureMode CaptureRequest::captureMode () const function data # QVariant CaptureRequest::data () const function delay # uint CaptureRequest::delay () const function id # uint CaptureRequest::id () const function initialSelection # QRect CaptureRequest::initialSelection () const function path # QString CaptureRequest::path () const function removeTask # void CaptureRequest::removeTask ( ExportTask task ) function setInitialSelection # void CaptureRequest::setInitialSelection ( const QRect & selection ) function setStaticID # void CaptureRequest::setStaticID ( uint id ) function tasks # ExportTask CaptureRequest::tasks () const","title":"Class CaptureRequest"},{"location":"flameshot/classCaptureRequest/#class-capturerequest","text":"ClassList > CaptureRequest","title":"Class CaptureRequest"},{"location":"flameshot/classCaptureRequest/#public-types","text":"Type Name enum CaptureMode enum ExportTask","title":"Public Types"},{"location":"flameshot/classCaptureRequest/#public-functions","text":"Type Name CaptureRequest (CaptureMode mode, const uint delay=0, QVariant data=QVariant(), ExportTask tasks=NO_TASK) void addPinTask (const QRect & pinWindowGeometry) void addSaveTask (const QString & path=QString()) void addTask (ExportTask task) CaptureMode captureMode () const QVariant data () const uint delay () const uint id () const QRect initialSelection () const QString path () const void removeTask (ExportTask task) void setInitialSelection (const QRect & selection) void setStaticID (uint id) ExportTask tasks () const","title":"Public Functions"},{"location":"flameshot/classCaptureRequest/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classCaptureRequest/#enum-capturemode","text":"enum CaptureRequest::CaptureMode { FULLSCREEN_MODE, GRAPHICAL_MODE, SCREEN_MODE };","title":"enum CaptureMode"},{"location":"flameshot/classCaptureRequest/#enum-exporttask","text":"enum CaptureRequest::ExportTask { NO_TASK = 0, COPY = 1, SAVE = 2, PRINT_RAW = 4, PRINT_GEOMETRY = 8, PIN = 16, UPLOAD = 32, ACCEPT_ON_SELECT = 64 };","title":"enum ExportTask"},{"location":"flameshot/classCaptureRequest/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureRequest/#function-capturerequest-12","text":"CaptureRequest::CaptureRequest ( CaptureMode mode, const uint delay=0, QVariant data=QVariant(), ExportTask tasks=NO_TASK )","title":"function CaptureRequest [1/2]"},{"location":"flameshot/classCaptureRequest/#function-addpintask","text":"void CaptureRequest::addPinTask ( const QRect & pinWindowGeometry )","title":"function addPinTask"},{"location":"flameshot/classCaptureRequest/#function-addsavetask","text":"void CaptureRequest::addSaveTask ( const QString & path=QString() )","title":"function addSaveTask"},{"location":"flameshot/classCaptureRequest/#function-addtask","text":"void CaptureRequest::addTask ( ExportTask task )","title":"function addTask"},{"location":"flameshot/classCaptureRequest/#function-capturemode","text":"CaptureMode CaptureRequest::captureMode () const","title":"function captureMode"},{"location":"flameshot/classCaptureRequest/#function-data","text":"QVariant CaptureRequest::data () const","title":"function data"},{"location":"flameshot/classCaptureRequest/#function-delay","text":"uint CaptureRequest::delay () const","title":"function delay"},{"location":"flameshot/classCaptureRequest/#function-id","text":"uint CaptureRequest::id () const","title":"function id"},{"location":"flameshot/classCaptureRequest/#function-initialselection","text":"QRect CaptureRequest::initialSelection () const","title":"function initialSelection"},{"location":"flameshot/classCaptureRequest/#function-path","text":"QString CaptureRequest::path () const","title":"function path"},{"location":"flameshot/classCaptureRequest/#function-removetask","text":"void CaptureRequest::removeTask ( ExportTask task )","title":"function removeTask"},{"location":"flameshot/classCaptureRequest/#function-setinitialselection","text":"void CaptureRequest::setInitialSelection ( const QRect & selection )","title":"function setInitialSelection"},{"location":"flameshot/classCaptureRequest/#function-setstaticid","text":"void CaptureRequest::setStaticID ( uint id )","title":"function setStaticID"},{"location":"flameshot/classCaptureRequest/#function-tasks","text":"ExportTask CaptureRequest::tasks () const","title":"function tasks"},{"location":"flameshot/classCaptureToolButton/","text":"Class CaptureToolButton # ClassList > CaptureToolButton Inherits the following classes: CaptureButton Public Functions # Type Name CaptureToolButton (const CaptureTool::Type t, QWidget * parent=nullptr) void animatedShow () QString description () const QIcon icon () const QString name () const void setColor (const QColor & c) CaptureTool * tool () const ~CaptureToolButton () Public Functions inherited from CaptureButton # See CaptureButton Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const Public Static Functions # Type Name const QList< CaptureTool::Type > & getIterableButtonTypes () int getPriorityByButton (CaptureTool::Type b) Public Static Functions inherited from CaptureButton # See CaptureButton Type Name QString globalStyleSheet () Protected Attributes # Type Name CaptureTool * m_tool Protected Static Attributes # Type Name QList< CaptureTool::Type > iterableButtonTypes = = { CaptureTool::TYPE_PENCIL, CaptureTool::TYPE_DRAWER, CaptureTool::TYPE_ARROW, CaptureTool::TYPE_SELECTION, CaptureTool::TYPE_RECTANGLE, CaptureTool::TYPE_CIRCLE, CaptureTool::TYPE_MARKER, CaptureTool::TYPE_TEXT, CaptureTool::TYPE_CIRCLECOUNT, CaptureTool::TYPE_PIXELATE, CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO, CaptureTool::TYPE_REDO, CaptureTool::TYPE_COPY, CaptureTool::TYPE_SAVE, CaptureTool::TYPE_EXIT, CaptureTool::TYPE_IMAGEUPLOADER, CaptureTool::TYPE\\_OPEN\\_APP, CaptureTool::TYPE\\_PIN, CaptureTool::TYPE\\_SIZEINCREASE, CaptureTool::TYPE\\_SIZEDECREASE, CaptureTool::TYPE\\_ACCEPT, } | Protected Functions # Type Name void mousePressEvent (QMouseEvent * e) override Public Functions Documentation # function CaptureToolButton [1/2] # explicit CaptureToolButton::CaptureToolButton ( const CaptureTool::Type t, QWidget * parent=nullptr ) function animatedShow # void CaptureToolButton::animatedShow () function description # QString CaptureToolButton::description () const function icon # QIcon CaptureToolButton::icon () const function name # QString CaptureToolButton::name () const function setColor # void CaptureToolButton::setColor ( const QColor & c ) function tool # CaptureTool * CaptureToolButton::tool () const function ~CaptureToolButton # CaptureToolButton::~CaptureToolButton () Public Static Functions Documentation # function getIterableButtonTypes # static const QList< CaptureTool::Type > & CaptureToolButton::getIterableButtonTypes () function getPriorityByButton # static int CaptureToolButton::getPriorityByButton ( CaptureTool::Type b ) Protected Attributes Documentation # variable m_tool # CaptureTool* CaptureToolButton::m_tool; Protected Static Attributes Documentation # variable iterableButtonTypes # QList< CaptureTool::Type > CaptureToolButton::iterableButtonTypes; Protected Functions Documentation # function mousePressEvent # void CaptureToolButton::mousePressEvent ( QMouseEvent * e ) override","title":"Class CaptureToolButton"},{"location":"flameshot/classCaptureToolButton/#class-capturetoolbutton","text":"ClassList > CaptureToolButton Inherits the following classes: CaptureButton","title":"Class CaptureToolButton"},{"location":"flameshot/classCaptureToolButton/#public-functions","text":"Type Name CaptureToolButton (const CaptureTool::Type t, QWidget * parent=nullptr) void animatedShow () QString description () const QIcon icon () const QString name () const void setColor (const QColor & c) CaptureTool * tool () const ~CaptureToolButton ()","title":"Public Functions"},{"location":"flameshot/classCaptureToolButton/#public-functions-inherited-from-capturebutton","text":"See CaptureButton Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const","title":"Public Functions inherited from CaptureButton"},{"location":"flameshot/classCaptureToolButton/#public-static-functions","text":"Type Name const QList< CaptureTool::Type > & getIterableButtonTypes () int getPriorityByButton (CaptureTool::Type b)","title":"Public Static Functions"},{"location":"flameshot/classCaptureToolButton/#public-static-functions-inherited-from-capturebutton","text":"See CaptureButton Type Name QString globalStyleSheet ()","title":"Public Static Functions inherited from CaptureButton"},{"location":"flameshot/classCaptureToolButton/#protected-attributes","text":"Type Name CaptureTool * m_tool","title":"Protected Attributes"},{"location":"flameshot/classCaptureToolButton/#protected-static-attributes","text":"Type Name QList< CaptureTool::Type > iterableButtonTypes = = { CaptureTool::TYPE_PENCIL, CaptureTool::TYPE_DRAWER, CaptureTool::TYPE_ARROW, CaptureTool::TYPE_SELECTION, CaptureTool::TYPE_RECTANGLE, CaptureTool::TYPE_CIRCLE, CaptureTool::TYPE_MARKER, CaptureTool::TYPE_TEXT, CaptureTool::TYPE_CIRCLECOUNT, CaptureTool::TYPE_PIXELATE, CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO, CaptureTool::TYPE_REDO, CaptureTool::TYPE_COPY, CaptureTool::TYPE_SAVE, CaptureTool::TYPE_EXIT, CaptureTool::TYPE_IMAGEUPLOADER, CaptureTool::TYPE\\_OPEN\\_APP, CaptureTool::TYPE\\_PIN, CaptureTool::TYPE\\_SIZEINCREASE, CaptureTool::TYPE\\_SIZEDECREASE, CaptureTool::TYPE\\_ACCEPT, } |","title":"Protected Static Attributes"},{"location":"flameshot/classCaptureToolButton/#protected-functions","text":"Type Name void mousePressEvent (QMouseEvent * e) override","title":"Protected Functions"},{"location":"flameshot/classCaptureToolButton/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureToolButton/#function-capturetoolbutton-12","text":"explicit CaptureToolButton::CaptureToolButton ( const CaptureTool::Type t, QWidget * parent=nullptr )","title":"function CaptureToolButton [1/2]"},{"location":"flameshot/classCaptureToolButton/#function-animatedshow","text":"void CaptureToolButton::animatedShow ()","title":"function animatedShow"},{"location":"flameshot/classCaptureToolButton/#function-description","text":"QString CaptureToolButton::description () const","title":"function description"},{"location":"flameshot/classCaptureToolButton/#function-icon","text":"QIcon CaptureToolButton::icon () const","title":"function icon"},{"location":"flameshot/classCaptureToolButton/#function-name","text":"QString CaptureToolButton::name () const","title":"function name"},{"location":"flameshot/classCaptureToolButton/#function-setcolor","text":"void CaptureToolButton::setColor ( const QColor & c )","title":"function setColor"},{"location":"flameshot/classCaptureToolButton/#function-tool","text":"CaptureTool * CaptureToolButton::tool () const","title":"function tool"},{"location":"flameshot/classCaptureToolButton/#function-capturetoolbutton","text":"CaptureToolButton::~CaptureToolButton ()","title":"function ~CaptureToolButton"},{"location":"flameshot/classCaptureToolButton/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classCaptureToolButton/#function-getiterablebuttontypes","text":"static const QList< CaptureTool::Type > & CaptureToolButton::getIterableButtonTypes ()","title":"function getIterableButtonTypes"},{"location":"flameshot/classCaptureToolButton/#function-getprioritybybutton","text":"static int CaptureToolButton::getPriorityByButton ( CaptureTool::Type b )","title":"function getPriorityByButton"},{"location":"flameshot/classCaptureToolButton/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"flameshot/classCaptureToolButton/#variable-m_tool","text":"CaptureTool* CaptureToolButton::m_tool;","title":"variable m_tool"},{"location":"flameshot/classCaptureToolButton/#protected-static-attributes-documentation","text":"","title":"Protected Static Attributes Documentation"},{"location":"flameshot/classCaptureToolButton/#variable-iterablebuttontypes","text":"QList< CaptureTool::Type > CaptureToolButton::iterableButtonTypes;","title":"variable iterableButtonTypes"},{"location":"flameshot/classCaptureToolButton/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classCaptureToolButton/#function-mousepressevent","text":"void CaptureToolButton::mousePressEvent ( QMouseEvent * e ) override","title":"function mousePressEvent"},{"location":"flameshot/classCaptureToolObjects/","text":"Class CaptureToolObjects # ClassList > CaptureToolObjects Inherits the following classes: QObject Public Functions # Type Name CaptureToolObjects (QObject * parent=nullptr) void append (const QPointer< CaptureTool > & captureTool) QPointer< CaptureTool > at (int index) QList< QPointer< CaptureTool > > captureToolObjects () void clear () int find (const QPoint & pos, const QSize & captureSize) void insert (int index, const QPointer< CaptureTool > & captureTool) CaptureToolObjects & operator= (const CaptureToolObjects & other) void removeAt (int index) int size () Public Functions Documentation # function CaptureToolObjects # explicit CaptureToolObjects::CaptureToolObjects ( QObject * parent=nullptr ) function append # void CaptureToolObjects::append ( const QPointer< CaptureTool > & captureTool ) function at # QPointer< CaptureTool > CaptureToolObjects::at ( int index ) function captureToolObjects # QList< QPointer< CaptureTool > > CaptureToolObjects::captureToolObjects () function clear # void CaptureToolObjects::clear () function find # int CaptureToolObjects::find ( const QPoint & pos, const QSize & captureSize ) function insert # void CaptureToolObjects::insert ( int index, const QPointer< CaptureTool > & captureTool ) function operator= # CaptureToolObjects & CaptureToolObjects::operator= ( const CaptureToolObjects & other ) function removeAt # void CaptureToolObjects::removeAt ( int index ) function size # int CaptureToolObjects::size ()","title":"Class CaptureToolObjects"},{"location":"flameshot/classCaptureToolObjects/#class-capturetoolobjects","text":"ClassList > CaptureToolObjects Inherits the following classes: QObject","title":"Class CaptureToolObjects"},{"location":"flameshot/classCaptureToolObjects/#public-functions","text":"Type Name CaptureToolObjects (QObject * parent=nullptr) void append (const QPointer< CaptureTool > & captureTool) QPointer< CaptureTool > at (int index) QList< QPointer< CaptureTool > > captureToolObjects () void clear () int find (const QPoint & pos, const QSize & captureSize) void insert (int index, const QPointer< CaptureTool > & captureTool) CaptureToolObjects & operator= (const CaptureToolObjects & other) void removeAt (int index) int size ()","title":"Public Functions"},{"location":"flameshot/classCaptureToolObjects/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureToolObjects/#function-capturetoolobjects","text":"explicit CaptureToolObjects::CaptureToolObjects ( QObject * parent=nullptr )","title":"function CaptureToolObjects"},{"location":"flameshot/classCaptureToolObjects/#function-append","text":"void CaptureToolObjects::append ( const QPointer< CaptureTool > & captureTool )","title":"function append"},{"location":"flameshot/classCaptureToolObjects/#function-at","text":"QPointer< CaptureTool > CaptureToolObjects::at ( int index )","title":"function at"},{"location":"flameshot/classCaptureToolObjects/#function-capturetoolobjects_1","text":"QList< QPointer< CaptureTool > > CaptureToolObjects::captureToolObjects ()","title":"function captureToolObjects"},{"location":"flameshot/classCaptureToolObjects/#function-clear","text":"void CaptureToolObjects::clear ()","title":"function clear"},{"location":"flameshot/classCaptureToolObjects/#function-find","text":"int CaptureToolObjects::find ( const QPoint & pos, const QSize & captureSize )","title":"function find"},{"location":"flameshot/classCaptureToolObjects/#function-insert","text":"void CaptureToolObjects::insert ( int index, const QPointer< CaptureTool > & captureTool )","title":"function insert"},{"location":"flameshot/classCaptureToolObjects/#function-operator","text":"CaptureToolObjects & CaptureToolObjects::operator= ( const CaptureToolObjects & other )","title":"function operator="},{"location":"flameshot/classCaptureToolObjects/#function-removeat","text":"void CaptureToolObjects::removeAt ( int index )","title":"function removeAt"},{"location":"flameshot/classCaptureToolObjects/#function-size","text":"int CaptureToolObjects::size ()","title":"function size"},{"location":"flameshot/classCaptureWidget/","text":"Class CaptureWidget # ClassList > CaptureWidget Inherits the following classes: QWidget Public Functions # Type Name CaptureWidget (const CaptureRequest & req, bool fullScreen=true, QWidget * parent=nullptr) QPixmap pixmap () void removeToolObject (int index=-1) void setCaptureToolObjects (const CaptureToolObjects & captureToolObjects) void showAppUpdateNotification (const QString & appLatestVersion, const QString & appLatestUrl) void showxywh (bool show=true) ~CaptureWidget () Protected Functions # Type Name void changeEvent (QEvent * changeEvent) override void keyPressEvent (QKeyEvent * keyEvent) override void keyReleaseEvent (QKeyEvent * keyEvent) override void mouseDoubleClickEvent (QMouseEvent * event) override void mouseMoveEvent (QMouseEvent * mouseEvent) override void mousePressEvent (QMouseEvent * mouseEvent) override void mouseReleaseEvent (QMouseEvent * mouseEvent) override void moveEvent (QMoveEvent * moveEvent) override void paintEvent (QPaintEvent * paintEvent) override void resizeEvent (QResizeEvent * resizeEvent) override void wheelEvent (QWheelEvent * wheelEvent) override Public Functions Documentation # function CaptureWidget # explicit CaptureWidget::CaptureWidget ( const CaptureRequest & req, bool fullScreen=true, QWidget * parent=nullptr ) function pixmap # QPixmap CaptureWidget::pixmap () function removeToolObject # void CaptureWidget::removeToolObject ( int index=-1 ) function setCaptureToolObjects # void CaptureWidget::setCaptureToolObjects ( const CaptureToolObjects & captureToolObjects ) function showAppUpdateNotification # void CaptureWidget::showAppUpdateNotification ( const QString & appLatestVersion, const QString & appLatestUrl ) function showxywh # void CaptureWidget::showxywh ( bool show=true ) function ~CaptureWidget # CaptureWidget::~CaptureWidget () Protected Functions Documentation # function changeEvent # void CaptureWidget::changeEvent ( QEvent * changeEvent ) override function keyPressEvent # void CaptureWidget::keyPressEvent ( QKeyEvent * keyEvent ) override function keyReleaseEvent # void CaptureWidget::keyReleaseEvent ( QKeyEvent * keyEvent ) override function mouseDoubleClickEvent # void CaptureWidget::mouseDoubleClickEvent ( QMouseEvent * event ) override function mouseMoveEvent # void CaptureWidget::mouseMoveEvent ( QMouseEvent * mouseEvent ) override function mousePressEvent # void CaptureWidget::mousePressEvent ( QMouseEvent * mouseEvent ) override function mouseReleaseEvent # void CaptureWidget::mouseReleaseEvent ( QMouseEvent * mouseEvent ) override function moveEvent # void CaptureWidget::moveEvent ( QMoveEvent * moveEvent ) override function paintEvent # void CaptureWidget::paintEvent ( QPaintEvent * paintEvent ) override function resizeEvent # void CaptureWidget::resizeEvent ( QResizeEvent * resizeEvent ) override function wheelEvent # void CaptureWidget::wheelEvent ( QWheelEvent * wheelEvent ) override","title":"Class CaptureWidget"},{"location":"flameshot/classCaptureWidget/#class-capturewidget","text":"ClassList > CaptureWidget Inherits the following classes: QWidget","title":"Class CaptureWidget"},{"location":"flameshot/classCaptureWidget/#public-functions","text":"Type Name CaptureWidget (const CaptureRequest & req, bool fullScreen=true, QWidget * parent=nullptr) QPixmap pixmap () void removeToolObject (int index=-1) void setCaptureToolObjects (const CaptureToolObjects & captureToolObjects) void showAppUpdateNotification (const QString & appLatestVersion, const QString & appLatestUrl) void showxywh (bool show=true) ~CaptureWidget ()","title":"Public Functions"},{"location":"flameshot/classCaptureWidget/#protected-functions","text":"Type Name void changeEvent (QEvent * changeEvent) override void keyPressEvent (QKeyEvent * keyEvent) override void keyReleaseEvent (QKeyEvent * keyEvent) override void mouseDoubleClickEvent (QMouseEvent * event) override void mouseMoveEvent (QMouseEvent * mouseEvent) override void mousePressEvent (QMouseEvent * mouseEvent) override void mouseReleaseEvent (QMouseEvent * mouseEvent) override void moveEvent (QMoveEvent * moveEvent) override void paintEvent (QPaintEvent * paintEvent) override void resizeEvent (QResizeEvent * resizeEvent) override void wheelEvent (QWheelEvent * wheelEvent) override","title":"Protected Functions"},{"location":"flameshot/classCaptureWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCaptureWidget/#function-capturewidget","text":"explicit CaptureWidget::CaptureWidget ( const CaptureRequest & req, bool fullScreen=true, QWidget * parent=nullptr )","title":"function CaptureWidget"},{"location":"flameshot/classCaptureWidget/#function-pixmap","text":"QPixmap CaptureWidget::pixmap ()","title":"function pixmap"},{"location":"flameshot/classCaptureWidget/#function-removetoolobject","text":"void CaptureWidget::removeToolObject ( int index=-1 )","title":"function removeToolObject"},{"location":"flameshot/classCaptureWidget/#function-setcapturetoolobjects","text":"void CaptureWidget::setCaptureToolObjects ( const CaptureToolObjects & captureToolObjects )","title":"function setCaptureToolObjects"},{"location":"flameshot/classCaptureWidget/#function-showappupdatenotification","text":"void CaptureWidget::showAppUpdateNotification ( const QString & appLatestVersion, const QString & appLatestUrl )","title":"function showAppUpdateNotification"},{"location":"flameshot/classCaptureWidget/#function-showxywh","text":"void CaptureWidget::showxywh ( bool show=true )","title":"function showxywh"},{"location":"flameshot/classCaptureWidget/#function-capturewidget_1","text":"CaptureWidget::~CaptureWidget ()","title":"function ~CaptureWidget"},{"location":"flameshot/classCaptureWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classCaptureWidget/#function-changeevent","text":"void CaptureWidget::changeEvent ( QEvent * changeEvent ) override","title":"function changeEvent"},{"location":"flameshot/classCaptureWidget/#function-keypressevent","text":"void CaptureWidget::keyPressEvent ( QKeyEvent * keyEvent ) override","title":"function keyPressEvent"},{"location":"flameshot/classCaptureWidget/#function-keyreleaseevent","text":"void CaptureWidget::keyReleaseEvent ( QKeyEvent * keyEvent ) override","title":"function keyReleaseEvent"},{"location":"flameshot/classCaptureWidget/#function-mousedoubleclickevent","text":"void CaptureWidget::mouseDoubleClickEvent ( QMouseEvent * event ) override","title":"function mouseDoubleClickEvent"},{"location":"flameshot/classCaptureWidget/#function-mousemoveevent","text":"void CaptureWidget::mouseMoveEvent ( QMouseEvent * mouseEvent ) override","title":"function mouseMoveEvent"},{"location":"flameshot/classCaptureWidget/#function-mousepressevent","text":"void CaptureWidget::mousePressEvent ( QMouseEvent * mouseEvent ) override","title":"function mousePressEvent"},{"location":"flameshot/classCaptureWidget/#function-mousereleaseevent","text":"void CaptureWidget::mouseReleaseEvent ( QMouseEvent * mouseEvent ) override","title":"function mouseReleaseEvent"},{"location":"flameshot/classCaptureWidget/#function-moveevent","text":"void CaptureWidget::moveEvent ( QMoveEvent * moveEvent ) override","title":"function moveEvent"},{"location":"flameshot/classCaptureWidget/#function-paintevent","text":"void CaptureWidget::paintEvent ( QPaintEvent * paintEvent ) override","title":"function paintEvent"},{"location":"flameshot/classCaptureWidget/#function-resizeevent","text":"void CaptureWidget::resizeEvent ( QResizeEvent * resizeEvent ) override","title":"function resizeEvent"},{"location":"flameshot/classCaptureWidget/#function-wheelevent","text":"void CaptureWidget::wheelEvent ( QWheelEvent * wheelEvent ) override","title":"function wheelEvent"},{"location":"flameshot/classCircleCountTool/","text":"Class CircleCountTool # ClassList > CircleCountTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name CircleCountTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString info () override bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name void copyParams (const CircleCountTool * from, CircleCountTool * to) CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function CircleCountTool # explicit CircleCountTool::CircleCountTool ( QObject * parent=nullptr ) function boundingRect # QRect CircleCountTool::boundingRect () override const function copy # CaptureTool * CircleCountTool::copy ( QObject * parent=nullptr ) override function description # QString CircleCountTool::description () override const function icon # QIcon CircleCountTool::icon ( const QColor & background, bool inEditor ) override const function info # QString CircleCountTool::info () override function isValid # bool CircleCountTool::isValid () override const function mousePreviewRect # QRect CircleCountTool::mousePreviewRect ( const CaptureContext & context ) override const function name # QString CircleCountTool::name () override const function paintMousePreview # void CircleCountTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void CircleCountTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function copyParams # void CircleCountTool::copyParams ( const CircleCountTool * from, CircleCountTool * to ) function type # CaptureTool::Type CircleCountTool::type () override const","title":"Class CircleCountTool"},{"location":"flameshot/classCircleCountTool/#class-circlecounttool","text":"ClassList > CircleCountTool Inherits the following classes: AbstractTwoPointTool","title":"Class CircleCountTool"},{"location":"flameshot/classCircleCountTool/#public-functions","text":"Type Name CircleCountTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString info () override bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classCircleCountTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleCountTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleCountTool/#protected-functions","text":"Type Name void copyParams (const CircleCountTool * from, CircleCountTool * to) CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classCircleCountTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleCountTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCircleCountTool/#function-circlecounttool","text":"explicit CircleCountTool::CircleCountTool ( QObject * parent=nullptr )","title":"function CircleCountTool"},{"location":"flameshot/classCircleCountTool/#function-boundingrect","text":"QRect CircleCountTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classCircleCountTool/#function-copy","text":"CaptureTool * CircleCountTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classCircleCountTool/#function-description","text":"QString CircleCountTool::description () override const","title":"function description"},{"location":"flameshot/classCircleCountTool/#function-icon","text":"QIcon CircleCountTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classCircleCountTool/#function-info","text":"QString CircleCountTool::info () override","title":"function info"},{"location":"flameshot/classCircleCountTool/#function-isvalid","text":"bool CircleCountTool::isValid () override const","title":"function isValid"},{"location":"flameshot/classCircleCountTool/#function-mousepreviewrect","text":"QRect CircleCountTool::mousePreviewRect ( const CaptureContext & context ) override const","title":"function mousePreviewRect"},{"location":"flameshot/classCircleCountTool/#function-name","text":"QString CircleCountTool::name () override const","title":"function name"},{"location":"flameshot/classCircleCountTool/#function-paintmousepreview","text":"void CircleCountTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classCircleCountTool/#function-process","text":"void CircleCountTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classCircleCountTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classCircleCountTool/#function-copyparams","text":"void CircleCountTool::copyParams ( const CircleCountTool * from, CircleCountTool * to )","title":"function copyParams"},{"location":"flameshot/classCircleCountTool/#function-type","text":"CaptureTool::Type CircleCountTool::type () override const","title":"function type"},{"location":"flameshot/classCircleTool/","text":"Class CircleTool # ClassList > CircleTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name CircleTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function CircleTool # explicit CircleTool::CircleTool ( QObject * parent=nullptr ) function copy # CaptureTool * CircleTool::copy ( QObject * parent=nullptr ) override function description # QString CircleTool::description () override const function icon # QIcon CircleTool::icon ( const QColor & background, bool inEditor ) override const function name # QString CircleTool::name () override const function process # void CircleTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type CircleTool::type () override const","title":"Class CircleTool"},{"location":"flameshot/classCircleTool/#class-circletool","text":"ClassList > CircleTool Inherits the following classes: AbstractTwoPointTool","title":"Class CircleTool"},{"location":"flameshot/classCircleTool/#public-functions","text":"Type Name CircleTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classCircleTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classCircleTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classCircleTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCircleTool/#function-circletool","text":"explicit CircleTool::CircleTool ( QObject * parent=nullptr )","title":"function CircleTool"},{"location":"flameshot/classCircleTool/#function-copy","text":"CaptureTool * CircleTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classCircleTool/#function-description","text":"QString CircleTool::description () override const","title":"function description"},{"location":"flameshot/classCircleTool/#function-icon","text":"QIcon CircleTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classCircleTool/#function-name","text":"QString CircleTool::name () override const","title":"function name"},{"location":"flameshot/classCircleTool/#function-process","text":"void CircleTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classCircleTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classCircleTool/#function-type","text":"CaptureTool::Type CircleTool::type () override const","title":"function type"},{"location":"flameshot/classClickableLabel/","text":"Class ClickableLabel # ClassList > ClickableLabel Inherits the following classes: QLabel Public Functions # Type Name ClickableLabel (QWidget * parent=nullptr) ClickableLabel (QString s, QWidget * parent=nullptr) Public Functions Documentation # function ClickableLabel [1/2] # explicit ClickableLabel::ClickableLabel ( QWidget * parent=nullptr ) function ClickableLabel [2/2] # ClickableLabel::ClickableLabel ( QString s, QWidget * parent=nullptr )","title":"Class ClickableLabel"},{"location":"flameshot/classClickableLabel/#class-clickablelabel","text":"ClassList > ClickableLabel Inherits the following classes: QLabel","title":"Class ClickableLabel"},{"location":"flameshot/classClickableLabel/#public-functions","text":"Type Name ClickableLabel (QWidget * parent=nullptr) ClickableLabel (QString s, QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classClickableLabel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classClickableLabel/#function-clickablelabel-12","text":"explicit ClickableLabel::ClickableLabel ( QWidget * parent=nullptr )","title":"function ClickableLabel [1/2]"},{"location":"flameshot/classClickableLabel/#function-clickablelabel-22","text":"ClickableLabel::ClickableLabel ( QString s, QWidget * parent=nullptr )","title":"function ClickableLabel [2/2]"},{"location":"flameshot/classColor/","text":"Class Color # ClassList > Color Inherits the following classes: ValueHandler Public Functions # Type Name Color (QColor def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file. Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function Color # Color::Color ( QColor def ) function check # Check the value semantically. virtual bool Color::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString Color::expected () override Implements ValueHandler::expected function fallback # virtual QVariant Color::fallback () override Implements ValueHandler::fallback function process # Process a value, presuming it is a valid QVariant . virtual QVariant Color::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process function representation # Return the representation of the value in the config file. virtual QVariant Color::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"Class Color"},{"location":"flameshot/classColor/#class-color","text":"ClassList > Color Inherits the following classes: ValueHandler","title":"Class Color"},{"location":"flameshot/classColor/#public-functions","text":"Type Name Color (QColor def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file.","title":"Public Functions"},{"location":"flameshot/classColor/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classColor/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classColor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColor/#function-color","text":"Color::Color ( QColor def )","title":"function Color"},{"location":"flameshot/classColor/#function-check","text":"Check the value semantically. virtual bool Color::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classColor/#function-expected","text":"virtual QString Color::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classColor/#function-fallback","text":"virtual QVariant Color::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classColor/#function-process","text":"Process a value, presuming it is a valid QVariant . virtual QVariant Color::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process","title":"function process"},{"location":"flameshot/classColor/#function-representation","text":"Return the representation of the value in the config file. virtual QVariant Color::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"function representation"},{"location":"flameshot/classColorGrabWidget/","text":"Class ColorGrabWidget # ClassList > ColorGrabWidget Inherits the following classes: QWidget Public Functions # Type Name ColorGrabWidget (QPixmap * p, QWidget * parent=nullptr) QColor color () void startGrabbing () Public Functions Documentation # function ColorGrabWidget # ColorGrabWidget::ColorGrabWidget ( QPixmap * p, QWidget * parent=nullptr ) function color # QColor ColorGrabWidget::color () function startGrabbing # void ColorGrabWidget::startGrabbing ()","title":"Class ColorGrabWidget"},{"location":"flameshot/classColorGrabWidget/#class-colorgrabwidget","text":"ClassList > ColorGrabWidget Inherits the following classes: QWidget","title":"Class ColorGrabWidget"},{"location":"flameshot/classColorGrabWidget/#public-functions","text":"Type Name ColorGrabWidget (QPixmap * p, QWidget * parent=nullptr) QColor color () void startGrabbing ()","title":"Public Functions"},{"location":"flameshot/classColorGrabWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColorGrabWidget/#function-colorgrabwidget","text":"ColorGrabWidget::ColorGrabWidget ( QPixmap * p, QWidget * parent=nullptr )","title":"function ColorGrabWidget"},{"location":"flameshot/classColorGrabWidget/#function-color","text":"QColor ColorGrabWidget::color ()","title":"function color"},{"location":"flameshot/classColorGrabWidget/#function-startgrabbing","text":"void ColorGrabWidget::startGrabbing ()","title":"function startGrabbing"},{"location":"flameshot/classColorPicker/","text":"Class ColorPicker # ClassList > ColorPicker Inherits the following classes: ColorPickerWidget Public Functions # Type Name ColorPicker (QWidget * parent=nullptr) Public Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget () Public Static Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette () Protected Attributes inherited from ColorPickerWidget # See ColorPickerWidget Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor Protected Functions # Type Name void hideEvent (QHideEvent * event) override void mouseMoveEvent (QMouseEvent * e) override void showEvent (QShowEvent * event) override Protected Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter) Public Functions Documentation # function ColorPicker # explicit ColorPicker::ColorPicker ( QWidget * parent=nullptr ) Protected Functions Documentation # function hideEvent # void ColorPicker::hideEvent ( QHideEvent * event ) override function mouseMoveEvent # void ColorPicker::mouseMoveEvent ( QMouseEvent * e ) override function showEvent # void ColorPicker::showEvent ( QShowEvent * event ) override","title":"Class ColorPicker"},{"location":"flameshot/classColorPicker/#class-colorpicker","text":"ClassList > ColorPicker Inherits the following classes: ColorPickerWidget","title":"Class ColorPicker"},{"location":"flameshot/classColorPicker/#public-functions","text":"Type Name ColorPicker (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classColorPicker/#public-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget ()","title":"Public Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPicker/#public-static-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette ()","title":"Public Static Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPicker/#protected-attributes-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor","title":"Protected Attributes inherited from ColorPickerWidget"},{"location":"flameshot/classColorPicker/#protected-functions","text":"Type Name void hideEvent (QHideEvent * event) override void mouseMoveEvent (QMouseEvent * e) override void showEvent (QShowEvent * event) override","title":"Protected Functions"},{"location":"flameshot/classColorPicker/#protected-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter)","title":"Protected Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPicker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColorPicker/#function-colorpicker","text":"explicit ColorPicker::ColorPicker ( QWidget * parent=nullptr )","title":"function ColorPicker"},{"location":"flameshot/classColorPicker/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classColorPicker/#function-hideevent","text":"void ColorPicker::hideEvent ( QHideEvent * event ) override","title":"function hideEvent"},{"location":"flameshot/classColorPicker/#function-mousemoveevent","text":"void ColorPicker::mouseMoveEvent ( QMouseEvent * e ) override","title":"function mouseMoveEvent"},{"location":"flameshot/classColorPicker/#function-showevent","text":"void ColorPicker::showEvent ( QShowEvent * event ) override","title":"function showEvent"},{"location":"flameshot/classColorPickerEditMode/","text":"Class ColorPickerEditMode # ClassList > ColorPickerEditMode Inherits the following classes: ColorPickerWidget Public Functions # Type Name ColorPickerEditMode (QWidget * parent=nullptr) Public Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget () Public Static Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette () Protected Attributes inherited from ColorPickerWidget # See ColorPickerWidget Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor Protected Functions inherited from ColorPickerWidget # See ColorPickerWidget Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter) Public Functions Documentation # function ColorPickerEditMode # explicit ColorPickerEditMode::ColorPickerEditMode ( QWidget * parent=nullptr )","title":"Class ColorPickerEditMode"},{"location":"flameshot/classColorPickerEditMode/#class-colorpickereditmode","text":"ClassList > ColorPickerEditMode Inherits the following classes: ColorPickerWidget","title":"Class ColorPickerEditMode"},{"location":"flameshot/classColorPickerEditMode/#public-functions","text":"Type Name ColorPickerEditMode (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classColorPickerEditMode/#public-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget ()","title":"Public Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPickerEditMode/#public-static-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette ()","title":"Public Static Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPickerEditMode/#protected-attributes-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor","title":"Protected Attributes inherited from ColorPickerWidget"},{"location":"flameshot/classColorPickerEditMode/#protected-functions-inherited-from-colorpickerwidget","text":"See ColorPickerWidget Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter)","title":"Protected Functions inherited from ColorPickerWidget"},{"location":"flameshot/classColorPickerEditMode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColorPickerEditMode/#function-colorpickereditmode","text":"explicit ColorPickerEditMode::ColorPickerEditMode ( QWidget * parent=nullptr )","title":"function ColorPickerEditMode"},{"location":"flameshot/classColorPickerEditor/","text":"Class ColorPickerEditor # ClassList > ColorPickerEditor Inherits the following classes: QWidget Public Functions # Type Name ColorPickerEditor (QWidget * parent=nullptr) Public Functions Documentation # function ColorPickerEditor # explicit ColorPickerEditor::ColorPickerEditor ( QWidget * parent=nullptr )","title":"Class ColorPickerEditor"},{"location":"flameshot/classColorPickerEditor/#class-colorpickereditor","text":"ClassList > ColorPickerEditor Inherits the following classes: QWidget","title":"Class ColorPickerEditor"},{"location":"flameshot/classColorPickerEditor/#public-functions","text":"Type Name ColorPickerEditor (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classColorPickerEditor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColorPickerEditor/#function-colorpickereditor","text":"explicit ColorPickerEditor::ColorPickerEditor ( QWidget * parent=nullptr )","title":"function ColorPickerEditor"},{"location":"flameshot/classColorPickerWidget/","text":"Class ColorPickerWidget # ClassList > ColorPickerWidget Inherits the following classes: QWidget Inherited by the following classes: ColorPicker , ColorPickerEditMode Public Functions # Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget () Public Static Functions # Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette () Protected Attributes # Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor Protected Functions # Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter) Public Functions Documentation # function ColorPickerWidget # explicit ColorPickerWidget::ColorPickerWidget ( QWidget * parent=nullptr ) function updateSelection # void ColorPickerWidget::updateSelection ( int index ) function updateWidget # void ColorPickerWidget::updateWidget () Public Static Functions Documentation # function getDefaultLargeColorPalette # static const QVector< QColor > & ColorPickerWidget::getDefaultLargeColorPalette () function getDefaultSmallColorPalette # static const QVector< QColor > & ColorPickerWidget::getDefaultSmallColorPalette () Protected Attributes Documentation # variable m_colorAreaList # QVector<QRect> ColorPickerWidget::m_colorAreaList; variable m_colorAreaSize # int ColorPickerWidget::m_colorAreaSize; variable m_colorList # QVector<QColor> ColorPickerWidget::m_colorList; variable m_lastIndex # int ColorPickerWidget::m_lastIndex; variable m_selectedIndex # int ColorPickerWidget::m_selectedIndex; variable m_uiColor # QColor ColorPickerWidget::m_uiColor; Protected Functions Documentation # function paintEvent # void ColorPickerWidget::paintEvent ( QPaintEvent * event ) override function repaint # void ColorPickerWidget::repaint ( int i, QPainter & painter )","title":"Class ColorPickerWidget"},{"location":"flameshot/classColorPickerWidget/#class-colorpickerwidget","text":"ClassList > ColorPickerWidget Inherits the following classes: QWidget Inherited by the following classes: ColorPicker , ColorPickerEditMode","title":"Class ColorPickerWidget"},{"location":"flameshot/classColorPickerWidget/#public-functions","text":"Type Name ColorPickerWidget (QWidget * parent=nullptr) void updateSelection (int index) void updateWidget ()","title":"Public Functions"},{"location":"flameshot/classColorPickerWidget/#public-static-functions","text":"Type Name const QVector< QColor > & getDefaultLargeColorPalette () const QVector< QColor > & getDefaultSmallColorPalette ()","title":"Public Static Functions"},{"location":"flameshot/classColorPickerWidget/#protected-attributes","text":"Type Name QVector< QRect > m_colorAreaList int m_colorAreaSize QVector< QColor > m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor","title":"Protected Attributes"},{"location":"flameshot/classColorPickerWidget/#protected-functions","text":"Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter & painter)","title":"Protected Functions"},{"location":"flameshot/classColorPickerWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classColorPickerWidget/#function-colorpickerwidget","text":"explicit ColorPickerWidget::ColorPickerWidget ( QWidget * parent=nullptr )","title":"function ColorPickerWidget"},{"location":"flameshot/classColorPickerWidget/#function-updateselection","text":"void ColorPickerWidget::updateSelection ( int index )","title":"function updateSelection"},{"location":"flameshot/classColorPickerWidget/#function-updatewidget","text":"void ColorPickerWidget::updateWidget ()","title":"function updateWidget"},{"location":"flameshot/classColorPickerWidget/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classColorPickerWidget/#function-getdefaultlargecolorpalette","text":"static const QVector< QColor > & ColorPickerWidget::getDefaultLargeColorPalette ()","title":"function getDefaultLargeColorPalette"},{"location":"flameshot/classColorPickerWidget/#function-getdefaultsmallcolorpalette","text":"static const QVector< QColor > & ColorPickerWidget::getDefaultSmallColorPalette ()","title":"function getDefaultSmallColorPalette"},{"location":"flameshot/classColorPickerWidget/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"flameshot/classColorPickerWidget/#variable-m_colorarealist","text":"QVector<QRect> ColorPickerWidget::m_colorAreaList;","title":"variable m_colorAreaList"},{"location":"flameshot/classColorPickerWidget/#variable-m_colorareasize","text":"int ColorPickerWidget::m_colorAreaSize;","title":"variable m_colorAreaSize"},{"location":"flameshot/classColorPickerWidget/#variable-m_colorlist","text":"QVector<QColor> ColorPickerWidget::m_colorList;","title":"variable m_colorList"},{"location":"flameshot/classColorPickerWidget/#variable-m_lastindex","text":"int ColorPickerWidget::m_lastIndex;","title":"variable m_lastIndex"},{"location":"flameshot/classColorPickerWidget/#variable-m_selectedindex","text":"int ColorPickerWidget::m_selectedIndex;","title":"variable m_selectedIndex"},{"location":"flameshot/classColorPickerWidget/#variable-m_uicolor","text":"QColor ColorPickerWidget::m_uiColor;","title":"variable m_uiColor"},{"location":"flameshot/classColorPickerWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classColorPickerWidget/#function-paintevent","text":"void ColorPickerWidget::paintEvent ( QPaintEvent * event ) override","title":"function paintEvent"},{"location":"flameshot/classColorPickerWidget/#function-repaint","text":"void ColorPickerWidget::repaint ( int i, QPainter & painter )","title":"function repaint"},{"location":"flameshot/namespaceColorUtils/","text":"Namespace ColorUtils # Namespace List > ColorUtils Public Functions # Type Name bool colorIsDark (const QColor & c) QColor contrastColor (const QColor & c) Public Functions Documentation # function colorIsDark # bool ColorUtils::colorIsDark ( const QColor & c ) function contrastColor # QColor ColorUtils::contrastColor ( const QColor & c )","title":"Namespace ColorUtils"},{"location":"flameshot/namespaceColorUtils/#namespace-colorutils","text":"Namespace List > ColorUtils","title":"Namespace ColorUtils"},{"location":"flameshot/namespaceColorUtils/#public-functions","text":"Type Name bool colorIsDark (const QColor & c) QColor contrastColor (const QColor & c)","title":"Public Functions"},{"location":"flameshot/namespaceColorUtils/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/namespaceColorUtils/#function-colorisdark","text":"bool ColorUtils::colorIsDark ( const QColor & c )","title":"function colorIsDark"},{"location":"flameshot/namespaceColorUtils/#function-contrastcolor","text":"QColor ColorUtils::contrastColor ( const QColor & c )","title":"function contrastColor"},{"location":"flameshot/classCommandArgument/","text":"Class CommandArgument # ClassList > CommandArgument Public Functions # Type Name CommandArgument () CommandArgument (QString name, QString description) QString description () const bool isRoot () const QString name () const bool operator== (const CommandArgument & arg) const void setDescription (const QString & description) void setName (const QString & name) Public Functions Documentation # function CommandArgument [1/2] # CommandArgument::CommandArgument () function CommandArgument [2/2] # explicit CommandArgument::CommandArgument ( QString name, QString description ) function description # QString CommandArgument::description () const function isRoot # bool CommandArgument::isRoot () const function name # QString CommandArgument::name () const function operator== # bool CommandArgument::operator== ( const CommandArgument & arg ) const function setDescription # void CommandArgument::setDescription ( const QString & description ) function setName # void CommandArgument::setName ( const QString & name )","title":"Class CommandArgument"},{"location":"flameshot/classCommandArgument/#class-commandargument","text":"ClassList > CommandArgument","title":"Class CommandArgument"},{"location":"flameshot/classCommandArgument/#public-functions","text":"Type Name CommandArgument () CommandArgument (QString name, QString description) QString description () const bool isRoot () const QString name () const bool operator== (const CommandArgument & arg) const void setDescription (const QString & description) void setName (const QString & name)","title":"Public Functions"},{"location":"flameshot/classCommandArgument/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCommandArgument/#function-commandargument-12","text":"CommandArgument::CommandArgument ()","title":"function CommandArgument [1/2]"},{"location":"flameshot/classCommandArgument/#function-commandargument-22","text":"explicit CommandArgument::CommandArgument ( QString name, QString description )","title":"function CommandArgument [2/2]"},{"location":"flameshot/classCommandArgument/#function-description","text":"QString CommandArgument::description () const","title":"function description"},{"location":"flameshot/classCommandArgument/#function-isroot","text":"bool CommandArgument::isRoot () const","title":"function isRoot"},{"location":"flameshot/classCommandArgument/#function-name","text":"QString CommandArgument::name () const","title":"function name"},{"location":"flameshot/classCommandArgument/#function-operator","text":"bool CommandArgument::operator== ( const CommandArgument & arg ) const","title":"function operator=="},{"location":"flameshot/classCommandArgument/#function-setdescription","text":"void CommandArgument::setDescription ( const QString & description )","title":"function setDescription"},{"location":"flameshot/classCommandArgument/#function-setname","text":"void CommandArgument::setName ( const QString & name )","title":"function setName"},{"location":"flameshot/classCommandLineParser/","text":"Class CommandLineParser # ClassList > CommandLineParser Public Functions # Type Name bool AddArgument (const CommandArgument & arg, const CommandArgument & parent= CommandArgument ()) bool AddOption (const CommandOption & option, const CommandArgument & parent= CommandArgument ()) bool AddOptions (const QList< CommandOption > & options, const CommandArgument & parent= CommandArgument ()) CommandLineParser () CommandOption addHelpOption () CommandOption addVersionOption () bool isSet (const CommandArgument & arg) const bool isSet (const CommandOption & option) const bool parse (const QStringList & args) CommandArgument rootArgument () const void setDescription (const QString & description) void setGeneralErrorMessage (const QString & msg) QString value (const CommandOption & option) const Public Functions Documentation # function AddArgument # bool CommandLineParser::AddArgument ( const CommandArgument & arg, const CommandArgument & parent=CommandArgument () ) function AddOption # bool CommandLineParser::AddOption ( const CommandOption & option, const CommandArgument & parent=CommandArgument () ) function AddOptions # bool CommandLineParser::AddOptions ( const QList< CommandOption > & options, const CommandArgument & parent=CommandArgument () ) function CommandLineParser # CommandLineParser::CommandLineParser () function addHelpOption # CommandOption CommandLineParser::addHelpOption () function addVersionOption # CommandOption CommandLineParser::addVersionOption () function isSet [1/2] # bool CommandLineParser::isSet ( const CommandArgument & arg ) const function isSet [2/2] # bool CommandLineParser::isSet ( const CommandOption & option ) const function parse # bool CommandLineParser::parse ( const QStringList & args ) function rootArgument # inline CommandArgument CommandLineParser::rootArgument () const function setDescription # void CommandLineParser::setDescription ( const QString & description ) function setGeneralErrorMessage # void CommandLineParser::setGeneralErrorMessage ( const QString & msg ) function value # QString CommandLineParser::value ( const CommandOption & option ) const","title":"Class CommandLineParser"},{"location":"flameshot/classCommandLineParser/#class-commandlineparser","text":"ClassList > CommandLineParser","title":"Class CommandLineParser"},{"location":"flameshot/classCommandLineParser/#public-functions","text":"Type Name bool AddArgument (const CommandArgument & arg, const CommandArgument & parent= CommandArgument ()) bool AddOption (const CommandOption & option, const CommandArgument & parent= CommandArgument ()) bool AddOptions (const QList< CommandOption > & options, const CommandArgument & parent= CommandArgument ()) CommandLineParser () CommandOption addHelpOption () CommandOption addVersionOption () bool isSet (const CommandArgument & arg) const bool isSet (const CommandOption & option) const bool parse (const QStringList & args) CommandArgument rootArgument () const void setDescription (const QString & description) void setGeneralErrorMessage (const QString & msg) QString value (const CommandOption & option) const","title":"Public Functions"},{"location":"flameshot/classCommandLineParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCommandLineParser/#function-addargument","text":"bool CommandLineParser::AddArgument ( const CommandArgument & arg, const CommandArgument & parent=CommandArgument () )","title":"function AddArgument"},{"location":"flameshot/classCommandLineParser/#function-addoption","text":"bool CommandLineParser::AddOption ( const CommandOption & option, const CommandArgument & parent=CommandArgument () )","title":"function AddOption"},{"location":"flameshot/classCommandLineParser/#function-addoptions","text":"bool CommandLineParser::AddOptions ( const QList< CommandOption > & options, const CommandArgument & parent=CommandArgument () )","title":"function AddOptions"},{"location":"flameshot/classCommandLineParser/#function-commandlineparser","text":"CommandLineParser::CommandLineParser ()","title":"function CommandLineParser"},{"location":"flameshot/classCommandLineParser/#function-addhelpoption","text":"CommandOption CommandLineParser::addHelpOption ()","title":"function addHelpOption"},{"location":"flameshot/classCommandLineParser/#function-addversionoption","text":"CommandOption CommandLineParser::addVersionOption ()","title":"function addVersionOption"},{"location":"flameshot/classCommandLineParser/#function-isset-12","text":"bool CommandLineParser::isSet ( const CommandArgument & arg ) const","title":"function isSet [1/2]"},{"location":"flameshot/classCommandLineParser/#function-isset-22","text":"bool CommandLineParser::isSet ( const CommandOption & option ) const","title":"function isSet [2/2]"},{"location":"flameshot/classCommandLineParser/#function-parse","text":"bool CommandLineParser::parse ( const QStringList & args )","title":"function parse"},{"location":"flameshot/classCommandLineParser/#function-rootargument","text":"inline CommandArgument CommandLineParser::rootArgument () const","title":"function rootArgument"},{"location":"flameshot/classCommandLineParser/#function-setdescription","text":"void CommandLineParser::setDescription ( const QString & description )","title":"function setDescription"},{"location":"flameshot/classCommandLineParser/#function-setgeneralerrormessage","text":"void CommandLineParser::setGeneralErrorMessage ( const QString & msg )","title":"function setGeneralErrorMessage"},{"location":"flameshot/classCommandLineParser/#function-value","text":"QString CommandLineParser::value ( const CommandOption & option ) const","title":"function value"},{"location":"flameshot/structCommandLineParser_1_1Node/","text":"Struct CommandLineParser::Node # ClassList > Node Public Attributes # Type Name CommandArgument argument QList< CommandOption > options QList< Node > subNodes Public Functions # Type Name Node (const CommandArgument & arg) Node () bool operator== (const Node & n) const Public Attributes Documentation # variable argument # CommandArgument CommandLineParser::Node::argument; variable options # QList<CommandOption> CommandLineParser::Node::options; variable subNodes # QList<Node> CommandLineParser::Node::subNodes; Public Functions Documentation # function Node [1/2] # inline explicit Node::Node ( const CommandArgument & arg ) function Node [2/2] # inline Node::Node () function operator== # inline bool Node::operator== ( const Node & n ) const","title":"Struct CommandLineParser::Node"},{"location":"flameshot/structCommandLineParser_1_1Node/#struct-commandlineparsernode","text":"ClassList > Node","title":"Struct CommandLineParser::Node"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-attributes","text":"Type Name CommandArgument argument QList< CommandOption > options QList< Node > subNodes","title":"Public Attributes"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-functions","text":"Type Name Node (const CommandArgument & arg) Node () bool operator== (const Node & n) const","title":"Public Functions"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-argument","text":"CommandArgument CommandLineParser::Node::argument;","title":"variable argument"},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-options","text":"QList<CommandOption> CommandLineParser::Node::options;","title":"variable options"},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-subnodes","text":"QList<Node> CommandLineParser::Node::subNodes;","title":"variable subNodes"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structCommandLineParser_1_1Node/#function-node-12","text":"inline explicit Node::Node ( const CommandArgument & arg )","title":"function Node [1/2]"},{"location":"flameshot/structCommandLineParser_1_1Node/#function-node-22","text":"inline Node::Node ()","title":"function Node [2/2]"},{"location":"flameshot/structCommandLineParser_1_1Node/#function-operator","text":"inline bool Node::operator== ( const Node & n ) const","title":"function operator=="},{"location":"flameshot/classCommandOption/","text":"Class CommandOption # ClassList > CommandOption Public Functions # Type Name CommandOption (const QString & name, QString description, QString valueName=QString(), QString defaultValue=QString()) CommandOption (QStringList names, QString description, QString valueName=QString(), QString defaultValue=QString()) void addChecker (const function< bool(QString const &)> checker, const QString & errMsg) bool checkValue (const QString & value) const QStringList dashedNames () const QString description () const QString errorMsg () const QStringList names () const bool operator== (const CommandOption & option) const void setDescription (const QString & description) void setName (const QString & name) void setNames (const QStringList & names) void setValue (const QString & value) void setValueName (const QString & name) QString value () const QString valueName () const Public Functions Documentation # function CommandOption [1/2] # CommandOption::CommandOption ( const QString & name, QString description, QString valueName=QString(), QString defaultValue=QString() ) function CommandOption [2/2] # CommandOption::CommandOption ( QStringList names, QString description, QString valueName=QString(), QString defaultValue=QString() ) function addChecker # void CommandOption::addChecker ( const function< bool(QString const &)> checker, const QString & errMsg ) function checkValue # bool CommandOption::checkValue ( const QString & value ) const function dashedNames # QStringList CommandOption::dashedNames () const function description # QString CommandOption::description () const function errorMsg # QString CommandOption::errorMsg () const function names # QStringList CommandOption::names () const function operator== # bool CommandOption::operator== ( const CommandOption & option ) const function setDescription # void CommandOption::setDescription ( const QString & description ) function setName # void CommandOption::setName ( const QString & name ) function setNames # void CommandOption::setNames ( const QStringList & names ) function setValue # void CommandOption::setValue ( const QString & value ) function setValueName # void CommandOption::setValueName ( const QString & name ) function value # QString CommandOption::value () const function valueName # QString CommandOption::valueName () const","title":"Class CommandOption"},{"location":"flameshot/classCommandOption/#class-commandoption","text":"ClassList > CommandOption","title":"Class CommandOption"},{"location":"flameshot/classCommandOption/#public-functions","text":"Type Name CommandOption (const QString & name, QString description, QString valueName=QString(), QString defaultValue=QString()) CommandOption (QStringList names, QString description, QString valueName=QString(), QString defaultValue=QString()) void addChecker (const function< bool(QString const &)> checker, const QString & errMsg) bool checkValue (const QString & value) const QStringList dashedNames () const QString description () const QString errorMsg () const QStringList names () const bool operator== (const CommandOption & option) const void setDescription (const QString & description) void setName (const QString & name) void setNames (const QStringList & names) void setValue (const QString & value) void setValueName (const QString & name) QString value () const QString valueName () const","title":"Public Functions"},{"location":"flameshot/classCommandOption/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCommandOption/#function-commandoption-12","text":"CommandOption::CommandOption ( const QString & name, QString description, QString valueName=QString(), QString defaultValue=QString() )","title":"function CommandOption [1/2]"},{"location":"flameshot/classCommandOption/#function-commandoption-22","text":"CommandOption::CommandOption ( QStringList names, QString description, QString valueName=QString(), QString defaultValue=QString() )","title":"function CommandOption [2/2]"},{"location":"flameshot/classCommandOption/#function-addchecker","text":"void CommandOption::addChecker ( const function< bool(QString const &)> checker, const QString & errMsg )","title":"function addChecker"},{"location":"flameshot/classCommandOption/#function-checkvalue","text":"bool CommandOption::checkValue ( const QString & value ) const","title":"function checkValue"},{"location":"flameshot/classCommandOption/#function-dashednames","text":"QStringList CommandOption::dashedNames () const","title":"function dashedNames"},{"location":"flameshot/classCommandOption/#function-description","text":"QString CommandOption::description () const","title":"function description"},{"location":"flameshot/classCommandOption/#function-errormsg","text":"QString CommandOption::errorMsg () const","title":"function errorMsg"},{"location":"flameshot/classCommandOption/#function-names","text":"QStringList CommandOption::names () const","title":"function names"},{"location":"flameshot/classCommandOption/#function-operator","text":"bool CommandOption::operator== ( const CommandOption & option ) const","title":"function operator=="},{"location":"flameshot/classCommandOption/#function-setdescription","text":"void CommandOption::setDescription ( const QString & description )","title":"function setDescription"},{"location":"flameshot/classCommandOption/#function-setname","text":"void CommandOption::setName ( const QString & name )","title":"function setName"},{"location":"flameshot/classCommandOption/#function-setnames","text":"void CommandOption::setNames ( const QStringList & names )","title":"function setNames"},{"location":"flameshot/classCommandOption/#function-setvalue","text":"void CommandOption::setValue ( const QString & value )","title":"function setValue"},{"location":"flameshot/classCommandOption/#function-setvaluename","text":"void CommandOption::setValueName ( const QString & name )","title":"function setValueName"},{"location":"flameshot/classCommandOption/#function-value","text":"QString CommandOption::value () const","title":"function value"},{"location":"flameshot/classCommandOption/#function-valuename","text":"QString CommandOption::valueName () const","title":"function valueName"},{"location":"flameshot/structCompareAppByName/","text":"Struct CompareAppByName # ClassList > CompareAppByName Public Functions # Type Name bool operator() (const DesktopAppData a, const DesktopAppData b) Public Functions Documentation # function operator() # inline bool CompareAppByName::operator() ( const DesktopAppData a, const DesktopAppData b )","title":"Struct CompareAppByName"},{"location":"flameshot/structCompareAppByName/#struct-compareappbyname","text":"ClassList > CompareAppByName","title":"Struct CompareAppByName"},{"location":"flameshot/structCompareAppByName/#public-functions","text":"Type Name bool operator() (const DesktopAppData a, const DesktopAppData b)","title":"Public Functions"},{"location":"flameshot/structCompareAppByName/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structCompareAppByName/#function-operator","text":"inline bool CompareAppByName::operator() ( const DesktopAppData a, const DesktopAppData b )","title":"function operator()"},{"location":"flameshot/classConfigErrorDetails/","text":"Class ConfigErrorDetails # ClassList > ConfigErrorDetails Inherits the following classes: QDialog Public Functions # Type Name ConfigErrorDetails (QWidget * parent=nullptr) Public Functions Documentation # function ConfigErrorDetails # ConfigErrorDetails::ConfigErrorDetails ( QWidget * parent=nullptr )","title":"Class ConfigErrorDetails"},{"location":"flameshot/classConfigErrorDetails/#class-configerrordetails","text":"ClassList > ConfigErrorDetails Inherits the following classes: QDialog","title":"Class ConfigErrorDetails"},{"location":"flameshot/classConfigErrorDetails/#public-functions","text":"Type Name ConfigErrorDetails (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classConfigErrorDetails/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classConfigErrorDetails/#function-configerrordetails","text":"ConfigErrorDetails::ConfigErrorDetails ( QWidget * parent=nullptr )","title":"function ConfigErrorDetails"},{"location":"flameshot/classConfigHandler/","text":"Class ConfigHandler # ClassList > ConfigHandler Inherits the following classes: QObject Public Attributes # Type Name setShowDesktopNotification bool setShowStartupLaunchMessage bool bool setUploadWithoutConfirmation Public Functions # Type Name CONFIG_GETTER_SETTER (userColors, setUserColors, QVector< QColor >) CONFIG_GETTER_SETTER (predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool) bool CONFIG_GETTER_SETTER (allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool) bool bool CONFIG_GETTER_SETTER (historyConfirmationToDelete, setHistoryConfirmationToDelete, bool) bool bool bool CONFIG_GETTER_SETTER (ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString) ConfigHandler () void checkAndHandleError () const Parse the configuration to find any errors in it. bool checkForErrors ( AbstractLogger * log=nullptr) const bool checkSemantics ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr) const Check each config value semantically. bool checkShortcutConflicts ( AbstractLogger * log=nullptr) const Check if there are multiple actions with the same shortcut. bool checkUnrecognizedSettings ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr) const Parse the config to find settings with unrecognized names. QString configFilePath () const QString errorMessage () const Error message that can be used by other classes as well. QString filenamePatternDefault () bool hasError () const Return if the config contains an error. QSet< QString > keysFromGroup (const QString & group) const Return keys from group group . Use CONFIG_GROUP_GENERAL (General) for general settings. void remove (const QString & key) void resetValue (const QString & key) void setAllTheButtons () void setDefaultSettings () void setErrorState (bool error) const Update the tracked error state of the config. bool setShortcut (const QString & actionName, const QString & shortcut) void setStartupLaunch (const bool start) void setToolSize (CaptureTool::Type toolType, int size) void setValue (const QString & key, const QVariant & value) QString shortcut (const QString & actionName) int toolSize (CaptureTool::Type toolType) QVariant value (const QString & key) const Public Static Functions # Type Name ConfigHandler * getInstance () Serves as an object to which slots can be connected. QSet< QString > & recognizedGeneralOptions () QSet< QString > & recognizedShortcutNames () Public Attributes Documentation # variable setShowDesktopNotification # ConfigHandler::setShowDesktopNotification; variable setShowStartupLaunchMessage # bool ConfigHandler::setShowStartupLaunchMessage; variable setUploadWithoutConfirmation # bool bool ConfigHandler::setUploadWithoutConfirmation; Public Functions Documentation # function CONFIG_GETTER_SETTER [1/5] # ConfigHandler::CONFIG_GETTER_SETTER ( userColors, setUserColors, QVector< QColor > ) function CONFIG_GETTER_SETTER [2/5] # ConfigHandler::CONFIG_GETTER_SETTER ( predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool ) function CONFIG_GETTER_SETTER [3/5] # bool ConfigHandler::CONFIG_GETTER_SETTER ( allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool ) function CONFIG_GETTER_SETTER [4/5] # bool bool ConfigHandler::CONFIG_GETTER_SETTER ( historyConfirmationToDelete, setHistoryConfirmationToDelete, bool ) function CONFIG_GETTER_SETTER [5/5] # bool bool bool ConfigHandler::CONFIG_GETTER_SETTER ( ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString ) function ConfigHandler # explicit ConfigHandler::ConfigHandler () function checkAndHandleError # Parse the configuration to find any errors in it. void ConfigHandler::checkAndHandleError () const If the error state changes as a result of the check, it will perform the appropriate action, e.g. notify the user. See also: ConfigHandler::setErrorState for all the actions. function checkForErrors # bool ConfigHandler::checkForErrors ( AbstractLogger * log=nullptr ) const function checkSemantics # Check each config value semantically. bool ConfigHandler::checkSemantics ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr ) const Parameters: log Destination for error log output. offenders Destination for the semantically invalid keys. Returns: Whether the config passes this check. function checkShortcutConflicts # Check if there are multiple actions with the same shortcut. bool ConfigHandler::checkShortcutConflicts ( AbstractLogger * log=nullptr ) const Returns: Whether the config passes this check. Note: It is not considered a conflict if action A uses shortcut S because it is the flameshot default (not because the user explicitly configured it), and action B uses the same shortcut. function checkUnrecognizedSettings # Parse the config to find settings with unrecognized names. bool ConfigHandler::checkUnrecognizedSettings ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr ) const Returns: Whether the config passes this check. Note: An unrecognized option is one that is not included in recognizedGeneralOptions or recognizedShortcutNames depending on the group the option belongs to. function configFilePath # QString ConfigHandler::configFilePath () const function errorMessage # QString ConfigHandler::errorMessage () const function filenamePatternDefault # QString ConfigHandler::filenamePatternDefault () function hasError # Return if the config contains an error. bool ConfigHandler::hasError () const If an error check is due, it will be performed. function keysFromGroup # QSet< QString > ConfigHandler::keysFromGroup ( const QString & group ) const function remove # void ConfigHandler::remove ( const QString & key ) function resetValue # void ConfigHandler::resetValue ( const QString & key ) function setAllTheButtons # void ConfigHandler::setAllTheButtons () function setDefaultSettings # void ConfigHandler::setDefaultSettings () function setErrorState # Update the tracked error state of the config. void ConfigHandler::setErrorState ( bool error ) const Parameters: error The new error state. The error state is tracked so that signals are not emitted and the user is not spammed every time the config file changes. Instead, only changes in error state get reported. function setShortcut # bool ConfigHandler::setShortcut ( const QString & actionName, const QString & shortcut ) function setStartupLaunch # void ConfigHandler::setStartupLaunch ( const bool start ) function setToolSize # void ConfigHandler::setToolSize ( CaptureTool::Type toolType, int size ) function setValue # void ConfigHandler::setValue ( const QString & key, const QVariant & value ) function shortcut # QString ConfigHandler::shortcut ( const QString & actionName ) function toolSize # int ConfigHandler::toolSize ( CaptureTool::Type toolType ) function value # QVariant ConfigHandler::value ( const QString & key ) const Public Static Functions Documentation # function getInstance # static ConfigHandler * ConfigHandler::getInstance () function recognizedGeneralOptions # static QSet< QString > & ConfigHandler::recognizedGeneralOptions () function recognizedShortcutNames # static QSet< QString > & ConfigHandler::recognizedShortcutNames ()","title":"Class ConfigHandler"},{"location":"flameshot/classConfigHandler/#class-confighandler","text":"ClassList > ConfigHandler Inherits the following classes: QObject","title":"Class ConfigHandler"},{"location":"flameshot/classConfigHandler/#public-attributes","text":"Type Name setShowDesktopNotification bool setShowStartupLaunchMessage bool bool setUploadWithoutConfirmation","title":"Public Attributes"},{"location":"flameshot/classConfigHandler/#public-functions","text":"Type Name CONFIG_GETTER_SETTER (userColors, setUserColors, QVector< QColor >) CONFIG_GETTER_SETTER (predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool) bool CONFIG_GETTER_SETTER (allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool) bool bool CONFIG_GETTER_SETTER (historyConfirmationToDelete, setHistoryConfirmationToDelete, bool) bool bool bool CONFIG_GETTER_SETTER (ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString) ConfigHandler () void checkAndHandleError () const Parse the configuration to find any errors in it. bool checkForErrors ( AbstractLogger * log=nullptr) const bool checkSemantics ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr) const Check each config value semantically. bool checkShortcutConflicts ( AbstractLogger * log=nullptr) const Check if there are multiple actions with the same shortcut. bool checkUnrecognizedSettings ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr) const Parse the config to find settings with unrecognized names. QString configFilePath () const QString errorMessage () const Error message that can be used by other classes as well. QString filenamePatternDefault () bool hasError () const Return if the config contains an error. QSet< QString > keysFromGroup (const QString & group) const Return keys from group group . Use CONFIG_GROUP_GENERAL (General) for general settings. void remove (const QString & key) void resetValue (const QString & key) void setAllTheButtons () void setDefaultSettings () void setErrorState (bool error) const Update the tracked error state of the config. bool setShortcut (const QString & actionName, const QString & shortcut) void setStartupLaunch (const bool start) void setToolSize (CaptureTool::Type toolType, int size) void setValue (const QString & key, const QVariant & value) QString shortcut (const QString & actionName) int toolSize (CaptureTool::Type toolType) QVariant value (const QString & key) const","title":"Public Functions"},{"location":"flameshot/classConfigHandler/#public-static-functions","text":"Type Name ConfigHandler * getInstance () Serves as an object to which slots can be connected. QSet< QString > & recognizedGeneralOptions () QSet< QString > & recognizedShortcutNames ()","title":"Public Static Functions"},{"location":"flameshot/classConfigHandler/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/classConfigHandler/#variable-setshowdesktopnotification","text":"ConfigHandler::setShowDesktopNotification;","title":"variable setShowDesktopNotification"},{"location":"flameshot/classConfigHandler/#variable-setshowstartuplaunchmessage","text":"bool ConfigHandler::setShowStartupLaunchMessage;","title":"variable setShowStartupLaunchMessage"},{"location":"flameshot/classConfigHandler/#variable-setuploadwithoutconfirmation","text":"bool bool ConfigHandler::setUploadWithoutConfirmation;","title":"variable setUploadWithoutConfirmation"},{"location":"flameshot/classConfigHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-15","text":"ConfigHandler::CONFIG_GETTER_SETTER ( userColors, setUserColors, QVector< QColor > )","title":"function CONFIG_GETTER_SETTER [1/5]"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-25","text":"ConfigHandler::CONFIG_GETTER_SETTER ( predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool )","title":"function CONFIG_GETTER_SETTER [2/5]"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-35","text":"bool ConfigHandler::CONFIG_GETTER_SETTER ( allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool )","title":"function CONFIG_GETTER_SETTER [3/5]"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-45","text":"bool bool ConfigHandler::CONFIG_GETTER_SETTER ( historyConfirmationToDelete, setHistoryConfirmationToDelete, bool )","title":"function CONFIG_GETTER_SETTER [4/5]"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-55","text":"bool bool bool ConfigHandler::CONFIG_GETTER_SETTER ( ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString )","title":"function CONFIG_GETTER_SETTER [5/5]"},{"location":"flameshot/classConfigHandler/#function-confighandler","text":"explicit ConfigHandler::ConfigHandler ()","title":"function ConfigHandler"},{"location":"flameshot/classConfigHandler/#function-checkandhandleerror","text":"Parse the configuration to find any errors in it. void ConfigHandler::checkAndHandleError () const If the error state changes as a result of the check, it will perform the appropriate action, e.g. notify the user. See also: ConfigHandler::setErrorState for all the actions.","title":"function checkAndHandleError"},{"location":"flameshot/classConfigHandler/#function-checkforerrors","text":"bool ConfigHandler::checkForErrors ( AbstractLogger * log=nullptr ) const","title":"function checkForErrors"},{"location":"flameshot/classConfigHandler/#function-checksemantics","text":"Check each config value semantically. bool ConfigHandler::checkSemantics ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr ) const Parameters: log Destination for error log output. offenders Destination for the semantically invalid keys. Returns: Whether the config passes this check.","title":"function checkSemantics"},{"location":"flameshot/classConfigHandler/#function-checkshortcutconflicts","text":"Check if there are multiple actions with the same shortcut. bool ConfigHandler::checkShortcutConflicts ( AbstractLogger * log=nullptr ) const Returns: Whether the config passes this check. Note: It is not considered a conflict if action A uses shortcut S because it is the flameshot default (not because the user explicitly configured it), and action B uses the same shortcut.","title":"function checkShortcutConflicts"},{"location":"flameshot/classConfigHandler/#function-checkunrecognizedsettings","text":"Parse the config to find settings with unrecognized names. bool ConfigHandler::checkUnrecognizedSettings ( AbstractLogger * log=nullptr, QList< QString > * offenders=nullptr ) const Returns: Whether the config passes this check. Note: An unrecognized option is one that is not included in recognizedGeneralOptions or recognizedShortcutNames depending on the group the option belongs to.","title":"function checkUnrecognizedSettings"},{"location":"flameshot/classConfigHandler/#function-configfilepath","text":"QString ConfigHandler::configFilePath () const","title":"function configFilePath"},{"location":"flameshot/classConfigHandler/#function-errormessage","text":"QString ConfigHandler::errorMessage () const","title":"function errorMessage"},{"location":"flameshot/classConfigHandler/#function-filenamepatterndefault","text":"QString ConfigHandler::filenamePatternDefault ()","title":"function filenamePatternDefault"},{"location":"flameshot/classConfigHandler/#function-haserror","text":"Return if the config contains an error. bool ConfigHandler::hasError () const If an error check is due, it will be performed.","title":"function hasError"},{"location":"flameshot/classConfigHandler/#function-keysfromgroup","text":"QSet< QString > ConfigHandler::keysFromGroup ( const QString & group ) const","title":"function keysFromGroup"},{"location":"flameshot/classConfigHandler/#function-remove","text":"void ConfigHandler::remove ( const QString & key )","title":"function remove"},{"location":"flameshot/classConfigHandler/#function-resetvalue","text":"void ConfigHandler::resetValue ( const QString & key )","title":"function resetValue"},{"location":"flameshot/classConfigHandler/#function-setallthebuttons","text":"void ConfigHandler::setAllTheButtons ()","title":"function setAllTheButtons"},{"location":"flameshot/classConfigHandler/#function-setdefaultsettings","text":"void ConfigHandler::setDefaultSettings ()","title":"function setDefaultSettings"},{"location":"flameshot/classConfigHandler/#function-seterrorstate","text":"Update the tracked error state of the config. void ConfigHandler::setErrorState ( bool error ) const Parameters: error The new error state. The error state is tracked so that signals are not emitted and the user is not spammed every time the config file changes. Instead, only changes in error state get reported.","title":"function setErrorState"},{"location":"flameshot/classConfigHandler/#function-setshortcut","text":"bool ConfigHandler::setShortcut ( const QString & actionName, const QString & shortcut )","title":"function setShortcut"},{"location":"flameshot/classConfigHandler/#function-setstartuplaunch","text":"void ConfigHandler::setStartupLaunch ( const bool start )","title":"function setStartupLaunch"},{"location":"flameshot/classConfigHandler/#function-settoolsize","text":"void ConfigHandler::setToolSize ( CaptureTool::Type toolType, int size )","title":"function setToolSize"},{"location":"flameshot/classConfigHandler/#function-setvalue","text":"void ConfigHandler::setValue ( const QString & key, const QVariant & value )","title":"function setValue"},{"location":"flameshot/classConfigHandler/#function-shortcut","text":"QString ConfigHandler::shortcut ( const QString & actionName )","title":"function shortcut"},{"location":"flameshot/classConfigHandler/#function-toolsize","text":"int ConfigHandler::toolSize ( CaptureTool::Type toolType )","title":"function toolSize"},{"location":"flameshot/classConfigHandler/#function-value","text":"QVariant ConfigHandler::value ( const QString & key ) const","title":"function value"},{"location":"flameshot/classConfigHandler/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classConfigHandler/#function-getinstance","text":"static ConfigHandler * ConfigHandler::getInstance ()","title":"function getInstance"},{"location":"flameshot/classConfigHandler/#function-recognizedgeneraloptions","text":"static QSet< QString > & ConfigHandler::recognizedGeneralOptions ()","title":"function recognizedGeneralOptions"},{"location":"flameshot/classConfigHandler/#function-recognizedshortcutnames","text":"static QSet< QString > & ConfigHandler::recognizedShortcutNames ()","title":"function recognizedShortcutNames"},{"location":"flameshot/classConfigResolver/","text":"Class ConfigResolver # ClassList > ConfigResolver Inherits the following classes: QDialog Public Functions # Type Name ConfigResolver (QWidget * parent=nullptr) QGridLayout * layout () Public Functions Documentation # function ConfigResolver # ConfigResolver::ConfigResolver ( QWidget * parent=nullptr ) function layout # QGridLayout * ConfigResolver::layout ()","title":"Class ConfigResolver"},{"location":"flameshot/classConfigResolver/#class-configresolver","text":"ClassList > ConfigResolver Inherits the following classes: QDialog","title":"Class ConfigResolver"},{"location":"flameshot/classConfigResolver/#public-functions","text":"Type Name ConfigResolver (QWidget * parent=nullptr) QGridLayout * layout ()","title":"Public Functions"},{"location":"flameshot/classConfigResolver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classConfigResolver/#function-configresolver","text":"ConfigResolver::ConfigResolver ( QWidget * parent=nullptr )","title":"function ConfigResolver"},{"location":"flameshot/classConfigResolver/#function-layout","text":"QGridLayout * ConfigResolver::layout ()","title":"function layout"},{"location":"flameshot/classConfigWindow/","text":"Class ConfigWindow # ClassList > ConfigWindow Inherits the following classes: QWidget Public Functions # Type Name ConfigWindow (QWidget * parent=nullptr) Protected Functions # Type Name void keyPressEvent (QKeyEvent * e) Public Functions Documentation # function ConfigWindow # explicit ConfigWindow::ConfigWindow ( QWidget * parent=nullptr ) Protected Functions Documentation # function keyPressEvent # void ConfigWindow::keyPressEvent ( QKeyEvent * e )","title":"Class ConfigWindow"},{"location":"flameshot/classConfigWindow/#class-configwindow","text":"ClassList > ConfigWindow Inherits the following classes: QWidget","title":"Class ConfigWindow"},{"location":"flameshot/classConfigWindow/#public-functions","text":"Type Name ConfigWindow (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classConfigWindow/#protected-functions","text":"Type Name void keyPressEvent (QKeyEvent * e)","title":"Protected Functions"},{"location":"flameshot/classConfigWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classConfigWindow/#function-configwindow","text":"explicit ConfigWindow::ConfigWindow ( QWidget * parent=nullptr )","title":"function ConfigWindow"},{"location":"flameshot/classConfigWindow/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classConfigWindow/#function-keypressevent","text":"void ConfigWindow::keyPressEvent ( QKeyEvent * e )","title":"function keyPressEvent"},{"location":"flameshot/classCopyTool/","text":"Class CopyTool # ClassList > CopyTool Inherits the following classes: AbstractActionTool Public Functions # Type Name CopyTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function CopyTool # explicit CopyTool::CopyTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool CopyTool::closeOnButtonPressed () override const function copy # CaptureTool * CopyTool::copy ( QObject * parent=nullptr ) override function description # QString CopyTool::description () override const function icon # QIcon CopyTool::icon ( const QColor & background, bool inEditor ) override const function name # QString CopyTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type CopyTool::type () override const","title":"Class CopyTool"},{"location":"flameshot/classCopyTool/#class-copytool","text":"ClassList > CopyTool Inherits the following classes: AbstractActionTool","title":"Class CopyTool"},{"location":"flameshot/classCopyTool/#public-functions","text":"Type Name CopyTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classCopyTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classCopyTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classCopyTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classCopyTool/#function-copytool","text":"explicit CopyTool::CopyTool ( QObject * parent=nullptr )","title":"function CopyTool"},{"location":"flameshot/classCopyTool/#function-closeonbuttonpressed","text":"bool CopyTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classCopyTool/#function-copy","text":"CaptureTool * CopyTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classCopyTool/#function-description","text":"QString CopyTool::description () override const","title":"function description"},{"location":"flameshot/classCopyTool/#function-icon","text":"QIcon CopyTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classCopyTool/#function-name","text":"QString CopyTool::name () override const","title":"function name"},{"location":"flameshot/classCopyTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classCopyTool/#function-type","text":"CaptureTool::Type CopyTool::type () override const","title":"function type"},{"location":"flameshot/structDesktopAppData/","text":"Struct DesktopAppData # ClassList > DesktopAppData Public Attributes # Type Name QStringList categories QString description QString exec QIcon icon QString name bool showInTerminal Public Functions # Type Name DesktopAppData () DesktopAppData (const QString & name, const QString & description, const QString & exec, QIcon icon) bool operator== (const DesktopAppData & other) const Public Attributes Documentation # variable categories # QStringList DesktopAppData::categories; variable description # QString DesktopAppData::description; variable exec # QString DesktopAppData::exec; variable icon # QIcon DesktopAppData::icon; variable name # QString DesktopAppData::name; variable showInTerminal # bool DesktopAppData::showInTerminal; Public Functions Documentation # function DesktopAppData [1/2] # inline DesktopAppData::DesktopAppData () function DesktopAppData [2/2] # inline DesktopAppData::DesktopAppData ( const QString & name, const QString & description, const QString & exec, QIcon icon ) function operator== # inline bool DesktopAppData::operator== ( const DesktopAppData & other ) const","title":"Struct DesktopAppData"},{"location":"flameshot/structDesktopAppData/#struct-desktopappdata","text":"ClassList > DesktopAppData","title":"Struct DesktopAppData"},{"location":"flameshot/structDesktopAppData/#public-attributes","text":"Type Name QStringList categories QString description QString exec QIcon icon QString name bool showInTerminal","title":"Public Attributes"},{"location":"flameshot/structDesktopAppData/#public-functions","text":"Type Name DesktopAppData () DesktopAppData (const QString & name, const QString & description, const QString & exec, QIcon icon) bool operator== (const DesktopAppData & other) const","title":"Public Functions"},{"location":"flameshot/structDesktopAppData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/structDesktopAppData/#variable-categories","text":"QStringList DesktopAppData::categories;","title":"variable categories"},{"location":"flameshot/structDesktopAppData/#variable-description","text":"QString DesktopAppData::description;","title":"variable description"},{"location":"flameshot/structDesktopAppData/#variable-exec","text":"QString DesktopAppData::exec;","title":"variable exec"},{"location":"flameshot/structDesktopAppData/#variable-icon","text":"QIcon DesktopAppData::icon;","title":"variable icon"},{"location":"flameshot/structDesktopAppData/#variable-name","text":"QString DesktopAppData::name;","title":"variable name"},{"location":"flameshot/structDesktopAppData/#variable-showinterminal","text":"bool DesktopAppData::showInTerminal;","title":"variable showInTerminal"},{"location":"flameshot/structDesktopAppData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structDesktopAppData/#function-desktopappdata-12","text":"inline DesktopAppData::DesktopAppData ()","title":"function DesktopAppData [1/2]"},{"location":"flameshot/structDesktopAppData/#function-desktopappdata-22","text":"inline DesktopAppData::DesktopAppData ( const QString & name, const QString & description, const QString & exec, QIcon icon )","title":"function DesktopAppData [2/2]"},{"location":"flameshot/structDesktopAppData/#function-operator","text":"inline bool DesktopAppData::operator== ( const DesktopAppData & other ) const","title":"function operator=="},{"location":"flameshot/structDesktopFileParser/","text":"Struct DesktopFileParser # ClassList > DesktopFileParser Public Functions # Type Name DesktopFileParser () QVector< DesktopAppData > getAppsByCategory (const QString & category) QMap< QString, QVector< DesktopAppData > > getAppsByCategory (const QStringList & categories) DesktopAppData parseDesktopFile (const QString & fileName, bool & ok) const int processDirectory (const QDir & dir) Public Functions Documentation # function DesktopFileParser # DesktopFileParser::DesktopFileParser () function getAppsByCategory [1/2] # QVector< DesktopAppData > DesktopFileParser::getAppsByCategory ( const QString & category ) function getAppsByCategory [2/2] # QMap< QString, QVector< DesktopAppData > > DesktopFileParser::getAppsByCategory ( const QStringList & categories ) function parseDesktopFile # DesktopAppData DesktopFileParser::parseDesktopFile ( const QString & fileName, bool & ok ) const function processDirectory # int DesktopFileParser::processDirectory ( const QDir & dir )","title":"Struct DesktopFileParser"},{"location":"flameshot/structDesktopFileParser/#struct-desktopfileparser","text":"ClassList > DesktopFileParser","title":"Struct DesktopFileParser"},{"location":"flameshot/structDesktopFileParser/#public-functions","text":"Type Name DesktopFileParser () QVector< DesktopAppData > getAppsByCategory (const QString & category) QMap< QString, QVector< DesktopAppData > > getAppsByCategory (const QStringList & categories) DesktopAppData parseDesktopFile (const QString & fileName, bool & ok) const int processDirectory (const QDir & dir)","title":"Public Functions"},{"location":"flameshot/structDesktopFileParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structDesktopFileParser/#function-desktopfileparser","text":"DesktopFileParser::DesktopFileParser ()","title":"function DesktopFileParser"},{"location":"flameshot/structDesktopFileParser/#function-getappsbycategory-12","text":"QVector< DesktopAppData > DesktopFileParser::getAppsByCategory ( const QString & category )","title":"function getAppsByCategory [1/2]"},{"location":"flameshot/structDesktopFileParser/#function-getappsbycategory-22","text":"QMap< QString, QVector< DesktopAppData > > DesktopFileParser::getAppsByCategory ( const QStringList & categories )","title":"function getAppsByCategory [2/2]"},{"location":"flameshot/structDesktopFileParser/#function-parsedesktopfile","text":"DesktopAppData DesktopFileParser::parseDesktopFile ( const QString & fileName, bool & ok ) const","title":"function parseDesktopFile"},{"location":"flameshot/structDesktopFileParser/#function-processdirectory","text":"int DesktopFileParser::processDirectory ( const QDir & dir )","title":"function processDirectory"},{"location":"flameshot/classDesktopInfo/","text":"Class DesktopInfo # ClassList > DesktopInfo Public Types # Type Name enum WM Public Functions # Type Name DesktopInfo () bool waylandDetected () WM windowManager () Public Types Documentation # enum WM # enum DesktopInfo::WM { GNOME, KDE, OTHER, QTILE, SWAY }; Public Functions Documentation # function DesktopInfo # DesktopInfo::DesktopInfo () function waylandDetected # bool DesktopInfo::waylandDetected () function windowManager # WM DesktopInfo::windowManager ()","title":"Class DesktopInfo"},{"location":"flameshot/classDesktopInfo/#class-desktopinfo","text":"ClassList > DesktopInfo","title":"Class DesktopInfo"},{"location":"flameshot/classDesktopInfo/#public-types","text":"Type Name enum WM","title":"Public Types"},{"location":"flameshot/classDesktopInfo/#public-functions","text":"Type Name DesktopInfo () bool waylandDetected () WM windowManager ()","title":"Public Functions"},{"location":"flameshot/classDesktopInfo/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classDesktopInfo/#enum-wm","text":"enum DesktopInfo::WM { GNOME, KDE, OTHER, QTILE, SWAY };","title":"enum WM"},{"location":"flameshot/classDesktopInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classDesktopInfo/#function-desktopinfo","text":"DesktopInfo::DesktopInfo ()","title":"function DesktopInfo"},{"location":"flameshot/classDesktopInfo/#function-waylanddetected","text":"bool DesktopInfo::waylandDetected ()","title":"function waylandDetected"},{"location":"flameshot/classDesktopInfo/#function-windowmanager","text":"WM DesktopInfo::windowManager ()","title":"function windowManager"},{"location":"flameshot/classDraggableWidgetMaker/","text":"Class DraggableWidgetMaker # ClassList > DraggableWidgetMaker Inherits the following classes: QObject Public Functions # Type Name DraggableWidgetMaker (QObject * parent=nullptr) void makeDraggable (QWidget * widget) Protected Functions # Type Name bool eventFilter (QObject * obj, QEvent * event) override Public Functions Documentation # function DraggableWidgetMaker # DraggableWidgetMaker::DraggableWidgetMaker ( QObject * parent=nullptr ) function makeDraggable # void DraggableWidgetMaker::makeDraggable ( QWidget * widget ) Protected Functions Documentation # function eventFilter # bool DraggableWidgetMaker::eventFilter ( QObject * obj, QEvent * event ) override","title":"Class DraggableWidgetMaker"},{"location":"flameshot/classDraggableWidgetMaker/#class-draggablewidgetmaker","text":"ClassList > DraggableWidgetMaker Inherits the following classes: QObject","title":"Class DraggableWidgetMaker"},{"location":"flameshot/classDraggableWidgetMaker/#public-functions","text":"Type Name DraggableWidgetMaker (QObject * parent=nullptr) void makeDraggable (QWidget * widget)","title":"Public Functions"},{"location":"flameshot/classDraggableWidgetMaker/#protected-functions","text":"Type Name bool eventFilter (QObject * obj, QEvent * event) override","title":"Protected Functions"},{"location":"flameshot/classDraggableWidgetMaker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classDraggableWidgetMaker/#function-draggablewidgetmaker","text":"DraggableWidgetMaker::DraggableWidgetMaker ( QObject * parent=nullptr )","title":"function DraggableWidgetMaker"},{"location":"flameshot/classDraggableWidgetMaker/#function-makedraggable","text":"void DraggableWidgetMaker::makeDraggable ( QWidget * widget )","title":"function makeDraggable"},{"location":"flameshot/classDraggableWidgetMaker/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classDraggableWidgetMaker/#function-eventfilter","text":"bool DraggableWidgetMaker::eventFilter ( QObject * obj, QEvent * event ) override","title":"function eventFilter"},{"location":"flameshot/classExistingDir/","text":"Class ExistingDir # ClassList > ExistingDir Inherits the following classes: ValueHandler Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Class ExistingDir"},{"location":"flameshot/classExistingDir/#class-existingdir","text":"ClassList > ExistingDir Inherits the following classes: ValueHandler","title":"Class ExistingDir"},{"location":"flameshot/classExistingDir/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classExistingDir/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classExitTool/","text":"Class ExitTool # ClassList > ExitTool Inherits the following classes: AbstractActionTool Public Functions # Type Name ExitTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function ExitTool # explicit ExitTool::ExitTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool ExitTool::closeOnButtonPressed () override const function copy # CaptureTool * ExitTool::copy ( QObject * parent=nullptr ) override function description # QString ExitTool::description () override const function icon # QIcon ExitTool::icon ( const QColor & background, bool inEditor ) override const function name # QString ExitTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type ExitTool::type () override const","title":"Class ExitTool"},{"location":"flameshot/classExitTool/#class-exittool","text":"ClassList > ExitTool Inherits the following classes: AbstractActionTool","title":"Class ExitTool"},{"location":"flameshot/classExitTool/#public-functions","text":"Type Name ExitTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classExitTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classExitTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classExitTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classExitTool/#function-exittool","text":"explicit ExitTool::ExitTool ( QObject * parent=nullptr )","title":"function ExitTool"},{"location":"flameshot/classExitTool/#function-closeonbuttonpressed","text":"bool ExitTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classExitTool/#function-copy","text":"CaptureTool * ExitTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classExitTool/#function-description","text":"QString ExitTool::description () override const","title":"function description"},{"location":"flameshot/classExitTool/#function-icon","text":"QIcon ExitTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classExitTool/#function-name","text":"QString ExitTool::name () override const","title":"function name"},{"location":"flameshot/classExitTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classExitTool/#function-type","text":"CaptureTool::Type ExitTool::type () override const","title":"function type"},{"location":"flameshot/classExtendedSlider/","text":"Class ExtendedSlider # ClassList > ExtendedSlider Inherits the following classes: QSlider Public Functions # Type Name ExtendedSlider (QWidget * parent=nullptr) int mappedValue (int min, int max) void setMapedValue (int min, int val, int max) Public Functions Documentation # function ExtendedSlider # explicit ExtendedSlider::ExtendedSlider ( QWidget * parent=nullptr ) function mappedValue # int ExtendedSlider::mappedValue ( int min, int max ) function setMapedValue # void ExtendedSlider::setMapedValue ( int min, int val, int max )","title":"Class ExtendedSlider"},{"location":"flameshot/classExtendedSlider/#class-extendedslider","text":"ClassList > ExtendedSlider Inherits the following classes: QSlider","title":"Class ExtendedSlider"},{"location":"flameshot/classExtendedSlider/#public-functions","text":"Type Name ExtendedSlider (QWidget * parent=nullptr) int mappedValue (int min, int max) void setMapedValue (int min, int val, int max)","title":"Public Functions"},{"location":"flameshot/classExtendedSlider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classExtendedSlider/#function-extendedslider","text":"explicit ExtendedSlider::ExtendedSlider ( QWidget * parent=nullptr )","title":"function ExtendedSlider"},{"location":"flameshot/classExtendedSlider/#function-mappedvalue","text":"int ExtendedSlider::mappedValue ( int min, int max )","title":"function mappedValue"},{"location":"flameshot/classExtendedSlider/#function-setmapedvalue","text":"void ExtendedSlider::setMapedValue ( int min, int val, int max )","title":"function setMapedValue"},{"location":"flameshot/classFileNameEditor/","text":"Class FileNameEditor # ClassList > FileNameEditor Inherits the following classes: QWidget Public Functions # Type Name FileNameEditor (QWidget * parent=nullptr) Public Functions Documentation # function FileNameEditor # explicit FileNameEditor::FileNameEditor ( QWidget * parent=nullptr )","title":"Class FileNameEditor"},{"location":"flameshot/classFileNameEditor/#class-filenameeditor","text":"ClassList > FileNameEditor Inherits the following classes: QWidget","title":"Class FileNameEditor"},{"location":"flameshot/classFileNameEditor/#public-functions","text":"Type Name FileNameEditor (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classFileNameEditor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classFileNameEditor/#function-filenameeditor","text":"explicit FileNameEditor::FileNameEditor ( QWidget * parent=nullptr )","title":"function FileNameEditor"},{"location":"flameshot/classFileNameHandler/","text":"Class FileNameHandler # ClassList > FileNameHandler Inherits the following classes: QObject Public Static Attributes # Type Name const int MAX_CHARACTERS = = 70 Public Functions # Type Name FileNameHandler (QObject * parent=nullptr) QString parseFilename (const QString & name) QString parsedPattern () QString properScreenshotPath (QString filename, const QString & format=QString()) Generate a valid destination path from the possibly incomplete path . The input path can be one of: Public Static Attributes Documentation # variable MAX_CHARACTERS # const int FileNameHandler::MAX_CHARACTERS; Public Functions Documentation # function FileNameHandler # explicit FileNameHandler::FileNameHandler ( QObject * parent=nullptr ) function parseFilename # QString FileNameHandler::parseFilename ( const QString & name ) function parsedPattern # QString FileNameHandler::parsedPattern () function properScreenshotPath # Generate a valid destination path from the possibly incomplete path . The input path can be one of: QString FileNameHandler::properScreenshotPath ( QString filename, const QString & format=QString() ) empty string an existing directory a file in an existing directory In each case, the output path will be an absolute path to a file with a suffix matching the specified format . Note: If path points to a directory, the file name will be generated from the formatted file name from the user configuration If path points to a file, its suffix will be changed to match format If format is not given, the suffix will remain untouched, unless path has no suffix, in which case it will be given the \"png\" suffix If the path generated by the previous steps points to an existing file, \"_NUM\" will be appended to its base name, where NUM is the first available number that produces a non-existent path (starting from 1). Parameters: path Possibly incomplete file name to transform format Desired output file suffix (excluding an initial '.' character)","title":"Class FileNameHandler"},{"location":"flameshot/classFileNameHandler/#class-filenamehandler","text":"ClassList > FileNameHandler Inherits the following classes: QObject","title":"Class FileNameHandler"},{"location":"flameshot/classFileNameHandler/#public-static-attributes","text":"Type Name const int MAX_CHARACTERS = = 70","title":"Public Static Attributes"},{"location":"flameshot/classFileNameHandler/#public-functions","text":"Type Name FileNameHandler (QObject * parent=nullptr) QString parseFilename (const QString & name) QString parsedPattern () QString properScreenshotPath (QString filename, const QString & format=QString()) Generate a valid destination path from the possibly incomplete path . The input path can be one of:","title":"Public Functions"},{"location":"flameshot/classFileNameHandler/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"flameshot/classFileNameHandler/#variable-max_characters","text":"const int FileNameHandler::MAX_CHARACTERS;","title":"variable MAX_CHARACTERS"},{"location":"flameshot/classFileNameHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classFileNameHandler/#function-filenamehandler","text":"explicit FileNameHandler::FileNameHandler ( QObject * parent=nullptr )","title":"function FileNameHandler"},{"location":"flameshot/classFileNameHandler/#function-parsefilename","text":"QString FileNameHandler::parseFilename ( const QString & name )","title":"function parseFilename"},{"location":"flameshot/classFileNameHandler/#function-parsedpattern","text":"QString FileNameHandler::parsedPattern ()","title":"function parsedPattern"},{"location":"flameshot/classFileNameHandler/#function-properscreenshotpath","text":"Generate a valid destination path from the possibly incomplete path . The input path can be one of: QString FileNameHandler::properScreenshotPath ( QString filename, const QString & format=QString() ) empty string an existing directory a file in an existing directory In each case, the output path will be an absolute path to a file with a suffix matching the specified format . Note: If path points to a directory, the file name will be generated from the formatted file name from the user configuration If path points to a file, its suffix will be changed to match format If format is not given, the suffix will remain untouched, unless path has no suffix, in which case it will be given the \"png\" suffix If the path generated by the previous steps points to an existing file, \"_NUM\" will be appended to its base name, where NUM is the first available number that produces a non-existent path (starting from 1). Parameters: path Possibly incomplete file name to transform format Desired output file suffix (excluding an initial '.' character)","title":"function properScreenshotPath"},{"location":"flameshot/classFilenamePattern/","text":"Class FilenamePattern # ClassList > FilenamePattern Inherits the following classes: ValueHandler Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Class FilenamePattern"},{"location":"flameshot/classFilenamePattern/#class-filenamepattern","text":"ClassList > FilenamePattern Inherits the following classes: ValueHandler","title":"Class FilenamePattern"},{"location":"flameshot/classFilenamePattern/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classFilenamePattern/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classFlameshot/","text":"Class Flameshot # ClassList > Flameshot Inherits the following classes: QObject Public Types # Type Name enum Origin Public Functions # Type Name bool haveExternalWidget () void setExternalWidget (bool b) Public Static Functions # Type Name Flameshot * instance () Origin origin () void setOrigin (Origin origin) Public Types Documentation # enum Origin # enum Flameshot::Origin { CLI, DAEMON }; Public Functions Documentation # function haveExternalWidget # bool Flameshot::haveExternalWidget () function setExternalWidget # void Flameshot::setExternalWidget ( bool b ) Public Static Functions Documentation # function instance # static Flameshot * Flameshot::instance () function origin # static Origin Flameshot::origin () function setOrigin # static void Flameshot::setOrigin ( Origin origin )","title":"Class Flameshot"},{"location":"flameshot/classFlameshot/#class-flameshot","text":"ClassList > Flameshot Inherits the following classes: QObject","title":"Class Flameshot"},{"location":"flameshot/classFlameshot/#public-types","text":"Type Name enum Origin","title":"Public Types"},{"location":"flameshot/classFlameshot/#public-functions","text":"Type Name bool haveExternalWidget () void setExternalWidget (bool b)","title":"Public Functions"},{"location":"flameshot/classFlameshot/#public-static-functions","text":"Type Name Flameshot * instance () Origin origin () void setOrigin (Origin origin)","title":"Public Static Functions"},{"location":"flameshot/classFlameshot/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classFlameshot/#enum-origin","text":"enum Flameshot::Origin { CLI, DAEMON };","title":"enum Origin"},{"location":"flameshot/classFlameshot/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classFlameshot/#function-haveexternalwidget","text":"bool Flameshot::haveExternalWidget ()","title":"function haveExternalWidget"},{"location":"flameshot/classFlameshot/#function-setexternalwidget","text":"void Flameshot::setExternalWidget ( bool b )","title":"function setExternalWidget"},{"location":"flameshot/classFlameshot/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classFlameshot/#function-instance","text":"static Flameshot * Flameshot::instance ()","title":"function instance"},{"location":"flameshot/classFlameshot/#function-origin","text":"static Origin Flameshot::origin ()","title":"function origin"},{"location":"flameshot/classFlameshot/#function-setorigin","text":"static void Flameshot::setOrigin ( Origin origin )","title":"function setOrigin"},{"location":"flameshot/classFlameshotDBusAdapter/","text":"Class FlameshotDBusAdapter # ClassList > FlameshotDBusAdapter Inherits the following classes: QDBusAbstractAdaptor Public Functions # Type Name FlameshotDBusAdapter (QObject * parent=nullptr) virtual ~FlameshotDBusAdapter () Public Functions Documentation # function FlameshotDBusAdapter # explicit FlameshotDBusAdapter::FlameshotDBusAdapter ( QObject * parent=nullptr ) function ~FlameshotDBusAdapter # virtual FlameshotDBusAdapter::~FlameshotDBusAdapter ()","title":"Class FlameshotDBusAdapter"},{"location":"flameshot/classFlameshotDBusAdapter/#class-flameshotdbusadapter","text":"ClassList > FlameshotDBusAdapter Inherits the following classes: QDBusAbstractAdaptor","title":"Class FlameshotDBusAdapter"},{"location":"flameshot/classFlameshotDBusAdapter/#public-functions","text":"Type Name FlameshotDBusAdapter (QObject * parent=nullptr) virtual ~FlameshotDBusAdapter ()","title":"Public Functions"},{"location":"flameshot/classFlameshotDBusAdapter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classFlameshotDBusAdapter/#function-flameshotdbusadapter","text":"explicit FlameshotDBusAdapter::FlameshotDBusAdapter ( QObject * parent=nullptr )","title":"function FlameshotDBusAdapter"},{"location":"flameshot/classFlameshotDBusAdapter/#function-flameshotdbusadapter_1","text":"virtual FlameshotDBusAdapter::~FlameshotDBusAdapter ()","title":"function ~FlameshotDBusAdapter"},{"location":"flameshot/classFlameshotDaemon/","text":"Class FlameshotDaemon # ClassList > FlameshotDaemon Inherits the following classes: QObject Public Functions # Type Name void sendTrayNotification (const QString & text, const QString & title=QStringLiteral(\"Flameshot Info\"), const int timeout=5000) void showUpdateNotificationIfAvailable ( CaptureWidget * widget) Public Static Functions # Type Name void copyToClipboard (QPixmap capture) void copyToClipboard (QString text, QString notification=\"\") void createPin (QPixmap capture, QRect geometry) FlameshotDaemon * instance () Return the daemon instance. bool isThisInstanceHostingWidgets () Is this instance of flameshot hosting any windows as a daemon? void start () Public Functions Documentation # function sendTrayNotification # void FlameshotDaemon::sendTrayNotification ( const QString & text, const QString & title=QStringLiteral(\"Flameshot Info\"), const int timeout=5000 ) function showUpdateNotificationIfAvailable # void FlameshotDaemon::showUpdateNotificationIfAvailable ( CaptureWidget * widget ) Public Static Functions Documentation # function copyToClipboard [1/2] # static void FlameshotDaemon::copyToClipboard ( QPixmap capture ) function copyToClipboard [2/2] # static void FlameshotDaemon::copyToClipboard ( QString text, QString notification=\"\" ) function createPin # static void FlameshotDaemon::createPin ( QPixmap capture, QRect geometry ) function instance # Return the daemon instance. static FlameshotDaemon * FlameshotDaemon::instance () If this instance of flameshot is the daemon, a singleton instance of FlameshotDaemon is returned. As a side effect start will called if it wasn't called earlier. If this instance of flameshot is not the daemon, nullptr is returned. This strategy is used because the daemon needs to receive signals from D-Bus, for which an instance of a QObject is required. The singleton serves as that object. function isThisInstanceHostingWidgets # static bool FlameshotDaemon::isThisInstanceHostingWidgets () function start # static void FlameshotDaemon::start ()","title":"Class FlameshotDaemon"},{"location":"flameshot/classFlameshotDaemon/#class-flameshotdaemon","text":"ClassList > FlameshotDaemon Inherits the following classes: QObject","title":"Class FlameshotDaemon"},{"location":"flameshot/classFlameshotDaemon/#public-functions","text":"Type Name void sendTrayNotification (const QString & text, const QString & title=QStringLiteral(\"Flameshot Info\"), const int timeout=5000) void showUpdateNotificationIfAvailable ( CaptureWidget * widget)","title":"Public Functions"},{"location":"flameshot/classFlameshotDaemon/#public-static-functions","text":"Type Name void copyToClipboard (QPixmap capture) void copyToClipboard (QString text, QString notification=\"\") void createPin (QPixmap capture, QRect geometry) FlameshotDaemon * instance () Return the daemon instance. bool isThisInstanceHostingWidgets () Is this instance of flameshot hosting any windows as a daemon? void start ()","title":"Public Static Functions"},{"location":"flameshot/classFlameshotDaemon/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classFlameshotDaemon/#function-sendtraynotification","text":"void FlameshotDaemon::sendTrayNotification ( const QString & text, const QString & title=QStringLiteral(\"Flameshot Info\"), const int timeout=5000 )","title":"function sendTrayNotification"},{"location":"flameshot/classFlameshotDaemon/#function-showupdatenotificationifavailable","text":"void FlameshotDaemon::showUpdateNotificationIfAvailable ( CaptureWidget * widget )","title":"function showUpdateNotificationIfAvailable"},{"location":"flameshot/classFlameshotDaemon/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classFlameshotDaemon/#function-copytoclipboard-12","text":"static void FlameshotDaemon::copyToClipboard ( QPixmap capture )","title":"function copyToClipboard [1/2]"},{"location":"flameshot/classFlameshotDaemon/#function-copytoclipboard-22","text":"static void FlameshotDaemon::copyToClipboard ( QString text, QString notification=\"\" )","title":"function copyToClipboard [2/2]"},{"location":"flameshot/classFlameshotDaemon/#function-createpin","text":"static void FlameshotDaemon::createPin ( QPixmap capture, QRect geometry )","title":"function createPin"},{"location":"flameshot/classFlameshotDaemon/#function-instance","text":"Return the daemon instance. static FlameshotDaemon * FlameshotDaemon::instance () If this instance of flameshot is the daemon, a singleton instance of FlameshotDaemon is returned. As a side effect start will called if it wasn't called earlier. If this instance of flameshot is not the daemon, nullptr is returned. This strategy is used because the daemon needs to receive signals from D-Bus, for which an instance of a QObject is required. The singleton serves as that object.","title":"function instance"},{"location":"flameshot/classFlameshotDaemon/#function-isthisinstancehostingwidgets","text":"static bool FlameshotDaemon::isThisInstanceHostingWidgets ()","title":"function isThisInstanceHostingWidgets"},{"location":"flameshot/classFlameshotDaemon/#function-start","text":"static void FlameshotDaemon::start ()","title":"function start"},{"location":"flameshot/classGeneralConf/","text":"Class GeneralConf # ClassList > GeneralConf Inherits the following classes: QWidget Public Types # Type Name enum xywh_position Public Functions # Type Name GeneralConf (QWidget * parent=nullptr) Public Types Documentation # enum xywh_position # enum GeneralConf::xywh_position { xywh_none = 0, xywh_top_left = 1, xywh_bottom_left = 2, xywh_top_right = 3, xywh_bottom_right = 4, xywh_center = 5 }; Public Functions Documentation # function GeneralConf # explicit GeneralConf::GeneralConf ( QWidget * parent=nullptr )","title":"Class GeneralConf"},{"location":"flameshot/classGeneralConf/#class-generalconf","text":"ClassList > GeneralConf Inherits the following classes: QWidget","title":"Class GeneralConf"},{"location":"flameshot/classGeneralConf/#public-types","text":"Type Name enum xywh_position","title":"Public Types"},{"location":"flameshot/classGeneralConf/#public-functions","text":"Type Name GeneralConf (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classGeneralConf/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classGeneralConf/#enum-xywh_position","text":"enum GeneralConf::xywh_position { xywh_none = 0, xywh_top_left = 1, xywh_bottom_left = 2, xywh_top_right = 3, xywh_bottom_right = 4, xywh_center = 5 };","title":"enum xywh_position"},{"location":"flameshot/classGeneralConf/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classGeneralConf/#function-generalconf","text":"explicit GeneralConf::GeneralConf ( QWidget * parent=nullptr )","title":"function GeneralConf"},{"location":"flameshot/classGlobalShortcutFilter/","text":"Class GlobalShortcutFilter # ClassList > GlobalShortcutFilter Inherits the following classes: QObject, QAbstractNativeEventFilter Public Functions # Type Name GlobalShortcutFilter (QObject * parent=nullptr) bool nativeEventFilter (const QByteArray & eventType, void * message, long * result) Public Functions Documentation # function GlobalShortcutFilter # explicit GlobalShortcutFilter::GlobalShortcutFilter ( QObject * parent=nullptr ) function nativeEventFilter # bool GlobalShortcutFilter::nativeEventFilter ( const QByteArray & eventType, void * message, long * result )","title":"Class GlobalShortcutFilter"},{"location":"flameshot/classGlobalShortcutFilter/#class-globalshortcutfilter","text":"ClassList > GlobalShortcutFilter Inherits the following classes: QObject, QAbstractNativeEventFilter","title":"Class GlobalShortcutFilter"},{"location":"flameshot/classGlobalShortcutFilter/#public-functions","text":"Type Name GlobalShortcutFilter (QObject * parent=nullptr) bool nativeEventFilter (const QByteArray & eventType, void * message, long * result)","title":"Public Functions"},{"location":"flameshot/classGlobalShortcutFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classGlobalShortcutFilter/#function-globalshortcutfilter","text":"explicit GlobalShortcutFilter::GlobalShortcutFilter ( QObject * parent=nullptr )","title":"function GlobalShortcutFilter"},{"location":"flameshot/classGlobalShortcutFilter/#function-nativeeventfilter","text":"bool GlobalShortcutFilter::nativeEventFilter ( const QByteArray & eventType, void * message, long * result )","title":"function nativeEventFilter"},{"location":"flameshot/namespaceGlobalValues/","text":"Namespace GlobalValues # Namespace List > GlobalValues Public Functions # Type Name int buttonBaseSize () QString iconPath () QString iconPathPNG () QString versionInfo () Public Functions Documentation # function buttonBaseSize # int GlobalValues::buttonBaseSize () function iconPath # QString GlobalValues::iconPath () function iconPathPNG # QString GlobalValues::iconPathPNG () function versionInfo # QString GlobalValues::versionInfo ()","title":"Namespace GlobalValues"},{"location":"flameshot/namespaceGlobalValues/#namespace-globalvalues","text":"Namespace List > GlobalValues","title":"Namespace GlobalValues"},{"location":"flameshot/namespaceGlobalValues/#public-functions","text":"Type Name int buttonBaseSize () QString iconPath () QString iconPathPNG () QString versionInfo ()","title":"Public Functions"},{"location":"flameshot/namespaceGlobalValues/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/namespaceGlobalValues/#function-buttonbasesize","text":"int GlobalValues::buttonBaseSize ()","title":"function buttonBaseSize"},{"location":"flameshot/namespaceGlobalValues/#function-iconpath","text":"QString GlobalValues::iconPath ()","title":"function iconPath"},{"location":"flameshot/namespaceGlobalValues/#function-iconpathpng","text":"QString GlobalValues::iconPathPNG ()","title":"function iconPathPNG"},{"location":"flameshot/namespaceGlobalValues/#function-versioninfo","text":"QString GlobalValues::versionInfo ()","title":"function versionInfo"},{"location":"flameshot/classHistory/","text":"Class History # ClassList > History Public Functions # Type Name History () const QList< QString > & history () const QString & packFileName (const QString & storageType, const QString & deleteToken, const QString & fileName) const QString & path () void save (const QPixmap & pixmap, const QString & fileName) const HistoryFileName & unpackFileName (const QString & fileNamePacked) Public Functions Documentation # function History # History::History () function history # const QList< QString > & History::history () function packFileName # const QString & History::packFileName ( const QString & storageType, const QString & deleteToken, const QString & fileName ) function path # const QString & History::path () function save # void History::save ( const QPixmap & pixmap, const QString & fileName ) function unpackFileName # const HistoryFileName & History::unpackFileName ( const QString & fileNamePacked )","title":"Class History"},{"location":"flameshot/classHistory/#class-history","text":"ClassList > History","title":"Class History"},{"location":"flameshot/classHistory/#public-functions","text":"Type Name History () const QList< QString > & history () const QString & packFileName (const QString & storageType, const QString & deleteToken, const QString & fileName) const QString & path () void save (const QPixmap & pixmap, const QString & fileName) const HistoryFileName & unpackFileName (const QString & fileNamePacked)","title":"Public Functions"},{"location":"flameshot/classHistory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classHistory/#function-history","text":"History::History ()","title":"function History"},{"location":"flameshot/classHistory/#function-history_1","text":"const QList< QString > & History::history ()","title":"function history"},{"location":"flameshot/classHistory/#function-packfilename","text":"const QString & History::packFileName ( const QString & storageType, const QString & deleteToken, const QString & fileName )","title":"function packFileName"},{"location":"flameshot/classHistory/#function-path","text":"const QString & History::path ()","title":"function path"},{"location":"flameshot/classHistory/#function-save","text":"void History::save ( const QPixmap & pixmap, const QString & fileName )","title":"function save"},{"location":"flameshot/classHistory/#function-unpackfilename","text":"const HistoryFileName & History::unpackFileName ( const QString & fileNamePacked )","title":"function unpackFileName"},{"location":"flameshot/structHistoryFileName/","text":"Struct HistoryFileName # ClassList > HistoryFileName Public Attributes # Type Name QString file QString token QString type Public Attributes Documentation # variable file # QString HistoryFileName::file; variable token # QString HistoryFileName::token; variable type # QString HistoryFileName::type;","title":"Struct HistoryFileName"},{"location":"flameshot/structHistoryFileName/#struct-historyfilename","text":"ClassList > HistoryFileName","title":"Struct HistoryFileName"},{"location":"flameshot/structHistoryFileName/#public-attributes","text":"Type Name QString file QString token QString type","title":"Public Attributes"},{"location":"flameshot/structHistoryFileName/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/structHistoryFileName/#variable-file","text":"QString HistoryFileName::file;","title":"variable file"},{"location":"flameshot/structHistoryFileName/#variable-token","text":"QString HistoryFileName::token;","title":"variable token"},{"location":"flameshot/structHistoryFileName/#variable-type","text":"QString HistoryFileName::type;","title":"variable type"},{"location":"flameshot/classHoverEventFilter/","text":"Class HoverEventFilter # ClassList > HoverEventFilter Inherits the following classes: QObject Public Functions # Type Name HoverEventFilter (QObject * parent=nullptr) Protected Functions # Type Name bool eventFilter (QObject * watched, QEvent * event) Public Functions Documentation # function HoverEventFilter # explicit HoverEventFilter::HoverEventFilter ( QObject * parent=nullptr ) Protected Functions Documentation # function eventFilter # bool HoverEventFilter::eventFilter ( QObject * watched, QEvent * event )","title":"Class HoverEventFilter"},{"location":"flameshot/classHoverEventFilter/#class-hovereventfilter","text":"ClassList > HoverEventFilter Inherits the following classes: QObject","title":"Class HoverEventFilter"},{"location":"flameshot/classHoverEventFilter/#public-functions","text":"Type Name HoverEventFilter (QObject * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classHoverEventFilter/#protected-functions","text":"Type Name bool eventFilter (QObject * watched, QEvent * event)","title":"Protected Functions"},{"location":"flameshot/classHoverEventFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classHoverEventFilter/#function-hovereventfilter","text":"explicit HoverEventFilter::HoverEventFilter ( QObject * parent=nullptr )","title":"function HoverEventFilter"},{"location":"flameshot/classHoverEventFilter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classHoverEventFilter/#function-eventfilter","text":"bool HoverEventFilter::eventFilter ( QObject * watched, QEvent * event )","title":"function eventFilter"},{"location":"flameshot/classImageLabel/","text":"Class ImageLabel # ClassList > ImageLabel Inherits the following classes: QLabel Public Functions # Type Name ImageLabel (QWidget * parent=nullptr) void setScreenshot (const QPixmap & pixmap) Protected Functions # Type Name void mouseMoveEvent (QMouseEvent * event) void mousePressEvent (QMouseEvent * event) void mouseReleaseEvent (QMouseEvent * event) void resizeEvent (QResizeEvent * event) Public Functions Documentation # function ImageLabel # explicit ImageLabel::ImageLabel ( QWidget * parent=nullptr ) function setScreenshot # void ImageLabel::setScreenshot ( const QPixmap & pixmap ) Protected Functions Documentation # function mouseMoveEvent # void ImageLabel::mouseMoveEvent ( QMouseEvent * event ) function mousePressEvent # void ImageLabel::mousePressEvent ( QMouseEvent * event ) function mouseReleaseEvent # void ImageLabel::mouseReleaseEvent ( QMouseEvent * event ) function resizeEvent # void ImageLabel::resizeEvent ( QResizeEvent * event )","title":"Class ImageLabel"},{"location":"flameshot/classImageLabel/#class-imagelabel","text":"ClassList > ImageLabel Inherits the following classes: QLabel","title":"Class ImageLabel"},{"location":"flameshot/classImageLabel/#public-functions","text":"Type Name ImageLabel (QWidget * parent=nullptr) void setScreenshot (const QPixmap & pixmap)","title":"Public Functions"},{"location":"flameshot/classImageLabel/#protected-functions","text":"Type Name void mouseMoveEvent (QMouseEvent * event) void mousePressEvent (QMouseEvent * event) void mouseReleaseEvent (QMouseEvent * event) void resizeEvent (QResizeEvent * event)","title":"Protected Functions"},{"location":"flameshot/classImageLabel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImageLabel/#function-imagelabel","text":"explicit ImageLabel::ImageLabel ( QWidget * parent=nullptr )","title":"function ImageLabel"},{"location":"flameshot/classImageLabel/#function-setscreenshot","text":"void ImageLabel::setScreenshot ( const QPixmap & pixmap )","title":"function setScreenshot"},{"location":"flameshot/classImageLabel/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classImageLabel/#function-mousemoveevent","text":"void ImageLabel::mouseMoveEvent ( QMouseEvent * event )","title":"function mouseMoveEvent"},{"location":"flameshot/classImageLabel/#function-mousepressevent","text":"void ImageLabel::mousePressEvent ( QMouseEvent * event )","title":"function mousePressEvent"},{"location":"flameshot/classImageLabel/#function-mousereleaseevent","text":"void ImageLabel::mouseReleaseEvent ( QMouseEvent * event )","title":"function mouseReleaseEvent"},{"location":"flameshot/classImageLabel/#function-resizeevent","text":"void ImageLabel::resizeEvent ( QResizeEvent * event )","title":"function resizeEvent"},{"location":"flameshot/classImgUploadDialog/","text":"Class ImgUploadDialog # ClassList > ImgUploadDialog Inherits the following classes: QDialog Public Functions # Type Name ImgUploadDialog (QDialog * parent=nullptr) Public Functions Documentation # function ImgUploadDialog # explicit ImgUploadDialog::ImgUploadDialog ( QDialog * parent=nullptr )","title":"Class ImgUploadDialog"},{"location":"flameshot/classImgUploadDialog/#class-imguploaddialog","text":"ClassList > ImgUploadDialog Inherits the following classes: QDialog","title":"Class ImgUploadDialog"},{"location":"flameshot/classImgUploadDialog/#public-functions","text":"Type Name ImgUploadDialog (QDialog * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classImgUploadDialog/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImgUploadDialog/#function-imguploaddialog","text":"explicit ImgUploadDialog::ImgUploadDialog ( QDialog * parent=nullptr )","title":"function ImgUploadDialog"},{"location":"flameshot/classImgUploaderBase/","text":"Class ImgUploaderBase # ClassList > ImgUploaderBase Inherits the following classes: QWidget Inherited by the following classes: ImgurUploader Public Attributes # Type Name QString m_currentImageName Public Functions # Type Name ImgUploaderBase (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken) = 0 const QUrl & imageURL () NotificationWidget * notification () const QPixmap & pixmap () void setImageURL (const QUrl & imageURL) void setInfoLabelText (const QString & text) void setPixmap (const QPixmap & pixmap) LoadSpinner * spinner () virtual void upload () = 0 Public Attributes Documentation # variable m_currentImageName # QString ImgUploaderBase::m_currentImageName; Public Functions Documentation # function ImgUploaderBase # explicit ImgUploaderBase::ImgUploaderBase ( const QPixmap & capture, QWidget * parent=nullptr ) function deleteImage # virtual void ImgUploaderBase::deleteImage ( const QString & fileName, const QString & deleteToken ) = 0 function imageURL # const QUrl & ImgUploaderBase::imageURL () function notification # NotificationWidget * ImgUploaderBase::notification () function pixmap # const QPixmap & ImgUploaderBase::pixmap () function setImageURL # void ImgUploaderBase::setImageURL ( const QUrl & imageURL ) function setInfoLabelText # void ImgUploaderBase::setInfoLabelText ( const QString & text ) function setPixmap # void ImgUploaderBase::setPixmap ( const QPixmap & pixmap ) function spinner # LoadSpinner * ImgUploaderBase::spinner () function upload # virtual void ImgUploaderBase::upload () = 0","title":"Class ImgUploaderBase"},{"location":"flameshot/classImgUploaderBase/#class-imguploaderbase","text":"ClassList > ImgUploaderBase Inherits the following classes: QWidget Inherited by the following classes: ImgurUploader","title":"Class ImgUploaderBase"},{"location":"flameshot/classImgUploaderBase/#public-attributes","text":"Type Name QString m_currentImageName","title":"Public Attributes"},{"location":"flameshot/classImgUploaderBase/#public-functions","text":"Type Name ImgUploaderBase (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken) = 0 const QUrl & imageURL () NotificationWidget * notification () const QPixmap & pixmap () void setImageURL (const QUrl & imageURL) void setInfoLabelText (const QString & text) void setPixmap (const QPixmap & pixmap) LoadSpinner * spinner () virtual void upload () = 0","title":"Public Functions"},{"location":"flameshot/classImgUploaderBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/classImgUploaderBase/#variable-m_currentimagename","text":"QString ImgUploaderBase::m_currentImageName;","title":"variable m_currentImageName"},{"location":"flameshot/classImgUploaderBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImgUploaderBase/#function-imguploaderbase","text":"explicit ImgUploaderBase::ImgUploaderBase ( const QPixmap & capture, QWidget * parent=nullptr )","title":"function ImgUploaderBase"},{"location":"flameshot/classImgUploaderBase/#function-deleteimage","text":"virtual void ImgUploaderBase::deleteImage ( const QString & fileName, const QString & deleteToken ) = 0","title":"function deleteImage"},{"location":"flameshot/classImgUploaderBase/#function-imageurl","text":"const QUrl & ImgUploaderBase::imageURL ()","title":"function imageURL"},{"location":"flameshot/classImgUploaderBase/#function-notification","text":"NotificationWidget * ImgUploaderBase::notification ()","title":"function notification"},{"location":"flameshot/classImgUploaderBase/#function-pixmap","text":"const QPixmap & ImgUploaderBase::pixmap ()","title":"function pixmap"},{"location":"flameshot/classImgUploaderBase/#function-setimageurl","text":"void ImgUploaderBase::setImageURL ( const QUrl & imageURL )","title":"function setImageURL"},{"location":"flameshot/classImgUploaderBase/#function-setinfolabeltext","text":"void ImgUploaderBase::setInfoLabelText ( const QString & text )","title":"function setInfoLabelText"},{"location":"flameshot/classImgUploaderBase/#function-setpixmap","text":"void ImgUploaderBase::setPixmap ( const QPixmap & pixmap )","title":"function setPixmap"},{"location":"flameshot/classImgUploaderBase/#function-spinner","text":"LoadSpinner * ImgUploaderBase::spinner ()","title":"function spinner"},{"location":"flameshot/classImgUploaderBase/#function-upload","text":"virtual void ImgUploaderBase::upload () = 0","title":"function upload"},{"location":"flameshot/classImgUploaderManager/","text":"Class ImgUploaderManager # ClassList > ImgUploaderManager Inherits the following classes: QObject Public Functions # Type Name ImgUploaderManager (QObject * parent=nullptr) ImgUploaderBase * uploader (const QPixmap & capture, QWidget * parent=nullptr) ImgUploaderBase * uploader (const QString & imgUploaderPlugin) const QString & uploaderPlugin () const QString & url () Public Functions Documentation # function ImgUploaderManager # explicit ImgUploaderManager::ImgUploaderManager ( QObject * parent=nullptr ) function uploader [1/2] # ImgUploaderBase * ImgUploaderManager::uploader ( const QPixmap & capture, QWidget * parent=nullptr ) function uploader [2/2] # ImgUploaderBase * ImgUploaderManager::uploader ( const QString & imgUploaderPlugin ) function uploaderPlugin # const QString & ImgUploaderManager::uploaderPlugin () function url # const QString & ImgUploaderManager::url ()","title":"Class ImgUploaderManager"},{"location":"flameshot/classImgUploaderManager/#class-imguploadermanager","text":"ClassList > ImgUploaderManager Inherits the following classes: QObject","title":"Class ImgUploaderManager"},{"location":"flameshot/classImgUploaderManager/#public-functions","text":"Type Name ImgUploaderManager (QObject * parent=nullptr) ImgUploaderBase * uploader (const QPixmap & capture, QWidget * parent=nullptr) ImgUploaderBase * uploader (const QString & imgUploaderPlugin) const QString & uploaderPlugin () const QString & url ()","title":"Public Functions"},{"location":"flameshot/classImgUploaderManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImgUploaderManager/#function-imguploadermanager","text":"explicit ImgUploaderManager::ImgUploaderManager ( QObject * parent=nullptr )","title":"function ImgUploaderManager"},{"location":"flameshot/classImgUploaderManager/#function-uploader-12","text":"ImgUploaderBase * ImgUploaderManager::uploader ( const QPixmap & capture, QWidget * parent=nullptr )","title":"function uploader [1/2]"},{"location":"flameshot/classImgUploaderManager/#function-uploader-22","text":"ImgUploaderBase * ImgUploaderManager::uploader ( const QString & imgUploaderPlugin )","title":"function uploader [2/2]"},{"location":"flameshot/classImgUploaderManager/#function-uploaderplugin","text":"const QString & ImgUploaderManager::uploaderPlugin ()","title":"function uploaderPlugin"},{"location":"flameshot/classImgUploaderManager/#function-url","text":"const QString & ImgUploaderManager::url ()","title":"function url"},{"location":"flameshot/classImgUploaderTool/","text":"Class ImgUploaderTool # ClassList > ImgUploaderTool Inherits the following classes: AbstractActionTool Public Functions # Type Name ImgUploaderTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function ImgUploaderTool # explicit ImgUploaderTool::ImgUploaderTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool ImgUploaderTool::closeOnButtonPressed () override const function copy # CaptureTool * ImgUploaderTool::copy ( QObject * parent=nullptr ) override function description # QString ImgUploaderTool::description () override const function icon # QIcon ImgUploaderTool::icon ( const QColor & background, bool inEditor ) override const function name # QString ImgUploaderTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type ImgUploaderTool::type () override const","title":"Class ImgUploaderTool"},{"location":"flameshot/classImgUploaderTool/#class-imguploadertool","text":"ClassList > ImgUploaderTool Inherits the following classes: AbstractActionTool","title":"Class ImgUploaderTool"},{"location":"flameshot/classImgUploaderTool/#public-functions","text":"Type Name ImgUploaderTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classImgUploaderTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classImgUploaderTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classImgUploaderTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImgUploaderTool/#function-imguploadertool","text":"explicit ImgUploaderTool::ImgUploaderTool ( QObject * parent=nullptr )","title":"function ImgUploaderTool"},{"location":"flameshot/classImgUploaderTool/#function-closeonbuttonpressed","text":"bool ImgUploaderTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classImgUploaderTool/#function-copy","text":"CaptureTool * ImgUploaderTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classImgUploaderTool/#function-description","text":"QString ImgUploaderTool::description () override const","title":"function description"},{"location":"flameshot/classImgUploaderTool/#function-icon","text":"QIcon ImgUploaderTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classImgUploaderTool/#function-name","text":"QString ImgUploaderTool::name () override const","title":"function name"},{"location":"flameshot/classImgUploaderTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classImgUploaderTool/#function-type","text":"CaptureTool::Type ImgUploaderTool::type () override const","title":"function type"},{"location":"flameshot/classImgurUploader/","text":"Class ImgurUploader # ClassList > ImgurUploader Inherits the following classes: ImgUploaderBase Public Attributes inherited from ImgUploaderBase # See ImgUploaderBase Type Name QString m_currentImageName Public Functions # Type Name ImgurUploader (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken) Public Functions inherited from ImgUploaderBase # See ImgUploaderBase Type Name ImgUploaderBase (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken) = 0 const QUrl & imageURL () NotificationWidget * notification () const QPixmap & pixmap () void setImageURL (const QUrl & imageURL) void setInfoLabelText (const QString & text) void setPixmap (const QPixmap & pixmap) LoadSpinner * spinner () virtual void upload () = 0 Public Functions Documentation # function ImgurUploader # explicit ImgurUploader::ImgurUploader ( const QPixmap & capture, QWidget * parent=nullptr ) function deleteImage # virtual void ImgurUploader::deleteImage ( const QString & fileName, const QString & deleteToken ) Implements ImgUploaderBase::deleteImage","title":"Class ImgurUploader"},{"location":"flameshot/classImgurUploader/#class-imguruploader","text":"ClassList > ImgurUploader Inherits the following classes: ImgUploaderBase","title":"Class ImgurUploader"},{"location":"flameshot/classImgurUploader/#public-attributes-inherited-from-imguploaderbase","text":"See ImgUploaderBase Type Name QString m_currentImageName","title":"Public Attributes inherited from ImgUploaderBase"},{"location":"flameshot/classImgurUploader/#public-functions","text":"Type Name ImgurUploader (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken)","title":"Public Functions"},{"location":"flameshot/classImgurUploader/#public-functions-inherited-from-imguploaderbase","text":"See ImgUploaderBase Type Name ImgUploaderBase (const QPixmap & capture, QWidget * parent=nullptr) virtual void deleteImage (const QString & fileName, const QString & deleteToken) = 0 const QUrl & imageURL () NotificationWidget * notification () const QPixmap & pixmap () void setImageURL (const QUrl & imageURL) void setInfoLabelText (const QString & text) void setPixmap (const QPixmap & pixmap) LoadSpinner * spinner () virtual void upload () = 0","title":"Public Functions inherited from ImgUploaderBase"},{"location":"flameshot/classImgurUploader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classImgurUploader/#function-imguruploader","text":"explicit ImgurUploader::ImgurUploader ( const QPixmap & capture, QWidget * parent=nullptr )","title":"function ImgurUploader"},{"location":"flameshot/classImgurUploader/#function-deleteimage","text":"virtual void ImgurUploader::deleteImage ( const QString & fileName, const QString & deleteToken ) Implements ImgUploaderBase::deleteImage","title":"function deleteImage"},{"location":"flameshot/classInfoWindow/","text":"Class InfoWindow # ClassList > InfoWindow Inherits the following classes: QWidget Public Functions # Type Name InfoWindow (QWidget * parent=nullptr) ~InfoWindow () Protected Functions # Type Name void keyPressEvent (QKeyEvent * event) Public Functions Documentation # function InfoWindow # explicit InfoWindow::InfoWindow ( QWidget * parent=nullptr ) function ~InfoWindow # InfoWindow::~InfoWindow () Protected Functions Documentation # function keyPressEvent # void InfoWindow::keyPressEvent ( QKeyEvent * event )","title":"Class InfoWindow"},{"location":"flameshot/classInfoWindow/#class-infowindow","text":"ClassList > InfoWindow Inherits the following classes: QWidget","title":"Class InfoWindow"},{"location":"flameshot/classInfoWindow/#public-functions","text":"Type Name InfoWindow (QWidget * parent=nullptr) ~InfoWindow ()","title":"Public Functions"},{"location":"flameshot/classInfoWindow/#protected-functions","text":"Type Name void keyPressEvent (QKeyEvent * event)","title":"Protected Functions"},{"location":"flameshot/classInfoWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classInfoWindow/#function-infowindow","text":"explicit InfoWindow::InfoWindow ( QWidget * parent=nullptr )","title":"function InfoWindow"},{"location":"flameshot/classInfoWindow/#function-infowindow_1","text":"InfoWindow::~InfoWindow ()","title":"function ~InfoWindow"},{"location":"flameshot/classInfoWindow/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classInfoWindow/#function-keypressevent","text":"void InfoWindow::keyPressEvent ( QKeyEvent * event )","title":"function keyPressEvent"},{"location":"flameshot/classInvertTool/","text":"Class InvertTool # ClassList > InvertTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name InvertTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter & painter, const QPixmap & pixmap) override QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function InvertTool # explicit InvertTool::InvertTool ( QObject * parent=nullptr ) function boundingRect # QRect InvertTool::boundingRect () override const function copy # CaptureTool * InvertTool::copy ( QObject * parent=nullptr ) override function description # QString InvertTool::description () override const function drawSearchArea # void InvertTool::drawSearchArea ( QPainter & painter, const QPixmap & pixmap ) override function icon # QIcon InvertTool::icon ( const QColor & background, bool inEditor ) override const function name # QString InvertTool::name () override const function paintMousePreview # void InvertTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void InvertTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type InvertTool::type () override const","title":"Class InvertTool"},{"location":"flameshot/classInvertTool/#class-inverttool","text":"ClassList > InvertTool Inherits the following classes: AbstractTwoPointTool","title":"Class InvertTool"},{"location":"flameshot/classInvertTool/#public-functions","text":"Type Name InvertTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter & painter, const QPixmap & pixmap) override QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classInvertTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classInvertTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classInvertTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classInvertTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classInvertTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classInvertTool/#function-inverttool","text":"explicit InvertTool::InvertTool ( QObject * parent=nullptr )","title":"function InvertTool"},{"location":"flameshot/classInvertTool/#function-boundingrect","text":"QRect InvertTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classInvertTool/#function-copy","text":"CaptureTool * InvertTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classInvertTool/#function-description","text":"QString InvertTool::description () override const","title":"function description"},{"location":"flameshot/classInvertTool/#function-drawsearcharea","text":"void InvertTool::drawSearchArea ( QPainter & painter, const QPixmap & pixmap ) override","title":"function drawSearchArea"},{"location":"flameshot/classInvertTool/#function-icon","text":"QIcon InvertTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classInvertTool/#function-name","text":"QString InvertTool::name () override const","title":"function name"},{"location":"flameshot/classInvertTool/#function-paintmousepreview","text":"void InvertTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classInvertTool/#function-process","text":"void InvertTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classInvertTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classInvertTool/#function-type","text":"CaptureTool::Type InvertTool::type () override const","title":"function type"},{"location":"flameshot/classKeySequence/","text":"Class KeySequence # ClassList > KeySequence Inherits the following classes: ValueHandler Public Functions # Type Name KeySequence (const QKeySequence & fallback={}) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file. Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function KeySequence # KeySequence::KeySequence ( const QKeySequence & fallback={} ) function check # Check the value semantically. virtual bool KeySequence::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString KeySequence::expected () override Implements ValueHandler::expected function fallback # virtual QVariant KeySequence::fallback () override Implements ValueHandler::fallback function representation # Return the representation of the value in the config file. virtual QVariant KeySequence::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"Class KeySequence"},{"location":"flameshot/classKeySequence/#class-keysequence","text":"ClassList > KeySequence Inherits the following classes: ValueHandler","title":"Class KeySequence"},{"location":"flameshot/classKeySequence/#public-functions","text":"Type Name KeySequence (const QKeySequence & fallback={}) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file.","title":"Public Functions"},{"location":"flameshot/classKeySequence/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classKeySequence/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classKeySequence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classKeySequence/#function-keysequence","text":"KeySequence::KeySequence ( const QKeySequence & fallback={} )","title":"function KeySequence"},{"location":"flameshot/classKeySequence/#function-check","text":"Check the value semantically. virtual bool KeySequence::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classKeySequence/#function-expected","text":"virtual QString KeySequence::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classKeySequence/#function-fallback","text":"virtual QVariant KeySequence::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classKeySequence/#function-representation","text":"Return the representation of the value in the config file. virtual QVariant KeySequence::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"function representation"},{"location":"flameshot/classLauncherItemDelegate/","text":"Class LauncherItemDelegate # ClassList > LauncherItemDelegate Inherits the following classes: QStyledItemDelegate Public Functions # Type Name LauncherItemDelegate (QObject * parent=nullptr) void paint (QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index) override const QSize sizeHint (const QStyleOptionViewItem & option, const QModelIndex & index) override const Public Functions Documentation # function LauncherItemDelegate # explicit LauncherItemDelegate::LauncherItemDelegate ( QObject * parent=nullptr ) function paint # void LauncherItemDelegate::paint ( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) override const function sizeHint # QSize LauncherItemDelegate::sizeHint ( const QStyleOptionViewItem & option, const QModelIndex & index ) override const","title":"Class LauncherItemDelegate"},{"location":"flameshot/classLauncherItemDelegate/#class-launcheritemdelegate","text":"ClassList > LauncherItemDelegate Inherits the following classes: QStyledItemDelegate","title":"Class LauncherItemDelegate"},{"location":"flameshot/classLauncherItemDelegate/#public-functions","text":"Type Name LauncherItemDelegate (QObject * parent=nullptr) void paint (QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index) override const QSize sizeHint (const QStyleOptionViewItem & option, const QModelIndex & index) override const","title":"Public Functions"},{"location":"flameshot/classLauncherItemDelegate/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classLauncherItemDelegate/#function-launcheritemdelegate","text":"explicit LauncherItemDelegate::LauncherItemDelegate ( QObject * parent=nullptr )","title":"function LauncherItemDelegate"},{"location":"flameshot/classLauncherItemDelegate/#function-paint","text":"void LauncherItemDelegate::paint ( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) override const","title":"function paint"},{"location":"flameshot/classLauncherItemDelegate/#function-sizehint","text":"QSize LauncherItemDelegate::sizeHint ( const QStyleOptionViewItem & option, const QModelIndex & index ) override const","title":"function sizeHint"},{"location":"flameshot/classLineTool/","text":"Class LineTool # ClassList > LineTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name LineTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function LineTool # explicit LineTool::LineTool ( QObject * parent=nullptr ) function copy # CaptureTool * LineTool::copy ( QObject * parent=nullptr ) override function description # QString LineTool::description () override const function icon # QIcon LineTool::icon ( const QColor & background, bool inEditor ) override const function name # QString LineTool::name () override const function process # void LineTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type LineTool::type () override const","title":"Class LineTool"},{"location":"flameshot/classLineTool/#class-linetool","text":"ClassList > LineTool Inherits the following classes: AbstractTwoPointTool","title":"Class LineTool"},{"location":"flameshot/classLineTool/#public-functions","text":"Type Name LineTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classLineTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classLineTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classLineTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classLineTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classLineTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classLineTool/#function-linetool","text":"explicit LineTool::LineTool ( QObject * parent=nullptr )","title":"function LineTool"},{"location":"flameshot/classLineTool/#function-copy","text":"CaptureTool * LineTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classLineTool/#function-description","text":"QString LineTool::description () override const","title":"function description"},{"location":"flameshot/classLineTool/#function-icon","text":"QIcon LineTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classLineTool/#function-name","text":"QString LineTool::name () override const","title":"function name"},{"location":"flameshot/classLineTool/#function-process","text":"void LineTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classLineTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classLineTool/#function-type","text":"CaptureTool::Type LineTool::type () override const","title":"function type"},{"location":"flameshot/classLoadSpinner/","text":"Class LoadSpinner # ClassList > LoadSpinner Inherits the following classes: QWidget Public Functions # Type Name LoadSpinner (QWidget * parent=nullptr) void setColor (const QColor & c) void setHeight (int h) void setWidth (int w) void start () void stop () Protected Functions # Type Name void paintEvent (QPaintEvent *) Public Functions Documentation # function LoadSpinner # explicit LoadSpinner::LoadSpinner ( QWidget * parent=nullptr ) function setColor # void LoadSpinner::setColor ( const QColor & c ) function setHeight # void LoadSpinner::setHeight ( int h ) function setWidth # void LoadSpinner::setWidth ( int w ) function start # void LoadSpinner::start () function stop # void LoadSpinner::stop () Protected Functions Documentation # function paintEvent # void LoadSpinner::paintEvent ( QPaintEvent * )","title":"Class LoadSpinner"},{"location":"flameshot/classLoadSpinner/#class-loadspinner","text":"ClassList > LoadSpinner Inherits the following classes: QWidget","title":"Class LoadSpinner"},{"location":"flameshot/classLoadSpinner/#public-functions","text":"Type Name LoadSpinner (QWidget * parent=nullptr) void setColor (const QColor & c) void setHeight (int h) void setWidth (int w) void start () void stop ()","title":"Public Functions"},{"location":"flameshot/classLoadSpinner/#protected-functions","text":"Type Name void paintEvent (QPaintEvent *)","title":"Protected Functions"},{"location":"flameshot/classLoadSpinner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classLoadSpinner/#function-loadspinner","text":"explicit LoadSpinner::LoadSpinner ( QWidget * parent=nullptr )","title":"function LoadSpinner"},{"location":"flameshot/classLoadSpinner/#function-setcolor","text":"void LoadSpinner::setColor ( const QColor & c )","title":"function setColor"},{"location":"flameshot/classLoadSpinner/#function-setheight","text":"void LoadSpinner::setHeight ( int h )","title":"function setHeight"},{"location":"flameshot/classLoadSpinner/#function-setwidth","text":"void LoadSpinner::setWidth ( int w )","title":"function setWidth"},{"location":"flameshot/classLoadSpinner/#function-start","text":"void LoadSpinner::start ()","title":"function start"},{"location":"flameshot/classLoadSpinner/#function-stop","text":"void LoadSpinner::stop ()","title":"function stop"},{"location":"flameshot/classLoadSpinner/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classLoadSpinner/#function-paintevent","text":"void LoadSpinner::paintEvent ( QPaintEvent * )","title":"function paintEvent"},{"location":"flameshot/classLowerBoundedInt/","text":"Class LowerBoundedInt # ClassList > LowerBoundedInt Inherits the following classes: ValueHandler Public Functions # Type Name LowerBoundedInt (int min, int def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function LowerBoundedInt # LowerBoundedInt::LowerBoundedInt ( int min, int def ) function check # Check the value semantically. virtual bool LowerBoundedInt::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString LowerBoundedInt::expected () override Implements ValueHandler::expected function fallback # virtual QVariant LowerBoundedInt::fallback () override Implements ValueHandler::fallback","title":"Class LowerBoundedInt"},{"location":"flameshot/classLowerBoundedInt/#class-lowerboundedint","text":"ClassList > LowerBoundedInt Inherits the following classes: ValueHandler","title":"Class LowerBoundedInt"},{"location":"flameshot/classLowerBoundedInt/#public-functions","text":"Type Name LowerBoundedInt (int min, int def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value).","title":"Public Functions"},{"location":"flameshot/classLowerBoundedInt/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classLowerBoundedInt/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classLowerBoundedInt/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classLowerBoundedInt/#function-lowerboundedint","text":"LowerBoundedInt::LowerBoundedInt ( int min, int def )","title":"function LowerBoundedInt"},{"location":"flameshot/classLowerBoundedInt/#function-check","text":"Check the value semantically. virtual bool LowerBoundedInt::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classLowerBoundedInt/#function-expected","text":"virtual QString LowerBoundedInt::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classLowerBoundedInt/#function-fallback","text":"virtual QVariant LowerBoundedInt::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classMagnifierWidget/","text":"Class MagnifierWidget # ClassList > MagnifierWidget Inherits the following classes: QWidget Public Functions # Type Name MagnifierWidget (const QPixmap & p, const QColor & c, bool isSquare, QWidget * parent=nullptr) Protected Functions # Type Name void paintEvent (QPaintEvent *) override Public Functions Documentation # function MagnifierWidget # explicit MagnifierWidget::MagnifierWidget ( const QPixmap & p, const QColor & c, bool isSquare, QWidget * parent=nullptr ) Protected Functions Documentation # function paintEvent # void MagnifierWidget::paintEvent ( QPaintEvent * ) override","title":"Class MagnifierWidget"},{"location":"flameshot/classMagnifierWidget/#class-magnifierwidget","text":"ClassList > MagnifierWidget Inherits the following classes: QWidget","title":"Class MagnifierWidget"},{"location":"flameshot/classMagnifierWidget/#public-functions","text":"Type Name MagnifierWidget (const QPixmap & p, const QColor & c, bool isSquare, QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classMagnifierWidget/#protected-functions","text":"Type Name void paintEvent (QPaintEvent *) override","title":"Protected Functions"},{"location":"flameshot/classMagnifierWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classMagnifierWidget/#function-magnifierwidget","text":"explicit MagnifierWidget::MagnifierWidget ( const QPixmap & p, const QColor & c, bool isSquare, QWidget * parent=nullptr )","title":"function MagnifierWidget"},{"location":"flameshot/classMagnifierWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classMagnifierWidget/#function-paintevent","text":"void MagnifierWidget::paintEvent ( QPaintEvent * ) override","title":"function paintEvent"},{"location":"flameshot/classMarkerTool/","text":"Class MarkerTool # ClassList > MarkerTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name MarkerTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QRect mousePreviewRect (const CaptureContext & context) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function MarkerTool # explicit MarkerTool::MarkerTool ( QObject * parent=nullptr ) function copy # CaptureTool * MarkerTool::copy ( QObject * parent=nullptr ) override function description # QString MarkerTool::description () override const function icon # QIcon MarkerTool::icon ( const QColor & background, bool inEditor ) override const function mousePreviewRect # QRect MarkerTool::mousePreviewRect ( const CaptureContext & context ) override const function name # QString MarkerTool::name () override const function paintMousePreview # void MarkerTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void MarkerTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type MarkerTool::type () override const","title":"Class MarkerTool"},{"location":"flameshot/classMarkerTool/#class-markertool","text":"ClassList > MarkerTool Inherits the following classes: AbstractTwoPointTool","title":"Class MarkerTool"},{"location":"flameshot/classMarkerTool/#public-functions","text":"Type Name MarkerTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QRect mousePreviewRect (const CaptureContext & context) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classMarkerTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classMarkerTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classMarkerTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classMarkerTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classMarkerTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classMarkerTool/#function-markertool","text":"explicit MarkerTool::MarkerTool ( QObject * parent=nullptr )","title":"function MarkerTool"},{"location":"flameshot/classMarkerTool/#function-copy","text":"CaptureTool * MarkerTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classMarkerTool/#function-description","text":"QString MarkerTool::description () override const","title":"function description"},{"location":"flameshot/classMarkerTool/#function-icon","text":"QIcon MarkerTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classMarkerTool/#function-mousepreviewrect","text":"QRect MarkerTool::mousePreviewRect ( const CaptureContext & context ) override const","title":"function mousePreviewRect"},{"location":"flameshot/classMarkerTool/#function-name","text":"QString MarkerTool::name () override const","title":"function name"},{"location":"flameshot/classMarkerTool/#function-paintmousepreview","text":"void MarkerTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classMarkerTool/#function-process","text":"void MarkerTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classMarkerTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classMarkerTool/#function-type","text":"CaptureTool::Type MarkerTool::type () override const","title":"function type"},{"location":"flameshot/classModificationCommand/","text":"Class ModificationCommand # ClassList > ModificationCommand Inherits the following classes: QUndoCommand Public Functions # Type Name ModificationCommand ( CaptureWidget * captureWidget, const CaptureToolObjects & captureToolObjects, const CaptureToolObjects & captureToolObjectsBackup) virtual void redo () override virtual void undo () override Public Functions Documentation # function ModificationCommand # ModificationCommand::ModificationCommand ( CaptureWidget * captureWidget, const CaptureToolObjects & captureToolObjects, const CaptureToolObjects & captureToolObjectsBackup ) function redo # virtual void ModificationCommand::redo () override function undo # virtual void ModificationCommand::undo () override","title":"Class ModificationCommand"},{"location":"flameshot/classModificationCommand/#class-modificationcommand","text":"ClassList > ModificationCommand Inherits the following classes: QUndoCommand","title":"Class ModificationCommand"},{"location":"flameshot/classModificationCommand/#public-functions","text":"Type Name ModificationCommand ( CaptureWidget * captureWidget, const CaptureToolObjects & captureToolObjects, const CaptureToolObjects & captureToolObjectsBackup) virtual void redo () override virtual void undo () override","title":"Public Functions"},{"location":"flameshot/classModificationCommand/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classModificationCommand/#function-modificationcommand","text":"ModificationCommand::ModificationCommand ( CaptureWidget * captureWidget, const CaptureToolObjects & captureToolObjects, const CaptureToolObjects & captureToolObjectsBackup )","title":"function ModificationCommand"},{"location":"flameshot/classModificationCommand/#function-redo","text":"virtual void ModificationCommand::redo () override","title":"function redo"},{"location":"flameshot/classModificationCommand/#function-undo","text":"virtual void ModificationCommand::undo () override","title":"function undo"},{"location":"flameshot/classMoveTool/","text":"Class MoveTool # ClassList > MoveTool Inherits the following classes: AbstractActionTool Public Functions # Type Name MoveTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const bool isSelectable () override const QString name () override const CaptureTool::Type type () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Public Functions Documentation # function MoveTool # explicit MoveTool::MoveTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool MoveTool::closeOnButtonPressed () override const function copy # CaptureTool * MoveTool::copy ( QObject * parent=nullptr ) override function description # QString MoveTool::description () override const function icon # QIcon MoveTool::icon ( const QColor & background, bool inEditor ) override const function isSelectable # bool MoveTool::isSelectable () override const function name # QString MoveTool::name () override const function type # CaptureTool::Type MoveTool::type () override const","title":"Class MoveTool"},{"location":"flameshot/classMoveTool/#class-movetool","text":"ClassList > MoveTool Inherits the following classes: AbstractActionTool","title":"Class MoveTool"},{"location":"flameshot/classMoveTool/#public-functions","text":"Type Name MoveTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const bool isSelectable () override const QString name () override const CaptureTool::Type type () override const","title":"Public Functions"},{"location":"flameshot/classMoveTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classMoveTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classMoveTool/#function-movetool","text":"explicit MoveTool::MoveTool ( QObject * parent=nullptr )","title":"function MoveTool"},{"location":"flameshot/classMoveTool/#function-closeonbuttonpressed","text":"bool MoveTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classMoveTool/#function-copy","text":"CaptureTool * MoveTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classMoveTool/#function-description","text":"QString MoveTool::description () override const","title":"function description"},{"location":"flameshot/classMoveTool/#function-icon","text":"QIcon MoveTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classMoveTool/#function-isselectable","text":"bool MoveTool::isSelectable () override const","title":"function isSelectable"},{"location":"flameshot/classMoveTool/#function-name","text":"QString MoveTool::name () override const","title":"function name"},{"location":"flameshot/classMoveTool/#function-type","text":"CaptureTool::Type MoveTool::type () override const","title":"function type"},{"location":"flameshot/classNotificationWidget/","text":"Class NotificationWidget # ClassList > NotificationWidget Inherits the following classes: QWidget Public Functions # Type Name NotificationWidget (QWidget * parent=nullptr) void showMessage (const QString & msg) Public Functions Documentation # function NotificationWidget # explicit NotificationWidget::NotificationWidget ( QWidget * parent=nullptr ) function showMessage # void NotificationWidget::showMessage ( const QString & msg )","title":"Class NotificationWidget"},{"location":"flameshot/classNotificationWidget/#class-notificationwidget","text":"ClassList > NotificationWidget Inherits the following classes: QWidget","title":"Class NotificationWidget"},{"location":"flameshot/classNotificationWidget/#public-functions","text":"Type Name NotificationWidget (QWidget * parent=nullptr) void showMessage (const QString & msg)","title":"Public Functions"},{"location":"flameshot/classNotificationWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classNotificationWidget/#function-notificationwidget","text":"explicit NotificationWidget::NotificationWidget ( QWidget * parent=nullptr )","title":"function NotificationWidget"},{"location":"flameshot/classNotificationWidget/#function-showmessage","text":"void NotificationWidget::showMessage ( const QString & msg )","title":"function showMessage"},{"location":"flameshot/classNotifierBox/","text":"Class NotifierBox # ClassList > NotifierBox Inherits the following classes: QWidget Public Functions # Type Name NotifierBox (QWidget * parent=nullptr) Protected Functions # Type Name virtual void enterEvent (QEvent *) override virtual void paintEvent (QPaintEvent *) override Public Functions Documentation # function NotifierBox # explicit NotifierBox::NotifierBox ( QWidget * parent=nullptr ) Protected Functions Documentation # function enterEvent # virtual void NotifierBox::enterEvent ( QEvent * ) override function paintEvent # virtual void NotifierBox::paintEvent ( QPaintEvent * ) override","title":"Class NotifierBox"},{"location":"flameshot/classNotifierBox/#class-notifierbox","text":"ClassList > NotifierBox Inherits the following classes: QWidget","title":"Class NotifierBox"},{"location":"flameshot/classNotifierBox/#public-functions","text":"Type Name NotifierBox (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classNotifierBox/#protected-functions","text":"Type Name virtual void enterEvent (QEvent *) override virtual void paintEvent (QPaintEvent *) override","title":"Protected Functions"},{"location":"flameshot/classNotifierBox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classNotifierBox/#function-notifierbox","text":"explicit NotifierBox::NotifierBox ( QWidget * parent=nullptr )","title":"function NotifierBox"},{"location":"flameshot/classNotifierBox/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classNotifierBox/#function-enterevent","text":"virtual void NotifierBox::enterEvent ( QEvent * ) override","title":"function enterEvent"},{"location":"flameshot/classNotifierBox/#function-paintevent","text":"virtual void NotifierBox::paintEvent ( QPaintEvent * ) override","title":"function paintEvent"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/","text":"Class OrgFreedesktopPortalRequestInterface # ClassList > OrgFreedesktopPortalRequestInterface Inherits the following classes: QDBusAbstractInterface Public Functions # Type Name OrgFreedesktopPortalRequestInterface (const QString & service, const QString & path, const QDBusConnection & connection, QObject * parent=nullptr) ~OrgFreedesktopPortalRequestInterface () Public Static Functions # Type Name const char * staticInterfaceName () Public Functions Documentation # function OrgFreedesktopPortalRequestInterface # OrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface ( const QString & service, const QString & path, const QDBusConnection & connection, QObject * parent=nullptr ) function ~OrgFreedesktopPortalRequestInterface # OrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface () Public Static Functions Documentation # function staticInterfaceName # static inline const char * OrgFreedesktopPortalRequestInterface::staticInterfaceName ()","title":"Class OrgFreedesktopPortalRequestInterface"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#class-orgfreedesktopportalrequestinterface","text":"ClassList > OrgFreedesktopPortalRequestInterface Inherits the following classes: QDBusAbstractInterface","title":"Class OrgFreedesktopPortalRequestInterface"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-functions","text":"Type Name OrgFreedesktopPortalRequestInterface (const QString & service, const QString & path, const QDBusConnection & connection, QObject * parent=nullptr) ~OrgFreedesktopPortalRequestInterface ()","title":"Public Functions"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-static-functions","text":"Type Name const char * staticInterfaceName ()","title":"Public Static Functions"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-orgfreedesktopportalrequestinterface","text":"OrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface ( const QString & service, const QString & path, const QDBusConnection & connection, QObject * parent=nullptr )","title":"function OrgFreedesktopPortalRequestInterface"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-orgfreedesktopportalrequestinterface_1","text":"OrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface ()","title":"function ~OrgFreedesktopPortalRequestInterface"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-staticinterfacename","text":"static inline const char * OrgFreedesktopPortalRequestInterface::staticInterfaceName ()","title":"function staticInterfaceName"},{"location":"flameshot/classOrientablePushButton/","text":"Class OrientablePushButton # ClassList > OrientablePushButton Inherits the following classes: CaptureButton Public Types # Type Name enum Orientation Public Functions # Type Name OrientablePushButton (QWidget * parent=nullptr) OrientablePushButton (const QString & text, QWidget * parent=nullptr) OrientablePushButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) OrientablePushButton::Orientation orientation () const void setOrientation (const OrientablePushButton::Orientation & orientation) QSize sizeHint () const Public Functions inherited from CaptureButton # See CaptureButton Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const Public Static Functions inherited from CaptureButton # See CaptureButton Type Name QString globalStyleSheet () Protected Functions # Type Name void paintEvent (QPaintEvent * event) Public Types Documentation # enum Orientation # enum OrientablePushButton::Orientation { Horizontal, VerticalTopToBottom, VerticalBottomToTop }; Public Functions Documentation # function OrientablePushButton [1/3] # OrientablePushButton::OrientablePushButton ( QWidget * parent=nullptr ) function OrientablePushButton [2/3] # OrientablePushButton::OrientablePushButton ( const QString & text, QWidget * parent=nullptr ) function OrientablePushButton [3/3] # OrientablePushButton::OrientablePushButton ( const QIcon & icon, const QString & text, QWidget * parent=nullptr ) function orientation # OrientablePushButton::Orientation OrientablePushButton::orientation () const function setOrientation # void OrientablePushButton::setOrientation ( const OrientablePushButton::Orientation & orientation ) function sizeHint # QSize OrientablePushButton::sizeHint () const Protected Functions Documentation # function paintEvent # void OrientablePushButton::paintEvent ( QPaintEvent * event )","title":"Class OrientablePushButton"},{"location":"flameshot/classOrientablePushButton/#class-orientablepushbutton","text":"ClassList > OrientablePushButton Inherits the following classes: CaptureButton","title":"Class OrientablePushButton"},{"location":"flameshot/classOrientablePushButton/#public-types","text":"Type Name enum Orientation","title":"Public Types"},{"location":"flameshot/classOrientablePushButton/#public-functions","text":"Type Name OrientablePushButton (QWidget * parent=nullptr) OrientablePushButton (const QString & text, QWidget * parent=nullptr) OrientablePushButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) OrientablePushButton::Orientation orientation () const void setOrientation (const OrientablePushButton::Orientation & orientation) QSize sizeHint () const","title":"Public Functions"},{"location":"flameshot/classOrientablePushButton/#public-functions-inherited-from-capturebutton","text":"See CaptureButton Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr) CaptureButton (const QString & text, QWidget * parent=nullptr) CaptureButton (const QIcon & icon, const QString & text, QWidget * parent=nullptr) void setColor (const QColor & c) QString styleSheet () const","title":"Public Functions inherited from CaptureButton"},{"location":"flameshot/classOrientablePushButton/#public-static-functions-inherited-from-capturebutton","text":"See CaptureButton Type Name QString globalStyleSheet ()","title":"Public Static Functions inherited from CaptureButton"},{"location":"flameshot/classOrientablePushButton/#protected-functions","text":"Type Name void paintEvent (QPaintEvent * event)","title":"Protected Functions"},{"location":"flameshot/classOrientablePushButton/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classOrientablePushButton/#enum-orientation","text":"enum OrientablePushButton::Orientation { Horizontal, VerticalTopToBottom, VerticalBottomToTop };","title":"enum Orientation"},{"location":"flameshot/classOrientablePushButton/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-13","text":"OrientablePushButton::OrientablePushButton ( QWidget * parent=nullptr )","title":"function OrientablePushButton [1/3]"},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-23","text":"OrientablePushButton::OrientablePushButton ( const QString & text, QWidget * parent=nullptr )","title":"function OrientablePushButton [2/3]"},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-33","text":"OrientablePushButton::OrientablePushButton ( const QIcon & icon, const QString & text, QWidget * parent=nullptr )","title":"function OrientablePushButton [3/3]"},{"location":"flameshot/classOrientablePushButton/#function-orientation","text":"OrientablePushButton::Orientation OrientablePushButton::orientation () const","title":"function orientation"},{"location":"flameshot/classOrientablePushButton/#function-setorientation","text":"void OrientablePushButton::setOrientation ( const OrientablePushButton::Orientation & orientation )","title":"function setOrientation"},{"location":"flameshot/classOrientablePushButton/#function-sizehint","text":"QSize OrientablePushButton::sizeHint () const","title":"function sizeHint"},{"location":"flameshot/classOrientablePushButton/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classOrientablePushButton/#function-paintevent","text":"void OrientablePushButton::paintEvent ( QPaintEvent * event )","title":"function paintEvent"},{"location":"flameshot/classOverlayMessage/","text":"Class OverlayMessage # ClassList > OverlayMessage Overlay a message in capture mode. More... #include <overlaymessage.h> Inherits the following classes: QLabel Public Functions # Type Name OverlayMessage () = delete Public Static Functions # Type Name QString compileFromKeyMap (const QList< QPair< QString, QString >> & map) Compile a message from a set of shortcuts and descriptions. void init (QWidget * parent, const QRect & targetArea) OverlayMessage * instance () void pop () void push (const QString & msg) Push a message to the message stack. void pushKeyMap (const QList< QPair< QString, QString >> & map) void setVisibility (bool visible) Detailed Description # The message must be initialized by calling init before it can be used. That can be done once per capture session. The class is a singleton. To change the active message call push . This will automatically show the widget. Previous messages won't be forgotten and will be reactivated after you call pop . You can show/hide the message using setVisibility (this won't push/pop anything). Note: You have to make sure that widgets pop the messages they pushed when they are closed, to avoid potential bugs and resource leaks. Public Functions Documentation # function OverlayMessage [1/2] # OverlayMessage::OverlayMessage () = delete Public Static Functions Documentation # function compileFromKeyMap # Compile a message from a set of shortcuts and descriptions. static QString OverlayMessage::compileFromKeyMap ( const QList< QPair< QString, QString >> & map ) Parameters: map List of (shortcut, description) pairs function init # static void OverlayMessage::init ( QWidget * parent, const QRect & targetArea ) function instance # static OverlayMessage * OverlayMessage::instance () function pop # static void OverlayMessage::pop () function push # Push a message to the message stack. static void OverlayMessage::push ( const QString & msg ) Parameters: msg Message text formatted as rich text function pushKeyMap # static void OverlayMessage::pushKeyMap ( const QList< QPair< QString, QString >> & map ) function setVisibility # static void OverlayMessage::setVisibility ( bool visible )","title":"Class OverlayMessage"},{"location":"flameshot/classOverlayMessage/#class-overlaymessage","text":"ClassList > OverlayMessage Overlay a message in capture mode. More... #include <overlaymessage.h> Inherits the following classes: QLabel","title":"Class OverlayMessage"},{"location":"flameshot/classOverlayMessage/#public-functions","text":"Type Name OverlayMessage () = delete","title":"Public Functions"},{"location":"flameshot/classOverlayMessage/#public-static-functions","text":"Type Name QString compileFromKeyMap (const QList< QPair< QString, QString >> & map) Compile a message from a set of shortcuts and descriptions. void init (QWidget * parent, const QRect & targetArea) OverlayMessage * instance () void pop () void push (const QString & msg) Push a message to the message stack. void pushKeyMap (const QList< QPair< QString, QString >> & map) void setVisibility (bool visible)","title":"Public Static Functions"},{"location":"flameshot/classOverlayMessage/#detailed-description","text":"The message must be initialized by calling init before it can be used. That can be done once per capture session. The class is a singleton. To change the active message call push . This will automatically show the widget. Previous messages won't be forgotten and will be reactivated after you call pop . You can show/hide the message using setVisibility (this won't push/pop anything). Note: You have to make sure that widgets pop the messages they pushed when they are closed, to avoid potential bugs and resource leaks.","title":"Detailed Description"},{"location":"flameshot/classOverlayMessage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classOverlayMessage/#function-overlaymessage-12","text":"OverlayMessage::OverlayMessage () = delete","title":"function OverlayMessage [1/2]"},{"location":"flameshot/classOverlayMessage/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classOverlayMessage/#function-compilefromkeymap","text":"Compile a message from a set of shortcuts and descriptions. static QString OverlayMessage::compileFromKeyMap ( const QList< QPair< QString, QString >> & map ) Parameters: map List of (shortcut, description) pairs","title":"function compileFromKeyMap"},{"location":"flameshot/classOverlayMessage/#function-init","text":"static void OverlayMessage::init ( QWidget * parent, const QRect & targetArea )","title":"function init"},{"location":"flameshot/classOverlayMessage/#function-instance","text":"static OverlayMessage * OverlayMessage::instance ()","title":"function instance"},{"location":"flameshot/classOverlayMessage/#function-pop","text":"static void OverlayMessage::pop ()","title":"function pop"},{"location":"flameshot/classOverlayMessage/#function-push","text":"Push a message to the message stack. static void OverlayMessage::push ( const QString & msg ) Parameters: msg Message text formatted as rich text","title":"function push"},{"location":"flameshot/classOverlayMessage/#function-pushkeymap","text":"static void OverlayMessage::pushKeyMap ( const QList< QPair< QString, QString >> & map )","title":"function pushKeyMap"},{"location":"flameshot/classOverlayMessage/#function-setvisibility","text":"static void OverlayMessage::setVisibility ( bool visible )","title":"function setVisibility"},{"location":"flameshot/namespacePathInfo/","text":"Namespace PathInfo # Namespace List > PathInfo Public Functions # Type Name const QString blackIconPath () QStringList translationsPaths () const QString whiteIconPath () Public Functions Documentation # function blackIconPath # const QString PathInfo::blackIconPath () function translationsPaths # QStringList PathInfo::translationsPaths () function whiteIconPath # const QString PathInfo::whiteIconPath ()","title":"Namespace PathInfo"},{"location":"flameshot/namespacePathInfo/#namespace-pathinfo","text":"Namespace List > PathInfo","title":"Namespace PathInfo"},{"location":"flameshot/namespacePathInfo/#public-functions","text":"Type Name const QString blackIconPath () QStringList translationsPaths () const QString whiteIconPath ()","title":"Public Functions"},{"location":"flameshot/namespacePathInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/namespacePathInfo/#function-blackiconpath","text":"const QString PathInfo::blackIconPath ()","title":"function blackIconPath"},{"location":"flameshot/namespacePathInfo/#function-translationspaths","text":"QStringList PathInfo::translationsPaths ()","title":"function translationsPaths"},{"location":"flameshot/namespacePathInfo/#function-whiteiconpath","text":"const QString PathInfo::whiteIconPath ()","title":"function whiteIconPath"},{"location":"flameshot/classPencilTool/","text":"Class PencilTool # ClassList > PencilTool Inherits the following classes: AbstractPathTool Public Functions # Type Name PencilTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractPathTool # See AbstractPathTool Type Name AbstractPathTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractPathTool # See AbstractPathTool Type Name QColor m_color int m_padding QRect m_pathArea QVector< QPoint > m_points QPoint m_pos Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractPathTool # See AbstractPathTool Type Name void addPoint (const QPoint & point) void copyParams (const AbstractPathTool * from, AbstractPathTool * to) Public Functions Documentation # function PencilTool # explicit PencilTool::PencilTool ( QObject * parent=nullptr ) function copy # CaptureTool * PencilTool::copy ( QObject * parent=nullptr ) override function description # QString PencilTool::description () override const function icon # QIcon PencilTool::icon ( const QColor & background, bool inEditor ) override const function name # QString PencilTool::name () override const function paintMousePreview # void PencilTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void PencilTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type PencilTool::type () override const","title":"Class PencilTool"},{"location":"flameshot/classPencilTool/#class-penciltool","text":"ClassList > PencilTool Inherits the following classes: AbstractPathTool","title":"Class PencilTool"},{"location":"flameshot/classPencilTool/#public-functions","text":"Type Name PencilTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classPencilTool/#public-functions-inherited-from-abstractpathtool","text":"See AbstractPathTool Type Name AbstractPathTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractPathTool"},{"location":"flameshot/classPencilTool/#protected-attributes-inherited-from-abstractpathtool","text":"See AbstractPathTool Type Name QColor m_color int m_padding QRect m_pathArea QVector< QPoint > m_points QPoint m_pos","title":"Protected Attributes inherited from AbstractPathTool"},{"location":"flameshot/classPencilTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classPencilTool/#protected-functions-inherited-from-abstractpathtool","text":"See AbstractPathTool Type Name void addPoint (const QPoint & point) void copyParams (const AbstractPathTool * from, AbstractPathTool * to)","title":"Protected Functions inherited from AbstractPathTool"},{"location":"flameshot/classPencilTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classPencilTool/#function-penciltool","text":"explicit PencilTool::PencilTool ( QObject * parent=nullptr )","title":"function PencilTool"},{"location":"flameshot/classPencilTool/#function-copy","text":"CaptureTool * PencilTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classPencilTool/#function-description","text":"QString PencilTool::description () override const","title":"function description"},{"location":"flameshot/classPencilTool/#function-icon","text":"QIcon PencilTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classPencilTool/#function-name","text":"QString PencilTool::name () override const","title":"function name"},{"location":"flameshot/classPencilTool/#function-paintmousepreview","text":"void PencilTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classPencilTool/#function-process","text":"void PencilTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classPencilTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classPencilTool/#function-type","text":"CaptureTool::Type PencilTool::type () override const","title":"function type"},{"location":"flameshot/classPinTool/","text":"Class PinTool # ClassList > PinTool Inherits the following classes: AbstractActionTool Public Functions # Type Name PinTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function PinTool # explicit PinTool::PinTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool PinTool::closeOnButtonPressed () override const function copy # CaptureTool * PinTool::copy ( QObject * parent=nullptr ) override function description # QString PinTool::description () override const function icon # QIcon PinTool::icon ( const QColor & background, bool inEditor ) override const function name # QString PinTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type PinTool::type () override const","title":"Class PinTool"},{"location":"flameshot/classPinTool/#class-pintool","text":"ClassList > PinTool Inherits the following classes: AbstractActionTool","title":"Class PinTool"},{"location":"flameshot/classPinTool/#public-functions","text":"Type Name PinTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classPinTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classPinTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classPinTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classPinTool/#function-pintool","text":"explicit PinTool::PinTool ( QObject * parent=nullptr )","title":"function PinTool"},{"location":"flameshot/classPinTool/#function-closeonbuttonpressed","text":"bool PinTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classPinTool/#function-copy","text":"CaptureTool * PinTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classPinTool/#function-description","text":"QString PinTool::description () override const","title":"function description"},{"location":"flameshot/classPinTool/#function-icon","text":"QIcon PinTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classPinTool/#function-name","text":"QString PinTool::name () override const","title":"function name"},{"location":"flameshot/classPinTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classPinTool/#function-type","text":"CaptureTool::Type PinTool::type () override const","title":"function type"},{"location":"flameshot/classPinWidget/","text":"Class PinWidget # ClassList > PinWidget Inherits the following classes: QWidget Public Functions # Type Name PinWidget (const QPixmap & pixmap, const QRect & geometry, QWidget * parent=nullptr) Protected Functions # Type Name void enterEvent (QEvent *) override bool event (QEvent * event) override void keyPressEvent (QKeyEvent * event) override void leaveEvent (QEvent *) override void mouseDoubleClickEvent (QMouseEvent *) override void mouseMoveEvent (QMouseEvent * e) override void mousePressEvent (QMouseEvent * e) override void paintEvent (QPaintEvent * event) override Public Functions Documentation # function PinWidget # explicit PinWidget::PinWidget ( const QPixmap & pixmap, const QRect & geometry, QWidget * parent=nullptr ) Protected Functions Documentation # function enterEvent # void PinWidget::enterEvent ( QEvent * ) override function event # bool PinWidget::event ( QEvent * event ) override function keyPressEvent # void PinWidget::keyPressEvent ( QKeyEvent * event ) override function leaveEvent # void PinWidget::leaveEvent ( QEvent * ) override function mouseDoubleClickEvent # void PinWidget::mouseDoubleClickEvent ( QMouseEvent * ) override function mouseMoveEvent # void PinWidget::mouseMoveEvent ( QMouseEvent * e ) override function mousePressEvent # void PinWidget::mousePressEvent ( QMouseEvent * e ) override function paintEvent # void PinWidget::paintEvent ( QPaintEvent * event ) override","title":"Class PinWidget"},{"location":"flameshot/classPinWidget/#class-pinwidget","text":"ClassList > PinWidget Inherits the following classes: QWidget","title":"Class PinWidget"},{"location":"flameshot/classPinWidget/#public-functions","text":"Type Name PinWidget (const QPixmap & pixmap, const QRect & geometry, QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classPinWidget/#protected-functions","text":"Type Name void enterEvent (QEvent *) override bool event (QEvent * event) override void keyPressEvent (QKeyEvent * event) override void leaveEvent (QEvent *) override void mouseDoubleClickEvent (QMouseEvent *) override void mouseMoveEvent (QMouseEvent * e) override void mousePressEvent (QMouseEvent * e) override void paintEvent (QPaintEvent * event) override","title":"Protected Functions"},{"location":"flameshot/classPinWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classPinWidget/#function-pinwidget","text":"explicit PinWidget::PinWidget ( const QPixmap & pixmap, const QRect & geometry, QWidget * parent=nullptr )","title":"function PinWidget"},{"location":"flameshot/classPinWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classPinWidget/#function-enterevent","text":"void PinWidget::enterEvent ( QEvent * ) override","title":"function enterEvent"},{"location":"flameshot/classPinWidget/#function-event","text":"bool PinWidget::event ( QEvent * event ) override","title":"function event"},{"location":"flameshot/classPinWidget/#function-keypressevent","text":"void PinWidget::keyPressEvent ( QKeyEvent * event ) override","title":"function keyPressEvent"},{"location":"flameshot/classPinWidget/#function-leaveevent","text":"void PinWidget::leaveEvent ( QEvent * ) override","title":"function leaveEvent"},{"location":"flameshot/classPinWidget/#function-mousedoubleclickevent","text":"void PinWidget::mouseDoubleClickEvent ( QMouseEvent * ) override","title":"function mouseDoubleClickEvent"},{"location":"flameshot/classPinWidget/#function-mousemoveevent","text":"void PinWidget::mouseMoveEvent ( QMouseEvent * e ) override","title":"function mouseMoveEvent"},{"location":"flameshot/classPinWidget/#function-mousepressevent","text":"void PinWidget::mousePressEvent ( QMouseEvent * e ) override","title":"function mousePressEvent"},{"location":"flameshot/classPinWidget/#function-paintevent","text":"void PinWidget::paintEvent ( QPaintEvent * event ) override","title":"function paintEvent"},{"location":"flameshot/classPixelateTool/","text":"Class PixelateTool # ClassList > PixelateTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name PixelateTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter & painter, const QPixmap & pixmap) override QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function PixelateTool # explicit PixelateTool::PixelateTool ( QObject * parent=nullptr ) function boundingRect # QRect PixelateTool::boundingRect () override const function copy # CaptureTool * PixelateTool::copy ( QObject * parent=nullptr ) override function description # QString PixelateTool::description () override const function drawSearchArea # void PixelateTool::drawSearchArea ( QPainter & painter, const QPixmap & pixmap ) override function icon # QIcon PixelateTool::icon ( const QColor & background, bool inEditor ) override const function name # QString PixelateTool::name () override const function paintMousePreview # void PixelateTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function process # void PixelateTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type PixelateTool::type () override const","title":"Class PixelateTool"},{"location":"flameshot/classPixelateTool/#class-pixelatetool","text":"ClassList > PixelateTool Inherits the following classes: AbstractTwoPointTool","title":"Class PixelateTool"},{"location":"flameshot/classPixelateTool/#public-functions","text":"Type Name PixelateTool (QObject * parent=nullptr) QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter & painter, const QPixmap & pixmap) override QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classPixelateTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classPixelateTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classPixelateTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classPixelateTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classPixelateTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classPixelateTool/#function-pixelatetool","text":"explicit PixelateTool::PixelateTool ( QObject * parent=nullptr )","title":"function PixelateTool"},{"location":"flameshot/classPixelateTool/#function-boundingrect","text":"QRect PixelateTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classPixelateTool/#function-copy","text":"CaptureTool * PixelateTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classPixelateTool/#function-description","text":"QString PixelateTool::description () override const","title":"function description"},{"location":"flameshot/classPixelateTool/#function-drawsearcharea","text":"void PixelateTool::drawSearchArea ( QPainter & painter, const QPixmap & pixmap ) override","title":"function drawSearchArea"},{"location":"flameshot/classPixelateTool/#function-icon","text":"QIcon PixelateTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classPixelateTool/#function-name","text":"QString PixelateTool::name () override const","title":"function name"},{"location":"flameshot/classPixelateTool/#function-paintmousepreview","text":"void PixelateTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classPixelateTool/#function-process","text":"void PixelateTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classPixelateTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classPixelateTool/#function-type","text":"CaptureTool::Type PixelateTool::type () override const","title":"function type"},{"location":"flameshot/classQGuiAppCurrentScreen/","text":"Class QGuiAppCurrentScreen # ClassList > QGuiAppCurrentScreen Public Functions # Type Name QGuiAppCurrentScreen () QScreen * currentScreen () QScreen * currentScreen (const QPoint & pos) Public Functions Documentation # function QGuiAppCurrentScreen # explicit QGuiAppCurrentScreen::QGuiAppCurrentScreen () function currentScreen [1/2] # QScreen * QGuiAppCurrentScreen::currentScreen () function currentScreen [2/2] # QScreen * QGuiAppCurrentScreen::currentScreen ( const QPoint & pos )","title":"Class QGuiAppCurrentScreen"},{"location":"flameshot/classQGuiAppCurrentScreen/#class-qguiappcurrentscreen","text":"ClassList > QGuiAppCurrentScreen","title":"Class QGuiAppCurrentScreen"},{"location":"flameshot/classQGuiAppCurrentScreen/#public-functions","text":"Type Name QGuiAppCurrentScreen () QScreen * currentScreen () QScreen * currentScreen (const QPoint & pos)","title":"Public Functions"},{"location":"flameshot/classQGuiAppCurrentScreen/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classQGuiAppCurrentScreen/#function-qguiappcurrentscreen","text":"explicit QGuiAppCurrentScreen::QGuiAppCurrentScreen ()","title":"function QGuiAppCurrentScreen"},{"location":"flameshot/classQGuiAppCurrentScreen/#function-currentscreen-12","text":"QScreen * QGuiAppCurrentScreen::currentScreen ()","title":"function currentScreen [1/2]"},{"location":"flameshot/classQGuiAppCurrentScreen/#function-currentscreen-22","text":"QScreen * QGuiAppCurrentScreen::currentScreen ( const QPoint & pos )","title":"function currentScreen [2/2]"},{"location":"flameshot/classQSharedPointer/","text":"Class QSharedPointer # template <class T class T> ClassList > QSharedPointer","title":"Class QSharedPointer"},{"location":"flameshot/classQSharedPointer/#class-qsharedpointer","text":"template <class T class T> ClassList > QSharedPointer","title":"Class QSharedPointer"},{"location":"flameshot/classRectangleTool/","text":"Class RectangleTool # ClassList > RectangleTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name RectangleTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function RectangleTool # explicit RectangleTool::RectangleTool ( QObject * parent=nullptr ) function copy # CaptureTool * RectangleTool::copy ( QObject * parent=nullptr ) override function description # QString RectangleTool::description () override const function icon # QIcon RectangleTool::icon ( const QColor & background, bool inEditor ) override const function name # QString RectangleTool::name () override const function process # void RectangleTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type RectangleTool::type () override const","title":"Class RectangleTool"},{"location":"flameshot/classRectangleTool/#class-rectangletool","text":"ClassList > RectangleTool Inherits the following classes: AbstractTwoPointTool","title":"Class RectangleTool"},{"location":"flameshot/classRectangleTool/#public-functions","text":"Type Name RectangleTool (QObject * parent=nullptr) CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classRectangleTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classRectangleTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classRectangleTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classRectangleTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classRectangleTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classRectangleTool/#function-rectangletool","text":"explicit RectangleTool::RectangleTool ( QObject * parent=nullptr )","title":"function RectangleTool"},{"location":"flameshot/classRectangleTool/#function-copy","text":"CaptureTool * RectangleTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classRectangleTool/#function-description","text":"QString RectangleTool::description () override const","title":"function description"},{"location":"flameshot/classRectangleTool/#function-icon","text":"QIcon RectangleTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classRectangleTool/#function-name","text":"QString RectangleTool::name () override const","title":"function name"},{"location":"flameshot/classRectangleTool/#function-process","text":"void RectangleTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classRectangleTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classRectangleTool/#function-type","text":"CaptureTool::Type RectangleTool::type () override const","title":"function type"},{"location":"flameshot/classRedoTool/","text":"Class RedoTool # ClassList > RedoTool Inherits the following classes: AbstractActionTool Public Functions # Type Name RedoTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function RedoTool # explicit RedoTool::RedoTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool RedoTool::closeOnButtonPressed () override const function copy # CaptureTool * RedoTool::copy ( QObject * parent=nullptr ) override function description # QString RedoTool::description () override const function icon # QIcon RedoTool::icon ( const QColor & background, bool inEditor ) override const function name # QString RedoTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type RedoTool::type () override const","title":"Class RedoTool"},{"location":"flameshot/classRedoTool/#class-redotool","text":"ClassList > RedoTool Inherits the following classes: AbstractActionTool","title":"Class RedoTool"},{"location":"flameshot/classRedoTool/#public-functions","text":"Type Name RedoTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classRedoTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classRedoTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classRedoTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classRedoTool/#function-redotool","text":"explicit RedoTool::RedoTool ( QObject * parent=nullptr )","title":"function RedoTool"},{"location":"flameshot/classRedoTool/#function-closeonbuttonpressed","text":"bool RedoTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classRedoTool/#function-copy","text":"CaptureTool * RedoTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classRedoTool/#function-description","text":"QString RedoTool::description () override const","title":"function description"},{"location":"flameshot/classRedoTool/#function-icon","text":"QIcon RedoTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classRedoTool/#function-name","text":"QString RedoTool::name () override const","title":"function name"},{"location":"flameshot/classRedoTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classRedoTool/#function-type","text":"CaptureTool::Type RedoTool::type () override const","title":"function type"},{"location":"flameshot/classRegion/","text":"Class Region # ClassList > Region Inherits the following classes: ValueHandler Public Functions # Type Name virtual bool check (const QVariant & val) override Check the value semantically. Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function check # Check the value semantically. virtual bool Region::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"Class Region"},{"location":"flameshot/classRegion/#class-region","text":"ClassList > Region Inherits the following classes: ValueHandler","title":"Class Region"},{"location":"flameshot/classRegion/#public-functions","text":"Type Name virtual bool check (const QVariant & val) override Check the value semantically.","title":"Public Functions"},{"location":"flameshot/classRegion/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classRegion/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classRegion/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classRegion/#function-check","text":"Check the value semantically. virtual bool Region::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classSaveFileExtension/","text":"Class SaveFileExtension # ClassList > SaveFileExtension Inherits the following classes: ValueHandler Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Class SaveFileExtension"},{"location":"flameshot/classSaveFileExtension/#class-savefileextension","text":"ClassList > SaveFileExtension Inherits the following classes: ValueHandler","title":"Class SaveFileExtension"},{"location":"flameshot/classSaveFileExtension/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classSaveFileExtension/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classSaveTool/","text":"Class SaveTool # ClassList > SaveTool Inherits the following classes: AbstractActionTool Public Functions # Type Name SaveTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function SaveTool # explicit SaveTool::SaveTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool SaveTool::closeOnButtonPressed () override const function copy # CaptureTool * SaveTool::copy ( QObject * parent=nullptr ) override function description # QString SaveTool::description () override const function icon # QIcon SaveTool::icon ( const QColor & background, bool inEditor ) override const function name # QString SaveTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type SaveTool::type () override const","title":"Class SaveTool"},{"location":"flameshot/classSaveTool/#class-savetool","text":"ClassList > SaveTool Inherits the following classes: AbstractActionTool","title":"Class SaveTool"},{"location":"flameshot/classSaveTool/#public-functions","text":"Type Name SaveTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classSaveTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classSaveTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classSaveTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSaveTool/#function-savetool","text":"explicit SaveTool::SaveTool ( QObject * parent=nullptr )","title":"function SaveTool"},{"location":"flameshot/classSaveTool/#function-closeonbuttonpressed","text":"bool SaveTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classSaveTool/#function-copy","text":"CaptureTool * SaveTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classSaveTool/#function-description","text":"QString SaveTool::description () override const","title":"function description"},{"location":"flameshot/classSaveTool/#function-icon","text":"QIcon SaveTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classSaveTool/#function-name","text":"QString SaveTool::name () override const","title":"function name"},{"location":"flameshot/classSaveTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classSaveTool/#function-type","text":"CaptureTool::Type SaveTool::type () override const","title":"function type"},{"location":"flameshot/classScreenGrabber/","text":"Class ScreenGrabber # ClassList > ScreenGrabber Inherits the following classes: QObject Public Functions # Type Name ScreenGrabber (QObject * parent=nullptr) QRect desktopGeometry () void freeDesktopPortal (bool & ok, QPixmap & res) QPixmap grabEntireDesktop (bool & ok) QPixmap grabScreen (QScreen * screenNumber, bool & ok) QRect screenGeometry (QScreen * screen) Public Functions Documentation # function ScreenGrabber # explicit ScreenGrabber::ScreenGrabber ( QObject * parent=nullptr ) function desktopGeometry # QRect ScreenGrabber::desktopGeometry () function freeDesktopPortal # void ScreenGrabber::freeDesktopPortal ( bool & ok, QPixmap & res ) function grabEntireDesktop # QPixmap ScreenGrabber::grabEntireDesktop ( bool & ok ) function grabScreen # QPixmap ScreenGrabber::grabScreen ( QScreen * screenNumber, bool & ok ) function screenGeometry # QRect ScreenGrabber::screenGeometry ( QScreen * screen )","title":"Class ScreenGrabber"},{"location":"flameshot/classScreenGrabber/#class-screengrabber","text":"ClassList > ScreenGrabber Inherits the following classes: QObject","title":"Class ScreenGrabber"},{"location":"flameshot/classScreenGrabber/#public-functions","text":"Type Name ScreenGrabber (QObject * parent=nullptr) QRect desktopGeometry () void freeDesktopPortal (bool & ok, QPixmap & res) QPixmap grabEntireDesktop (bool & ok) QPixmap grabScreen (QScreen * screenNumber, bool & ok) QRect screenGeometry (QScreen * screen)","title":"Public Functions"},{"location":"flameshot/classScreenGrabber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classScreenGrabber/#function-screengrabber","text":"explicit ScreenGrabber::ScreenGrabber ( QObject * parent=nullptr )","title":"function ScreenGrabber"},{"location":"flameshot/classScreenGrabber/#function-desktopgeometry","text":"QRect ScreenGrabber::desktopGeometry ()","title":"function desktopGeometry"},{"location":"flameshot/classScreenGrabber/#function-freedesktopportal","text":"void ScreenGrabber::freeDesktopPortal ( bool & ok, QPixmap & res )","title":"function freeDesktopPortal"},{"location":"flameshot/classScreenGrabber/#function-grabentiredesktop","text":"QPixmap ScreenGrabber::grabEntireDesktop ( bool & ok )","title":"function grabEntireDesktop"},{"location":"flameshot/classScreenGrabber/#function-grabscreen","text":"QPixmap ScreenGrabber::grabScreen ( QScreen * screenNumber, bool & ok )","title":"function grabScreen"},{"location":"flameshot/classScreenGrabber/#function-screengeometry","text":"QRect ScreenGrabber::screenGeometry ( QScreen * screen )","title":"function screenGeometry"},{"location":"flameshot/classSelectionTool/","text":"Class SelectionTool # ClassList > SelectionTool Inherits the following classes: AbstractTwoPointTool Public Functions # Type Name SelectionTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override Public Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const Protected Attributes inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false Protected Functions # Type Name CaptureTool::Type type () override const Protected Functions inherited from AbstractTwoPointTool # See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding) Public Functions Documentation # function SelectionTool # explicit SelectionTool::SelectionTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool SelectionTool::closeOnButtonPressed () override const function copy # CaptureTool * SelectionTool::copy ( QObject * parent=nullptr ) override function description # QString SelectionTool::description () override const function icon # QIcon SelectionTool::icon ( const QColor & background, bool inEditor ) override const function name # QString SelectionTool::name () override const function process # void SelectionTool::process ( QPainter & painter, const QPixmap & pixmap ) override Protected Functions Documentation # function type # CaptureTool::Type SelectionTool::type () override const","title":"Class SelectionTool"},{"location":"flameshot/classSelectionTool/#class-selectiontool","text":"ClassList > SelectionTool Inherits the following classes: AbstractTwoPointTool","title":"Class SelectionTool"},{"location":"flameshot/classSelectionTool/#public-functions","text":"Type Name SelectionTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const void process (QPainter & painter, const QPixmap & pixmap) override","title":"Public Functions"},{"location":"flameshot/classSelectionTool/#public-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name AbstractTwoPointTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor & color () bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext & context) override const void move (const QPoint & pos) override void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPair< QPoint, QPoint > points () const const QPoint * pos () override bool showMousePreview () override const int size () override const","title":"Public Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classSelectionTool/#protected-attributes-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name bool m_supportsDiagonalAdj = = false bool m_supportsOrthogonalAdj = = false","title":"Protected Attributes inherited from AbstractTwoPointTool"},{"location":"flameshot/classSelectionTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classSelectionTool/#protected-functions-inherited-from-abstracttwopointtool","text":"See AbstractTwoPointTool Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to) void setPadding (int padding)","title":"Protected Functions inherited from AbstractTwoPointTool"},{"location":"flameshot/classSelectionTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSelectionTool/#function-selectiontool","text":"explicit SelectionTool::SelectionTool ( QObject * parent=nullptr )","title":"function SelectionTool"},{"location":"flameshot/classSelectionTool/#function-closeonbuttonpressed","text":"bool SelectionTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classSelectionTool/#function-copy","text":"CaptureTool * SelectionTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classSelectionTool/#function-description","text":"QString SelectionTool::description () override const","title":"function description"},{"location":"flameshot/classSelectionTool/#function-icon","text":"QIcon SelectionTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classSelectionTool/#function-name","text":"QString SelectionTool::name () override const","title":"function name"},{"location":"flameshot/classSelectionTool/#function-process","text":"void SelectionTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classSelectionTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classSelectionTool/#function-type","text":"CaptureTool::Type SelectionTool::type () override const","title":"function type"},{"location":"flameshot/classSelectionWidget/","text":"Class SelectionWidget # ClassList > SelectionWidget Inherits the following classes: QWidget Public Types # Type Name enum SideType Public Functions # Type Name SelectionWidget (QColor c, QWidget * parent=nullptr) QRect fullGeometry () const QRect geometry () const SideType getMouseSide (const QPoint & mousePos) const Get the side where the mouse cursor is. QVector< QRect > handlerAreas () QRect rect () const void setGeometry (const QRect & r) void setGeometryAnimated (const QRect & r) void setIdleCentralCursor (const QCursor & cursor) void setIgnoreMouse (bool ignore) Protected Functions # Type Name bool eventFilter (QObject * obj, QEvent * event) override void hideEvent (QHideEvent *) override void moveEvent (QMoveEvent *) override void paintEvent (QPaintEvent *) override void parentMouseMoveEvent (QMouseEvent * e) void parentMousePressEvent (QMouseEvent * e) void parentMouseReleaseEvent (QMouseEvent * e) void resizeEvent (QResizeEvent *) override void showEvent (QShowEvent *) override Public Types Documentation # enum SideType # enum SelectionWidget::SideType { NO_SIDE = 0, TOP_SIDE = 0b0001, BOTTOM_SIDE = 0b0010, RIGHT_SIDE = 0b0100, LEFT_SIDE = 0b1000, TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE, BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE, TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE, BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE, CENTER = 0b10000 }; Public Functions Documentation # function SelectionWidget # explicit SelectionWidget::SelectionWidget ( QColor c, QWidget * parent=nullptr ) function fullGeometry # QRect SelectionWidget::fullGeometry () const function geometry # QRect SelectionWidget::geometry () const function getMouseSide # Get the side where the mouse cursor is. SideType SelectionWidget::getMouseSide ( const QPoint & mousePos ) const Parameters: mousePos Mouse cursor position relative to the parent widget. function handlerAreas # QVector< QRect > SelectionWidget::handlerAreas () function rect # QRect SelectionWidget::rect () const function setGeometry # void SelectionWidget::setGeometry ( const QRect & r ) function setGeometryAnimated # void SelectionWidget::setGeometryAnimated ( const QRect & r ) function setIdleCentralCursor # void SelectionWidget::setIdleCentralCursor ( const QCursor & cursor ) Set the cursor that will be active when the mouse is inside the selection and the mouse is not clicked. function setIgnoreMouse # void SelectionWidget::setIgnoreMouse ( bool ignore ) Protected Functions Documentation # function eventFilter # bool SelectionWidget::eventFilter ( QObject * obj, QEvent * event ) override function hideEvent # void SelectionWidget::hideEvent ( QHideEvent * ) override function moveEvent # void SelectionWidget::moveEvent ( QMoveEvent * ) override function paintEvent # void SelectionWidget::paintEvent ( QPaintEvent * ) override function parentMouseMoveEvent # void SelectionWidget::parentMouseMoveEvent ( QMouseEvent * e ) function parentMousePressEvent # void SelectionWidget::parentMousePressEvent ( QMouseEvent * e ) function parentMouseReleaseEvent # void SelectionWidget::parentMouseReleaseEvent ( QMouseEvent * e ) function resizeEvent # void SelectionWidget::resizeEvent ( QResizeEvent * ) override function showEvent # void SelectionWidget::showEvent ( QShowEvent * ) override","title":"Class SelectionWidget"},{"location":"flameshot/classSelectionWidget/#class-selectionwidget","text":"ClassList > SelectionWidget Inherits the following classes: QWidget","title":"Class SelectionWidget"},{"location":"flameshot/classSelectionWidget/#public-types","text":"Type Name enum SideType","title":"Public Types"},{"location":"flameshot/classSelectionWidget/#public-functions","text":"Type Name SelectionWidget (QColor c, QWidget * parent=nullptr) QRect fullGeometry () const QRect geometry () const SideType getMouseSide (const QPoint & mousePos) const Get the side where the mouse cursor is. QVector< QRect > handlerAreas () QRect rect () const void setGeometry (const QRect & r) void setGeometryAnimated (const QRect & r) void setIdleCentralCursor (const QCursor & cursor) void setIgnoreMouse (bool ignore)","title":"Public Functions"},{"location":"flameshot/classSelectionWidget/#protected-functions","text":"Type Name bool eventFilter (QObject * obj, QEvent * event) override void hideEvent (QHideEvent *) override void moveEvent (QMoveEvent *) override void paintEvent (QPaintEvent *) override void parentMouseMoveEvent (QMouseEvent * e) void parentMousePressEvent (QMouseEvent * e) void parentMouseReleaseEvent (QMouseEvent * e) void resizeEvent (QResizeEvent *) override void showEvent (QShowEvent *) override","title":"Protected Functions"},{"location":"flameshot/classSelectionWidget/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/classSelectionWidget/#enum-sidetype","text":"enum SelectionWidget::SideType { NO_SIDE = 0, TOP_SIDE = 0b0001, BOTTOM_SIDE = 0b0010, RIGHT_SIDE = 0b0100, LEFT_SIDE = 0b1000, TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE, BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE, TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE, BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE, CENTER = 0b10000 };","title":"enum SideType"},{"location":"flameshot/classSelectionWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSelectionWidget/#function-selectionwidget","text":"explicit SelectionWidget::SelectionWidget ( QColor c, QWidget * parent=nullptr )","title":"function SelectionWidget"},{"location":"flameshot/classSelectionWidget/#function-fullgeometry","text":"QRect SelectionWidget::fullGeometry () const","title":"function fullGeometry"},{"location":"flameshot/classSelectionWidget/#function-geometry","text":"QRect SelectionWidget::geometry () const","title":"function geometry"},{"location":"flameshot/classSelectionWidget/#function-getmouseside","text":"Get the side where the mouse cursor is. SideType SelectionWidget::getMouseSide ( const QPoint & mousePos ) const Parameters: mousePos Mouse cursor position relative to the parent widget.","title":"function getMouseSide"},{"location":"flameshot/classSelectionWidget/#function-handlerareas","text":"QVector< QRect > SelectionWidget::handlerAreas ()","title":"function handlerAreas"},{"location":"flameshot/classSelectionWidget/#function-rect","text":"QRect SelectionWidget::rect () const","title":"function rect"},{"location":"flameshot/classSelectionWidget/#function-setgeometry","text":"void SelectionWidget::setGeometry ( const QRect & r )","title":"function setGeometry"},{"location":"flameshot/classSelectionWidget/#function-setgeometryanimated","text":"void SelectionWidget::setGeometryAnimated ( const QRect & r )","title":"function setGeometryAnimated"},{"location":"flameshot/classSelectionWidget/#function-setidlecentralcursor","text":"void SelectionWidget::setIdleCentralCursor ( const QCursor & cursor ) Set the cursor that will be active when the mouse is inside the selection and the mouse is not clicked.","title":"function setIdleCentralCursor"},{"location":"flameshot/classSelectionWidget/#function-setignoremouse","text":"void SelectionWidget::setIgnoreMouse ( bool ignore )","title":"function setIgnoreMouse"},{"location":"flameshot/classSelectionWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classSelectionWidget/#function-eventfilter","text":"bool SelectionWidget::eventFilter ( QObject * obj, QEvent * event ) override","title":"function eventFilter"},{"location":"flameshot/classSelectionWidget/#function-hideevent","text":"void SelectionWidget::hideEvent ( QHideEvent * ) override","title":"function hideEvent"},{"location":"flameshot/classSelectionWidget/#function-moveevent","text":"void SelectionWidget::moveEvent ( QMoveEvent * ) override","title":"function moveEvent"},{"location":"flameshot/classSelectionWidget/#function-paintevent","text":"void SelectionWidget::paintEvent ( QPaintEvent * ) override","title":"function paintEvent"},{"location":"flameshot/classSelectionWidget/#function-parentmousemoveevent","text":"void SelectionWidget::parentMouseMoveEvent ( QMouseEvent * e )","title":"function parentMouseMoveEvent"},{"location":"flameshot/classSelectionWidget/#function-parentmousepressevent","text":"void SelectionWidget::parentMousePressEvent ( QMouseEvent * e )","title":"function parentMousePressEvent"},{"location":"flameshot/classSelectionWidget/#function-parentmousereleaseevent","text":"void SelectionWidget::parentMouseReleaseEvent ( QMouseEvent * e )","title":"function parentMouseReleaseEvent"},{"location":"flameshot/classSelectionWidget/#function-resizeevent","text":"void SelectionWidget::resizeEvent ( QResizeEvent * ) override","title":"function resizeEvent"},{"location":"flameshot/classSelectionWidget/#function-showevent","text":"void SelectionWidget::showEvent ( QShowEvent * ) override","title":"function showEvent"},{"location":"flameshot/classSetShortcutDialog/","text":"Class SetShortcutDialog # ClassList > SetShortcutDialog Inherits the following classes: QDialog Public Functions # Type Name SetShortcutDialog (QDialog * parent=nullptr, QString shortcutName=\"\") void keyPressEvent (QKeyEvent * ke) void keyReleaseEvent (QKeyEvent * event) const QKeySequence & shortcut () Public Functions Documentation # function SetShortcutDialog # explicit SetShortcutDialog::SetShortcutDialog ( QDialog * parent=nullptr, QString shortcutName=\"\" ) function keyPressEvent # void SetShortcutDialog::keyPressEvent ( QKeyEvent * ke ) function keyReleaseEvent # void SetShortcutDialog::keyReleaseEvent ( QKeyEvent * event ) function shortcut # const QKeySequence & SetShortcutDialog::shortcut ()","title":"Class SetShortcutDialog"},{"location":"flameshot/classSetShortcutDialog/#class-setshortcutdialog","text":"ClassList > SetShortcutDialog Inherits the following classes: QDialog","title":"Class SetShortcutDialog"},{"location":"flameshot/classSetShortcutDialog/#public-functions","text":"Type Name SetShortcutDialog (QDialog * parent=nullptr, QString shortcutName=\"\") void keyPressEvent (QKeyEvent * ke) void keyReleaseEvent (QKeyEvent * event) const QKeySequence & shortcut ()","title":"Public Functions"},{"location":"flameshot/classSetShortcutDialog/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSetShortcutDialog/#function-setshortcutdialog","text":"explicit SetShortcutDialog::SetShortcutDialog ( QDialog * parent=nullptr, QString shortcutName=\"\" )","title":"function SetShortcutDialog"},{"location":"flameshot/classSetShortcutDialog/#function-keypressevent","text":"void SetShortcutDialog::keyPressEvent ( QKeyEvent * ke )","title":"function keyPressEvent"},{"location":"flameshot/classSetShortcutDialog/#function-keyreleaseevent","text":"void SetShortcutDialog::keyReleaseEvent ( QKeyEvent * event )","title":"function keyReleaseEvent"},{"location":"flameshot/classSetShortcutDialog/#function-shortcut","text":"const QKeySequence & SetShortcutDialog::shortcut ()","title":"function shortcut"},{"location":"flameshot/classShortcutsWidget/","text":"Class ShortcutsWidget # ClassList > ShortcutsWidget Inherits the following classes: QWidget Public Functions # Type Name ShortcutsWidget (QWidget * parent=nullptr) Public Functions Documentation # function ShortcutsWidget # explicit ShortcutsWidget::ShortcutsWidget ( QWidget * parent=nullptr )","title":"Class ShortcutsWidget"},{"location":"flameshot/classShortcutsWidget/#class-shortcutswidget","text":"ClassList > ShortcutsWidget Inherits the following classes: QWidget","title":"Class ShortcutsWidget"},{"location":"flameshot/classShortcutsWidget/#public-functions","text":"Type Name ShortcutsWidget (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classShortcutsWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classShortcutsWidget/#function-shortcutswidget","text":"explicit ShortcutsWidget::ShortcutsWidget ( QWidget * parent=nullptr )","title":"function ShortcutsWidget"},{"location":"flameshot/classSidePanelWidget/","text":"Class SidePanelWidget # ClassList > SidePanelWidget Inherits the following classes: QWidget Public Functions # Type Name SidePanelWidget (QPixmap * p, QWidget * parent=nullptr) Public Functions Documentation # function SidePanelWidget # explicit SidePanelWidget::SidePanelWidget ( QPixmap * p, QWidget * parent=nullptr )","title":"Class SidePanelWidget"},{"location":"flameshot/classSidePanelWidget/#class-sidepanelwidget","text":"ClassList > SidePanelWidget Inherits the following classes: QWidget","title":"Class SidePanelWidget"},{"location":"flameshot/classSidePanelWidget/#public-functions","text":"Type Name SidePanelWidget (QPixmap * p, QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classSidePanelWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSidePanelWidget/#function-sidepanelwidget","text":"explicit SidePanelWidget::SidePanelWidget ( QPixmap * p, QWidget * parent=nullptr )","title":"function SidePanelWidget"},{"location":"flameshot/classSizeDecreaseTool/","text":"Class SizeDecreaseTool # ClassList > SizeDecreaseTool Inherits the following classes: AbstractActionTool Public Functions # Type Name SizeDecreaseTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function SizeDecreaseTool # explicit SizeDecreaseTool::SizeDecreaseTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool SizeDecreaseTool::closeOnButtonPressed () override const function copy # CaptureTool * SizeDecreaseTool::copy ( QObject * parent=nullptr ) override function description # QString SizeDecreaseTool::description () override const function icon # QIcon SizeDecreaseTool::icon ( const QColor & background, bool inEditor ) override const function name # QString SizeDecreaseTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type SizeDecreaseTool::type () override const","title":"Class SizeDecreaseTool"},{"location":"flameshot/classSizeDecreaseTool/#class-sizedecreasetool","text":"ClassList > SizeDecreaseTool Inherits the following classes: AbstractActionTool","title":"Class SizeDecreaseTool"},{"location":"flameshot/classSizeDecreaseTool/#public-functions","text":"Type Name SizeDecreaseTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classSizeDecreaseTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classSizeDecreaseTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classSizeDecreaseTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSizeDecreaseTool/#function-sizedecreasetool","text":"explicit SizeDecreaseTool::SizeDecreaseTool ( QObject * parent=nullptr )","title":"function SizeDecreaseTool"},{"location":"flameshot/classSizeDecreaseTool/#function-closeonbuttonpressed","text":"bool SizeDecreaseTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classSizeDecreaseTool/#function-copy","text":"CaptureTool * SizeDecreaseTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classSizeDecreaseTool/#function-description","text":"QString SizeDecreaseTool::description () override const","title":"function description"},{"location":"flameshot/classSizeDecreaseTool/#function-icon","text":"QIcon SizeDecreaseTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classSizeDecreaseTool/#function-name","text":"QString SizeDecreaseTool::name () override const","title":"function name"},{"location":"flameshot/classSizeDecreaseTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classSizeDecreaseTool/#function-type","text":"CaptureTool::Type SizeDecreaseTool::type () override const","title":"function type"},{"location":"flameshot/classSizeIncreaseTool/","text":"Class SizeIncreaseTool # ClassList > SizeIncreaseTool Inherits the following classes: AbstractActionTool Public Functions # Type Name SizeIncreaseTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function SizeIncreaseTool # explicit SizeIncreaseTool::SizeIncreaseTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool SizeIncreaseTool::closeOnButtonPressed () override const function copy # CaptureTool * SizeIncreaseTool::copy ( QObject * parent=nullptr ) override function description # QString SizeIncreaseTool::description () override const function icon # QIcon SizeIncreaseTool::icon ( const QColor & background, bool inEditor ) override const function name # QString SizeIncreaseTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type SizeIncreaseTool::type () override const","title":"Class SizeIncreaseTool"},{"location":"flameshot/classSizeIncreaseTool/#class-sizeincreasetool","text":"ClassList > SizeIncreaseTool Inherits the following classes: AbstractActionTool","title":"Class SizeIncreaseTool"},{"location":"flameshot/classSizeIncreaseTool/#public-functions","text":"Type Name SizeIncreaseTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classSizeIncreaseTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classSizeIncreaseTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classSizeIncreaseTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSizeIncreaseTool/#function-sizeincreasetool","text":"explicit SizeIncreaseTool::SizeIncreaseTool ( QObject * parent=nullptr )","title":"function SizeIncreaseTool"},{"location":"flameshot/classSizeIncreaseTool/#function-closeonbuttonpressed","text":"bool SizeIncreaseTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classSizeIncreaseTool/#function-copy","text":"CaptureTool * SizeIncreaseTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classSizeIncreaseTool/#function-description","text":"QString SizeIncreaseTool::description () override const","title":"function description"},{"location":"flameshot/classSizeIncreaseTool/#function-icon","text":"QIcon SizeIncreaseTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classSizeIncreaseTool/#function-name","text":"QString SizeIncreaseTool::name () override const","title":"function name"},{"location":"flameshot/classSizeIncreaseTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classSizeIncreaseTool/#function-type","text":"CaptureTool::Type SizeIncreaseTool::type () override const","title":"function type"},{"location":"flameshot/classStrftimeChooserWidget/","text":"Class StrftimeChooserWidget # ClassList > StrftimeChooserWidget Inherits the following classes: QWidget Public Functions # Type Name StrftimeChooserWidget (QWidget * parent=nullptr) Public Functions Documentation # function StrftimeChooserWidget # explicit StrftimeChooserWidget::StrftimeChooserWidget ( QWidget * parent=nullptr )","title":"Class StrftimeChooserWidget"},{"location":"flameshot/classStrftimeChooserWidget/#class-strftimechooserwidget","text":"ClassList > StrftimeChooserWidget Inherits the following classes: QWidget","title":"Class StrftimeChooserWidget"},{"location":"flameshot/classStrftimeChooserWidget/#public-functions","text":"Type Name StrftimeChooserWidget (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classStrftimeChooserWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classStrftimeChooserWidget/#function-strftimechooserwidget","text":"explicit StrftimeChooserWidget::StrftimeChooserWidget ( QWidget * parent=nullptr )","title":"function StrftimeChooserWidget"},{"location":"flameshot/classString/","text":"Class String # ClassList > String Inherits the following classes: ValueHandler Public Functions # Type Name String (QString def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function String # String::String ( QString def ) function check # Check the value semantically. virtual bool String::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString String::expected () override Implements ValueHandler::expected function fallback # virtual QVariant String::fallback () override Implements ValueHandler::fallback","title":"Class String"},{"location":"flameshot/classString/#class-string","text":"ClassList > String Inherits the following classes: ValueHandler","title":"Class String"},{"location":"flameshot/classString/#public-functions","text":"Type Name String (QString def) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value).","title":"Public Functions"},{"location":"flameshot/classString/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classString/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classString/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classString/#function-string","text":"String::String ( QString def )","title":"function String"},{"location":"flameshot/classString/#function-check","text":"Check the value semantically. virtual bool String::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classString/#function-expected","text":"virtual QString String::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classString/#function-fallback","text":"virtual QVariant String::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classStyleOverride/","text":"Class StyleOverride # ClassList > StyleOverride Inherits the following classes: QProxyStyle Public Functions # Type Name int styleHint (StyleHint hint, const QStyleOption * option=Q_NULLPTR, const QWidget * widget=Q_NULLPTR, QStyleHintReturn * returnData=Q_NULLPTR) const Public Functions Documentation # function styleHint # int StyleOverride::styleHint ( StyleHint hint, const QStyleOption * option=Q_NULLPTR, const QWidget * widget=Q_NULLPTR, QStyleHintReturn * returnData=Q_NULLPTR ) const","title":"Class StyleOverride"},{"location":"flameshot/classStyleOverride/#class-styleoverride","text":"ClassList > StyleOverride Inherits the following classes: QProxyStyle","title":"Class StyleOverride"},{"location":"flameshot/classStyleOverride/#public-functions","text":"Type Name int styleHint (StyleHint hint, const QStyleOption * option=Q_NULLPTR, const QWidget * widget=Q_NULLPTR, QStyleHintReturn * returnData=Q_NULLPTR) const","title":"Public Functions"},{"location":"flameshot/classStyleOverride/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classStyleOverride/#function-stylehint","text":"int StyleOverride::styleHint ( StyleHint hint, const QStyleOption * option=Q_NULLPTR, const QWidget * widget=Q_NULLPTR, QStyleHintReturn * returnData=Q_NULLPTR ) const","title":"function styleHint"},{"location":"flameshot/classSystemNotification/","text":"Class SystemNotification # ClassList > SystemNotification Inherits the following classes: QObject Public Functions # Type Name SystemNotification (QObject * parent=nullptr) void sendMessage (const QString & text, const QString & savePath={}) void sendMessage (const QString & text, const QString & title, const QString & savePath, const int timeout=5000) Public Functions Documentation # function SystemNotification # explicit SystemNotification::SystemNotification ( QObject * parent=nullptr ) function sendMessage [1/2] # void SystemNotification::sendMessage ( const QString & text, const QString & savePath={} ) function sendMessage [2/2] # void SystemNotification::sendMessage ( const QString & text, const QString & title, const QString & savePath, const int timeout=5000 )","title":"Class SystemNotification"},{"location":"flameshot/classSystemNotification/#class-systemnotification","text":"ClassList > SystemNotification Inherits the following classes: QObject","title":"Class SystemNotification"},{"location":"flameshot/classSystemNotification/#public-functions","text":"Type Name SystemNotification (QObject * parent=nullptr) void sendMessage (const QString & text, const QString & savePath={}) void sendMessage (const QString & text, const QString & title, const QString & savePath, const int timeout=5000)","title":"Public Functions"},{"location":"flameshot/classSystemNotification/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classSystemNotification/#function-systemnotification","text":"explicit SystemNotification::SystemNotification ( QObject * parent=nullptr )","title":"function SystemNotification"},{"location":"flameshot/classSystemNotification/#function-sendmessage-12","text":"void SystemNotification::sendMessage ( const QString & text, const QString & savePath={} )","title":"function sendMessage [1/2]"},{"location":"flameshot/classSystemNotification/#function-sendmessage-22","text":"void SystemNotification::sendMessage ( const QString & text, const QString & title, const QString & savePath, const int timeout=5000 )","title":"function sendMessage [2/2]"},{"location":"flameshot/structTerminalApp/","text":"Struct TerminalApp # ClassList > TerminalApp Public Attributes # Type Name QString arg QString name Public Attributes Documentation # variable arg # QString TerminalApp::arg; variable name # QString TerminalApp::name;","title":"Struct TerminalApp"},{"location":"flameshot/structTerminalApp/#struct-terminalapp","text":"ClassList > TerminalApp","title":"Struct TerminalApp"},{"location":"flameshot/structTerminalApp/#public-attributes","text":"Type Name QString arg QString name","title":"Public Attributes"},{"location":"flameshot/structTerminalApp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/structTerminalApp/#variable-arg","text":"QString TerminalApp::arg;","title":"variable arg"},{"location":"flameshot/structTerminalApp/#variable-name","text":"QString TerminalApp::name;","title":"variable name"},{"location":"flameshot/classTerminalLauncher/","text":"Class TerminalLauncher # ClassList > TerminalLauncher Inherits the following classes: QObject Public Functions # Type Name TerminalLauncher (QObject * parent=nullptr) Public Static Functions # Type Name bool launchDetached (const QString & command) Public Functions Documentation # function TerminalLauncher # explicit TerminalLauncher::TerminalLauncher ( QObject * parent=nullptr ) Public Static Functions Documentation # function launchDetached # static bool TerminalLauncher::launchDetached ( const QString & command )","title":"Class TerminalLauncher"},{"location":"flameshot/classTerminalLauncher/#class-terminallauncher","text":"ClassList > TerminalLauncher Inherits the following classes: QObject","title":"Class TerminalLauncher"},{"location":"flameshot/classTerminalLauncher/#public-functions","text":"Type Name TerminalLauncher (QObject * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classTerminalLauncher/#public-static-functions","text":"Type Name bool launchDetached (const QString & command)","title":"Public Static Functions"},{"location":"flameshot/classTerminalLauncher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classTerminalLauncher/#function-terminallauncher","text":"explicit TerminalLauncher::TerminalLauncher ( QObject * parent=nullptr )","title":"function TerminalLauncher"},{"location":"flameshot/classTerminalLauncher/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classTerminalLauncher/#function-launchdetached","text":"static bool TerminalLauncher::launchDetached ( const QString & command )","title":"function launchDetached"},{"location":"flameshot/classTextConfig/","text":"Class TextConfig # ClassList > TextConfig Inherits the following classes: QWidget Public Functions # Type Name TextConfig (QWidget * parent=nullptr) void setFontFamily (const QString & fontFamily) void setItalic (bool italic) void setStrikeOut (bool strikeout) void setTextAlignment (Qt::AlignmentFlag alignment) void setUnderline (bool underline) void setWeight (int weight) Public Functions Documentation # function TextConfig # explicit TextConfig::TextConfig ( QWidget * parent=nullptr ) function setFontFamily # void TextConfig::setFontFamily ( const QString & fontFamily ) function setItalic # void TextConfig::setItalic ( bool italic ) function setStrikeOut # void TextConfig::setStrikeOut ( bool strikeout ) function setTextAlignment # void TextConfig::setTextAlignment ( Qt::AlignmentFlag alignment ) function setUnderline # void TextConfig::setUnderline ( bool underline ) function setWeight # void TextConfig::setWeight ( int weight )","title":"Class TextConfig"},{"location":"flameshot/classTextConfig/#class-textconfig","text":"ClassList > TextConfig Inherits the following classes: QWidget","title":"Class TextConfig"},{"location":"flameshot/classTextConfig/#public-functions","text":"Type Name TextConfig (QWidget * parent=nullptr) void setFontFamily (const QString & fontFamily) void setItalic (bool italic) void setStrikeOut (bool strikeout) void setTextAlignment (Qt::AlignmentFlag alignment) void setUnderline (bool underline) void setWeight (int weight)","title":"Public Functions"},{"location":"flameshot/classTextConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classTextConfig/#function-textconfig","text":"explicit TextConfig::TextConfig ( QWidget * parent=nullptr )","title":"function TextConfig"},{"location":"flameshot/classTextConfig/#function-setfontfamily","text":"void TextConfig::setFontFamily ( const QString & fontFamily )","title":"function setFontFamily"},{"location":"flameshot/classTextConfig/#function-setitalic","text":"void TextConfig::setItalic ( bool italic )","title":"function setItalic"},{"location":"flameshot/classTextConfig/#function-setstrikeout","text":"void TextConfig::setStrikeOut ( bool strikeout )","title":"function setStrikeOut"},{"location":"flameshot/classTextConfig/#function-settextalignment","text":"void TextConfig::setTextAlignment ( Qt::AlignmentFlag alignment )","title":"function setTextAlignment"},{"location":"flameshot/classTextConfig/#function-setunderline","text":"void TextConfig::setUnderline ( bool underline )","title":"function setUnderline"},{"location":"flameshot/classTextConfig/#function-setweight","text":"void TextConfig::setWeight ( int weight )","title":"function setWeight"},{"location":"flameshot/classTextTool/","text":"Class TextTool # ClassList > TextTool Inherits the following classes: CaptureTool Public Functions # Type Name TextTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const QWidget * configurationWidget () override CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawObjectSelection (QPainter & painter) override QIcon icon (const QColor & background, bool inEditor) override const QString info () override bool isChanged () override bool isSelectable () override const bool isValid () override const void move (const QPoint & pos) override QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPoint * pos () override void process (QPainter & painter, const QPixmap & pixmap) override void setEditMode (bool editMode) override bool showMousePreview () override const QWidget * widget () override ~TextTool () override Protected Functions # Type Name void copyParams (const TextTool * from, TextTool * to) CaptureTool::Type type () override const Public Functions Documentation # function TextTool # explicit TextTool::TextTool ( QObject * parent=nullptr ) function boundingRect # QRect TextTool::boundingRect () override const function closeOnButtonPressed # bool TextTool::closeOnButtonPressed () override const function configurationWidget # QWidget * TextTool::configurationWidget () override function copy # CaptureTool * TextTool::copy ( QObject * parent=nullptr ) override function description # QString TextTool::description () override const function drawObjectSelection # void TextTool::drawObjectSelection ( QPainter & painter ) override function icon # QIcon TextTool::icon ( const QColor & background, bool inEditor ) override const function info # QString TextTool::info () override function isChanged # bool TextTool::isChanged () override function isSelectable # bool TextTool::isSelectable () override const function isValid # bool TextTool::isValid () override const function move # void TextTool::move ( const QPoint & pos ) override function name # QString TextTool::name () override const function paintMousePreview # void TextTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override function pos # const QPoint * TextTool::pos () override function process # void TextTool::process ( QPainter & painter, const QPixmap & pixmap ) override function setEditMode # void TextTool::setEditMode ( bool editMode ) override function showMousePreview # bool TextTool::showMousePreview () override const function widget # QWidget * TextTool::widget () override function ~TextTool # TextTool::~TextTool () override Protected Functions Documentation # function copyParams # void TextTool::copyParams ( const TextTool * from, TextTool * to ) function type # CaptureTool::Type TextTool::type () override const","title":"Class TextTool"},{"location":"flameshot/classTextTool/#class-texttool","text":"ClassList > TextTool Inherits the following classes: CaptureTool","title":"Class TextTool"},{"location":"flameshot/classTextTool/#public-functions","text":"Type Name TextTool (QObject * parent=nullptr) QRect boundingRect () override const bool closeOnButtonPressed () override const QWidget * configurationWidget () override CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawObjectSelection (QPainter & painter) override QIcon icon (const QColor & background, bool inEditor) override const QString info () override bool isChanged () override bool isSelectable () override const bool isValid () override const void move (const QPoint & pos) override QString name () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override const QPoint * pos () override void process (QPainter & painter, const QPixmap & pixmap) override void setEditMode (bool editMode) override bool showMousePreview () override const QWidget * widget () override ~TextTool () override","title":"Public Functions"},{"location":"flameshot/classTextTool/#protected-functions","text":"Type Name void copyParams (const TextTool * from, TextTool * to) CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classTextTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classTextTool/#function-texttool","text":"explicit TextTool::TextTool ( QObject * parent=nullptr )","title":"function TextTool"},{"location":"flameshot/classTextTool/#function-boundingrect","text":"QRect TextTool::boundingRect () override const","title":"function boundingRect"},{"location":"flameshot/classTextTool/#function-closeonbuttonpressed","text":"bool TextTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classTextTool/#function-configurationwidget","text":"QWidget * TextTool::configurationWidget () override","title":"function configurationWidget"},{"location":"flameshot/classTextTool/#function-copy","text":"CaptureTool * TextTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classTextTool/#function-description","text":"QString TextTool::description () override const","title":"function description"},{"location":"flameshot/classTextTool/#function-drawobjectselection","text":"void TextTool::drawObjectSelection ( QPainter & painter ) override","title":"function drawObjectSelection"},{"location":"flameshot/classTextTool/#function-icon","text":"QIcon TextTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classTextTool/#function-info","text":"QString TextTool::info () override","title":"function info"},{"location":"flameshot/classTextTool/#function-ischanged","text":"bool TextTool::isChanged () override","title":"function isChanged"},{"location":"flameshot/classTextTool/#function-isselectable","text":"bool TextTool::isSelectable () override const","title":"function isSelectable"},{"location":"flameshot/classTextTool/#function-isvalid","text":"bool TextTool::isValid () override const","title":"function isValid"},{"location":"flameshot/classTextTool/#function-move","text":"void TextTool::move ( const QPoint & pos ) override","title":"function move"},{"location":"flameshot/classTextTool/#function-name","text":"QString TextTool::name () override const","title":"function name"},{"location":"flameshot/classTextTool/#function-paintmousepreview","text":"void TextTool::paintMousePreview ( QPainter & painter, const CaptureContext & context ) override","title":"function paintMousePreview"},{"location":"flameshot/classTextTool/#function-pos","text":"const QPoint * TextTool::pos () override","title":"function pos"},{"location":"flameshot/classTextTool/#function-process","text":"void TextTool::process ( QPainter & painter, const QPixmap & pixmap ) override","title":"function process"},{"location":"flameshot/classTextTool/#function-seteditmode","text":"void TextTool::setEditMode ( bool editMode ) override","title":"function setEditMode"},{"location":"flameshot/classTextTool/#function-showmousepreview","text":"bool TextTool::showMousePreview () override const","title":"function showMousePreview"},{"location":"flameshot/classTextTool/#function-widget","text":"QWidget * TextTool::widget () override","title":"function widget"},{"location":"flameshot/classTextTool/#function-texttool_1","text":"TextTool::~TextTool () override","title":"function ~TextTool"},{"location":"flameshot/classTextTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classTextTool/#function-copyparams","text":"void TextTool::copyParams ( const TextTool * from, TextTool * to )","title":"function copyParams"},{"location":"flameshot/classTextTool/#function-type","text":"CaptureTool::Type TextTool::type () override const","title":"function type"},{"location":"flameshot/classTextWidget/","text":"Class TextWidget # ClassList > TextWidget Inherits the following classes: QTextEdit Public Functions # Type Name TextWidget (QWidget * parent=nullptr) void adjustSize () void setFont (const QFont & f) Protected Functions # Type Name void resizeEvent (QResizeEvent * e) void showEvent (QShowEvent * e) Public Functions Documentation # function TextWidget # explicit TextWidget::TextWidget ( QWidget * parent=nullptr ) function adjustSize # void TextWidget::adjustSize () function setFont # void TextWidget::setFont ( const QFont & f ) Protected Functions Documentation # function resizeEvent # void TextWidget::resizeEvent ( QResizeEvent * e ) function showEvent # void TextWidget::showEvent ( QShowEvent * e )","title":"Class TextWidget"},{"location":"flameshot/classTextWidget/#class-textwidget","text":"ClassList > TextWidget Inherits the following classes: QTextEdit","title":"Class TextWidget"},{"location":"flameshot/classTextWidget/#public-functions","text":"Type Name TextWidget (QWidget * parent=nullptr) void adjustSize () void setFont (const QFont & f)","title":"Public Functions"},{"location":"flameshot/classTextWidget/#protected-functions","text":"Type Name void resizeEvent (QResizeEvent * e) void showEvent (QShowEvent * e)","title":"Protected Functions"},{"location":"flameshot/classTextWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classTextWidget/#function-textwidget","text":"explicit TextWidget::TextWidget ( QWidget * parent=nullptr )","title":"function TextWidget"},{"location":"flameshot/classTextWidget/#function-adjustsize","text":"void TextWidget::adjustSize ()","title":"function adjustSize"},{"location":"flameshot/classTextWidget/#function-setfont","text":"void TextWidget::setFont ( const QFont & f )","title":"function setFont"},{"location":"flameshot/classTextWidget/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classTextWidget/#function-resizeevent","text":"void TextWidget::resizeEvent ( QResizeEvent * e )","title":"function resizeEvent"},{"location":"flameshot/classTextWidget/#function-showevent","text":"void TextWidget::showEvent ( QShowEvent * e )","title":"function showEvent"},{"location":"flameshot/classToolFactory/","text":"Class ToolFactory # ClassList > ToolFactory Inherits the following classes: QObject Public Functions # Type Name CaptureTool * CreateTool (CaptureTool::Type t, QObject * parent=nullptr) ToolFactory (QObject * parent=nullptr) ToolFactory (const ToolFactory &) = delete ToolFactory & operator= (const ToolFactory &) = delete Public Functions Documentation # function CreateTool # CaptureTool * ToolFactory::CreateTool ( CaptureTool::Type t, QObject * parent=nullptr ) function ToolFactory [1/2] # explicit ToolFactory::ToolFactory ( QObject * parent=nullptr ) function ToolFactory [2/2] # ToolFactory::ToolFactory ( const ToolFactory & ) = delete function operator= # ToolFactory & ToolFactory::operator= ( const ToolFactory & ) = delete","title":"Class ToolFactory"},{"location":"flameshot/classToolFactory/#class-toolfactory","text":"ClassList > ToolFactory Inherits the following classes: QObject","title":"Class ToolFactory"},{"location":"flameshot/classToolFactory/#public-functions","text":"Type Name CaptureTool * CreateTool (CaptureTool::Type t, QObject * parent=nullptr) ToolFactory (QObject * parent=nullptr) ToolFactory (const ToolFactory &) = delete ToolFactory & operator= (const ToolFactory &) = delete","title":"Public Functions"},{"location":"flameshot/classToolFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classToolFactory/#function-createtool","text":"CaptureTool * ToolFactory::CreateTool ( CaptureTool::Type t, QObject * parent=nullptr )","title":"function CreateTool"},{"location":"flameshot/classToolFactory/#function-toolfactory-12","text":"explicit ToolFactory::ToolFactory ( QObject * parent=nullptr )","title":"function ToolFactory [1/2]"},{"location":"flameshot/classToolFactory/#function-toolfactory-22","text":"ToolFactory::ToolFactory ( const ToolFactory & ) = delete","title":"function ToolFactory [2/2]"},{"location":"flameshot/classToolFactory/#function-operator","text":"ToolFactory & ToolFactory::operator= ( const ToolFactory & ) = delete","title":"function operator="},{"location":"flameshot/classTrayIcon/","text":"Class TrayIcon # ClassList > TrayIcon Inherits the following classes: QSystemTrayIcon Public Functions # Type Name TrayIcon (QObject * parent=nullptr) QAction * appUpdates () virtual ~TrayIcon () Public Functions Documentation # function TrayIcon # TrayIcon::TrayIcon ( QObject * parent=nullptr ) function appUpdates # QAction * TrayIcon::appUpdates () function ~TrayIcon # virtual TrayIcon::~TrayIcon ()","title":"Class TrayIcon"},{"location":"flameshot/classTrayIcon/#class-trayicon","text":"ClassList > TrayIcon Inherits the following classes: QSystemTrayIcon","title":"Class TrayIcon"},{"location":"flameshot/classTrayIcon/#public-functions","text":"Type Name TrayIcon (QObject * parent=nullptr) QAction * appUpdates () virtual ~TrayIcon ()","title":"Public Functions"},{"location":"flameshot/classTrayIcon/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classTrayIcon/#function-trayicon","text":"TrayIcon::TrayIcon ( QObject * parent=nullptr )","title":"function TrayIcon"},{"location":"flameshot/classTrayIcon/#function-appupdates","text":"QAction * TrayIcon::appUpdates ()","title":"function appUpdates"},{"location":"flameshot/classTrayIcon/#function-trayicon_1","text":"virtual TrayIcon::~TrayIcon ()","title":"function ~TrayIcon"},{"location":"flameshot/classUIcolorEditor/","text":"Class UIcolorEditor # ClassList > UIcolorEditor Inherits the following classes: QWidget Public Functions # Type Name UIcolorEditor (QWidget * parent=nullptr) Public Functions Documentation # function UIcolorEditor # explicit UIcolorEditor::UIcolorEditor ( QWidget * parent=nullptr )","title":"Class UIcolorEditor"},{"location":"flameshot/classUIcolorEditor/#class-uicoloreditor","text":"ClassList > UIcolorEditor Inherits the following classes: QWidget","title":"Class UIcolorEditor"},{"location":"flameshot/classUIcolorEditor/#public-functions","text":"Type Name UIcolorEditor (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classUIcolorEditor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUIcolorEditor/#function-uicoloreditor","text":"explicit UIcolorEditor::UIcolorEditor ( QWidget * parent=nullptr )","title":"function UIcolorEditor"},{"location":"flameshot/namespaceUi/","text":"Namespace Ui # Namespace List > Ui","title":"Namespace Ui"},{"location":"flameshot/namespaceUi/#namespace-ui","text":"Namespace List > Ui","title":"Namespace Ui"},{"location":"flameshot/classUndoTool/","text":"Class UndoTool # ClassList > UndoTool Inherits the following classes: AbstractActionTool Public Functions # Type Name UndoTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const Public Functions inherited from AbstractActionTool # See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const Protected Functions # Type Name CaptureTool::Type type () override const Public Functions Documentation # function UndoTool # explicit UndoTool::UndoTool ( QObject * parent=nullptr ) function closeOnButtonPressed # bool UndoTool::closeOnButtonPressed () override const function copy # CaptureTool * UndoTool::copy ( QObject * parent=nullptr ) override function description # QString UndoTool::description () override const function icon # QIcon UndoTool::icon ( const QColor & background, bool inEditor ) override const function name # QString UndoTool::name () override const Protected Functions Documentation # function type # CaptureTool::Type UndoTool::type () override const","title":"Class UndoTool"},{"location":"flameshot/classUndoTool/#class-undotool","text":"ClassList > UndoTool Inherits the following classes: AbstractActionTool","title":"Class UndoTool"},{"location":"flameshot/classUndoTool/#public-functions","text":"Type Name UndoTool (QObject * parent=nullptr) bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor & background, bool inEditor) override const QString name () override const","title":"Public Functions"},{"location":"flameshot/classUndoTool/#public-functions-inherited-from-abstractactiontool","text":"See AbstractActionTool Type Name AbstractActionTool (QObject * parent=nullptr) QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter & painter, const CaptureContext & context) override void process (QPainter & painter, const QPixmap & pixmap) override bool showMousePreview () override const","title":"Public Functions inherited from AbstractActionTool"},{"location":"flameshot/classUndoTool/#protected-functions","text":"Type Name CaptureTool::Type type () override const","title":"Protected Functions"},{"location":"flameshot/classUndoTool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUndoTool/#function-undotool","text":"explicit UndoTool::UndoTool ( QObject * parent=nullptr )","title":"function UndoTool"},{"location":"flameshot/classUndoTool/#function-closeonbuttonpressed","text":"bool UndoTool::closeOnButtonPressed () override const","title":"function closeOnButtonPressed"},{"location":"flameshot/classUndoTool/#function-copy","text":"CaptureTool * UndoTool::copy ( QObject * parent=nullptr ) override","title":"function copy"},{"location":"flameshot/classUndoTool/#function-description","text":"QString UndoTool::description () override const","title":"function description"},{"location":"flameshot/classUndoTool/#function-icon","text":"QIcon UndoTool::icon ( const QColor & background, bool inEditor ) override const","title":"function icon"},{"location":"flameshot/classUndoTool/#function-name","text":"QString UndoTool::name () override const","title":"function name"},{"location":"flameshot/classUndoTool/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classUndoTool/#function-type","text":"CaptureTool::Type UndoTool::type () override const","title":"function type"},{"location":"flameshot/classUpdateNotificationWidget/","text":"Class UpdateNotificationWidget # ClassList > UpdateNotificationWidget Inherits the following classes: QWidget Public Functions # Type Name UpdateNotificationWidget (QWidget * parent, const QString & appLatestVersion, QString appLatestUrl) void hide () void setAppLatestVersion (const QString & latestVersion) void show () Public Functions Documentation # function UpdateNotificationWidget # explicit UpdateNotificationWidget::UpdateNotificationWidget ( QWidget * parent, const QString & appLatestVersion, QString appLatestUrl ) function hide # void UpdateNotificationWidget::hide () function setAppLatestVersion # void UpdateNotificationWidget::setAppLatestVersion ( const QString & latestVersion ) function show # void UpdateNotificationWidget::show ()","title":"Class UpdateNotificationWidget"},{"location":"flameshot/classUpdateNotificationWidget/#class-updatenotificationwidget","text":"ClassList > UpdateNotificationWidget Inherits the following classes: QWidget","title":"Class UpdateNotificationWidget"},{"location":"flameshot/classUpdateNotificationWidget/#public-functions","text":"Type Name UpdateNotificationWidget (QWidget * parent, const QString & appLatestVersion, QString appLatestUrl) void hide () void setAppLatestVersion (const QString & latestVersion) void show ()","title":"Public Functions"},{"location":"flameshot/classUpdateNotificationWidget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUpdateNotificationWidget/#function-updatenotificationwidget","text":"explicit UpdateNotificationWidget::UpdateNotificationWidget ( QWidget * parent, const QString & appLatestVersion, QString appLatestUrl )","title":"function UpdateNotificationWidget"},{"location":"flameshot/classUpdateNotificationWidget/#function-hide","text":"void UpdateNotificationWidget::hide ()","title":"function hide"},{"location":"flameshot/classUpdateNotificationWidget/#function-setapplatestversion","text":"void UpdateNotificationWidget::setAppLatestVersion ( const QString & latestVersion )","title":"function setAppLatestVersion"},{"location":"flameshot/classUpdateNotificationWidget/#function-show","text":"void UpdateNotificationWidget::show ()","title":"function show"},{"location":"flameshot/classUploadHistory/","text":"Class UploadHistory # ClassList > UploadHistory Inherits the following classes: QWidget Public Functions # Type Name UploadHistory (QWidget * parent=nullptr) void loadHistory () ~UploadHistory () Public Functions Documentation # function UploadHistory # explicit UploadHistory::UploadHistory ( QWidget * parent=nullptr ) function loadHistory # void UploadHistory::loadHistory () function ~UploadHistory # UploadHistory::~UploadHistory ()","title":"Class UploadHistory"},{"location":"flameshot/classUploadHistory/#class-uploadhistory","text":"ClassList > UploadHistory Inherits the following classes: QWidget","title":"Class UploadHistory"},{"location":"flameshot/classUploadHistory/#public-functions","text":"Type Name UploadHistory (QWidget * parent=nullptr) void loadHistory () ~UploadHistory ()","title":"Public Functions"},{"location":"flameshot/classUploadHistory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUploadHistory/#function-uploadhistory","text":"explicit UploadHistory::UploadHistory ( QWidget * parent=nullptr )","title":"function UploadHistory"},{"location":"flameshot/classUploadHistory/#function-loadhistory","text":"void UploadHistory::loadHistory ()","title":"function loadHistory"},{"location":"flameshot/classUploadHistory/#function-uploadhistory_1","text":"UploadHistory::~UploadHistory ()","title":"function ~UploadHistory"},{"location":"flameshot/classUploadLineItem/","text":"Class UploadLineItem # ClassList > UploadLineItem Inherits the following classes: QWidget Public Functions # Type Name UploadLineItem (QWidget * parent, QPixmap const & preview, QString const & timestamp, QString const & url, QString const & fullFileName, HistoryFileName const & unpackFileName) ~UploadLineItem () Public Functions Documentation # function UploadLineItem # UploadLineItem::UploadLineItem ( QWidget * parent, QPixmap const & preview, QString const & timestamp, QString const & url, QString const & fullFileName, HistoryFileName const & unpackFileName ) function ~UploadLineItem # UploadLineItem::~UploadLineItem ()","title":"Class UploadLineItem"},{"location":"flameshot/classUploadLineItem/#class-uploadlineitem","text":"ClassList > UploadLineItem Inherits the following classes: QWidget","title":"Class UploadLineItem"},{"location":"flameshot/classUploadLineItem/#public-functions","text":"Type Name UploadLineItem (QWidget * parent, QPixmap const & preview, QString const & timestamp, QString const & url, QString const & fullFileName, HistoryFileName const & unpackFileName) ~UploadLineItem ()","title":"Public Functions"},{"location":"flameshot/classUploadLineItem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUploadLineItem/#function-uploadlineitem","text":"UploadLineItem::UploadLineItem ( QWidget * parent, QPixmap const & preview, QString const & timestamp, QString const & url, QString const & fullFileName, HistoryFileName const & unpackFileName )","title":"function UploadLineItem"},{"location":"flameshot/classUploadLineItem/#function-uploadlineitem_1","text":"UploadLineItem::~UploadLineItem ()","title":"function ~UploadLineItem"},{"location":"flameshot/classUserColors/","text":"Class UserColors # ClassList > UserColors Inherits the following classes: ValueHandler Public Functions # Type Name UserColors (int min, int max) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file. Public Functions inherited from ValueHandler # See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions inherited from ValueHandler # See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Public Functions Documentation # function UserColors # UserColors::UserColors ( int min, int max ) function check # Check the value semantically. virtual bool UserColors::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check function expected # virtual QString UserColors::expected () override Implements ValueHandler::expected function fallback # virtual QVariant UserColors::fallback () override Implements ValueHandler::fallback function process # Process a value, presuming it is a valid QVariant . virtual QVariant UserColors::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process function representation # Return the representation of the value in the config file. virtual QVariant UserColors::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"Class UserColors"},{"location":"flameshot/classUserColors/#class-usercolors","text":"ClassList > UserColors Inherits the following classes: ValueHandler","title":"Class UserColors"},{"location":"flameshot/classUserColors/#public-functions","text":"Type Name UserColors (int min, int max) virtual bool check (const QVariant & val) override Check the value semantically. virtual QString expected () override The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () override Fallback value (default value). virtual QVariant process (const QVariant & val) override Process a value, presuming it is a valid QVariant . virtual QVariant representation (const QVariant & val) override Return the representation of the value in the config file.","title":"Public Functions"},{"location":"flameshot/classUserColors/#public-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions inherited from ValueHandler"},{"location":"flameshot/classUserColors/#protected-functions-inherited-from-valuehandler","text":"See ValueHandler Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions inherited from ValueHandler"},{"location":"flameshot/classUserColors/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUserColors/#function-usercolors","text":"UserColors::UserColors ( int min, int max )","title":"function UserColors"},{"location":"flameshot/classUserColors/#function-check","text":"Check the value semantically. virtual bool UserColors::check ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. Implements ValueHandler::check","title":"function check"},{"location":"flameshot/classUserColors/#function-expected","text":"virtual QString UserColors::expected () override Implements ValueHandler::expected","title":"function expected"},{"location":"flameshot/classUserColors/#function-fallback","text":"virtual QVariant UserColors::fallback () override Implements ValueHandler::fallback","title":"function fallback"},{"location":"flameshot/classUserColors/#function-process","text":"Process a value, presuming it is a valid QVariant . virtual QVariant UserColors::process ( const QVariant & val ) override Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value . Implements ValueHandler::process","title":"function process"},{"location":"flameshot/classUserColors/#function-representation","text":"Return the representation of the value in the config file. virtual QVariant UserColors::representation ( const QVariant & val ) override Override this if you want to write the value in a different format than the one provided by QVariant . Implements ValueHandler::representation","title":"function representation"},{"location":"flameshot/classUtilityPanel/","text":"Class UtilityPanel # ClassList > UtilityPanel Inherits the following classes: QWidget Public Functions # Type Name UtilityPanel ( CaptureWidget * captureWidget) int activeLayerIndex () void clearToolWidget () void fillCaptureTools (const QList< QPointer< CaptureTool >> & captureToolObjectsHistory) void hide () bool isVisible () const void pushWidget (QWidget * widget) void setActiveLayer (int index) void setToolWidget (QWidget * weight) void show () QWidget * toolWidget () const Public Functions Documentation # function UtilityPanel # explicit UtilityPanel::UtilityPanel ( CaptureWidget * captureWidget ) function activeLayerIndex # int UtilityPanel::activeLayerIndex () function clearToolWidget # void UtilityPanel::clearToolWidget () function fillCaptureTools # void UtilityPanel::fillCaptureTools ( const QList< QPointer< CaptureTool >> & captureToolObjectsHistory ) function hide # void UtilityPanel::hide () function isVisible # bool UtilityPanel::isVisible () const function pushWidget # void UtilityPanel::pushWidget ( QWidget * widget ) function setActiveLayer # void UtilityPanel::setActiveLayer ( int index ) function setToolWidget # void UtilityPanel::setToolWidget ( QWidget * weight ) function show # void UtilityPanel::show () function toolWidget # QWidget * UtilityPanel::toolWidget () const","title":"Class UtilityPanel"},{"location":"flameshot/classUtilityPanel/#class-utilitypanel","text":"ClassList > UtilityPanel Inherits the following classes: QWidget","title":"Class UtilityPanel"},{"location":"flameshot/classUtilityPanel/#public-functions","text":"Type Name UtilityPanel ( CaptureWidget * captureWidget) int activeLayerIndex () void clearToolWidget () void fillCaptureTools (const QList< QPointer< CaptureTool >> & captureToolObjectsHistory) void hide () bool isVisible () const void pushWidget (QWidget * widget) void setActiveLayer (int index) void setToolWidget (QWidget * weight) void show () QWidget * toolWidget () const","title":"Public Functions"},{"location":"flameshot/classUtilityPanel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classUtilityPanel/#function-utilitypanel","text":"explicit UtilityPanel::UtilityPanel ( CaptureWidget * captureWidget )","title":"function UtilityPanel"},{"location":"flameshot/classUtilityPanel/#function-activelayerindex","text":"int UtilityPanel::activeLayerIndex ()","title":"function activeLayerIndex"},{"location":"flameshot/classUtilityPanel/#function-cleartoolwidget","text":"void UtilityPanel::clearToolWidget ()","title":"function clearToolWidget"},{"location":"flameshot/classUtilityPanel/#function-fillcapturetools","text":"void UtilityPanel::fillCaptureTools ( const QList< QPointer< CaptureTool >> & captureToolObjectsHistory )","title":"function fillCaptureTools"},{"location":"flameshot/classUtilityPanel/#function-hide","text":"void UtilityPanel::hide ()","title":"function hide"},{"location":"flameshot/classUtilityPanel/#function-isvisible","text":"bool UtilityPanel::isVisible () const","title":"function isVisible"},{"location":"flameshot/classUtilityPanel/#function-pushwidget","text":"void UtilityPanel::pushWidget ( QWidget * widget )","title":"function pushWidget"},{"location":"flameshot/classUtilityPanel/#function-setactivelayer","text":"void UtilityPanel::setActiveLayer ( int index )","title":"function setActiveLayer"},{"location":"flameshot/classUtilityPanel/#function-settoolwidget","text":"void UtilityPanel::setToolWidget ( QWidget * weight )","title":"function setToolWidget"},{"location":"flameshot/classUtilityPanel/#function-show","text":"void UtilityPanel::show ()","title":"function show"},{"location":"flameshot/classUtilityPanel/#function-toolwidget","text":"QWidget * UtilityPanel::toolWidget () const","title":"function toolWidget"},{"location":"flameshot/classValueHandler/","text":"Class ValueHandler # ClassList > ValueHandler Handles the value of a configuration option (abstract class). More... #include <valuehandler.h> Inherited by the following classes: Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors Public Functions # Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use. Protected Functions # Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant . Detailed Description # Each configuration option is represented as a QVariant . If the option was not specified in a config file, the QVariant will be invalid. Each option will usually be handled in three different ways: * have its value checked for semantic errors (type, format, etc). See also: ValueHandler::check have its value (that was taken from the config file) adapted for proper use. See also: ValueHandler::value provided a fallback value in case: the config does not explicitly specify it, or the config contains an error and is globally falling back to defaults. See also: ValueHandler::fallback . some options may want to be stored in the config file in a different way than the default one provided by QVariant . See also: ValueHandler::representation Note: Please see the documentation of the functions to learn when you should override each. Public Functions Documentation # function check # Check the value semantically. virtual bool ValueHandler::check ( const QVariant & val ) = 0 Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true. function expected # virtual QString ValueHandler::expected () function fallback # virtual QVariant ValueHandler::fallback () function representation # Return the representation of the value in the config file. virtual QVariant ValueHandler::representation ( const QVariant & val ) Override this if you want to write the value in a different format than the one provided by QVariant . function value # Adapt the value for proper use. QVariant ValueHandler::value ( const QVariant & val ) Parameters: val The value that was read from the config file Returns: The modified value If the value is invalid (unspecified in the config) or does not pass check , the fallback will be returned. Otherwise the value is processed by process and then returned. Note: Cannot be overridden See also: fallback , process Protected Functions Documentation # function process # Process a value, presuming it is a valid QVariant . virtual QVariant ValueHandler::process ( const QVariant & val ) Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value .","title":"Class ValueHandler"},{"location":"flameshot/classValueHandler/#class-valuehandler","text":"ClassList > ValueHandler Handles the value of a configuration option (abstract class). More... #include <valuehandler.h> Inherited by the following classes: Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors","title":"Class ValueHandler"},{"location":"flameshot/classValueHandler/#public-functions","text":"Type Name virtual bool check (const QVariant & val) = 0 Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant & val) Return the representation of the value in the config file. QVariant value (const QVariant & val) Adapt the value for proper use.","title":"Public Functions"},{"location":"flameshot/classValueHandler/#protected-functions","text":"Type Name virtual QVariant process (const QVariant & val) Process a value, presuming it is a valid QVariant .","title":"Protected Functions"},{"location":"flameshot/classValueHandler/#detailed-description","text":"Each configuration option is represented as a QVariant . If the option was not specified in a config file, the QVariant will be invalid. Each option will usually be handled in three different ways: * have its value checked for semantic errors (type, format, etc). See also: ValueHandler::check have its value (that was taken from the config file) adapted for proper use. See also: ValueHandler::value provided a fallback value in case: the config does not explicitly specify it, or the config contains an error and is globally falling back to defaults. See also: ValueHandler::fallback . some options may want to be stored in the config file in a different way than the default one provided by QVariant . See also: ValueHandler::representation Note: Please see the documentation of the functions to learn when you should override each.","title":"Detailed Description"},{"location":"flameshot/classValueHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classValueHandler/#function-check","text":"Check the value semantically. virtual bool ValueHandler::check ( const QVariant & val ) = 0 Parameters: val The value that was read from the config file Returns: Whether the value is correct Note: The function should presume that val.isValid() is true.","title":"function check"},{"location":"flameshot/classValueHandler/#function-expected","text":"virtual QString ValueHandler::expected ()","title":"function expected"},{"location":"flameshot/classValueHandler/#function-fallback","text":"virtual QVariant ValueHandler::fallback ()","title":"function fallback"},{"location":"flameshot/classValueHandler/#function-representation","text":"Return the representation of the value in the config file. virtual QVariant ValueHandler::representation ( const QVariant & val ) Override this if you want to write the value in a different format than the one provided by QVariant .","title":"function representation"},{"location":"flameshot/classValueHandler/#function-value","text":"Adapt the value for proper use. QVariant ValueHandler::value ( const QVariant & val ) Parameters: val The value that was read from the config file Returns: The modified value If the value is invalid (unspecified in the config) or does not pass check , the fallback will be returned. Otherwise the value is processed by process and then returned. Note: Cannot be overridden See also: fallback , process","title":"function value"},{"location":"flameshot/classValueHandler/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"flameshot/classValueHandler/#function-process","text":"Process a value, presuming it is a valid QVariant . virtual QVariant ValueHandler::process ( const QVariant & val ) Parameters: val The value that was read from the config file Returns: The processed value Note: You will usually want to override this. In rare cases, you may want to override value .","title":"function process"},{"location":"flameshot/classVisualsEditor/","text":"Class VisualsEditor # ClassList > VisualsEditor Inherits the following classes: QWidget Public Functions # Type Name VisualsEditor (QWidget * parent=nullptr) Public Functions Documentation # function VisualsEditor # explicit VisualsEditor::VisualsEditor ( QWidget * parent=nullptr )","title":"Class VisualsEditor"},{"location":"flameshot/classVisualsEditor/#class-visualseditor","text":"ClassList > VisualsEditor Inherits the following classes: QWidget","title":"Class VisualsEditor"},{"location":"flameshot/classVisualsEditor/#public-functions","text":"Type Name VisualsEditor (QWidget * parent=nullptr)","title":"Public Functions"},{"location":"flameshot/classVisualsEditor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classVisualsEditor/#function-visualseditor","text":"explicit VisualsEditor::VisualsEditor ( QWidget * parent=nullptr )","title":"function VisualsEditor"},{"location":"flameshot/classWaylandUtils/","text":"Class WaylandUtils # ClassList > WaylandUtils Public Functions # Type Name WaylandUtils () Public Static Functions # Type Name bool waylandDetected () Public Functions Documentation # function WaylandUtils # WaylandUtils::WaylandUtils () Public Static Functions Documentation # function waylandDetected # static bool WaylandUtils::waylandDetected ()","title":"Class WaylandUtils"},{"location":"flameshot/classWaylandUtils/#class-waylandutils","text":"ClassList > WaylandUtils","title":"Class WaylandUtils"},{"location":"flameshot/classWaylandUtils/#public-functions","text":"Type Name WaylandUtils ()","title":"Public Functions"},{"location":"flameshot/classWaylandUtils/#public-static-functions","text":"Type Name bool waylandDetected ()","title":"Public Static Functions"},{"location":"flameshot/classWaylandUtils/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/classWaylandUtils/#function-waylandutils","text":"WaylandUtils::WaylandUtils ()","title":"function WaylandUtils"},{"location":"flameshot/classWaylandUtils/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"flameshot/classWaylandUtils/#function-waylanddetected","text":"static bool WaylandUtils::waylandDetected ()","title":"function waylandDetected"},{"location":"flameshot/structWinLnkFileParser/","text":"Struct WinLnkFileParser # ClassList > WinLnkFileParser Public Functions # Type Name WinLnkFileParser () QString getAllUsersStartMenuPath () QVector< DesktopAppData > getAppsByCategory (const QString & category) QMap< QString, QVector< DesktopAppData > > getAppsByCategory (const QStringList & categories) DesktopAppData parseLnkFile (const QFileInfo & fiLnk, bool & ok) const int processDirectory (const QDir & dir) Public Functions Documentation # function WinLnkFileParser # WinLnkFileParser::WinLnkFileParser () function getAllUsersStartMenuPath # QString WinLnkFileParser::getAllUsersStartMenuPath () function getAppsByCategory [1/2] # QVector< DesktopAppData > WinLnkFileParser::getAppsByCategory ( const QString & category ) function getAppsByCategory [2/2] # QMap< QString, QVector< DesktopAppData > > WinLnkFileParser::getAppsByCategory ( const QStringList & categories ) function parseLnkFile # DesktopAppData WinLnkFileParser::parseLnkFile ( const QFileInfo & fiLnk, bool & ok ) const function processDirectory # int WinLnkFileParser::processDirectory ( const QDir & dir )","title":"Struct WinLnkFileParser"},{"location":"flameshot/structWinLnkFileParser/#struct-winlnkfileparser","text":"ClassList > WinLnkFileParser","title":"Struct WinLnkFileParser"},{"location":"flameshot/structWinLnkFileParser/#public-functions","text":"Type Name WinLnkFileParser () QString getAllUsersStartMenuPath () QVector< DesktopAppData > getAppsByCategory (const QString & category) QMap< QString, QVector< DesktopAppData > > getAppsByCategory (const QStringList & categories) DesktopAppData parseLnkFile (const QFileInfo & fiLnk, bool & ok) const int processDirectory (const QDir & dir)","title":"Public Functions"},{"location":"flameshot/structWinLnkFileParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/structWinLnkFileParser/#function-winlnkfileparser","text":"WinLnkFileParser::WinLnkFileParser ()","title":"function WinLnkFileParser"},{"location":"flameshot/structWinLnkFileParser/#function-getallusersstartmenupath","text":"QString WinLnkFileParser::getAllUsersStartMenuPath ()","title":"function getAllUsersStartMenuPath"},{"location":"flameshot/structWinLnkFileParser/#function-getappsbycategory-12","text":"QVector< DesktopAppData > WinLnkFileParser::getAppsByCategory ( const QString & category )","title":"function getAppsByCategory [1/2]"},{"location":"flameshot/structWinLnkFileParser/#function-getappsbycategory-22","text":"QMap< QString, QVector< DesktopAppData > > WinLnkFileParser::getAppsByCategory ( const QStringList & categories )","title":"function getAppsByCategory [2/2]"},{"location":"flameshot/structWinLnkFileParser/#function-parselnkfile","text":"DesktopAppData WinLnkFileParser::parseLnkFile ( const QFileInfo & fiLnk, bool & ok ) const","title":"function parseLnkFile"},{"location":"flameshot/structWinLnkFileParser/#function-processdirectory","text":"int WinLnkFileParser::processDirectory ( const QDir & dir )","title":"function processDirectory"},{"location":"flameshot/namespaceorg/","text":"Namespace org # Namespace List > org Namespaces # Type Name namespace freedesktop","title":"Namespace org"},{"location":"flameshot/namespaceorg/#namespace-org","text":"Namespace List > org","title":"Namespace org"},{"location":"flameshot/namespaceorg/#namespaces","text":"Type Name namespace freedesktop","title":"Namespaces"},{"location":"flameshot/namespaceorg_1_1freedesktop/","text":"Namespace org::freedesktop # Namespace List > org > freedesktop Namespaces # Type Name namespace portal","title":"Namespace org::freedesktop"},{"location":"flameshot/namespaceorg_1_1freedesktop/#namespace-orgfreedesktop","text":"Namespace List > org > freedesktop","title":"Namespace org::freedesktop"},{"location":"flameshot/namespaceorg_1_1freedesktop/#namespaces","text":"Type Name namespace portal","title":"Namespaces"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/","text":"Namespace org::freedesktop::portal # Namespace List > org > freedesktop > portal Public Types # Type Name typedef :: OrgFreedesktopPortalRequestInterface Request Public Types Documentation # typedef Request # typedef ::OrgFreedesktopPortalRequestInterface org::freedesktop::portal::Request;","title":"Namespace org::freedesktop::portal"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#namespace-orgfreedesktopportal","text":"Namespace List > org > freedesktop > portal","title":"Namespace org::freedesktop::portal"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#public-types","text":"Type Name typedef :: OrgFreedesktopPortalRequestInterface Request","title":"Public Types"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#typedef-request","text":"typedef ::OrgFreedesktopPortalRequestInterface org::freedesktop::portal::Request;","title":"typedef Request"},{"location":"flameshot/namespacestrfparse/","text":"Namespace strfparse # Namespace List > strfparse Public Functions # Type Name std::vector< char > create_specifier_list () std::string format_time_string (std::string const & specifier) std::vector< char > match_specifiers (std::string const & specifier, std::vector< char > allowed_specifier) std::string replace_all (std::string input, std::string const & to_find, std::string const & to_replace) std::vector< std::string > split (std::string const & s, char delimiter) Public Functions Documentation # function create_specifier_list # std::vector< char > strfparse::create_specifier_list () function format_time_string # std::string strfparse::format_time_string ( std::string const & specifier ) function match_specifiers # std::vector< char > strfparse::match_specifiers ( std::string const & specifier, std::vector< char > allowed_specifier ) function replace_all # std::string strfparse::replace_all ( std::string input, std::string const & to_find, std::string const & to_replace ) function split # std::vector< std::string > strfparse::split ( std::string const & s, char delimiter )","title":"Namespace strfparse"},{"location":"flameshot/namespacestrfparse/#namespace-strfparse","text":"Namespace List > strfparse","title":"Namespace strfparse"},{"location":"flameshot/namespacestrfparse/#public-functions","text":"Type Name std::vector< char > create_specifier_list () std::string format_time_string (std::string const & specifier) std::vector< char > match_specifiers (std::string const & specifier, std::vector< char > allowed_specifier) std::string replace_all (std::string input, std::string const & to_find, std::string const & to_replace) std::vector< std::string > split (std::string const & s, char delimiter)","title":"Public Functions"},{"location":"flameshot/namespacestrfparse/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/namespacestrfparse/#function-create_specifier_list","text":"std::vector< char > strfparse::create_specifier_list ()","title":"function create_specifier_list"},{"location":"flameshot/namespacestrfparse/#function-format_time_string","text":"std::string strfparse::format_time_string ( std::string const & specifier )","title":"function format_time_string"},{"location":"flameshot/namespacestrfparse/#function-match_specifiers","text":"std::vector< char > strfparse::match_specifiers ( std::string const & specifier, std::vector< char > allowed_specifier )","title":"function match_specifiers"},{"location":"flameshot/namespacestrfparse/#function-replace_all","text":"std::string strfparse::replace_all ( std::string input, std::string const & to_find, std::string const & to_replace )","title":"function replace_all"},{"location":"flameshot/namespacestrfparse/#function-split","text":"std::vector< std::string > strfparse::split ( std::string const & s, char delimiter )","title":"function split"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src # FileList > src Files # Type Name file main.cpp Directories # Type Name dir cli dir config dir core dir tools dir utils dir widgets","title":"Dir src"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"FileList > src","title":"Dir src"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file main.cpp","title":"Files"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Type Name dir cli dir config dir core dir tools dir utils dir widgets","title":"Directories"},{"location":"flameshot/dir_b78fdfbbb632ce54d070469d6a721373/","text":"Dir cli # FileList > cli Files # Type Name file commandargument.cpp file commandargument.h file commandlineparser.cpp file commandlineparser.h file commandoption.cpp file commandoption.h","title":"Dir cli"},{"location":"flameshot/dir_b78fdfbbb632ce54d070469d6a721373/#dir-cli","text":"FileList > cli","title":"Dir cli"},{"location":"flameshot/dir_b78fdfbbb632ce54d070469d6a721373/#files","text":"Type Name file commandargument.cpp file commandargument.h file commandlineparser.cpp file commandlineparser.h file commandoption.cpp file commandoption.h","title":"Files"},{"location":"flameshot/commandargument_8cpp/","text":"File commandargument.cpp # FileList > cli > commandargument.cpp Go to the source code of this file. #include \"commandargument.h\" #include <utility>","title":"File commandargument.cpp"},{"location":"flameshot/commandargument_8cpp/#file-commandargumentcpp","text":"FileList > cli > commandargument.cpp Go to the source code of this file. #include \"commandargument.h\" #include <utility>","title":"File commandargument.cpp"},{"location":"flameshot/commandargument_8cpp_source/","text":"File commandargument.cpp # File List > cli > commandargument.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandargument.h\" #include <utility> CommandArgument::CommandArgument() = default; CommandArgument::CommandArgument(QString name, QString description) : m_name(std::move(name)) , m_description(std::move(description)) {} void CommandArgument::setName(const QString& name) { m_name = name; } QString CommandArgument::name() const { return m_name; } void CommandArgument::setDescription(const QString& description) { m_description = description; } QString CommandArgument::description() const { return m_description; } bool CommandArgument::isRoot() const { return m_name.isEmpty() && m_description.isEmpty(); } bool CommandArgument::operator==(const CommandArgument& arg) const { return m_description == arg.m_description && m_name == arg.m_name; }","title":"File commandargument.cpp"},{"location":"flameshot/commandargument_8cpp_source/#file-commandargumentcpp","text":"File List > cli > commandargument.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandargument.h\" #include <utility> CommandArgument::CommandArgument() = default; CommandArgument::CommandArgument(QString name, QString description) : m_name(std::move(name)) , m_description(std::move(description)) {} void CommandArgument::setName(const QString& name) { m_name = name; } QString CommandArgument::name() const { return m_name; } void CommandArgument::setDescription(const QString& description) { m_description = description; } QString CommandArgument::description() const { return m_description; } bool CommandArgument::isRoot() const { return m_name.isEmpty() && m_description.isEmpty(); } bool CommandArgument::operator==(const CommandArgument& arg) const { return m_description == arg.m_description && m_name == arg.m_name; }","title":"File commandargument.cpp"},{"location":"flameshot/commandargument_8h/","text":"File commandargument.h # FileList > cli > commandargument.h Go to the source code of this file. #include <QString> Classes # Type Name class CommandArgument","title":"File commandargument.h"},{"location":"flameshot/commandargument_8h/#file-commandargumenth","text":"FileList > cli > commandargument.h Go to the source code of this file. #include <QString>","title":"File commandargument.h"},{"location":"flameshot/commandargument_8h/#classes","text":"Type Name class CommandArgument","title":"Classes"},{"location":"flameshot/commandargument_8h_source/","text":"File commandargument.h # File List > cli > commandargument.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class CommandArgument { public: CommandArgument(); explicit CommandArgument(QString name, QString description); void setName(const QString& name); QString name() const; void setDescription(const QString& description); QString description() const; bool isRoot() const; bool operator==(const CommandArgument& arg) const; private: QString m_name; QString m_description; };","title":"File commandargument.h"},{"location":"flameshot/commandargument_8h_source/#file-commandargumenth","text":"File List > cli > commandargument.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class CommandArgument { public: CommandArgument(); explicit CommandArgument(QString name, QString description); void setName(const QString& name); QString name() const; void setDescription(const QString& description); QString description() const; bool isRoot() const; bool operator==(const CommandArgument& arg) const; private: QString m_name; QString m_description; };","title":"File commandargument.h"},{"location":"flameshot/commandlineparser_8cpp/","text":"File commandlineparser.cpp # FileList > cli > commandlineparser.cpp Go to the source code of this file. #include \"commandlineparser.h\" #include \"abstractlogger.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QTextStream>","title":"File commandlineparser.cpp"},{"location":"flameshot/commandlineparser_8cpp/#file-commandlineparsercpp","text":"FileList > cli > commandlineparser.cpp Go to the source code of this file. #include \"commandlineparser.h\" #include \"abstractlogger.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QTextStream>","title":"File commandlineparser.cpp"},{"location":"flameshot/commandlineparser_8cpp_source/","text":"File commandlineparser.cpp # File List > cli > commandlineparser.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandlineparser.h\" #include \"abstractlogger.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QTextStream> CommandLineParser::CommandLineParser() : m_description(qApp->applicationName()) {} namespace { AbstractLogger out = AbstractLogger::info(AbstractLogger::Stdout).enableMessageHeader(false); AbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr); auto versionOption = CommandOption({ \"v\", \"version\" }, QStringLiteral(\"Displays version information\")); auto helpOption = CommandOption({ \"h\", \"help\" }, QStringLiteral(\"Displays this help\")); QString optionsToString(const QList<CommandOption>& options, const QList<CommandArgument>& arguments) { int size = 0; // track the largest size QStringList dashedOptionList; // save the dashed options and its size in order to print the description // of every option at the same horizontal character position. for (auto const& option : options) { QStringList dashedOptions = option.dashedNames(); QString joinedDashedOptions = dashedOptions.join(QStringLiteral(\", \")); if (!option.valueName().isEmpty()) { joinedDashedOptions += QStringLiteral(\" <%1>\").arg(option.valueName()); } if (joinedDashedOptions.length() > size) { size = joinedDashedOptions.length(); } dashedOptionList << joinedDashedOptions; } // check the length of the arguments for (auto const& arg : arguments) { if (arg.name().length() > size) { size = arg.name().length(); } } // generate the text QString result; if (!dashedOptionList.isEmpty()) { result += QObject::tr(\"Options\") + \":\\n\"; QString linePadding = QStringLiteral(\" \").repeated(size + 4).prepend(\"\\n\"); for (int i = 0; i < options.length(); ++i) { result += QStringLiteral(\" %1 %2\\n\") .arg(dashedOptionList.at(i).leftJustified(size, ' ')) .arg(options.at(i).description().replace( QLatin1String(\"\\n\"), linePadding)); } if (!arguments.isEmpty()) { result += QLatin1String(\"\\n\"); } } if (!arguments.isEmpty()) { result += QObject::tr(\"Arguments\") + \":\\n\"; } for (const auto& argument : arguments) { result += QStringLiteral(\" %1 %2\\n\") .arg(argument.name().leftJustified(size, ' ')) .arg(argument.description()); } return result; } } // unnamed namespace bool CommandLineParser::processArgs(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode) { QString argument = *actualIt; bool ok = true; bool isValidArg = false; for (Node& n : actualNode->subNodes) { if (n.argument.name() == argument) { actualNode = &n; isValidArg = true; break; } } if (isValidArg) { auto nextArg = actualNode->argument; m_foundArgs.append(nextArg); // check next is help ++actualIt; ok = processIfOptionIsHelp(args, actualIt, actualNode); --actualIt; } else { ok = false; err << QStringLiteral(\"'%1' is not a valid argument.\").arg(argument); } return ok; } bool CommandLineParser::processOptions(const QStringList& args, QStringList::const_iterator& actualIt, Node* const actualNode) { QString arg = *actualIt; bool ok = true; // track values int equalsPos = arg.indexOf(QLatin1String(\"=\")); QString valueStr; if (equalsPos != -1) { valueStr = arg.mid(equalsPos + 1); // right arg = arg.mid(0, equalsPos); // left } // check format -x --xx... bool isDoubleDashed = arg.startsWith(QLatin1String(\"--\")); ok = isDoubleDashed ? arg.length() > 3 : arg.length() == 2; if (!ok) { err << QStringLiteral(\"the option %1 has a wrong format.\").arg(arg); return ok; } arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1); // get option auto endIt = actualNode->options.cend(); auto optionIt = endIt; for (auto i = actualNode->options.cbegin(); i != endIt; ++i) { if ((*i).names().contains(arg)) { optionIt = i; break; } } if (optionIt == endIt) { QString argName = actualNode->argument.name(); if (argName.isEmpty()) { argName = qApp->applicationName(); } err << QStringLiteral(\"the option '%1' is not a valid option \" \"for the argument '%2'.\") .arg(arg) .arg(argName); ok = false; return ok; } // check presence of values CommandOption option = *optionIt; bool requiresValue = !(option.valueName().isEmpty()); if (!requiresValue && equalsPos != -1) { err << QStringLiteral(\"the option '%1' contains a '=' and it doesn't \" \"require a value.\") .arg(arg); ok = false; return ok; } else if (requiresValue && valueStr.isEmpty()) { // find in the next if (actualIt + 1 != args.cend()) { ++actualIt; } else { err << QStringLiteral(\"Expected value after the option '%1'.\") .arg(arg); ok = false; return ok; } valueStr = *actualIt; } // check the value correctness if (requiresValue) { ok = option.checkValue(valueStr); if (!ok) { QString msg = option.errorMsg(); if (!msg.endsWith(QLatin1String(\".\"))) { msg += QLatin1String(\".\"); } err << msg; return ok; } option.setValue(valueStr); } m_foundOptions.append(option); return ok; } bool CommandLineParser::parse(const QStringList& args) { m_foundArgs.clear(); m_foundOptions.clear(); bool ok = true; Node* actualNode = &m_parseTree; auto it = ++args.cbegin(); // check version option QStringList dashedVersion = versionOption.dashedNames(); if (m_withVersion && args.length() > 1 && dashedVersion.contains(args.at(1))) { if (args.length() == 2) { printVersion(); m_foundOptions << versionOption; } else { err << \"Invalid arguments after the version option.\"; ok = false; } return ok; } // check help option ok = processIfOptionIsHelp(args, it, actualNode); // process the other args for (; it != args.cend() && ok; ++it) { const QString& value = *it; if (value.startsWith(QLatin1String(\"-\"))) { ok = processOptions(args, it, actualNode); } else { ok = processArgs(args, it, actualNode); } } if (!ok && !m_generalErrorMessage.isEmpty()) { err.enableMessageHeader(false); err << m_generalErrorMessage; err.enableMessageHeader(true); } return ok; } CommandOption CommandLineParser::addVersionOption() { m_withVersion = true; return versionOption; } CommandOption CommandLineParser::addHelpOption() { m_withHelp = true; return helpOption; } bool CommandLineParser::AddArgument(const CommandArgument& arg, const CommandArgument& parent) { bool res = true; Node* n = findParent(parent); if (n == nullptr) { res = false; } else { Node child; child.argument = arg; n->subNodes.append(child); } return res; } bool CommandLineParser::AddOption(const CommandOption& option, const CommandArgument& parent) { bool res = true; Node* n = findParent(parent); if (n == nullptr) { res = false; } else { n->options.append(option); } return res; } bool CommandLineParser::AddOptions(const QList<CommandOption>& options, const CommandArgument& parent) { bool res = true; for (auto const& option : options) { if (!AddOption(option, parent)) { res = false; break; } } return res; } void CommandLineParser::setGeneralErrorMessage(const QString& msg) { m_generalErrorMessage = msg; } void CommandLineParser::setDescription(const QString& description) { m_description = description; } bool CommandLineParser::isSet(const CommandArgument& arg) const { return m_foundArgs.contains(arg); } bool CommandLineParser::isSet(const CommandOption& option) const { return m_foundOptions.contains(option); } QString CommandLineParser::value(const CommandOption& option) const { QString value = option.value(); for (const CommandOption& fOption : m_foundOptions) { if (option == fOption) { value = fOption.value(); break; } } return value; } void CommandLineParser::printVersion() { out << GlobalValues::versionInfo(); } void CommandLineParser::printHelp(QStringList args, const Node* node) { args.removeLast(); // remove the help, it's always the last QString helpText; // add usage info QString argName = node->argument.name(); if (argName.isEmpty()) { argName = qApp->applicationName(); } QString argText = node->subNodes.isEmpty() ? \"\" : \"[\" + QObject::tr(\"arguments\") + \"]\"; helpText += (QObject::tr(\"Usage\") + \": %1 [%2-\" + QObject::tr(\"options\") + QStringLiteral(\"] %3\\n\\n\")) .arg(args.join(QStringLiteral(\" \"))) .arg(argName) .arg(argText); // short section about default behavior helpText += QObject::tr(\"Per default runs Flameshot in the background and \" \"adds a tray icon for configuration.\"); helpText += \"\\n\\n\"; // add command options and subarguments QList<CommandArgument> subArgs; for (const Node& n : node->subNodes) { subArgs.append(n.argument); } auto modifiedOptions = node->options; if (m_withHelp) { modifiedOptions << helpOption; } if (m_withVersion && node == &m_parseTree) { modifiedOptions << versionOption; } helpText += optionsToString(modifiedOptions, subArgs); // print it out << helpText; } CommandLineParser::Node* CommandLineParser::findParent( const CommandArgument& parent) { if (parent == CommandArgument()) { return &m_parseTree; } // find the parent in the subNodes recursively Node* res = nullptr; for (auto& subNode : m_parseTree.subNodes) { res = recursiveParentSearch(parent, subNode); if (res != nullptr) { break; } } return res; } CommandLineParser::Node* CommandLineParser::recursiveParentSearch( const CommandArgument& parent, Node& node) const { Node* res = nullptr; if (node.argument == parent) { res = &node; } else { for (auto& subNode : node.subNodes) { res = recursiveParentSearch(parent, subNode); if (res != nullptr) { break; } } } return res; } bool CommandLineParser::processIfOptionIsHelp( const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode) { bool ok = true; auto dashedHelpNames = helpOption.dashedNames(); if (m_withHelp && actualIt != args.cend() && dashedHelpNames.contains(*actualIt)) { if (actualIt + 1 == args.cend()) { m_foundOptions << helpOption; printHelp(args, actualNode); actualIt++; } else { err << \"Invalid arguments after the help option.\"; ok = false; } } return ok; }","title":"File commandlineparser.cpp"},{"location":"flameshot/commandlineparser_8cpp_source/#file-commandlineparsercpp","text":"File List > cli > commandlineparser.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandlineparser.h\" #include \"abstractlogger.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QTextStream> CommandLineParser::CommandLineParser() : m_description(qApp->applicationName()) {} namespace { AbstractLogger out = AbstractLogger::info(AbstractLogger::Stdout).enableMessageHeader(false); AbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr); auto versionOption = CommandOption({ \"v\", \"version\" }, QStringLiteral(\"Displays version information\")); auto helpOption = CommandOption({ \"h\", \"help\" }, QStringLiteral(\"Displays this help\")); QString optionsToString(const QList<CommandOption>& options, const QList<CommandArgument>& arguments) { int size = 0; // track the largest size QStringList dashedOptionList; // save the dashed options and its size in order to print the description // of every option at the same horizontal character position. for (auto const& option : options) { QStringList dashedOptions = option.dashedNames(); QString joinedDashedOptions = dashedOptions.join(QStringLiteral(\", \")); if (!option.valueName().isEmpty()) { joinedDashedOptions += QStringLiteral(\" <%1>\").arg(option.valueName()); } if (joinedDashedOptions.length() > size) { size = joinedDashedOptions.length(); } dashedOptionList << joinedDashedOptions; } // check the length of the arguments for (auto const& arg : arguments) { if (arg.name().length() > size) { size = arg.name().length(); } } // generate the text QString result; if (!dashedOptionList.isEmpty()) { result += QObject::tr(\"Options\") + \":\\n\"; QString linePadding = QStringLiteral(\" \").repeated(size + 4).prepend(\"\\n\"); for (int i = 0; i < options.length(); ++i) { result += QStringLiteral(\" %1 %2\\n\") .arg(dashedOptionList.at(i).leftJustified(size, ' ')) .arg(options.at(i).description().replace( QLatin1String(\"\\n\"), linePadding)); } if (!arguments.isEmpty()) { result += QLatin1String(\"\\n\"); } } if (!arguments.isEmpty()) { result += QObject::tr(\"Arguments\") + \":\\n\"; } for (const auto& argument : arguments) { result += QStringLiteral(\" %1 %2\\n\") .arg(argument.name().leftJustified(size, ' ')) .arg(argument.description()); } return result; } } // unnamed namespace bool CommandLineParser::processArgs(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode) { QString argument = *actualIt; bool ok = true; bool isValidArg = false; for (Node& n : actualNode->subNodes) { if (n.argument.name() == argument) { actualNode = &n; isValidArg = true; break; } } if (isValidArg) { auto nextArg = actualNode->argument; m_foundArgs.append(nextArg); // check next is help ++actualIt; ok = processIfOptionIsHelp(args, actualIt, actualNode); --actualIt; } else { ok = false; err << QStringLiteral(\"'%1' is not a valid argument.\").arg(argument); } return ok; } bool CommandLineParser::processOptions(const QStringList& args, QStringList::const_iterator& actualIt, Node* const actualNode) { QString arg = *actualIt; bool ok = true; // track values int equalsPos = arg.indexOf(QLatin1String(\"=\")); QString valueStr; if (equalsPos != -1) { valueStr = arg.mid(equalsPos + 1); // right arg = arg.mid(0, equalsPos); // left } // check format -x --xx... bool isDoubleDashed = arg.startsWith(QLatin1String(\"--\")); ok = isDoubleDashed ? arg.length() > 3 : arg.length() == 2; if (!ok) { err << QStringLiteral(\"the option %1 has a wrong format.\").arg(arg); return ok; } arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1); // get option auto endIt = actualNode->options.cend(); auto optionIt = endIt; for (auto i = actualNode->options.cbegin(); i != endIt; ++i) { if ((*i).names().contains(arg)) { optionIt = i; break; } } if (optionIt == endIt) { QString argName = actualNode->argument.name(); if (argName.isEmpty()) { argName = qApp->applicationName(); } err << QStringLiteral(\"the option '%1' is not a valid option \" \"for the argument '%2'.\") .arg(arg) .arg(argName); ok = false; return ok; } // check presence of values CommandOption option = *optionIt; bool requiresValue = !(option.valueName().isEmpty()); if (!requiresValue && equalsPos != -1) { err << QStringLiteral(\"the option '%1' contains a '=' and it doesn't \" \"require a value.\") .arg(arg); ok = false; return ok; } else if (requiresValue && valueStr.isEmpty()) { // find in the next if (actualIt + 1 != args.cend()) { ++actualIt; } else { err << QStringLiteral(\"Expected value after the option '%1'.\") .arg(arg); ok = false; return ok; } valueStr = *actualIt; } // check the value correctness if (requiresValue) { ok = option.checkValue(valueStr); if (!ok) { QString msg = option.errorMsg(); if (!msg.endsWith(QLatin1String(\".\"))) { msg += QLatin1String(\".\"); } err << msg; return ok; } option.setValue(valueStr); } m_foundOptions.append(option); return ok; } bool CommandLineParser::parse(const QStringList& args) { m_foundArgs.clear(); m_foundOptions.clear(); bool ok = true; Node* actualNode = &m_parseTree; auto it = ++args.cbegin(); // check version option QStringList dashedVersion = versionOption.dashedNames(); if (m_withVersion && args.length() > 1 && dashedVersion.contains(args.at(1))) { if (args.length() == 2) { printVersion(); m_foundOptions << versionOption; } else { err << \"Invalid arguments after the version option.\"; ok = false; } return ok; } // check help option ok = processIfOptionIsHelp(args, it, actualNode); // process the other args for (; it != args.cend() && ok; ++it) { const QString& value = *it; if (value.startsWith(QLatin1String(\"-\"))) { ok = processOptions(args, it, actualNode); } else { ok = processArgs(args, it, actualNode); } } if (!ok && !m_generalErrorMessage.isEmpty()) { err.enableMessageHeader(false); err << m_generalErrorMessage; err.enableMessageHeader(true); } return ok; } CommandOption CommandLineParser::addVersionOption() { m_withVersion = true; return versionOption; } CommandOption CommandLineParser::addHelpOption() { m_withHelp = true; return helpOption; } bool CommandLineParser::AddArgument(const CommandArgument& arg, const CommandArgument& parent) { bool res = true; Node* n = findParent(parent); if (n == nullptr) { res = false; } else { Node child; child.argument = arg; n->subNodes.append(child); } return res; } bool CommandLineParser::AddOption(const CommandOption& option, const CommandArgument& parent) { bool res = true; Node* n = findParent(parent); if (n == nullptr) { res = false; } else { n->options.append(option); } return res; } bool CommandLineParser::AddOptions(const QList<CommandOption>& options, const CommandArgument& parent) { bool res = true; for (auto const& option : options) { if (!AddOption(option, parent)) { res = false; break; } } return res; } void CommandLineParser::setGeneralErrorMessage(const QString& msg) { m_generalErrorMessage = msg; } void CommandLineParser::setDescription(const QString& description) { m_description = description; } bool CommandLineParser::isSet(const CommandArgument& arg) const { return m_foundArgs.contains(arg); } bool CommandLineParser::isSet(const CommandOption& option) const { return m_foundOptions.contains(option); } QString CommandLineParser::value(const CommandOption& option) const { QString value = option.value(); for (const CommandOption& fOption : m_foundOptions) { if (option == fOption) { value = fOption.value(); break; } } return value; } void CommandLineParser::printVersion() { out << GlobalValues::versionInfo(); } void CommandLineParser::printHelp(QStringList args, const Node* node) { args.removeLast(); // remove the help, it's always the last QString helpText; // add usage info QString argName = node->argument.name(); if (argName.isEmpty()) { argName = qApp->applicationName(); } QString argText = node->subNodes.isEmpty() ? \"\" : \"[\" + QObject::tr(\"arguments\") + \"]\"; helpText += (QObject::tr(\"Usage\") + \": %1 [%2-\" + QObject::tr(\"options\") + QStringLiteral(\"] %3\\n\\n\")) .arg(args.join(QStringLiteral(\" \"))) .arg(argName) .arg(argText); // short section about default behavior helpText += QObject::tr(\"Per default runs Flameshot in the background and \" \"adds a tray icon for configuration.\"); helpText += \"\\n\\n\"; // add command options and subarguments QList<CommandArgument> subArgs; for (const Node& n : node->subNodes) { subArgs.append(n.argument); } auto modifiedOptions = node->options; if (m_withHelp) { modifiedOptions << helpOption; } if (m_withVersion && node == &m_parseTree) { modifiedOptions << versionOption; } helpText += optionsToString(modifiedOptions, subArgs); // print it out << helpText; } CommandLineParser::Node* CommandLineParser::findParent( const CommandArgument& parent) { if (parent == CommandArgument()) { return &m_parseTree; } // find the parent in the subNodes recursively Node* res = nullptr; for (auto& subNode : m_parseTree.subNodes) { res = recursiveParentSearch(parent, subNode); if (res != nullptr) { break; } } return res; } CommandLineParser::Node* CommandLineParser::recursiveParentSearch( const CommandArgument& parent, Node& node) const { Node* res = nullptr; if (node.argument == parent) { res = &node; } else { for (auto& subNode : node.subNodes) { res = recursiveParentSearch(parent, subNode); if (res != nullptr) { break; } } } return res; } bool CommandLineParser::processIfOptionIsHelp( const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode) { bool ok = true; auto dashedHelpNames = helpOption.dashedNames(); if (m_withHelp && actualIt != args.cend() && dashedHelpNames.contains(*actualIt)) { if (actualIt + 1 == args.cend()) { m_foundOptions << helpOption; printHelp(args, actualNode); actualIt++; } else { err << \"Invalid arguments after the help option.\"; ok = false; } } return ok; }","title":"File commandlineparser.cpp"},{"location":"flameshot/commandlineparser_8h/","text":"File commandlineparser.h # FileList > cli > commandlineparser.h Go to the source code of this file. #include \"src/cli/commandargument.h\" #include \"src/cli/commandoption.h\" #include <QMap> Classes # Type Name class CommandLineParser","title":"File commandlineparser.h"},{"location":"flameshot/commandlineparser_8h/#file-commandlineparserh","text":"FileList > cli > commandlineparser.h Go to the source code of this file. #include \"src/cli/commandargument.h\" #include \"src/cli/commandoption.h\" #include <QMap>","title":"File commandlineparser.h"},{"location":"flameshot/commandlineparser_8h/#classes","text":"Type Name class CommandLineParser","title":"Classes"},{"location":"flameshot/commandlineparser_8h_source/","text":"File commandlineparser.h # File List > cli > commandlineparser.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/cli/commandargument.h\" #include \"src/cli/commandoption.h\" #include <QMap> class CommandLineParser { public: CommandLineParser(); bool parse(const QStringList& args); CommandArgument rootArgument() const { return CommandArgument(); } CommandOption addVersionOption(); CommandOption addHelpOption(); bool AddArgument(const CommandArgument& arg, const CommandArgument& parent = CommandArgument()); bool AddOption(const CommandOption& option, const CommandArgument& parent = CommandArgument()); bool AddOptions(const QList<CommandOption>& options, const CommandArgument& parent = CommandArgument()); void setGeneralErrorMessage(const QString& msg); void setDescription(const QString& description); bool isSet(const CommandArgument& arg) const; bool isSet(const CommandOption& option) const; QString value(const CommandOption& option) const; private: bool m_withHelp = false; bool m_withVersion = false; QString m_description; QString m_generalErrorMessage; struct Node { explicit Node(const CommandArgument& arg) : argument(arg) {} Node() {} bool operator==(const Node& n) const { return argument == n.argument && options == n.options && subNodes == n.subNodes; } CommandArgument argument; QList<CommandOption> options; QList<Node> subNodes; }; Node m_parseTree; QList<CommandOption> m_foundOptions; QList<CommandArgument> m_foundArgs; // helper functions void printVersion(); void printHelp(QStringList args, const Node* node); Node* findParent(const CommandArgument& parent); Node* recursiveParentSearch(const CommandArgument& parent, Node& node) const; bool processIfOptionIsHelp(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode); bool processArgs(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode); bool processOptions(const QStringList& args, QStringList::const_iterator& actualIt, Node* const actualNode); };","title":"File commandlineparser.h"},{"location":"flameshot/commandlineparser_8h_source/#file-commandlineparserh","text":"File List > cli > commandlineparser.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/cli/commandargument.h\" #include \"src/cli/commandoption.h\" #include <QMap> class CommandLineParser { public: CommandLineParser(); bool parse(const QStringList& args); CommandArgument rootArgument() const { return CommandArgument(); } CommandOption addVersionOption(); CommandOption addHelpOption(); bool AddArgument(const CommandArgument& arg, const CommandArgument& parent = CommandArgument()); bool AddOption(const CommandOption& option, const CommandArgument& parent = CommandArgument()); bool AddOptions(const QList<CommandOption>& options, const CommandArgument& parent = CommandArgument()); void setGeneralErrorMessage(const QString& msg); void setDescription(const QString& description); bool isSet(const CommandArgument& arg) const; bool isSet(const CommandOption& option) const; QString value(const CommandOption& option) const; private: bool m_withHelp = false; bool m_withVersion = false; QString m_description; QString m_generalErrorMessage; struct Node { explicit Node(const CommandArgument& arg) : argument(arg) {} Node() {} bool operator==(const Node& n) const { return argument == n.argument && options == n.options && subNodes == n.subNodes; } CommandArgument argument; QList<CommandOption> options; QList<Node> subNodes; }; Node m_parseTree; QList<CommandOption> m_foundOptions; QList<CommandArgument> m_foundArgs; // helper functions void printVersion(); void printHelp(QStringList args, const Node* node); Node* findParent(const CommandArgument& parent); Node* recursiveParentSearch(const CommandArgument& parent, Node& node) const; bool processIfOptionIsHelp(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode); bool processArgs(const QStringList& args, QStringList::const_iterator& actualIt, Node*& actualNode); bool processOptions(const QStringList& args, QStringList::const_iterator& actualIt, Node* const actualNode); };","title":"File commandlineparser.h"},{"location":"flameshot/commandoption_8cpp/","text":"File commandoption.cpp # FileList > cli > commandoption.cpp Go to the source code of this file. #include \"commandoption.h\" #include <utility>","title":"File commandoption.cpp"},{"location":"flameshot/commandoption_8cpp/#file-commandoptioncpp","text":"FileList > cli > commandoption.cpp Go to the source code of this file. #include \"commandoption.h\" #include <utility>","title":"File commandoption.cpp"},{"location":"flameshot/commandoption_8cpp_source/","text":"File commandoption.cpp # File List > cli > commandoption.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandoption.h\" #include <utility> CommandOption::CommandOption(const QString& name, QString description, QString valueName, QString defaultValue) : m_names(name) , m_description(std::move(description)) , m_valueName(std::move(valueName)) , m_value(std::move(defaultValue)) { m_checker = [](QString const&) { return true; }; } CommandOption::CommandOption(QStringList names, QString description, QString valueName, QString defaultValue) : m_names(std::move(names)) , m_description(std::move(description)) , m_valueName(std::move(valueName)) , m_value(std::move(defaultValue)) { m_checker = [](QString const&) -> bool { return true; }; } void CommandOption::setName(const QString& name) { m_names = QStringList() << name; } void CommandOption::setNames(const QStringList& names) { m_names = names; } QStringList CommandOption::names() const { return m_names; } QStringList CommandOption::dashedNames() const { QStringList dashedNames; for (const QString& name : m_names) { // prepend \"-\" to single character options, and \"--\" to the others QString dashedName = (name.length() == 1) ? QStringLiteral(\"-%1\").arg(name) : QStringLiteral(\"--%1\").arg(name); dashedNames << dashedName; } return dashedNames; } void CommandOption::setValueName(const QString& name) { m_valueName = name; } QString CommandOption::valueName() const { return m_valueName; } void CommandOption::setValue(const QString& value) { if (m_valueName.isEmpty()) { m_valueName = QLatin1String(\"value\"); } m_value = value; } QString CommandOption::value() const { return m_value; } void CommandOption::addChecker(const function<bool(const QString&)> checker, const QString& errMsg) { m_checker = checker; m_errorMsg = errMsg; } bool CommandOption::checkValue(const QString& value) const { return m_checker(value); } QString CommandOption::description() const { return m_description; } void CommandOption::setDescription(const QString& description) { m_description = description; } QString CommandOption::errorMsg() const { return m_errorMsg; } bool CommandOption::operator==(const CommandOption& option) const { return m_description == option.m_description && m_names == option.m_names && m_valueName == option.m_valueName; }","title":"File commandoption.cpp"},{"location":"flameshot/commandoption_8cpp_source/#file-commandoptioncpp","text":"File List > cli > commandoption.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"commandoption.h\" #include <utility> CommandOption::CommandOption(const QString& name, QString description, QString valueName, QString defaultValue) : m_names(name) , m_description(std::move(description)) , m_valueName(std::move(valueName)) , m_value(std::move(defaultValue)) { m_checker = [](QString const&) { return true; }; } CommandOption::CommandOption(QStringList names, QString description, QString valueName, QString defaultValue) : m_names(std::move(names)) , m_description(std::move(description)) , m_valueName(std::move(valueName)) , m_value(std::move(defaultValue)) { m_checker = [](QString const&) -> bool { return true; }; } void CommandOption::setName(const QString& name) { m_names = QStringList() << name; } void CommandOption::setNames(const QStringList& names) { m_names = names; } QStringList CommandOption::names() const { return m_names; } QStringList CommandOption::dashedNames() const { QStringList dashedNames; for (const QString& name : m_names) { // prepend \"-\" to single character options, and \"--\" to the others QString dashedName = (name.length() == 1) ? QStringLiteral(\"-%1\").arg(name) : QStringLiteral(\"--%1\").arg(name); dashedNames << dashedName; } return dashedNames; } void CommandOption::setValueName(const QString& name) { m_valueName = name; } QString CommandOption::valueName() const { return m_valueName; } void CommandOption::setValue(const QString& value) { if (m_valueName.isEmpty()) { m_valueName = QLatin1String(\"value\"); } m_value = value; } QString CommandOption::value() const { return m_value; } void CommandOption::addChecker(const function<bool(const QString&)> checker, const QString& errMsg) { m_checker = checker; m_errorMsg = errMsg; } bool CommandOption::checkValue(const QString& value) const { return m_checker(value); } QString CommandOption::description() const { return m_description; } void CommandOption::setDescription(const QString& description) { m_description = description; } QString CommandOption::errorMsg() const { return m_errorMsg; } bool CommandOption::operator==(const CommandOption& option) const { return m_description == option.m_description && m_names == option.m_names && m_valueName == option.m_valueName; }","title":"File commandoption.cpp"},{"location":"flameshot/commandoption_8h/","text":"File commandoption.h # FileList > cli > commandoption.h Go to the source code of this file. #include <QStringList> #include <functional> Classes # Type Name class CommandOption","title":"File commandoption.h"},{"location":"flameshot/commandoption_8h/#file-commandoptionh","text":"FileList > cli > commandoption.h Go to the source code of this file. #include <QStringList> #include <functional>","title":"File commandoption.h"},{"location":"flameshot/commandoption_8h/#classes","text":"Type Name class CommandOption","title":"Classes"},{"location":"flameshot/commandoption_8h_source/","text":"File commandoption.h # File List > cli > commandoption.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QStringList> #include <functional> using std::function; class CommandOption { public: CommandOption(const QString& name, QString description, QString valueName = QString(), QString defaultValue = QString()); CommandOption(QStringList names, QString description, QString valueName = QString(), QString defaultValue = QString()); void setName(const QString& name); void setNames(const QStringList& names); QStringList names() const; QStringList dashedNames() const; void setValueName(const QString& name); QString valueName() const; void setValue(const QString& value); QString value() const; void addChecker(const function<bool(QString const&)> checker, const QString& errMsg); bool checkValue(const QString& value) const; QString description() const; void setDescription(const QString& description); QString errorMsg() const; bool operator==(const CommandOption& option) const; private: QStringList m_names; QString m_description; QString m_valueName; QString m_value; function<bool(QString const&)> m_checker; QString m_errorMsg; };","title":"File commandoption.h"},{"location":"flameshot/commandoption_8h_source/#file-commandoptionh","text":"File List > cli > commandoption.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QStringList> #include <functional> using std::function; class CommandOption { public: CommandOption(const QString& name, QString description, QString valueName = QString(), QString defaultValue = QString()); CommandOption(QStringList names, QString description, QString valueName = QString(), QString defaultValue = QString()); void setName(const QString& name); void setNames(const QStringList& names); QStringList names() const; QStringList dashedNames() const; void setValueName(const QString& name); QString valueName() const; void setValue(const QString& value); QString value() const; void addChecker(const function<bool(QString const&)> checker, const QString& errMsg); bool checkValue(const QString& value) const; QString description() const; void setDescription(const QString& description); QString errorMsg() const; bool operator==(const CommandOption& option) const; private: QStringList m_names; QString m_description; QString m_valueName; QString m_value; function<bool(QString const&)> m_checker; QString m_errorMsg; };","title":"File commandoption.h"},{"location":"flameshot/dir_7e83d1792d529f4aa7126ac7e0b3b699/","text":"Dir config # FileList > config Files # Type Name file buttonlistview.cpp file buttonlistview.h file cacheutils.cpp file cacheutils.h file clickablelabel.cpp file clickablelabel.h file colorpickereditmode.cpp file colorpickereditmode.h file colorpickereditor.cpp file colorpickereditor.h file configerrordetails.cpp file configerrordetails.h file configresolver.cpp file configresolver.h file configwindow.cpp file configwindow.h file extendedslider.cpp file extendedslider.h file filenameeditor.cpp file filenameeditor.h file generalconf.cpp file generalconf.h file setshortcutwidget.cpp file setshortcutwidget.h file shortcutswidget.cpp file shortcutswidget.h file strftimechooserwidget.cpp file strftimechooserwidget.h file styleoverride.cpp file styleoverride.h file uicoloreditor.cpp file uicoloreditor.h file visualseditor.cpp file visualseditor.h","title":"Dir config"},{"location":"flameshot/dir_7e83d1792d529f4aa7126ac7e0b3b699/#dir-config","text":"FileList > config","title":"Dir config"},{"location":"flameshot/dir_7e83d1792d529f4aa7126ac7e0b3b699/#files","text":"Type Name file buttonlistview.cpp file buttonlistview.h file cacheutils.cpp file cacheutils.h file clickablelabel.cpp file clickablelabel.h file colorpickereditmode.cpp file colorpickereditmode.h file colorpickereditor.cpp file colorpickereditor.h file configerrordetails.cpp file configerrordetails.h file configresolver.cpp file configresolver.h file configwindow.cpp file configwindow.h file extendedslider.cpp file extendedslider.h file filenameeditor.cpp file filenameeditor.h file generalconf.cpp file generalconf.h file setshortcutwidget.cpp file setshortcutwidget.h file shortcutswidget.cpp file shortcutswidget.h file strftimechooserwidget.cpp file strftimechooserwidget.h file styleoverride.cpp file styleoverride.h file uicoloreditor.cpp file uicoloreditor.h file visualseditor.cpp file visualseditor.h","title":"Files"},{"location":"flameshot/buttonlistview_8cpp/","text":"File buttonlistview.cpp # FileList > config > buttonlistview.cpp Go to the source code of this file. #include \"buttonlistview.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/confighandler.h\" #include <QListWidgetItem> #include <algorithm>","title":"File buttonlistview.cpp"},{"location":"flameshot/buttonlistview_8cpp/#file-buttonlistviewcpp","text":"FileList > config > buttonlistview.cpp Go to the source code of this file. #include \"buttonlistview.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/confighandler.h\" #include <QListWidgetItem> #include <algorithm>","title":"File buttonlistview.cpp"},{"location":"flameshot/buttonlistview_8cpp_source/","text":"File buttonlistview.cpp # File List > config > buttonlistview.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"buttonlistview.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/confighandler.h\" #include <QListWidgetItem> #include <algorithm> ButtonListView::ButtonListView(QWidget* parent) : QListWidget(parent) { setMouseTracking(true); setFlow(QListWidget::TopToBottom); initButtonList(); updateComponents(); connect( this, &QListWidget::itemClicked, this, &ButtonListView::reverseItemCheck); } void ButtonListView::initButtonList() { ToolFactory factory; auto listTypes = CaptureToolButton::getIterableButtonTypes(); for (const CaptureTool::Type t : listTypes) { CaptureTool* tool = factory.CreateTool(t); // add element to the local map m_buttonTypeByName.insert(tool->name(), t); // init the menu option auto* m_buttonItem = new QListWidgetItem(this); // when the background is lighter than gray, it uses the white icons QColor bgColor = this->palette().color(QWidget::backgroundRole()); m_buttonItem->setIcon(tool->icon(bgColor, false)); m_buttonItem->setFlags(Qt::ItemIsUserCheckable); QColor foregroundColor = this->palette().color(QWidget::foregroundRole()); m_buttonItem->setForeground(foregroundColor); m_buttonItem->setText(tool->name()); m_buttonItem->setToolTip(tool->description()); tool->deleteLater(); } } void ButtonListView::updateActiveButtons(QListWidgetItem* item) { CaptureTool::Type bType = m_buttonTypeByName[item->text()]; if (item->checkState() == Qt::Checked) { m_listButtons.append(bType); // TODO refactor so we don't need external sorts using bt = CaptureTool::Type; std::sort(m_listButtons.begin(), m_listButtons.end(), [](bt a, bt b) { return CaptureToolButton::getPriorityByButton(a) < CaptureToolButton::getPriorityByButton(b); }); } else { m_listButtons.removeOne(bType); } ConfigHandler().setButtons(m_listButtons); } void ButtonListView::reverseItemCheck(QListWidgetItem* item) { if (item->checkState() == Qt::Checked) { item->setCheckState(Qt::Unchecked); } else { item->setCheckState(Qt::Checked); } updateActiveButtons(item); } void ButtonListView::selectAll() { ConfigHandler().setAllTheButtons(); for (int i = 0; i < this->count(); ++i) { QListWidgetItem* item = this->item(i); item->setCheckState(Qt::Checked); } } void ButtonListView::updateComponents() { m_listButtons = ConfigHandler().buttons(); auto listTypes = CaptureToolButton::getIterableButtonTypes(); for (int i = 0; i < this->count(); ++i) { QListWidgetItem* item = this->item(i); auto elem = static_cast<CaptureTool::Type>(listTypes.at(i)); if (m_listButtons.contains(elem)) { item->setCheckState(Qt::Checked); } else { item->setCheckState(Qt::Unchecked); } } }","title":"File buttonlistview.cpp"},{"location":"flameshot/buttonlistview_8cpp_source/#file-buttonlistviewcpp","text":"File List > config > buttonlistview.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"buttonlistview.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/confighandler.h\" #include <QListWidgetItem> #include <algorithm> ButtonListView::ButtonListView(QWidget* parent) : QListWidget(parent) { setMouseTracking(true); setFlow(QListWidget::TopToBottom); initButtonList(); updateComponents(); connect( this, &QListWidget::itemClicked, this, &ButtonListView::reverseItemCheck); } void ButtonListView::initButtonList() { ToolFactory factory; auto listTypes = CaptureToolButton::getIterableButtonTypes(); for (const CaptureTool::Type t : listTypes) { CaptureTool* tool = factory.CreateTool(t); // add element to the local map m_buttonTypeByName.insert(tool->name(), t); // init the menu option auto* m_buttonItem = new QListWidgetItem(this); // when the background is lighter than gray, it uses the white icons QColor bgColor = this->palette().color(QWidget::backgroundRole()); m_buttonItem->setIcon(tool->icon(bgColor, false)); m_buttonItem->setFlags(Qt::ItemIsUserCheckable); QColor foregroundColor = this->palette().color(QWidget::foregroundRole()); m_buttonItem->setForeground(foregroundColor); m_buttonItem->setText(tool->name()); m_buttonItem->setToolTip(tool->description()); tool->deleteLater(); } } void ButtonListView::updateActiveButtons(QListWidgetItem* item) { CaptureTool::Type bType = m_buttonTypeByName[item->text()]; if (item->checkState() == Qt::Checked) { m_listButtons.append(bType); // TODO refactor so we don't need external sorts using bt = CaptureTool::Type; std::sort(m_listButtons.begin(), m_listButtons.end(), [](bt a, bt b) { return CaptureToolButton::getPriorityByButton(a) < CaptureToolButton::getPriorityByButton(b); }); } else { m_listButtons.removeOne(bType); } ConfigHandler().setButtons(m_listButtons); } void ButtonListView::reverseItemCheck(QListWidgetItem* item) { if (item->checkState() == Qt::Checked) { item->setCheckState(Qt::Unchecked); } else { item->setCheckState(Qt::Checked); } updateActiveButtons(item); } void ButtonListView::selectAll() { ConfigHandler().setAllTheButtons(); for (int i = 0; i < this->count(); ++i) { QListWidgetItem* item = this->item(i); item->setCheckState(Qt::Checked); } } void ButtonListView::updateComponents() { m_listButtons = ConfigHandler().buttons(); auto listTypes = CaptureToolButton::getIterableButtonTypes(); for (int i = 0; i < this->count(); ++i) { QListWidgetItem* item = this->item(i); auto elem = static_cast<CaptureTool::Type>(listTypes.at(i)); if (m_listButtons.contains(elem)) { item->setCheckState(Qt::Checked); } else { item->setCheckState(Qt::Unchecked); } } }","title":"File buttonlistview.cpp"},{"location":"flameshot/buttonlistview_8h/","text":"File buttonlistview.h # FileList > config > buttonlistview.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include <QListWidget> Classes # Type Name class ButtonListView","title":"File buttonlistview.h"},{"location":"flameshot/buttonlistview_8h/#file-buttonlistviewh","text":"FileList > config > buttonlistview.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include <QListWidget>","title":"File buttonlistview.h"},{"location":"flameshot/buttonlistview_8h/#classes","text":"Type Name class ButtonListView","title":"Classes"},{"location":"flameshot/buttonlistview_8h_source/","text":"File buttonlistview.h # File List > config > buttonlistview.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include <QListWidget> class ButtonListView : public QListWidget { public: explicit ButtonListView(QWidget* parent = nullptr); public slots: void selectAll(); void updateComponents(); private slots: void reverseItemCheck(QListWidgetItem*); protected: void initButtonList(); private: QList<CaptureTool::Type> m_listButtons; QMap<QString, CaptureTool::Type> m_buttonTypeByName; void updateActiveButtons(QListWidgetItem*); };","title":"File buttonlistview.h"},{"location":"flameshot/buttonlistview_8h_source/#file-buttonlistviewh","text":"File List > config > buttonlistview.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include <QListWidget> class ButtonListView : public QListWidget { public: explicit ButtonListView(QWidget* parent = nullptr); public slots: void selectAll(); void updateComponents(); private slots: void reverseItemCheck(QListWidgetItem*); protected: void initButtonList(); private: QList<CaptureTool::Type> m_listButtons; QMap<QString, CaptureTool::Type> m_buttonTypeByName; void updateActiveButtons(QListWidgetItem*); };","title":"File buttonlistview.h"},{"location":"flameshot/cacheutils_8cpp/","text":"File cacheutils.cpp # FileList > config > cacheutils.cpp Go to the source code of this file. #include \"cacheutils.h\" #include <QDataStream> #include <QDir> #include <QFile> #include <QRect> #include <QStandardPaths> #include <QString> Public Functions # Type Name QString getCachePath () QRect getLastRegion () void setLastRegion (QRect const & newRegion) Public Functions Documentation # function getCachePath # QString getCachePath () function getLastRegion # QRect getLastRegion () function setLastRegion # void setLastRegion ( QRect const & newRegion )","title":"File cacheutils.cpp"},{"location":"flameshot/cacheutils_8cpp/#file-cacheutilscpp","text":"FileList > config > cacheutils.cpp Go to the source code of this file. #include \"cacheutils.h\" #include <QDataStream> #include <QDir> #include <QFile> #include <QRect> #include <QStandardPaths> #include <QString>","title":"File cacheutils.cpp"},{"location":"flameshot/cacheutils_8cpp/#public-functions","text":"Type Name QString getCachePath () QRect getLastRegion () void setLastRegion (QRect const & newRegion)","title":"Public Functions"},{"location":"flameshot/cacheutils_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/cacheutils_8cpp/#function-getcachepath","text":"QString getCachePath ()","title":"function getCachePath"},{"location":"flameshot/cacheutils_8cpp/#function-getlastregion","text":"QRect getLastRegion ()","title":"function getLastRegion"},{"location":"flameshot/cacheutils_8cpp/#function-setlastregion","text":"void setLastRegion ( QRect const & newRegion )","title":"function setLastRegion"},{"location":"flameshot/cacheutils_8cpp_source/","text":"File cacheutils.cpp # File List > config > cacheutils.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include \"cacheutils.h\" #include <QDataStream> #include <QDir> #include <QFile> #include <QRect> #include <QStandardPaths> #include <QString> QString getCachePath() { auto cachePath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation); if (!QDir(cachePath).exists()) { QDir().mkpath(cachePath); } return cachePath; } void setLastRegion(QRect const& newRegion) { auto cachePath = getCachePath() + \"/region.txt\"; QFile file(cachePath); if (file.open(QIODevice::WriteOnly)) { QDataStream out(&file); out << newRegion; file.close(); } } QRect getLastRegion() { auto cachePath = getCachePath() + \"/region.txt\"; QFile file(cachePath); QRect lastRegion; if (file.open(QIODevice::ReadOnly)) { QDataStream input(&file); input >> lastRegion; file.close(); } else { lastRegion = QRect(0, 0, 0, 0); } return lastRegion; }","title":"File cacheutils.cpp"},{"location":"flameshot/cacheutils_8cpp_source/#file-cacheutilscpp","text":"File List > config > cacheutils.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include \"cacheutils.h\" #include <QDataStream> #include <QDir> #include <QFile> #include <QRect> #include <QStandardPaths> #include <QString> QString getCachePath() { auto cachePath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation); if (!QDir(cachePath).exists()) { QDir().mkpath(cachePath); } return cachePath; } void setLastRegion(QRect const& newRegion) { auto cachePath = getCachePath() + \"/region.txt\"; QFile file(cachePath); if (file.open(QIODevice::WriteOnly)) { QDataStream out(&file); out << newRegion; file.close(); } } QRect getLastRegion() { auto cachePath = getCachePath() + \"/region.txt\"; QFile file(cachePath); QRect lastRegion; if (file.open(QIODevice::ReadOnly)) { QDataStream input(&file); input >> lastRegion; file.close(); } else { lastRegion = QRect(0, 0, 0, 0); } return lastRegion; }","title":"File cacheutils.cpp"},{"location":"flameshot/cacheutils_8h/","text":"File cacheutils.h # FileList > config > cacheutils.h Go to the source code of this file. Public Functions # Type Name QString getCachePath () QRect getLastRegion () void setLastRegion (QRect const & newRegion) Public Functions Documentation # function getCachePath # QString getCachePath () function getLastRegion # QRect getLastRegion () function setLastRegion # void setLastRegion ( QRect const & newRegion )","title":"File cacheutils.h"},{"location":"flameshot/cacheutils_8h/#file-cacheutilsh","text":"FileList > config > cacheutils.h Go to the source code of this file.","title":"File cacheutils.h"},{"location":"flameshot/cacheutils_8h/#public-functions","text":"Type Name QString getCachePath () QRect getLastRegion () void setLastRegion (QRect const & newRegion)","title":"Public Functions"},{"location":"flameshot/cacheutils_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/cacheutils_8h/#function-getcachepath","text":"QString getCachePath ()","title":"function getCachePath"},{"location":"flameshot/cacheutils_8h/#function-getlastregion","text":"QRect getLastRegion ()","title":"function getLastRegion"},{"location":"flameshot/cacheutils_8h/#function-setlastregion","text":"void setLastRegion ( QRect const & newRegion )","title":"function setLastRegion"},{"location":"flameshot/cacheutils_8h_source/","text":"File cacheutils.h # File List > config > cacheutils.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #ifndef FLAMESHOT_CACHEUTILS_H #define FLAMESHOT_CACHEUTILS_H class QString; class QRect; QString getCachePath(); QRect getLastRegion(); void setLastRegion(QRect const& newRegion); #endif // FLAMESHOT_CACHEUTILS_H","title":"File cacheutils.h"},{"location":"flameshot/cacheutils_8h_source/#file-cacheutilsh","text":"File List > config > cacheutils.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #ifndef FLAMESHOT_CACHEUTILS_H #define FLAMESHOT_CACHEUTILS_H class QString; class QRect; QString getCachePath(); QRect getLastRegion(); void setLastRegion(QRect const& newRegion); #endif // FLAMESHOT_CACHEUTILS_H","title":"File cacheutils.h"},{"location":"flameshot/clickablelabel_8cpp/","text":"File clickablelabel.cpp # FileList > config > clickablelabel.cpp Go to the source code of this file. #include \"clickablelabel.h\"","title":"File clickablelabel.cpp"},{"location":"flameshot/clickablelabel_8cpp/#file-clickablelabelcpp","text":"FileList > config > clickablelabel.cpp Go to the source code of this file. #include \"clickablelabel.h\"","title":"File clickablelabel.cpp"},{"location":"flameshot/clickablelabel_8cpp_source/","text":"File clickablelabel.cpp # File List > config > clickablelabel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"clickablelabel.h\" ClickableLabel::ClickableLabel(QWidget* parent) : QLabel(parent) {} ClickableLabel::ClickableLabel(QString s, QWidget* parent) : QLabel(parent) { setText(s); } void ClickableLabel::mousePressEvent(QMouseEvent*) { emit clicked(); }","title":"File clickablelabel.cpp"},{"location":"flameshot/clickablelabel_8cpp_source/#file-clickablelabelcpp","text":"File List > config > clickablelabel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"clickablelabel.h\" ClickableLabel::ClickableLabel(QWidget* parent) : QLabel(parent) {} ClickableLabel::ClickableLabel(QString s, QWidget* parent) : QLabel(parent) { setText(s); } void ClickableLabel::mousePressEvent(QMouseEvent*) { emit clicked(); }","title":"File clickablelabel.cpp"},{"location":"flameshot/clickablelabel_8h/","text":"File clickablelabel.h # FileList > config > clickablelabel.h Go to the source code of this file. #include <QLabel> Classes # Type Name class ClickableLabel","title":"File clickablelabel.h"},{"location":"flameshot/clickablelabel_8h/#file-clickablelabelh","text":"FileList > config > clickablelabel.h Go to the source code of this file. #include <QLabel>","title":"File clickablelabel.h"},{"location":"flameshot/clickablelabel_8h/#classes","text":"Type Name class ClickableLabel","title":"Classes"},{"location":"flameshot/clickablelabel_8h_source/","text":"File clickablelabel.h # File List > config > clickablelabel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QLabel> class ClickableLabel : public QLabel { Q_OBJECT public: explicit ClickableLabel(QWidget* parent = nullptr); ClickableLabel(QString s, QWidget* parent = nullptr); signals: void clicked(); private: void mousePressEvent(QMouseEvent*); };","title":"File clickablelabel.h"},{"location":"flameshot/clickablelabel_8h_source/#file-clickablelabelh","text":"File List > config > clickablelabel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QLabel> class ClickableLabel : public QLabel { Q_OBJECT public: explicit ClickableLabel(QWidget* parent = nullptr); ClickableLabel(QString s, QWidget* parent = nullptr); signals: void clicked(); private: void mousePressEvent(QMouseEvent*); };","title":"File clickablelabel.h"},{"location":"flameshot/colorpickereditmode_8cpp/","text":"File colorpickereditmode.cpp # FileList > config > colorpickereditmode.cpp Go to the source code of this file. #include \"colorpickereditmode.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpickereditmode.cpp"},{"location":"flameshot/colorpickereditmode_8cpp/#file-colorpickereditmodecpp","text":"FileList > config > colorpickereditmode.cpp Go to the source code of this file. #include \"colorpickereditmode.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpickereditmode.cpp"},{"location":"flameshot/colorpickereditmode_8cpp_source/","text":"File colorpickereditmode.cpp # File List > config > colorpickereditmode.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickereditmode.h\" #include <QMouseEvent> #include <QPainter> ColorPickerEditMode::ColorPickerEditMode(QWidget* parent) : ColorPickerWidget(parent) { m_isPressing = false; m_isDragging = false; installEventFilter(this); } bool ColorPickerEditMode::eventFilter(QObject* obj, QEvent* event) { auto widget = static_cast<QWidget*>(obj); switch (event->type()) { case QEvent::MouseButtonPress: { auto mouseEvent = static_cast<QMouseEvent*>(event); if (mouseEvent->button() == Qt::LeftButton) { m_mousePressPos = mouseEvent->pos(); m_mouseMovePos = m_mousePressPos; for (int i = 1; i < m_colorList.size(); ++i) { if (m_colorAreaList.at(i).contains(m_mousePressPos)) { m_isPressing = true; m_draggedPresetInitialPos = m_colorAreaList[i].topLeft(); m_selectedIndex = i; update(m_colorAreaList.at(i) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = i; emit colorSelected(m_selectedIndex); break; } } } } break; case QEvent::MouseMove: { auto mouseEvent = static_cast<QMouseEvent*>(event); if (m_isPressing) { QPoint eventPos = mouseEvent->pos(); QPoint diff = eventPos - m_mouseMovePos; m_colorAreaList[m_selectedIndex].translate(diff); widget->update(); if (!m_isDragging) { QPoint totalMovedDiff = eventPos - m_mousePressPos; if (totalMovedDiff.manhattanLength() > 3) { m_isDragging = true; } } m_mouseMovePos = eventPos; } } break; case QEvent::MouseButtonRelease: { m_isPressing = false; if (m_isDragging) { QPoint draggedPresetCenter = m_colorAreaList[m_selectedIndex].center(); m_isDragging = false; bool swapped = false; for (int i = 1; i < m_colorList.size(); ++i) { if (i != m_selectedIndex && m_colorAreaList.at(i).contains(draggedPresetCenter)) { // swap colors QColor temp = m_colorList[i]; m_colorList[i] = m_colorList[m_selectedIndex]; m_colorList[m_selectedIndex] = temp; m_config.setUserColors(m_colorList); m_colorAreaList[m_selectedIndex].moveTo( m_draggedPresetInitialPos); m_selectedIndex = i; widget->update(); m_lastIndex = i; emit presetsSwapped(m_selectedIndex); swapped = true; break; } } if (!swapped) { m_colorAreaList[m_selectedIndex].moveTo( m_draggedPresetInitialPos); widget->update(); } } } break; default: break; } return QObject::eventFilter(obj, event); }","title":"File colorpickereditmode.cpp"},{"location":"flameshot/colorpickereditmode_8cpp_source/#file-colorpickereditmodecpp","text":"File List > config > colorpickereditmode.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickereditmode.h\" #include <QMouseEvent> #include <QPainter> ColorPickerEditMode::ColorPickerEditMode(QWidget* parent) : ColorPickerWidget(parent) { m_isPressing = false; m_isDragging = false; installEventFilter(this); } bool ColorPickerEditMode::eventFilter(QObject* obj, QEvent* event) { auto widget = static_cast<QWidget*>(obj); switch (event->type()) { case QEvent::MouseButtonPress: { auto mouseEvent = static_cast<QMouseEvent*>(event); if (mouseEvent->button() == Qt::LeftButton) { m_mousePressPos = mouseEvent->pos(); m_mouseMovePos = m_mousePressPos; for (int i = 1; i < m_colorList.size(); ++i) { if (m_colorAreaList.at(i).contains(m_mousePressPos)) { m_isPressing = true; m_draggedPresetInitialPos = m_colorAreaList[i].topLeft(); m_selectedIndex = i; update(m_colorAreaList.at(i) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = i; emit colorSelected(m_selectedIndex); break; } } } } break; case QEvent::MouseMove: { auto mouseEvent = static_cast<QMouseEvent*>(event); if (m_isPressing) { QPoint eventPos = mouseEvent->pos(); QPoint diff = eventPos - m_mouseMovePos; m_colorAreaList[m_selectedIndex].translate(diff); widget->update(); if (!m_isDragging) { QPoint totalMovedDiff = eventPos - m_mousePressPos; if (totalMovedDiff.manhattanLength() > 3) { m_isDragging = true; } } m_mouseMovePos = eventPos; } } break; case QEvent::MouseButtonRelease: { m_isPressing = false; if (m_isDragging) { QPoint draggedPresetCenter = m_colorAreaList[m_selectedIndex].center(); m_isDragging = false; bool swapped = false; for (int i = 1; i < m_colorList.size(); ++i) { if (i != m_selectedIndex && m_colorAreaList.at(i).contains(draggedPresetCenter)) { // swap colors QColor temp = m_colorList[i]; m_colorList[i] = m_colorList[m_selectedIndex]; m_colorList[m_selectedIndex] = temp; m_config.setUserColors(m_colorList); m_colorAreaList[m_selectedIndex].moveTo( m_draggedPresetInitialPos); m_selectedIndex = i; widget->update(); m_lastIndex = i; emit presetsSwapped(m_selectedIndex); swapped = true; break; } } if (!swapped) { m_colorAreaList[m_selectedIndex].moveTo( m_draggedPresetInitialPos); widget->update(); } } } break; default: break; } return QObject::eventFilter(obj, event); }","title":"File colorpickereditmode.cpp"},{"location":"flameshot/colorpickereditmode_8h/","text":"File colorpickereditmode.h # FileList > config > colorpickereditmode.h Go to the source code of this file. #include \"src/utils/confighandler.h\" #include \"src/widgets/colorpickerwidget.h\" Classes # Type Name class ColorPickerEditMode","title":"File colorpickereditmode.h"},{"location":"flameshot/colorpickereditmode_8h/#file-colorpickereditmodeh","text":"FileList > config > colorpickereditmode.h Go to the source code of this file. #include \"src/utils/confighandler.h\" #include \"src/widgets/colorpickerwidget.h\"","title":"File colorpickereditmode.h"},{"location":"flameshot/colorpickereditmode_8h/#classes","text":"Type Name class ColorPickerEditMode","title":"Classes"},{"location":"flameshot/colorpickereditmode_8h_source/","text":"File colorpickereditmode.h # File List > config > colorpickereditmode.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include \"src/utils/confighandler.h\" #include \"src/widgets/colorpickerwidget.h\" class ColorPickerEditMode : public ColorPickerWidget { Q_OBJECT public: explicit ColorPickerEditMode(QWidget* parent = nullptr); signals: void colorSelected(int index); void presetsSwapped(int index); private: bool eventFilter(QObject* obj, QEvent* event) override; bool m_isPressing = false; bool m_isDragging = false; QPoint m_mouseMovePos; QPoint m_mousePressPos; QPoint m_draggedPresetInitialPos; ConfigHandler m_config; };","title":"File colorpickereditmode.h"},{"location":"flameshot/colorpickereditmode_8h_source/#file-colorpickereditmodeh","text":"File List > config > colorpickereditmode.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include \"src/utils/confighandler.h\" #include \"src/widgets/colorpickerwidget.h\" class ColorPickerEditMode : public ColorPickerWidget { Q_OBJECT public: explicit ColorPickerEditMode(QWidget* parent = nullptr); signals: void colorSelected(int index); void presetsSwapped(int index); private: bool eventFilter(QObject* obj, QEvent* event) override; bool m_isPressing = false; bool m_isDragging = false; QPoint m_mouseMovePos; QPoint m_mousePressPos; QPoint m_draggedPresetInitialPos; ConfigHandler m_config; };","title":"File colorpickereditmode.h"},{"location":"flameshot/colorpickereditor_8cpp/","text":"File colorpickereditor.cpp # FileList > config > colorpickereditor.cpp Go to the source code of this file. #include \"colorpickereditor.h\" #include \"colorpickereditmode.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QColor> #include <QGridLayout> #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QString> #include <QVector>","title":"File colorpickereditor.cpp"},{"location":"flameshot/colorpickereditor_8cpp/#file-colorpickereditorcpp","text":"FileList > config > colorpickereditor.cpp Go to the source code of this file. #include \"colorpickereditor.h\" #include \"colorpickereditmode.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QColor> #include <QGridLayout> #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QString> #include <QVector>","title":"File colorpickereditor.cpp"},{"location":"flameshot/colorpickereditor_8cpp_source/","text":"File colorpickereditor.cpp # File List > config > colorpickereditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickereditor.h\" #include \"colorpickereditmode.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QColor> #include <QGridLayout> #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QString> #include <QVector> ColorPickerEditor::ColorPickerEditor(QWidget* parent) : QWidget(parent) , m_selectedIndex(1) { m_color = m_config.drawColor(); m_colorList = m_config.userColors(); m_gLayout = new QGridLayout(this); m_colorpicker = new ColorPickerEditMode(this); m_gLayout->addWidget(m_colorpicker, 0, 0); m_colorWheel = new color_widgets::ColorWheel(this); m_colorWheel->setColor(m_color); const int size = GlobalValues::buttonBaseSize() * 3.5; m_colorWheel->setMinimumSize(size, size); m_gLayout->addWidget(m_colorWheel, 1, 0); auto* m_vLocalLayout1 = new QVBoxLayout(); m_vLocalLayout1->addStretch(); m_colorEditLabel = new QLabel(tr(\"Edit Preset:\"), this); m_vLocalLayout1->addWidget(m_colorEditLabel); m_colorEdit = new QLineEdit(this); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); m_colorEdit->setToolTip(tr(\"Enter color to update preset\")); connect(m_colorpicker, &ColorPickerEditMode::colorSelected, this, [this](int index) { m_selectedIndex = index; m_colorEdit->setText( m_colorList[m_selectedIndex].name(QColor::HexRgb)); }); connect(m_colorpicker, &ColorPickerEditMode::presetsSwapped, this, [this](int index) { m_selectedIndex = index; m_colorList = m_config.userColors(); m_colorEdit->setText( m_colorList[m_selectedIndex].name(QColor::HexRgb)); }); m_vLocalLayout1->addWidget(m_colorEdit); m_updatePresetButton = new QPushButton(tr(\"Update\"), this); m_updatePresetButton->setToolTip( tr(\"Press button to update the selected preset\")); connect(m_updatePresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onUpdatePreset); m_vLocalLayout1->addWidget(m_updatePresetButton); m_deletePresetButton = new QPushButton(tr(\"Delete\"), this); m_deletePresetButton->setToolTip( tr(\"Press button to delete the selected preset\")); connect(m_deletePresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onDeletePreset); m_vLocalLayout1->addWidget(m_deletePresetButton); m_vLocalLayout1->addStretch(); m_gLayout->addLayout(m_vLocalLayout1, 0, 1); auto* m_vLocalLayout2 = new QVBoxLayout(); m_vLocalLayout2->addStretch(); m_addPresetLabel = new QLabel(tr(\"Add Preset:\"), this); m_vLocalLayout2->addWidget(m_addPresetLabel); m_colorInput = new QLineEdit(this); m_colorInput->setText(m_color.name(QColor::HexRgb)); m_colorInput->setToolTip( tr(\"Enter color manually or select it using the color-wheel\")); connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, [=](QColor c) { m_color = c; m_colorInput->setText(m_color.name(QColor::HexRgb)); }); m_vLocalLayout2->addWidget(m_colorInput); m_addPresetButton = new QPushButton(tr(\"Add\"), this); m_addPresetButton->setToolTip(tr(\"Press button to add preset\")); connect(m_addPresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onAddPreset); m_vLocalLayout2->addWidget(m_addPresetButton); m_vLocalLayout2->addStretch(); m_gLayout->addLayout(m_vLocalLayout2, 1, 1); } void ColorPickerEditor::addPreset() { if (m_colorList.contains(m_color)) { return; } const int maxPresetsAllowed = 17; if (m_colorList.size() >= maxPresetsAllowed) { QMessageBox::critical( this, tr(\"Error\"), tr(\"Unable to add preset. Maximum limit reached.\")); return; } m_colorList << m_color; m_config.setUserColors(m_colorList); } void ColorPickerEditor::deletePreset() { const int minPresetsAllowed = 3; if (m_colorList.size() <= minPresetsAllowed) { QMessageBox::critical( this, tr(\"Error\"), tr(\"Unable to remove preset. Minimum limit reached.\")); return; } m_colorList.remove(m_selectedIndex); m_config.setUserColors(m_colorList); } void ColorPickerEditor::updatePreset() { QColor c = QColor(m_colorEdit->text()); if (m_colorList.contains(c)) { m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); return; } m_colorList[m_selectedIndex] = c; m_config.setUserColors(m_colorList); } void ColorPickerEditor::onAddPreset() { if (QColor::isValidColor(m_colorInput->text())) { m_color = QColor(m_colorInput->text()); m_colorInput->setText(m_color.name(QColor::HexRgb)); } else { m_colorInput->setText(m_color.name(QColor::HexRgb)); return; } addPreset(); m_colorpicker->updateWidget(); m_selectedIndex = 1; m_colorpicker->updateSelection(m_selectedIndex); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); } void ColorPickerEditor::onDeletePreset() { deletePreset(); m_colorpicker->updateWidget(); m_selectedIndex = 1; m_colorpicker->updateSelection(m_selectedIndex); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); } void ColorPickerEditor::onUpdatePreset() { if (QColor::isValidColor(m_colorEdit->text())) { QColor c = QColor(m_colorEdit->text()); m_colorEdit->setText(c.name(QColor::HexRgb)); } else { m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); return; } updatePreset(); m_colorpicker->updateWidget(); }","title":"File colorpickereditor.cpp"},{"location":"flameshot/colorpickereditor_8cpp_source/#file-colorpickereditorcpp","text":"File List > config > colorpickereditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickereditor.h\" #include \"colorpickereditmode.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QColor> #include <QGridLayout> #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QString> #include <QVector> ColorPickerEditor::ColorPickerEditor(QWidget* parent) : QWidget(parent) , m_selectedIndex(1) { m_color = m_config.drawColor(); m_colorList = m_config.userColors(); m_gLayout = new QGridLayout(this); m_colorpicker = new ColorPickerEditMode(this); m_gLayout->addWidget(m_colorpicker, 0, 0); m_colorWheel = new color_widgets::ColorWheel(this); m_colorWheel->setColor(m_color); const int size = GlobalValues::buttonBaseSize() * 3.5; m_colorWheel->setMinimumSize(size, size); m_gLayout->addWidget(m_colorWheel, 1, 0); auto* m_vLocalLayout1 = new QVBoxLayout(); m_vLocalLayout1->addStretch(); m_colorEditLabel = new QLabel(tr(\"Edit Preset:\"), this); m_vLocalLayout1->addWidget(m_colorEditLabel); m_colorEdit = new QLineEdit(this); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); m_colorEdit->setToolTip(tr(\"Enter color to update preset\")); connect(m_colorpicker, &ColorPickerEditMode::colorSelected, this, [this](int index) { m_selectedIndex = index; m_colorEdit->setText( m_colorList[m_selectedIndex].name(QColor::HexRgb)); }); connect(m_colorpicker, &ColorPickerEditMode::presetsSwapped, this, [this](int index) { m_selectedIndex = index; m_colorList = m_config.userColors(); m_colorEdit->setText( m_colorList[m_selectedIndex].name(QColor::HexRgb)); }); m_vLocalLayout1->addWidget(m_colorEdit); m_updatePresetButton = new QPushButton(tr(\"Update\"), this); m_updatePresetButton->setToolTip( tr(\"Press button to update the selected preset\")); connect(m_updatePresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onUpdatePreset); m_vLocalLayout1->addWidget(m_updatePresetButton); m_deletePresetButton = new QPushButton(tr(\"Delete\"), this); m_deletePresetButton->setToolTip( tr(\"Press button to delete the selected preset\")); connect(m_deletePresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onDeletePreset); m_vLocalLayout1->addWidget(m_deletePresetButton); m_vLocalLayout1->addStretch(); m_gLayout->addLayout(m_vLocalLayout1, 0, 1); auto* m_vLocalLayout2 = new QVBoxLayout(); m_vLocalLayout2->addStretch(); m_addPresetLabel = new QLabel(tr(\"Add Preset:\"), this); m_vLocalLayout2->addWidget(m_addPresetLabel); m_colorInput = new QLineEdit(this); m_colorInput->setText(m_color.name(QColor::HexRgb)); m_colorInput->setToolTip( tr(\"Enter color manually or select it using the color-wheel\")); connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, [=](QColor c) { m_color = c; m_colorInput->setText(m_color.name(QColor::HexRgb)); }); m_vLocalLayout2->addWidget(m_colorInput); m_addPresetButton = new QPushButton(tr(\"Add\"), this); m_addPresetButton->setToolTip(tr(\"Press button to add preset\")); connect(m_addPresetButton, &QPushButton::pressed, this, &ColorPickerEditor::onAddPreset); m_vLocalLayout2->addWidget(m_addPresetButton); m_vLocalLayout2->addStretch(); m_gLayout->addLayout(m_vLocalLayout2, 1, 1); } void ColorPickerEditor::addPreset() { if (m_colorList.contains(m_color)) { return; } const int maxPresetsAllowed = 17; if (m_colorList.size() >= maxPresetsAllowed) { QMessageBox::critical( this, tr(\"Error\"), tr(\"Unable to add preset. Maximum limit reached.\")); return; } m_colorList << m_color; m_config.setUserColors(m_colorList); } void ColorPickerEditor::deletePreset() { const int minPresetsAllowed = 3; if (m_colorList.size() <= minPresetsAllowed) { QMessageBox::critical( this, tr(\"Error\"), tr(\"Unable to remove preset. Minimum limit reached.\")); return; } m_colorList.remove(m_selectedIndex); m_config.setUserColors(m_colorList); } void ColorPickerEditor::updatePreset() { QColor c = QColor(m_colorEdit->text()); if (m_colorList.contains(c)) { m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); return; } m_colorList[m_selectedIndex] = c; m_config.setUserColors(m_colorList); } void ColorPickerEditor::onAddPreset() { if (QColor::isValidColor(m_colorInput->text())) { m_color = QColor(m_colorInput->text()); m_colorInput->setText(m_color.name(QColor::HexRgb)); } else { m_colorInput->setText(m_color.name(QColor::HexRgb)); return; } addPreset(); m_colorpicker->updateWidget(); m_selectedIndex = 1; m_colorpicker->updateSelection(m_selectedIndex); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); } void ColorPickerEditor::onDeletePreset() { deletePreset(); m_colorpicker->updateWidget(); m_selectedIndex = 1; m_colorpicker->updateSelection(m_selectedIndex); m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); } void ColorPickerEditor::onUpdatePreset() { if (QColor::isValidColor(m_colorEdit->text())) { QColor c = QColor(m_colorEdit->text()); m_colorEdit->setText(c.name(QColor::HexRgb)); } else { m_colorEdit->setText(m_colorList[m_selectedIndex].name(QColor::HexRgb)); return; } updatePreset(); m_colorpicker->updateWidget(); }","title":"File colorpickereditor.cpp"},{"location":"flameshot/colorpickereditor_8h/","text":"File colorpickereditor.h # FileList > config > colorpickereditor.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/utils/confighandler.h\" #include <QWidget> Classes # Type Name class ColorPickerEditor","title":"File colorpickereditor.h"},{"location":"flameshot/colorpickereditor_8h/#file-colorpickereditorh","text":"FileList > config > colorpickereditor.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/utils/confighandler.h\" #include <QWidget>","title":"File colorpickereditor.h"},{"location":"flameshot/colorpickereditor_8h/#classes","text":"Type Name class ColorPickerEditor","title":"Classes"},{"location":"flameshot/colorpickereditor_8h_source/","text":"File colorpickereditor.h # File List > config > colorpickereditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/utils/confighandler.h\" #include <QWidget> class ColorPickerEditMode; class QLabel; class QPushButton; class QLineEdit; class QColor; class QGridLayout; class ColorPickerEditor : public QWidget { Q_OBJECT public: explicit ColorPickerEditor(QWidget* parent = nullptr); private slots: void onAddPreset(); void onDeletePreset(); void onUpdatePreset(); private: void addPreset(); void deletePreset(); void updatePreset(); ColorPickerEditMode* m_colorpicker; color_widgets::ColorWheel* m_colorWheel; QLabel* m_colorEditLabel; QLineEdit* m_colorEdit; QPushButton* m_deletePresetButton; QPushButton* m_updatePresetButton; QLineEdit* m_colorInput; QLabel* m_addPresetLabel; QPushButton* m_addPresetButton; QColor m_color; int m_selectedIndex; QVector<QColor> m_colorList; ConfigHandler m_config; QGridLayout* m_gLayout; };","title":"File colorpickereditor.h"},{"location":"flameshot/colorpickereditor_8h_source/#file-colorpickereditorh","text":"File List > config > colorpickereditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/utils/confighandler.h\" #include <QWidget> class ColorPickerEditMode; class QLabel; class QPushButton; class QLineEdit; class QColor; class QGridLayout; class ColorPickerEditor : public QWidget { Q_OBJECT public: explicit ColorPickerEditor(QWidget* parent = nullptr); private slots: void onAddPreset(); void onDeletePreset(); void onUpdatePreset(); private: void addPreset(); void deletePreset(); void updatePreset(); ColorPickerEditMode* m_colorpicker; color_widgets::ColorWheel* m_colorWheel; QLabel* m_colorEditLabel; QLineEdit* m_colorEdit; QPushButton* m_deletePresetButton; QPushButton* m_updatePresetButton; QLineEdit* m_colorInput; QLabel* m_addPresetLabel; QPushButton* m_addPresetButton; QColor m_color; int m_selectedIndex; QVector<QColor> m_colorList; ConfigHandler m_config; QGridLayout* m_gLayout; };","title":"File colorpickereditor.h"},{"location":"flameshot/configerrordetails_8cpp/","text":"File configerrordetails.cpp # FileList > config > configerrordetails.cpp Go to the source code of this file. #include \"src/config/configerrordetails.h\" #include \"src/utils/abstractlogger.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QDialogButtonBox> #include <QTextEdit> #include <QVBoxLayout>","title":"File configerrordetails.cpp"},{"location":"flameshot/configerrordetails_8cpp/#file-configerrordetailscpp","text":"FileList > config > configerrordetails.cpp Go to the source code of this file. #include \"src/config/configerrordetails.h\" #include \"src/utils/abstractlogger.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QDialogButtonBox> #include <QTextEdit> #include <QVBoxLayout>","title":"File configerrordetails.cpp"},{"location":"flameshot/configerrordetails_8cpp_source/","text":"File configerrordetails.cpp # File List > config > configerrordetails.cpp Go to the documentation of this file. #include \"src/config/configerrordetails.h\" #include \"src/utils/abstractlogger.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QDialogButtonBox> #include <QTextEdit> #include <QVBoxLayout> ConfigErrorDetails::ConfigErrorDetails(QWidget* parent) : QDialog(parent) { // Generate error log message QString str; AbstractLogger stream(str, AbstractLogger::Error); ConfigHandler().checkForErrors(&stream); // Set up dialog setWindowTitle(tr(\"Configuration errors\")); setLayout(new QVBoxLayout(this)); // Add text display auto* textDisplay = new QTextEdit(this); textDisplay->setPlainText(str); textDisplay->setReadOnly(true); layout()->addWidget(textDisplay); // Add Ok button using BBox = QDialogButtonBox; BBox* buttons = new BBox(BBox::Ok); layout()->addWidget(buttons); connect(buttons, &BBox::clicked, this, [this]() { close(); }); show(); qApp->processEvents(); QPoint center = geometry().center(); QRect dialogRect(0, 0, 600, 400); dialogRect.moveCenter(center); setGeometry(dialogRect); }","title":"File configerrordetails.cpp"},{"location":"flameshot/configerrordetails_8cpp_source/#file-configerrordetailscpp","text":"File List > config > configerrordetails.cpp Go to the documentation of this file. #include \"src/config/configerrordetails.h\" #include \"src/utils/abstractlogger.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QDialogButtonBox> #include <QTextEdit> #include <QVBoxLayout> ConfigErrorDetails::ConfigErrorDetails(QWidget* parent) : QDialog(parent) { // Generate error log message QString str; AbstractLogger stream(str, AbstractLogger::Error); ConfigHandler().checkForErrors(&stream); // Set up dialog setWindowTitle(tr(\"Configuration errors\")); setLayout(new QVBoxLayout(this)); // Add text display auto* textDisplay = new QTextEdit(this); textDisplay->setPlainText(str); textDisplay->setReadOnly(true); layout()->addWidget(textDisplay); // Add Ok button using BBox = QDialogButtonBox; BBox* buttons = new BBox(BBox::Ok); layout()->addWidget(buttons); connect(buttons, &BBox::clicked, this, [this]() { close(); }); show(); qApp->processEvents(); QPoint center = geometry().center(); QRect dialogRect(0, 0, 600, 400); dialogRect.moveCenter(center); setGeometry(dialogRect); }","title":"File configerrordetails.cpp"},{"location":"flameshot/configerrordetails_8h/","text":"File configerrordetails.h # FileList > config > configerrordetails.h Go to the source code of this file. #include <QDialog> Classes # Type Name class ConfigErrorDetails","title":"File configerrordetails.h"},{"location":"flameshot/configerrordetails_8h/#file-configerrordetailsh","text":"FileList > config > configerrordetails.h Go to the source code of this file. #include <QDialog>","title":"File configerrordetails.h"},{"location":"flameshot/configerrordetails_8h/#classes","text":"Type Name class ConfigErrorDetails","title":"Classes"},{"location":"flameshot/configerrordetails_8h_source/","text":"File configerrordetails.h # File List > config > configerrordetails.h Go to the documentation of this file. #include <QDialog> #pragma once class ConfigErrorDetails : public QDialog { public: ConfigErrorDetails(QWidget* parent = nullptr); };","title":"File configerrordetails.h"},{"location":"flameshot/configerrordetails_8h_source/#file-configerrordetailsh","text":"File List > config > configerrordetails.h Go to the documentation of this file. #include <QDialog> #pragma once class ConfigErrorDetails : public QDialog { public: ConfigErrorDetails(QWidget* parent = nullptr); };","title":"File configerrordetails.h"},{"location":"flameshot/configresolver_8cpp/","text":"File configresolver.cpp # FileList > config > configresolver.cpp Go to the source code of this file. #include \"src/config/configresolver.h\" #include \"src/config/configerrordetails.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/valuehandler.h\" #include <QDialogButtonBox> #include <QLabel> #include <QSplitter> #include <QVBoxLayout>","title":"File configresolver.cpp"},{"location":"flameshot/configresolver_8cpp/#file-configresolvercpp","text":"FileList > config > configresolver.cpp Go to the source code of this file. #include \"src/config/configresolver.h\" #include \"src/config/configerrordetails.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/valuehandler.h\" #include <QDialogButtonBox> #include <QLabel> #include <QSplitter> #include <QVBoxLayout>","title":"File configresolver.cpp"},{"location":"flameshot/configresolver_8cpp_source/","text":"File configresolver.cpp # File List > config > configresolver.cpp Go to the documentation of this file. #include \"src/config/configresolver.h\" #include \"src/config/configerrordetails.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/valuehandler.h\" #include <QDialogButtonBox> #include <QLabel> #include <QSplitter> #include <QVBoxLayout> ConfigResolver::ConfigResolver(QWidget* parent) : QDialog(parent) { setWindowTitle(tr(\"Resolve configuration errors\")); setMinimumSize({ 250, 200 }); setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Maximum); populate(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() { populate(); }); } QGridLayout* ConfigResolver::layout() { return dynamic_cast<QGridLayout*>(QDialog::layout()); } void ConfigResolver::populate() { ConfigHandler config; QList<QString> unrecognized; QList<QString> semanticallyWrong; config.checkUnrecognizedSettings(nullptr, &unrecognized); config.checkSemantics(nullptr, &semanticallyWrong); // Remove previous layout and children, if any resetLayout(); bool anyErrors = !semanticallyWrong.isEmpty() || !unrecognized.isEmpty(); int row = 0; // No errors detected if (!anyErrors) { accept(); } else { layout()->addWidget( new QLabel( tr(\"<b>You must resolve all errors before continuing:</b>\")), 0, 0, 1, 2); ++row; } // List semantically incorrect settings with a \"Reset\" button for (const auto& key : semanticallyWrong) { auto* label = new QLabel(key); auto* reset = new QPushButton(tr(\"Reset\")); label->setToolTip(\"This setting has a bad value.\"); reset->setToolTip(tr(\"Reset to the default value.\")); layout()->addWidget(label, row, 0); layout()->addWidget(reset, row, 1); reset->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed); connect(reset, &QPushButton::clicked, this, [key]() { ConfigHandler().resetValue(key); }); ++row; } // List unrecognized settings with a \"Remove\" button for (const auto& key : unrecognized) { auto* label = new QLabel(key); auto* remove = new QPushButton(tr(\"Remove\")); label->setToolTip(\"This setting is unrecognized.\"); remove->setToolTip(tr(\"Remove this setting.\")); layout()->addWidget(label, row, 0); layout()->addWidget(remove, row, 1); connect(remove, &QPushButton::clicked, this, [key]() { ConfigHandler().remove(key); }); ++row; } if (!config.checkShortcutConflicts()) { auto* conflicts = new QLabel( tr(\"Some keyboard shortcuts have conflicts.\\n\" \"This will NOT prevent flameshot from starting.\\n\" \"Please solve them manually in the configuration file.\")); conflicts->setWordWrap(true); conflicts->setMaximumWidth(geometry().width()); conflicts->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum); layout()->addWidget(conflicts, row, 0, 1, 2, Qt::AlignCenter); ++row; } auto* separator = new QFrame(this); separator->setFrameShape(QFrame::HLine); separator->setFrameShadow(QFrame::Sunken); layout()->addWidget(separator, row, 0, 1, 2); ++row; using BBox = QDialogButtonBox; // Add button box at the bottom auto* buttons = new BBox(this); layout()->addWidget(buttons, row, 0, 1, 2, Qt::AlignCenter); if (anyErrors) { auto* resolveAll = new QPushButton(tr(\"Resolve all\")); resolveAll->setToolTip(tr(\"Resolve all listed errors.\")); buttons->addButton(resolveAll, BBox::ResetRole); connect(resolveAll, &QPushButton::clicked, this, [=]() { for (const auto& key : semanticallyWrong) { ConfigHandler().resetValue(key); } for (const auto& key : unrecognized) { ConfigHandler().remove(key); } }); } auto* details = new QPushButton(tr(\"Details\")); buttons->addButton(details, BBox::HelpRole); connect(details, &QPushButton::clicked, this, [this]() { (new ConfigErrorDetails(this))->exec(); }); buttons->addButton(BBox::Cancel); connect(buttons, &BBox::rejected, this, [this]() { reject(); }); } void ConfigResolver::resetLayout() { for (auto* child : children()) { child->deleteLater(); } delete layout(); setLayout(new QGridLayout()); layout()->setSizeConstraint(QLayout::SetFixedSize); }","title":"File configresolver.cpp"},{"location":"flameshot/configresolver_8cpp_source/#file-configresolvercpp","text":"File List > config > configresolver.cpp Go to the documentation of this file. #include \"src/config/configresolver.h\" #include \"src/config/configerrordetails.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/valuehandler.h\" #include <QDialogButtonBox> #include <QLabel> #include <QSplitter> #include <QVBoxLayout> ConfigResolver::ConfigResolver(QWidget* parent) : QDialog(parent) { setWindowTitle(tr(\"Resolve configuration errors\")); setMinimumSize({ 250, 200 }); setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Maximum); populate(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() { populate(); }); } QGridLayout* ConfigResolver::layout() { return dynamic_cast<QGridLayout*>(QDialog::layout()); } void ConfigResolver::populate() { ConfigHandler config; QList<QString> unrecognized; QList<QString> semanticallyWrong; config.checkUnrecognizedSettings(nullptr, &unrecognized); config.checkSemantics(nullptr, &semanticallyWrong); // Remove previous layout and children, if any resetLayout(); bool anyErrors = !semanticallyWrong.isEmpty() || !unrecognized.isEmpty(); int row = 0; // No errors detected if (!anyErrors) { accept(); } else { layout()->addWidget( new QLabel( tr(\"<b>You must resolve all errors before continuing:</b>\")), 0, 0, 1, 2); ++row; } // List semantically incorrect settings with a \"Reset\" button for (const auto& key : semanticallyWrong) { auto* label = new QLabel(key); auto* reset = new QPushButton(tr(\"Reset\")); label->setToolTip(\"This setting has a bad value.\"); reset->setToolTip(tr(\"Reset to the default value.\")); layout()->addWidget(label, row, 0); layout()->addWidget(reset, row, 1); reset->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed); connect(reset, &QPushButton::clicked, this, [key]() { ConfigHandler().resetValue(key); }); ++row; } // List unrecognized settings with a \"Remove\" button for (const auto& key : unrecognized) { auto* label = new QLabel(key); auto* remove = new QPushButton(tr(\"Remove\")); label->setToolTip(\"This setting is unrecognized.\"); remove->setToolTip(tr(\"Remove this setting.\")); layout()->addWidget(label, row, 0); layout()->addWidget(remove, row, 1); connect(remove, &QPushButton::clicked, this, [key]() { ConfigHandler().remove(key); }); ++row; } if (!config.checkShortcutConflicts()) { auto* conflicts = new QLabel( tr(\"Some keyboard shortcuts have conflicts.\\n\" \"This will NOT prevent flameshot from starting.\\n\" \"Please solve them manually in the configuration file.\")); conflicts->setWordWrap(true); conflicts->setMaximumWidth(geometry().width()); conflicts->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum); layout()->addWidget(conflicts, row, 0, 1, 2, Qt::AlignCenter); ++row; } auto* separator = new QFrame(this); separator->setFrameShape(QFrame::HLine); separator->setFrameShadow(QFrame::Sunken); layout()->addWidget(separator, row, 0, 1, 2); ++row; using BBox = QDialogButtonBox; // Add button box at the bottom auto* buttons = new BBox(this); layout()->addWidget(buttons, row, 0, 1, 2, Qt::AlignCenter); if (anyErrors) { auto* resolveAll = new QPushButton(tr(\"Resolve all\")); resolveAll->setToolTip(tr(\"Resolve all listed errors.\")); buttons->addButton(resolveAll, BBox::ResetRole); connect(resolveAll, &QPushButton::clicked, this, [=]() { for (const auto& key : semanticallyWrong) { ConfigHandler().resetValue(key); } for (const auto& key : unrecognized) { ConfigHandler().remove(key); } }); } auto* details = new QPushButton(tr(\"Details\")); buttons->addButton(details, BBox::HelpRole); connect(details, &QPushButton::clicked, this, [this]() { (new ConfigErrorDetails(this))->exec(); }); buttons->addButton(BBox::Cancel); connect(buttons, &BBox::rejected, this, [this]() { reject(); }); } void ConfigResolver::resetLayout() { for (auto* child : children()) { child->deleteLater(); } delete layout(); setLayout(new QGridLayout()); layout()->setSizeConstraint(QLayout::SetFixedSize); }","title":"File configresolver.cpp"},{"location":"flameshot/configresolver_8h/","text":"File configresolver.h # FileList > config > configresolver.h Go to the source code of this file. #include <QDialog> Classes # Type Name class ConfigResolver","title":"File configresolver.h"},{"location":"flameshot/configresolver_8h/#file-configresolverh","text":"FileList > config > configresolver.h Go to the source code of this file. #include <QDialog>","title":"File configresolver.h"},{"location":"flameshot/configresolver_8h/#classes","text":"Type Name class ConfigResolver","title":"Classes"},{"location":"flameshot/configresolver_8h_source/","text":"File configresolver.h # File List > config > configresolver.h Go to the documentation of this file. #pragma once #include <QDialog> class QGridLayout; class ConfigResolver : public QDialog { public: ConfigResolver(QWidget* parent = nullptr); QGridLayout* layout(); private: void populate(); void resetLayout(); };","title":"File configresolver.h"},{"location":"flameshot/configresolver_8h_source/#file-configresolverh","text":"File List > config > configresolver.h Go to the documentation of this file. #pragma once #include <QDialog> class QGridLayout; class ConfigResolver : public QDialog { public: ConfigResolver(QWidget* parent = nullptr); QGridLayout* layout(); private: void populate(); void resetLayout(); };","title":"File configresolver.h"},{"location":"flameshot/configwindow_8cpp/","text":"File configwindow.cpp # FileList > config > configwindow.cpp Go to the source code of this file. #include \"configwindow.h\" #include \"abstractlogger.h\" #include \"src/config/configresolver.h\" #include \"src/config/filenameeditor.h\" #include \"src/config/generalconf.h\" #include \"src/config/shortcutswidget.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/config/visualseditor.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/pathinfo.h\" #include <QApplication> #include <QDialogButtonBox> #include <QFileSystemWatcher> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QSizePolicy> #include <QTabBar> #include <QTextStream> #include <QVBoxLayout>","title":"File configwindow.cpp"},{"location":"flameshot/configwindow_8cpp/#file-configwindowcpp","text":"FileList > config > configwindow.cpp Go to the source code of this file. #include \"configwindow.h\" #include \"abstractlogger.h\" #include \"src/config/configresolver.h\" #include \"src/config/filenameeditor.h\" #include \"src/config/generalconf.h\" #include \"src/config/shortcutswidget.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/config/visualseditor.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/pathinfo.h\" #include <QApplication> #include <QDialogButtonBox> #include <QFileSystemWatcher> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QSizePolicy> #include <QTabBar> #include <QTextStream> #include <QVBoxLayout>","title":"File configwindow.cpp"},{"location":"flameshot/configwindow_8cpp_source/","text":"File configwindow.cpp # File List > config > configwindow.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"configwindow.h\" #include \"abstractlogger.h\" #include \"src/config/configresolver.h\" #include \"src/config/filenameeditor.h\" #include \"src/config/generalconf.h\" #include \"src/config/shortcutswidget.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/config/visualseditor.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/pathinfo.h\" #include <QApplication> #include <QDialogButtonBox> #include <QFileSystemWatcher> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QSizePolicy> #include <QTabBar> #include <QTextStream> #include <QVBoxLayout> // ConfigWindow contains the menus where you can configure the application ConfigWindow::ConfigWindow(QWidget* parent) : QWidget(parent) { // We wrap QTabWidget in a QWidget because of a Qt bug auto* layout = new QVBoxLayout(this); m_tabWidget = new QTabWidget(this); m_tabWidget->tabBar()->setUsesScrollButtons(false); layout->addWidget(m_tabWidget); setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Configuration\")); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, &ConfigWindow::updateChildren); QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); // visuals m_visuals = new VisualsEditor(); m_visualsTab = new QWidget(); auto* visualsLayout = new QVBoxLayout(m_visualsTab); m_visualsTab->setLayout(visualsLayout); visualsLayout->addWidget(m_visuals); m_tabWidget->addTab( m_visualsTab, QIcon(modifier + \"graphics.svg\"), tr(\"Interface\")); // filename m_filenameEditor = new FileNameEditor(); m_filenameEditorTab = new QWidget(); auto* filenameEditorLayout = new QVBoxLayout(m_filenameEditorTab); m_filenameEditorTab->setLayout(filenameEditorLayout); filenameEditorLayout->addWidget(m_filenameEditor); m_tabWidget->addTab(m_filenameEditorTab, QIcon(modifier + \"name_edition.svg\"), tr(\"Filename Editor\")); // general m_generalConfig = new GeneralConf(); m_generalConfigTab = new QWidget(); auto* generalConfigLayout = new QVBoxLayout(m_generalConfigTab); m_generalConfigTab->setLayout(generalConfigLayout); generalConfigLayout->addWidget(m_generalConfig); m_tabWidget->addTab( m_generalConfigTab, QIcon(modifier + \"config.svg\"), tr(\"General\")); // shortcuts m_shortcuts = new ShortcutsWidget(); m_shortcutsTab = new QWidget(); auto* shortcutsLayout = new QVBoxLayout(m_shortcutsTab); m_shortcutsTab->setLayout(shortcutsLayout); shortcutsLayout->addWidget(m_shortcuts); m_tabWidget->addTab( m_shortcutsTab, QIcon(modifier + \"shortcut.svg\"), tr(\"Shortcuts\")); // connect update sigslots connect(this, &ConfigWindow::updateChildren, m_filenameEditor, &FileNameEditor::updateComponents); connect(this, &ConfigWindow::updateChildren, m_visuals, &VisualsEditor::updateComponents); connect(this, &ConfigWindow::updateChildren, m_generalConfig, &GeneralConf::updateComponents); // Error indicator (this must come last) initErrorIndicator(m_visualsTab, m_visuals); initErrorIndicator(m_filenameEditorTab, m_filenameEditor); initErrorIndicator(m_generalConfigTab, m_generalConfig); initErrorIndicator(m_shortcutsTab, m_shortcuts); } void ConfigWindow::keyPressEvent(QKeyEvent* e) { if (e->key() == Qt::Key_Escape) { close(); } } void ConfigWindow::initErrorIndicator(QWidget* tab, QWidget* widget) { auto* label = new QLabel(tab); auto* btnResolve = new QPushButton(tr(\"Resolve\"), tab); auto* btnLayout = new QHBoxLayout(); // Set up label label->setText(tr( \"<b>Configuration file has errors. Resolve them before continuing.</b>\")); label->setStyleSheet(QStringLiteral(\":disabled { color: %1; }\") .arg(qApp->palette().color(QPalette::Text).name())); label->setVisible(ConfigHandler().hasError()); // Set up \"Show errors\" button btnResolve->setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Fixed); btnLayout->addWidget(btnResolve); btnResolve->setVisible(ConfigHandler().hasError()); widget->setEnabled(!ConfigHandler().hasError()); // Add label and button to the parent widget's layout auto* layout = static_cast<QBoxLayout*>(tab->layout()); if (layout != nullptr) { layout->insertWidget(0, label); layout->insertLayout(1, btnLayout); } else { widget->layout()->addWidget(label); widget->layout()->addWidget(btnResolve); } // Sigslots connect(ConfigHandler::getInstance(), &ConfigHandler::error, widget, [=]() { widget->setEnabled(false); label->show(); btnResolve->show(); }); connect(ConfigHandler::getInstance(), &ConfigHandler::errorResolved, widget, [=]() { widget->setEnabled(true); label->hide(); btnResolve->hide(); }); connect(btnResolve, &QPushButton::clicked, this, [this]() { ConfigResolver().exec(); }); }","title":"File configwindow.cpp"},{"location":"flameshot/configwindow_8cpp_source/#file-configwindowcpp","text":"File List > config > configwindow.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"configwindow.h\" #include \"abstractlogger.h\" #include \"src/config/configresolver.h\" #include \"src/config/filenameeditor.h\" #include \"src/config/generalconf.h\" #include \"src/config/shortcutswidget.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/config/visualseditor.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/pathinfo.h\" #include <QApplication> #include <QDialogButtonBox> #include <QFileSystemWatcher> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QSizePolicy> #include <QTabBar> #include <QTextStream> #include <QVBoxLayout> // ConfigWindow contains the menus where you can configure the application ConfigWindow::ConfigWindow(QWidget* parent) : QWidget(parent) { // We wrap QTabWidget in a QWidget because of a Qt bug auto* layout = new QVBoxLayout(this); m_tabWidget = new QTabWidget(this); m_tabWidget->tabBar()->setUsesScrollButtons(false); layout->addWidget(m_tabWidget); setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Configuration\")); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, &ConfigWindow::updateChildren); QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); // visuals m_visuals = new VisualsEditor(); m_visualsTab = new QWidget(); auto* visualsLayout = new QVBoxLayout(m_visualsTab); m_visualsTab->setLayout(visualsLayout); visualsLayout->addWidget(m_visuals); m_tabWidget->addTab( m_visualsTab, QIcon(modifier + \"graphics.svg\"), tr(\"Interface\")); // filename m_filenameEditor = new FileNameEditor(); m_filenameEditorTab = new QWidget(); auto* filenameEditorLayout = new QVBoxLayout(m_filenameEditorTab); m_filenameEditorTab->setLayout(filenameEditorLayout); filenameEditorLayout->addWidget(m_filenameEditor); m_tabWidget->addTab(m_filenameEditorTab, QIcon(modifier + \"name_edition.svg\"), tr(\"Filename Editor\")); // general m_generalConfig = new GeneralConf(); m_generalConfigTab = new QWidget(); auto* generalConfigLayout = new QVBoxLayout(m_generalConfigTab); m_generalConfigTab->setLayout(generalConfigLayout); generalConfigLayout->addWidget(m_generalConfig); m_tabWidget->addTab( m_generalConfigTab, QIcon(modifier + \"config.svg\"), tr(\"General\")); // shortcuts m_shortcuts = new ShortcutsWidget(); m_shortcutsTab = new QWidget(); auto* shortcutsLayout = new QVBoxLayout(m_shortcutsTab); m_shortcutsTab->setLayout(shortcutsLayout); shortcutsLayout->addWidget(m_shortcuts); m_tabWidget->addTab( m_shortcutsTab, QIcon(modifier + \"shortcut.svg\"), tr(\"Shortcuts\")); // connect update sigslots connect(this, &ConfigWindow::updateChildren, m_filenameEditor, &FileNameEditor::updateComponents); connect(this, &ConfigWindow::updateChildren, m_visuals, &VisualsEditor::updateComponents); connect(this, &ConfigWindow::updateChildren, m_generalConfig, &GeneralConf::updateComponents); // Error indicator (this must come last) initErrorIndicator(m_visualsTab, m_visuals); initErrorIndicator(m_filenameEditorTab, m_filenameEditor); initErrorIndicator(m_generalConfigTab, m_generalConfig); initErrorIndicator(m_shortcutsTab, m_shortcuts); } void ConfigWindow::keyPressEvent(QKeyEvent* e) { if (e->key() == Qt::Key_Escape) { close(); } } void ConfigWindow::initErrorIndicator(QWidget* tab, QWidget* widget) { auto* label = new QLabel(tab); auto* btnResolve = new QPushButton(tr(\"Resolve\"), tab); auto* btnLayout = new QHBoxLayout(); // Set up label label->setText(tr( \"<b>Configuration file has errors. Resolve them before continuing.</b>\")); label->setStyleSheet(QStringLiteral(\":disabled { color: %1; }\") .arg(qApp->palette().color(QPalette::Text).name())); label->setVisible(ConfigHandler().hasError()); // Set up \"Show errors\" button btnResolve->setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Fixed); btnLayout->addWidget(btnResolve); btnResolve->setVisible(ConfigHandler().hasError()); widget->setEnabled(!ConfigHandler().hasError()); // Add label and button to the parent widget's layout auto* layout = static_cast<QBoxLayout*>(tab->layout()); if (layout != nullptr) { layout->insertWidget(0, label); layout->insertLayout(1, btnLayout); } else { widget->layout()->addWidget(label); widget->layout()->addWidget(btnResolve); } // Sigslots connect(ConfigHandler::getInstance(), &ConfigHandler::error, widget, [=]() { widget->setEnabled(false); label->show(); btnResolve->show(); }); connect(ConfigHandler::getInstance(), &ConfigHandler::errorResolved, widget, [=]() { widget->setEnabled(true); label->hide(); btnResolve->hide(); }); connect(btnResolve, &QPushButton::clicked, this, [this]() { ConfigResolver().exec(); }); }","title":"File configwindow.cpp"},{"location":"flameshot/configwindow_8h/","text":"File configwindow.h # FileList > config > configwindow.h Go to the source code of this file. #include <QTabWidget> Classes # Type Name class ConfigWindow","title":"File configwindow.h"},{"location":"flameshot/configwindow_8h/#file-configwindowh","text":"FileList > config > configwindow.h Go to the source code of this file. #include <QTabWidget>","title":"File configwindow.h"},{"location":"flameshot/configwindow_8h/#classes","text":"Type Name class ConfigWindow","title":"Classes"},{"location":"flameshot/configwindow_8h_source/","text":"File configwindow.h # File List > config > configwindow.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTabWidget> class FileNameEditor; class ShortcutsWidget; class GeneralConf; class QFileSystemWatcher; class VisualsEditor; class QWidget; class ConfigWindow : public QWidget { Q_OBJECT public: explicit ConfigWindow(QWidget* parent = nullptr); signals: void updateChildren(); protected: void keyPressEvent(QKeyEvent*); private: QTabWidget* m_tabWidget; FileNameEditor* m_filenameEditor; QWidget* m_filenameEditorTab; ShortcutsWidget* m_shortcuts; QWidget* m_shortcutsTab; GeneralConf* m_generalConfig; QWidget* m_generalConfigTab; VisualsEditor* m_visuals; QWidget* m_visualsTab; void initErrorIndicator(QWidget* tab, QWidget* widget); };","title":"File configwindow.h"},{"location":"flameshot/configwindow_8h_source/#file-configwindowh","text":"File List > config > configwindow.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTabWidget> class FileNameEditor; class ShortcutsWidget; class GeneralConf; class QFileSystemWatcher; class VisualsEditor; class QWidget; class ConfigWindow : public QWidget { Q_OBJECT public: explicit ConfigWindow(QWidget* parent = nullptr); signals: void updateChildren(); protected: void keyPressEvent(QKeyEvent*); private: QTabWidget* m_tabWidget; FileNameEditor* m_filenameEditor; QWidget* m_filenameEditorTab; ShortcutsWidget* m_shortcuts; QWidget* m_shortcutsTab; GeneralConf* m_generalConfig; QWidget* m_generalConfigTab; VisualsEditor* m_visuals; QWidget* m_visualsTab; void initErrorIndicator(QWidget* tab, QWidget* widget); };","title":"File configwindow.h"},{"location":"flameshot/extendedslider_8cpp/","text":"File extendedslider.cpp # FileList > config > extendedslider.cpp Go to the source code of this file. #include \"extendedslider.h\"","title":"File extendedslider.cpp"},{"location":"flameshot/extendedslider_8cpp/#file-extendedslidercpp","text":"FileList > config > extendedslider.cpp Go to the source code of this file. #include \"extendedslider.h\"","title":"File extendedslider.cpp"},{"location":"flameshot/extendedslider_8cpp_source/","text":"File extendedslider.cpp # File List > config > extendedslider.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"extendedslider.h\" ExtendedSlider::ExtendedSlider(QWidget* parent) : QSlider(parent) { connect(this, &ExtendedSlider::valueChanged, this, &ExtendedSlider::updateTooltip); connect( this, &ExtendedSlider::sliderMoved, this, &ExtendedSlider::fireTimer); m_timer.setSingleShot(true); connect( &m_timer, &QTimer::timeout, this, &ExtendedSlider::modificationsEnded); } int ExtendedSlider::mappedValue(int min, int max) { qreal progress = ((value() - minimum())) / static_cast<qreal>(maximum() - minimum()); return min + (max - min) * progress; } void ExtendedSlider::setMapedValue(int min, int val, int max) { qreal progress = ((val - min) + 1) / static_cast<qreal>(max - min); int value = minimum() + (maximum() - minimum()) * progress; setValue(value); } void ExtendedSlider::updateTooltip() { setToolTip(QString::number(value()) + \"%\"); } void ExtendedSlider::fireTimer() { m_timer.start(500); }","title":"File extendedslider.cpp"},{"location":"flameshot/extendedslider_8cpp_source/#file-extendedslidercpp","text":"File List > config > extendedslider.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"extendedslider.h\" ExtendedSlider::ExtendedSlider(QWidget* parent) : QSlider(parent) { connect(this, &ExtendedSlider::valueChanged, this, &ExtendedSlider::updateTooltip); connect( this, &ExtendedSlider::sliderMoved, this, &ExtendedSlider::fireTimer); m_timer.setSingleShot(true); connect( &m_timer, &QTimer::timeout, this, &ExtendedSlider::modificationsEnded); } int ExtendedSlider::mappedValue(int min, int max) { qreal progress = ((value() - minimum())) / static_cast<qreal>(maximum() - minimum()); return min + (max - min) * progress; } void ExtendedSlider::setMapedValue(int min, int val, int max) { qreal progress = ((val - min) + 1) / static_cast<qreal>(max - min); int value = minimum() + (maximum() - minimum()) * progress; setValue(value); } void ExtendedSlider::updateTooltip() { setToolTip(QString::number(value()) + \"%\"); } void ExtendedSlider::fireTimer() { m_timer.start(500); }","title":"File extendedslider.cpp"},{"location":"flameshot/extendedslider_8h/","text":"File extendedslider.h # FileList > config > extendedslider.h Go to the source code of this file. #include <QSlider> #include <QTimer> Classes # Type Name class ExtendedSlider","title":"File extendedslider.h"},{"location":"flameshot/extendedslider_8h/#file-extendedsliderh","text":"FileList > config > extendedslider.h Go to the source code of this file. #include <QSlider> #include <QTimer>","title":"File extendedslider.h"},{"location":"flameshot/extendedslider_8h/#classes","text":"Type Name class ExtendedSlider","title":"Classes"},{"location":"flameshot/extendedslider_8h_source/","text":"File extendedslider.h # File List > config > extendedslider.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QSlider> #include <QTimer> class ExtendedSlider : public QSlider { Q_OBJECT public: explicit ExtendedSlider(QWidget* parent = nullptr); int mappedValue(int min, int max); void setMapedValue(int min, int val, int max); signals: void modificationsEnded(); private slots: void updateTooltip(); void fireTimer(); private: QTimer m_timer; };","title":"File extendedslider.h"},{"location":"flameshot/extendedslider_8h_source/#file-extendedsliderh","text":"File List > config > extendedslider.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QSlider> #include <QTimer> class ExtendedSlider : public QSlider { Q_OBJECT public: explicit ExtendedSlider(QWidget* parent = nullptr); int mappedValue(int min, int max); void setMapedValue(int min, int val, int max); signals: void modificationsEnded(); private slots: void updateTooltip(); void fireTimer(); private: QTimer m_timer; };","title":"File extendedslider.h"},{"location":"flameshot/filenameeditor_8cpp/","text":"File filenameeditor.cpp # FileList > config > filenameeditor.cpp Go to the source code of this file. #include \"filenameeditor.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QVBoxLayout>","title":"File filenameeditor.cpp"},{"location":"flameshot/filenameeditor_8cpp/#file-filenameeditorcpp","text":"FileList > config > filenameeditor.cpp Go to the source code of this file. #include \"filenameeditor.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QVBoxLayout>","title":"File filenameeditor.cpp"},{"location":"flameshot/filenameeditor_8cpp_source/","text":"File filenameeditor.cpp # File List > config > filenameeditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"filenameeditor.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QVBoxLayout> FileNameEditor::FileNameEditor(QWidget* parent) : QWidget(parent) { initWidgets(); initLayout(); } void FileNameEditor::initLayout() { m_layout = new QVBoxLayout(this); auto* infoLabel = new QLabel(tr(\"Edit the name of your captures:\"), this); infoLabel->setFixedHeight(20); m_layout->addWidget(infoLabel); m_layout->addWidget(m_helperButtons); m_layout->addWidget(new QLabel(tr(\"Edit:\"))); m_layout->addWidget(m_nameEditor); m_layout->addWidget(new QLabel(tr(\"Preview:\"))); m_layout->addWidget(m_outputLabel); auto* horizLayout = new QHBoxLayout(); horizLayout->addWidget(m_saveButton); horizLayout->addWidget(m_resetButton); horizLayout->addWidget(m_clearButton); m_layout->addLayout(horizLayout); } void FileNameEditor::initWidgets() { m_nameHandler = new FileNameHandler(this); // editor m_nameEditor = new QLineEdit(this); m_nameEditor->setMaxLength(FileNameHandler::MAX_CHARACTERS); // preview m_outputLabel = new QLineEdit(this); m_outputLabel->setDisabled(true); QString foreground = this->palette().windowText().color().name(); m_outputLabel->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); QPalette pal = m_outputLabel->palette(); QColor color = pal.color(QPalette::Disabled, m_outputLabel->backgroundRole()); pal.setColor(QPalette::Active, m_outputLabel->backgroundRole(), color); m_outputLabel->setPalette(pal); connect(m_nameEditor, &QLineEdit::textChanged, this, &FileNameEditor::showParsedPattern); updateComponents(); // helper buttons m_helperButtons = new StrftimeChooserWidget(this); connect(m_helperButtons, &StrftimeChooserWidget::variableEmitted, this, &FileNameEditor::addToNameEditor); // save m_saveButton = new QPushButton(tr(\"Save\"), this); connect( m_saveButton, &QPushButton::clicked, this, &FileNameEditor::savePattern); m_saveButton->setToolTip(tr(\"Saves the pattern\")); // restore previous saved values m_resetButton = new QPushButton(tr(\"Restore\"), this); connect( m_resetButton, &QPushButton::clicked, this, &FileNameEditor::resetName); m_resetButton->setToolTip(tr(\"Restores the saved pattern\")); // clear m_clearButton = new QPushButton(tr(\"Clear\"), this); connect(m_clearButton, &QPushButton::clicked, this, [this]() { m_nameEditor->setText(ConfigHandler().filenamePatternDefault()); m_nameEditor->selectAll(); m_nameEditor->setFocus(); }); m_clearButton->setToolTip(tr(\"Deletes the name\")); } void FileNameEditor::savePattern() { QString pattern = m_nameEditor->text(); ConfigHandler().setFilenamePattern(pattern); } void FileNameEditor::showParsedPattern(const QString& p) { QString output = m_nameHandler->parseFilename(p); m_outputLabel->setText(output); } void FileNameEditor::resetName() { m_nameEditor->setText(ConfigHandler().filenamePattern()); } void FileNameEditor::addToNameEditor(QString s) { m_nameEditor->setText(m_nameEditor->text() + s); m_nameEditor->setFocus(); } void FileNameEditor::updateComponents() { m_nameEditor->setText(ConfigHandler().filenamePattern()); m_outputLabel->setText(m_nameHandler->parsedPattern()); }","title":"File filenameeditor.cpp"},{"location":"flameshot/filenameeditor_8cpp_source/#file-filenameeditorcpp","text":"File List > config > filenameeditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"filenameeditor.h\" #include \"src/config/strftimechooserwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include <QHBoxLayout> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QVBoxLayout> FileNameEditor::FileNameEditor(QWidget* parent) : QWidget(parent) { initWidgets(); initLayout(); } void FileNameEditor::initLayout() { m_layout = new QVBoxLayout(this); auto* infoLabel = new QLabel(tr(\"Edit the name of your captures:\"), this); infoLabel->setFixedHeight(20); m_layout->addWidget(infoLabel); m_layout->addWidget(m_helperButtons); m_layout->addWidget(new QLabel(tr(\"Edit:\"))); m_layout->addWidget(m_nameEditor); m_layout->addWidget(new QLabel(tr(\"Preview:\"))); m_layout->addWidget(m_outputLabel); auto* horizLayout = new QHBoxLayout(); horizLayout->addWidget(m_saveButton); horizLayout->addWidget(m_resetButton); horizLayout->addWidget(m_clearButton); m_layout->addLayout(horizLayout); } void FileNameEditor::initWidgets() { m_nameHandler = new FileNameHandler(this); // editor m_nameEditor = new QLineEdit(this); m_nameEditor->setMaxLength(FileNameHandler::MAX_CHARACTERS); // preview m_outputLabel = new QLineEdit(this); m_outputLabel->setDisabled(true); QString foreground = this->palette().windowText().color().name(); m_outputLabel->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); QPalette pal = m_outputLabel->palette(); QColor color = pal.color(QPalette::Disabled, m_outputLabel->backgroundRole()); pal.setColor(QPalette::Active, m_outputLabel->backgroundRole(), color); m_outputLabel->setPalette(pal); connect(m_nameEditor, &QLineEdit::textChanged, this, &FileNameEditor::showParsedPattern); updateComponents(); // helper buttons m_helperButtons = new StrftimeChooserWidget(this); connect(m_helperButtons, &StrftimeChooserWidget::variableEmitted, this, &FileNameEditor::addToNameEditor); // save m_saveButton = new QPushButton(tr(\"Save\"), this); connect( m_saveButton, &QPushButton::clicked, this, &FileNameEditor::savePattern); m_saveButton->setToolTip(tr(\"Saves the pattern\")); // restore previous saved values m_resetButton = new QPushButton(tr(\"Restore\"), this); connect( m_resetButton, &QPushButton::clicked, this, &FileNameEditor::resetName); m_resetButton->setToolTip(tr(\"Restores the saved pattern\")); // clear m_clearButton = new QPushButton(tr(\"Clear\"), this); connect(m_clearButton, &QPushButton::clicked, this, [this]() { m_nameEditor->setText(ConfigHandler().filenamePatternDefault()); m_nameEditor->selectAll(); m_nameEditor->setFocus(); }); m_clearButton->setToolTip(tr(\"Deletes the name\")); } void FileNameEditor::savePattern() { QString pattern = m_nameEditor->text(); ConfigHandler().setFilenamePattern(pattern); } void FileNameEditor::showParsedPattern(const QString& p) { QString output = m_nameHandler->parseFilename(p); m_outputLabel->setText(output); } void FileNameEditor::resetName() { m_nameEditor->setText(ConfigHandler().filenamePattern()); } void FileNameEditor::addToNameEditor(QString s) { m_nameEditor->setText(m_nameEditor->text() + s); m_nameEditor->setFocus(); } void FileNameEditor::updateComponents() { m_nameEditor->setText(ConfigHandler().filenamePattern()); m_outputLabel->setText(m_nameHandler->parsedPattern()); }","title":"File filenameeditor.cpp"},{"location":"flameshot/filenameeditor_8h/","text":"File filenameeditor.h # FileList > config > filenameeditor.h Go to the source code of this file. #include <QPointer> #include <QWidget> Classes # Type Name class FileNameEditor","title":"File filenameeditor.h"},{"location":"flameshot/filenameeditor_8h/#file-filenameeditorh","text":"FileList > config > filenameeditor.h Go to the source code of this file. #include <QPointer> #include <QWidget>","title":"File filenameeditor.h"},{"location":"flameshot/filenameeditor_8h/#classes","text":"Type Name class FileNameEditor","title":"Classes"},{"location":"flameshot/filenameeditor_8h_source/","text":"File filenameeditor.h # File List > config > filenameeditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPointer> #include <QWidget> class QVBoxLayout; class QLineEdit; class FileNameHandler; class QPushButton; class StrftimeChooserWidget; class FileNameEditor : public QWidget { Q_OBJECT public: explicit FileNameEditor(QWidget* parent = nullptr); private: QVBoxLayout* m_layout; QLineEdit* m_outputLabel; QLineEdit* m_nameEditor; FileNameHandler* m_nameHandler; StrftimeChooserWidget* m_helperButtons; QPushButton* m_saveButton; QPushButton* m_resetButton; QPushButton* m_clearButton; void initLayout(); void initWidgets(); public slots: void addToNameEditor(QString s); void updateComponents(); private slots: void savePattern(); void showParsedPattern(const QString&); void resetName(); };","title":"File filenameeditor.h"},{"location":"flameshot/filenameeditor_8h_source/#file-filenameeditorh","text":"File List > config > filenameeditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPointer> #include <QWidget> class QVBoxLayout; class QLineEdit; class FileNameHandler; class QPushButton; class StrftimeChooserWidget; class FileNameEditor : public QWidget { Q_OBJECT public: explicit FileNameEditor(QWidget* parent = nullptr); private: QVBoxLayout* m_layout; QLineEdit* m_outputLabel; QLineEdit* m_nameEditor; FileNameHandler* m_nameHandler; StrftimeChooserWidget* m_helperButtons; QPushButton* m_saveButton; QPushButton* m_resetButton; QPushButton* m_clearButton; void initLayout(); void initWidgets(); public slots: void addToNameEditor(QString s); void updateComponents(); private slots: void savePattern(); void showParsedPattern(const QString&); void resetName(); };","title":"File filenameeditor.h"},{"location":"flameshot/generalconf_8cpp/","text":"File generalconf.cpp # FileList > config > generalconf.cpp Go to the source code of this file. #include \"generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QCheckBox> #include <QComboBox> #include <QFile> #include <QFileDialog> #include <QGroupBox> #include <QImageWriter> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QSettings> #include <QSizePolicy> #include <QSpinBox> #include <QStandardPaths> #include <QTextCodec> #include <QVBoxLayout>","title":"File generalconf.cpp"},{"location":"flameshot/generalconf_8cpp/#file-generalconfcpp","text":"FileList > config > generalconf.cpp Go to the source code of this file. #include \"generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QCheckBox> #include <QComboBox> #include <QFile> #include <QFileDialog> #include <QGroupBox> #include <QImageWriter> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QSettings> #include <QSizePolicy> #include <QSpinBox> #include <QStandardPaths> #include <QTextCodec> #include <QVBoxLayout>","title":"File generalconf.cpp"},{"location":"flameshot/generalconf_8cpp_source/","text":"File generalconf.cpp # File List > config > generalconf.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QCheckBox> #include <QComboBox> #include <QFile> #include <QFileDialog> #include <QGroupBox> #include <QImageWriter> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QSettings> #include <QSizePolicy> #include <QSpinBox> #include <QStandardPaths> #include <QTextCodec> #include <QVBoxLayout> GeneralConf::GeneralConf(QWidget* parent) : QWidget(parent) , m_historyConfirmationToDelete(nullptr) , m_undoLimit(nullptr) { m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignTop); // Scroll area adapts the size of the content on small screens. // It must be initialized before the checkboxes. initScrollArea(); initAutostart(); #if !defined(Q_OS_WIN) initAutoCloseIdleDaemon(); #endif initShowTrayIcon(); initShowDesktopNotification(); #if !defined(DISABLE_UPDATE_CHECKER) initCheckForUpdates(); #endif initShowStartupLaunchMessage(); initAllowMultipleGuiInstances(); initSaveLastRegion(); initShowHelp(); initShowSidePanelButton(); initUseJpgForClipboard(); initCopyOnDoubleClick(); initSaveAfterCopy(); initCopyPathAfterSave(); initCopyAndCloseAfterUpload(); initUploadWithoutConfirmation(); initHistoryConfirmationToDelete(); initAntialiasingPinZoom(); initUploadHistoryMax(); initUndoLimit(); initUploadClientSecret(); initPredefinedColorPaletteLarge(); initShowSelectionGeometry(); m_layout->addStretch(); initShowMagnifier(); initSquareMagnifier(); // this has to be at the end initConfigButtons(); updateComponents(); } void GeneralConf::_updateComponents(bool allowEmptySavePath) { ConfigHandler config; m_helpMessage->setChecked(config.showHelp()); m_sidePanelButton->setChecked(config.showSidePanelButton()); m_sysNotifications->setChecked(config.showDesktopNotification()); m_autostart->setChecked(config.startupLaunch()); m_copyURLAfterUpload->setChecked(config.copyURLAfterUpload()); m_saveAfterCopy->setChecked(config.saveAfterCopy()); m_copyPathAfterSave->setChecked(config.copyPathAfterSave()); m_antialiasingPinZoom->setChecked(config.antialiasingPinZoom()); m_useJpgForClipboard->setChecked(config.useJpgForClipboard()); m_copyOnDoubleClick->setChecked(config.copyOnDoubleClick()); m_uploadWithoutConfirmation->setChecked(config.uploadWithoutConfirmation()); m_historyConfirmationToDelete->setChecked( config.historyConfirmationToDelete()); #if !defined(DISABLE_UPDATE_CHECKER) m_checkForUpdates->setChecked(config.checkForUpdates()); #endif m_allowMultipleGuiInstances->setChecked(config.allowMultipleGuiInstances()); m_showMagnifier->setChecked(config.showMagnifier()); m_squareMagnifier->setChecked(config.squareMagnifier()); m_saveLastRegion->setChecked(config.saveLastRegion()); #if !defined(Q_OS_WIN) m_autoCloseIdleDaemon->setChecked(config.autoCloseIdleDaemon()); #endif m_predefinedColorPaletteLarge->setChecked( config.predefinedColorPaletteLarge()); m_showStartupLaunchMessage->setChecked(config.showStartupLaunchMessage()); m_screenshotPathFixedCheck->setChecked(config.savePathFixed()); m_uploadHistoryMax->setValue(config.uploadHistoryMax()); m_undoLimit->setValue(config.undoLimit()); if (allowEmptySavePath || !config.savePath().isEmpty()) { m_savePath->setText(config.savePath()); } #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) m_showTray->setChecked(!config.disabledTrayIcon()); #endif } void GeneralConf::updateComponents() { _updateComponents(false); } void GeneralConf::saveLastRegion(bool checked) { ConfigHandler().setSaveLastRegion(checked); } void GeneralConf::showHelpChanged(bool checked) { ConfigHandler().setShowHelp(checked); } void GeneralConf::showSidePanelButtonChanged(bool checked) { ConfigHandler().setShowSidePanelButton(checked); } void GeneralConf::showDesktopNotificationChanged(bool checked) { ConfigHandler().setShowDesktopNotification(checked); } #if !defined(DISABLE_UPDATE_CHECKER) void GeneralConf::checkForUpdatesChanged(bool checked) { ConfigHandler().setCheckForUpdates(checked); } #endif void GeneralConf::allowMultipleGuiInstancesChanged(bool checked) { ConfigHandler().setAllowMultipleGuiInstances(checked); } void GeneralConf::autoCloseIdleDaemonChanged(bool checked) { ConfigHandler().setAutoCloseIdleDaemon(checked); } void GeneralConf::autostartChanged(bool checked) { ConfigHandler().setStartupLaunch(checked); } void GeneralConf::importConfiguration() { QString fileName = QFileDialog::getOpenFileName(this, tr(\"Import\")); if (fileName.isEmpty()) { return; } QFile file(fileName); QTextCodec* codec = QTextCodec::codecForLocale(); if (!file.open(QFile::ReadOnly)) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to read file.\")); return; } QString text = codec->toUnicode(file.readAll()); file.close(); QFile config(ConfigHandler().configFilePath()); if (!config.open(QFile::WriteOnly)) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\")); return; } config.write(codec->fromUnicode(text)); config.close(); } void GeneralConf::exportFileConfiguration() { QString defaultFileName = QSettings().fileName(); QString fileName = QFileDialog::getSaveFileName(this, tr(\"Save File\"), defaultFileName); // Cancel button or target same as source if (fileName.isNull() || fileName == defaultFileName) { return; } QFile targetFile(fileName); if (targetFile.exists()) { targetFile.remove(); } bool ok = QFile::copy(ConfigHandler().configFilePath(), fileName); if (!ok) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\")); } } void GeneralConf::resetConfiguration() { QMessageBox::StandardButton reply; reply = QMessageBox::question( this, tr(\"Confirm Reset\"), tr(\"Are you sure you want to reset the configuration?\"), QMessageBox::Yes | QMessageBox::No); if (reply == QMessageBox::Yes) { m_savePath->setText( QStandardPaths::writableLocation(QStandardPaths::PicturesLocation)); ConfigHandler().setDefaultSettings(); _updateComponents(true); } } void GeneralConf::initScrollArea() { m_scrollArea = new QScrollArea(this); m_layout->addWidget(m_scrollArea); auto* content = new QWidget(m_scrollArea); m_scrollArea->setWidget(content); m_scrollArea->setWidgetResizable(true); m_scrollArea->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum); m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); content->setObjectName(\"content\"); m_scrollArea->setObjectName(\"scrollArea\"); m_scrollArea->setStyleSheet( \"#content, #scrollArea { background: transparent; border: 0px; }\"); m_scrollAreaLayout = new QVBoxLayout(content); m_scrollAreaLayout->setContentsMargins(0, 0, 20, 0); } void GeneralConf::initShowHelp() { m_helpMessage = new QCheckBox(tr(\"Show help message\"), this); m_helpMessage->setToolTip(tr(\"Show the help message at the beginning \" \"in the capture mode\")); m_scrollAreaLayout->addWidget(m_helpMessage); connect( m_helpMessage, &QCheckBox::clicked, this, &GeneralConf::showHelpChanged); } void GeneralConf::initSaveLastRegion() { m_saveLastRegion = new QCheckBox(tr(\"Use last region\"), this); m_saveLastRegion->setToolTip(tr(\"Uses the last region as the default \" \"selection for the next screenshot\")); m_scrollAreaLayout->addWidget(m_saveLastRegion); connect(m_saveLastRegion, &QCheckBox::clicked, this, &GeneralConf::saveLastRegion); } void GeneralConf::initShowSidePanelButton() { m_sidePanelButton = new QCheckBox(tr(\"Show the side panel button\"), this); m_sidePanelButton->setToolTip( tr(\"Show the side panel toggle button in the capture mode\")); m_scrollAreaLayout->addWidget(m_sidePanelButton); connect(m_sidePanelButton, &QCheckBox::clicked, this, &GeneralConf::showSidePanelButtonChanged); } void GeneralConf::initShowDesktopNotification() { m_sysNotifications = new QCheckBox(tr(\"Show desktop notifications\"), this); m_sysNotifications->setToolTip(tr(\"Enable desktop notifications\")); m_scrollAreaLayout->addWidget(m_sysNotifications); connect(m_sysNotifications, &QCheckBox::clicked, this, &GeneralConf::showDesktopNotificationChanged); } void GeneralConf::initShowTrayIcon() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) m_showTray = new QCheckBox(tr(\"Show tray icon\"), this); m_showTray->setToolTip(tr(\"Show icon in the system tray\")); m_scrollAreaLayout->addWidget(m_showTray); connect(m_showTray, &QCheckBox::clicked, this, [](bool checked) { ConfigHandler().setDisabledTrayIcon(!checked); }); #endif } void GeneralConf::initHistoryConfirmationToDelete() { m_historyConfirmationToDelete = new QCheckBox( tr(\"Confirmation required to delete screenshot from the latest uploads\"), this); m_historyConfirmationToDelete->setToolTip( tr(\"Ask for confirmation to delete screenshot from the latest uploads\")); m_scrollAreaLayout->addWidget(m_historyConfirmationToDelete); connect(m_historyConfirmationToDelete, &QCheckBox::clicked, this, &GeneralConf::historyConfirmationToDelete); } void GeneralConf::initConfigButtons() { auto* buttonLayout = new QHBoxLayout(); auto* box = new QGroupBox(tr(\"Configuration File\")); box->setFlat(true); box->setLayout(buttonLayout); m_layout->addWidget(box); m_exportButton = new QPushButton(tr(\"Export\")); buttonLayout->addWidget(m_exportButton); connect(m_exportButton, &QPushButton::clicked, this, &GeneralConf::exportFileConfiguration); m_importButton = new QPushButton(tr(\"Import\")); buttonLayout->addWidget(m_importButton); connect(m_importButton, &QPushButton::clicked, this, &GeneralConf::importConfiguration); m_resetButton = new QPushButton(tr(\"Reset\")); buttonLayout->addWidget(m_resetButton); connect(m_resetButton, &QPushButton::clicked, this, &GeneralConf::resetConfiguration); } #if !defined(DISABLE_UPDATE_CHECKER) void GeneralConf::initCheckForUpdates() { m_checkForUpdates = new QCheckBox(tr(\"Automatic check for updates\"), this); m_checkForUpdates->setToolTip(tr(\"Check for updates automatically\")); m_scrollAreaLayout->addWidget(m_checkForUpdates); connect(m_checkForUpdates, &QCheckBox::clicked, this, &GeneralConf::checkForUpdatesChanged); } #endif void GeneralConf::initAllowMultipleGuiInstances() { m_allowMultipleGuiInstances = new QCheckBox( tr(\"Allow multiple flameshot GUI instances simultaneously\"), this); m_allowMultipleGuiInstances->setToolTip(tr( \"This allows you to take screenshots of Flameshot itself for example\")); m_scrollAreaLayout->addWidget(m_allowMultipleGuiInstances); connect(m_allowMultipleGuiInstances, &QCheckBox::clicked, this, &GeneralConf::allowMultipleGuiInstancesChanged); } void GeneralConf::initAutoCloseIdleDaemon() { m_autoCloseIdleDaemon = new QCheckBox( tr(\"Automatically unload from memory when it is not needed\"), this); m_autoCloseIdleDaemon->setToolTip(tr( \"Automatically close daemon (background process) when it is not needed\")); m_scrollAreaLayout->addWidget(m_autoCloseIdleDaemon); connect(m_autoCloseIdleDaemon, &QCheckBox::clicked, this, &GeneralConf::autoCloseIdleDaemonChanged); } void GeneralConf::initAutostart() { m_autostart = new QCheckBox(tr(\"Launch in background at startup\"), this); m_autostart->setToolTip(tr( \"Launch Flameshot daemon (background process) when computer is booted\")); m_scrollAreaLayout->addWidget(m_autostart); connect( m_autostart, &QCheckBox::clicked, this, &GeneralConf::autostartChanged); } void GeneralConf::initShowStartupLaunchMessage() { m_showStartupLaunchMessage = new QCheckBox(tr(\"Show welcome message on launch\"), this); ConfigHandler config; m_showStartupLaunchMessage->setToolTip( tr(\"Show the welcome message box in the middle of the screen while \" \"taking a screenshot\")); m_scrollAreaLayout->addWidget(m_showStartupLaunchMessage); connect(m_showStartupLaunchMessage, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setShowStartupLaunchMessage(checked); }); } void GeneralConf::initPredefinedColorPaletteLarge() { m_predefinedColorPaletteLarge = new QCheckBox(tr(\"Use large predefined color palette\"), this); m_predefinedColorPaletteLarge->setToolTip( tr(\"Use a large predefined color palette\")); m_scrollAreaLayout->addWidget(m_predefinedColorPaletteLarge); connect( m_predefinedColorPaletteLarge, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setPredefinedColorPaletteLarge(checked); }); } void GeneralConf::initCopyOnDoubleClick() { m_copyOnDoubleClick = new QCheckBox(tr(\"Copy on double click\"), this); m_copyOnDoubleClick->setToolTip( tr(\"Enable Copy to clipboard on Double Click\")); m_scrollAreaLayout->addWidget(m_copyOnDoubleClick); connect(m_copyOnDoubleClick, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyOnDoubleClick(checked); }); } void GeneralConf::initCopyAndCloseAfterUpload() { m_copyURLAfterUpload = new QCheckBox(tr(\"Copy URL after upload\"), this); m_copyURLAfterUpload->setToolTip( tr(\"Copy URL after uploading was successful\")); m_scrollAreaLayout->addWidget(m_copyURLAfterUpload); connect(m_copyURLAfterUpload, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyURLAfterUpload(checked); }); } void GeneralConf::initSaveAfterCopy() { m_saveAfterCopy = new QCheckBox(tr(\"Save image after copy\"), this); m_saveAfterCopy->setToolTip( tr(\"After copying the screenshot, save it to a file as well\")); m_scrollAreaLayout->addWidget(m_saveAfterCopy); connect(m_saveAfterCopy, &QCheckBox::clicked, this, &GeneralConf::saveAfterCopyChanged); auto* box = new QGroupBox(tr(\"Save Path\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); auto* pathLayout = new QHBoxLayout(); QString path = ConfigHandler().savePath(); m_savePath = new QLineEdit(path, this); m_savePath->setDisabled(true); QString foreground = this->palette().windowText().color().name(); m_savePath->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); pathLayout->addWidget(m_savePath); m_changeSaveButton = new QPushButton(tr(\"Change...\"), this); pathLayout->addWidget(m_changeSaveButton); connect(m_changeSaveButton, &QPushButton::clicked, this, &GeneralConf::changeSavePath); m_screenshotPathFixedCheck = new QCheckBox(tr(\"Use fixed path for screenshots to save\"), this); connect(m_screenshotPathFixedCheck, SIGNAL(toggled(bool)), this, SLOT(togglePathFixed())); vboxLayout->addLayout(pathLayout); vboxLayout->addWidget(m_screenshotPathFixedCheck); auto* extensionLayout = new QHBoxLayout(); extensionLayout->addWidget( new QLabel(tr(\"Preferred save file extension:\"))); m_setSaveAsFileExtension = new QComboBox(this); QStringList imageFormatList; foreach (auto mimeType, QImageWriter::supportedImageFormats()) imageFormatList.append(mimeType); m_setSaveAsFileExtension->addItems(imageFormatList); int currentIndex = m_setSaveAsFileExtension->findText(ConfigHandler().saveAsFileExtension()); m_setSaveAsFileExtension->setCurrentIndex(currentIndex); connect(m_setSaveAsFileExtension, SIGNAL(currentTextChanged(QString)), this, SLOT(setSaveAsFileExtension(QString))); extensionLayout->addWidget(m_setSaveAsFileExtension); vboxLayout->addLayout(extensionLayout); } void GeneralConf::historyConfirmationToDelete(bool checked) { ConfigHandler().setHistoryConfirmationToDelete(checked); } void GeneralConf::initUploadHistoryMax() { auto* box = new QGroupBox(tr(\"Latest Uploads Max Size\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_uploadHistoryMax = new QSpinBox(this); m_uploadHistoryMax->setMaximum(50); QString foreground = this->palette().windowText().color().name(); m_uploadHistoryMax->setStyleSheet( QStringLiteral(\"color: %1\").arg(foreground)); connect(m_uploadHistoryMax, SIGNAL(valueChanged(int)), this, SLOT(uploadHistoryMaxChanged(int))); vboxLayout->addWidget(m_uploadHistoryMax); } void GeneralConf::initUploadClientSecret() { auto* box = new QGroupBox(tr(\"Imgur Application Client ID\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_uploadClientKey = new QLineEdit(this); QString foreground = this->palette().windowText().color().name(); m_uploadClientKey->setStyleSheet( QStringLiteral(\"color: %1\").arg(foreground)); m_uploadClientKey->setText(ConfigHandler().uploadClientSecret()); connect(m_uploadClientKey, SIGNAL(editingFinished()), this, SLOT(uploadClientKeyEdited())); vboxLayout->addWidget(m_uploadClientKey); } void GeneralConf::uploadClientKeyEdited() { ConfigHandler().setUploadClientSecret(m_uploadClientKey->text()); } void GeneralConf::uploadHistoryMaxChanged(int max) { ConfigHandler().setUploadHistoryMax(max); } void GeneralConf::initUndoLimit() { auto* box = new QGroupBox(tr(\"Undo limit\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_undoLimit = new QSpinBox(this); m_undoLimit->setMinimum(1); m_undoLimit->setMaximum(999); QString foreground = this->palette().windowText().color().name(); m_undoLimit->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); connect(m_undoLimit, SIGNAL(valueChanged(int)), this, SLOT(undoLimit(int))); vboxLayout->addWidget(m_undoLimit); } void GeneralConf::undoLimit(int limit) { ConfigHandler().setUndoLimit(limit); } void GeneralConf::initUseJpgForClipboard() { m_useJpgForClipboard = new QCheckBox(tr(\"Use JPG format for clipboard (PNG default)\"), this); m_useJpgForClipboard->setToolTip( tr(\"Use lossy JPG format for clipboard (lossless PNG default)\")); m_scrollAreaLayout->addWidget(m_useJpgForClipboard); #if defined(Q_OS_MACOS) // FIXME - temporary fix to disable option for MacOS m_useJpgForClipboard->hide(); #endif connect(m_useJpgForClipboard, &QCheckBox::clicked, this, &GeneralConf::useJpgForClipboardChanged); } void GeneralConf::saveAfterCopyChanged(bool checked) { ConfigHandler().setSaveAfterCopy(checked); } void GeneralConf::changeSavePath() { QString path = ConfigHandler().savePath(); path = chooseFolder(path); if (!path.isEmpty()) { m_savePath->setText(path); ConfigHandler().setSavePath(path); } } void GeneralConf::initCopyPathAfterSave() { m_copyPathAfterSave = new QCheckBox(tr(\"Copy file path after save\"), this); m_copyPathAfterSave->setToolTip(tr(\"Copy the file path to clipboard after \" \"the file is saved\")); m_scrollAreaLayout->addWidget(m_copyPathAfterSave); connect(m_copyPathAfterSave, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyPathAfterSave(checked); }); } void GeneralConf::initAntialiasingPinZoom() { m_antialiasingPinZoom = new QCheckBox(tr(\"Anti-aliasing image when zoom the pinned image\"), this); m_antialiasingPinZoom->setToolTip( tr(\"After zooming the pinned image, should the image get smoothened or \" \"stay pixelated\")); m_scrollAreaLayout->addWidget(m_antialiasingPinZoom); connect(m_antialiasingPinZoom, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setAntialiasingPinZoom(checked); }); } void GeneralConf::initUploadWithoutConfirmation() { m_uploadWithoutConfirmation = new QCheckBox(tr(\"Upload image without confirmation\"), this); m_uploadWithoutConfirmation->setToolTip( tr(\"Upload image without confirmation\")); m_scrollAreaLayout->addWidget(m_uploadWithoutConfirmation); connect(m_uploadWithoutConfirmation, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setUploadWithoutConfirmation(checked); }); } const QString GeneralConf::chooseFolder(const QString pathDefault) { QString path; if (pathDefault.isEmpty()) { path = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); } path = QFileDialog::getExistingDirectory( this, tr(\"Choose a Folder\"), path, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks); if (path.isEmpty()) { return path; } if (!path.isEmpty()) { if (!QFileInfo(path).isWritable()) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to write to directory.\")); return QString(); } } return path; } void GeneralConf::initShowMagnifier() { m_showMagnifier = new QCheckBox(tr(\"Show magnifier\"), this); m_showMagnifier->setToolTip(tr(\"Enable a magnifier while selecting the \" \"screenshot area\")); m_scrollAreaLayout->addWidget(m_showMagnifier); connect(m_showMagnifier, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setShowMagnifier(checked); }); } void GeneralConf::initSquareMagnifier() { m_squareMagnifier = new QCheckBox(tr(\"Square shaped magnifier\"), this); m_squareMagnifier->setToolTip(tr(\"Make the magnifier to be square-shaped\")); m_scrollAreaLayout->addWidget(m_squareMagnifier); connect(m_squareMagnifier, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setSquareMagnifier(checked); }); } void GeneralConf::initShowSelectionGeometry() { auto* tobox = new QHBoxLayout(); int timeout = ConfigHandler().value(\"showSelectionGeometryHideTime\").toInt(); m_xywhTimeout = new QSpinBox(); m_xywhTimeout->setRange(0, INT_MAX); m_xywhTimeout->setToolTip( tr(\"Milliseconds before geometry display hides; 0 means do not hide\")); m_xywhTimeout->setValue(timeout); tobox->addWidget(m_xywhTimeout); tobox->addWidget(new QLabel(tr(\"Set geometry display timeout (ms)\"))); m_scrollAreaLayout->addLayout(tobox); connect(m_xywhTimeout, SIGNAL(valueChanged(int)), this, SLOT(setSelGeoHideTime(int))); auto* box = new QGroupBox(tr(\"Selection Geometry Display\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); auto* selGeoLayout = new QHBoxLayout(); selGeoLayout->addWidget(new QLabel(tr(\"Display Location\"))); m_selectGeometryLocation = new QComboBox(this); m_selectGeometryLocation->addItem(tr(\"None\"), GeneralConf::xywh_none); m_selectGeometryLocation->addItem(tr(\"Top Left\"), GeneralConf::xywh_top_left); m_selectGeometryLocation->addItem(tr(\"Top Right\"), GeneralConf::xywh_top_right); m_selectGeometryLocation->addItem(tr(\"Bottom Left\"), GeneralConf::xywh_bottom_left); m_selectGeometryLocation->addItem(tr(\"Bottom Right\"), GeneralConf::xywh_bottom_right); m_selectGeometryLocation->addItem(tr(\"Center\"), GeneralConf::xywh_center); // pick up int from config and use findData int pos = ConfigHandler().value(\"showSelectionGeometry\").toInt(); m_selectGeometryLocation->setCurrentIndex( m_selectGeometryLocation->findData(pos)); connect(m_selectGeometryLocation, SIGNAL(currentIndexChanged(int)), this, SLOT(setGeometryLocation(int))); selGeoLayout->addWidget(m_selectGeometryLocation); vboxLayout->addLayout(selGeoLayout); vboxLayout->addStretch(); } void GeneralConf::setSelGeoHideTime(int v) { ConfigHandler().setValue(\"showSelectionGeometryHideTime\", v); } void GeneralConf::setGeometryLocation(int index) { ConfigHandler().setValue(\"showSelectionGeometry\", m_selectGeometryLocation->itemData(index)); } void GeneralConf::togglePathFixed() { ConfigHandler().setSavePathFixed(m_screenshotPathFixedCheck->isChecked()); } void GeneralConf::setSaveAsFileExtension(QString extension) { ConfigHandler().setSaveAsFileExtension(extension); } void GeneralConf::useJpgForClipboardChanged(bool checked) { ConfigHandler().setUseJpgForClipboard(checked); }","title":"File generalconf.cpp"},{"location":"flameshot/generalconf_8cpp_source/#file-generalconfcpp","text":"File List > config > generalconf.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QCheckBox> #include <QComboBox> #include <QFile> #include <QFileDialog> #include <QGroupBox> #include <QImageWriter> #include <QLabel> #include <QLineEdit> #include <QMessageBox> #include <QPushButton> #include <QSettings> #include <QSizePolicy> #include <QSpinBox> #include <QStandardPaths> #include <QTextCodec> #include <QVBoxLayout> GeneralConf::GeneralConf(QWidget* parent) : QWidget(parent) , m_historyConfirmationToDelete(nullptr) , m_undoLimit(nullptr) { m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignTop); // Scroll area adapts the size of the content on small screens. // It must be initialized before the checkboxes. initScrollArea(); initAutostart(); #if !defined(Q_OS_WIN) initAutoCloseIdleDaemon(); #endif initShowTrayIcon(); initShowDesktopNotification(); #if !defined(DISABLE_UPDATE_CHECKER) initCheckForUpdates(); #endif initShowStartupLaunchMessage(); initAllowMultipleGuiInstances(); initSaveLastRegion(); initShowHelp(); initShowSidePanelButton(); initUseJpgForClipboard(); initCopyOnDoubleClick(); initSaveAfterCopy(); initCopyPathAfterSave(); initCopyAndCloseAfterUpload(); initUploadWithoutConfirmation(); initHistoryConfirmationToDelete(); initAntialiasingPinZoom(); initUploadHistoryMax(); initUndoLimit(); initUploadClientSecret(); initPredefinedColorPaletteLarge(); initShowSelectionGeometry(); m_layout->addStretch(); initShowMagnifier(); initSquareMagnifier(); // this has to be at the end initConfigButtons(); updateComponents(); } void GeneralConf::_updateComponents(bool allowEmptySavePath) { ConfigHandler config; m_helpMessage->setChecked(config.showHelp()); m_sidePanelButton->setChecked(config.showSidePanelButton()); m_sysNotifications->setChecked(config.showDesktopNotification()); m_autostart->setChecked(config.startupLaunch()); m_copyURLAfterUpload->setChecked(config.copyURLAfterUpload()); m_saveAfterCopy->setChecked(config.saveAfterCopy()); m_copyPathAfterSave->setChecked(config.copyPathAfterSave()); m_antialiasingPinZoom->setChecked(config.antialiasingPinZoom()); m_useJpgForClipboard->setChecked(config.useJpgForClipboard()); m_copyOnDoubleClick->setChecked(config.copyOnDoubleClick()); m_uploadWithoutConfirmation->setChecked(config.uploadWithoutConfirmation()); m_historyConfirmationToDelete->setChecked( config.historyConfirmationToDelete()); #if !defined(DISABLE_UPDATE_CHECKER) m_checkForUpdates->setChecked(config.checkForUpdates()); #endif m_allowMultipleGuiInstances->setChecked(config.allowMultipleGuiInstances()); m_showMagnifier->setChecked(config.showMagnifier()); m_squareMagnifier->setChecked(config.squareMagnifier()); m_saveLastRegion->setChecked(config.saveLastRegion()); #if !defined(Q_OS_WIN) m_autoCloseIdleDaemon->setChecked(config.autoCloseIdleDaemon()); #endif m_predefinedColorPaletteLarge->setChecked( config.predefinedColorPaletteLarge()); m_showStartupLaunchMessage->setChecked(config.showStartupLaunchMessage()); m_screenshotPathFixedCheck->setChecked(config.savePathFixed()); m_uploadHistoryMax->setValue(config.uploadHistoryMax()); m_undoLimit->setValue(config.undoLimit()); if (allowEmptySavePath || !config.savePath().isEmpty()) { m_savePath->setText(config.savePath()); } #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) m_showTray->setChecked(!config.disabledTrayIcon()); #endif } void GeneralConf::updateComponents() { _updateComponents(false); } void GeneralConf::saveLastRegion(bool checked) { ConfigHandler().setSaveLastRegion(checked); } void GeneralConf::showHelpChanged(bool checked) { ConfigHandler().setShowHelp(checked); } void GeneralConf::showSidePanelButtonChanged(bool checked) { ConfigHandler().setShowSidePanelButton(checked); } void GeneralConf::showDesktopNotificationChanged(bool checked) { ConfigHandler().setShowDesktopNotification(checked); } #if !defined(DISABLE_UPDATE_CHECKER) void GeneralConf::checkForUpdatesChanged(bool checked) { ConfigHandler().setCheckForUpdates(checked); } #endif void GeneralConf::allowMultipleGuiInstancesChanged(bool checked) { ConfigHandler().setAllowMultipleGuiInstances(checked); } void GeneralConf::autoCloseIdleDaemonChanged(bool checked) { ConfigHandler().setAutoCloseIdleDaemon(checked); } void GeneralConf::autostartChanged(bool checked) { ConfigHandler().setStartupLaunch(checked); } void GeneralConf::importConfiguration() { QString fileName = QFileDialog::getOpenFileName(this, tr(\"Import\")); if (fileName.isEmpty()) { return; } QFile file(fileName); QTextCodec* codec = QTextCodec::codecForLocale(); if (!file.open(QFile::ReadOnly)) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to read file.\")); return; } QString text = codec->toUnicode(file.readAll()); file.close(); QFile config(ConfigHandler().configFilePath()); if (!config.open(QFile::WriteOnly)) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\")); return; } config.write(codec->fromUnicode(text)); config.close(); } void GeneralConf::exportFileConfiguration() { QString defaultFileName = QSettings().fileName(); QString fileName = QFileDialog::getSaveFileName(this, tr(\"Save File\"), defaultFileName); // Cancel button or target same as source if (fileName.isNull() || fileName == defaultFileName) { return; } QFile targetFile(fileName); if (targetFile.exists()) { targetFile.remove(); } bool ok = QFile::copy(ConfigHandler().configFilePath(), fileName); if (!ok) { QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\")); } } void GeneralConf::resetConfiguration() { QMessageBox::StandardButton reply; reply = QMessageBox::question( this, tr(\"Confirm Reset\"), tr(\"Are you sure you want to reset the configuration?\"), QMessageBox::Yes | QMessageBox::No); if (reply == QMessageBox::Yes) { m_savePath->setText( QStandardPaths::writableLocation(QStandardPaths::PicturesLocation)); ConfigHandler().setDefaultSettings(); _updateComponents(true); } } void GeneralConf::initScrollArea() { m_scrollArea = new QScrollArea(this); m_layout->addWidget(m_scrollArea); auto* content = new QWidget(m_scrollArea); m_scrollArea->setWidget(content); m_scrollArea->setWidgetResizable(true); m_scrollArea->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum); m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); content->setObjectName(\"content\"); m_scrollArea->setObjectName(\"scrollArea\"); m_scrollArea->setStyleSheet( \"#content, #scrollArea { background: transparent; border: 0px; }\"); m_scrollAreaLayout = new QVBoxLayout(content); m_scrollAreaLayout->setContentsMargins(0, 0, 20, 0); } void GeneralConf::initShowHelp() { m_helpMessage = new QCheckBox(tr(\"Show help message\"), this); m_helpMessage->setToolTip(tr(\"Show the help message at the beginning \" \"in the capture mode\")); m_scrollAreaLayout->addWidget(m_helpMessage); connect( m_helpMessage, &QCheckBox::clicked, this, &GeneralConf::showHelpChanged); } void GeneralConf::initSaveLastRegion() { m_saveLastRegion = new QCheckBox(tr(\"Use last region\"), this); m_saveLastRegion->setToolTip(tr(\"Uses the last region as the default \" \"selection for the next screenshot\")); m_scrollAreaLayout->addWidget(m_saveLastRegion); connect(m_saveLastRegion, &QCheckBox::clicked, this, &GeneralConf::saveLastRegion); } void GeneralConf::initShowSidePanelButton() { m_sidePanelButton = new QCheckBox(tr(\"Show the side panel button\"), this); m_sidePanelButton->setToolTip( tr(\"Show the side panel toggle button in the capture mode\")); m_scrollAreaLayout->addWidget(m_sidePanelButton); connect(m_sidePanelButton, &QCheckBox::clicked, this, &GeneralConf::showSidePanelButtonChanged); } void GeneralConf::initShowDesktopNotification() { m_sysNotifications = new QCheckBox(tr(\"Show desktop notifications\"), this); m_sysNotifications->setToolTip(tr(\"Enable desktop notifications\")); m_scrollAreaLayout->addWidget(m_sysNotifications); connect(m_sysNotifications, &QCheckBox::clicked, this, &GeneralConf::showDesktopNotificationChanged); } void GeneralConf::initShowTrayIcon() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) m_showTray = new QCheckBox(tr(\"Show tray icon\"), this); m_showTray->setToolTip(tr(\"Show icon in the system tray\")); m_scrollAreaLayout->addWidget(m_showTray); connect(m_showTray, &QCheckBox::clicked, this, [](bool checked) { ConfigHandler().setDisabledTrayIcon(!checked); }); #endif } void GeneralConf::initHistoryConfirmationToDelete() { m_historyConfirmationToDelete = new QCheckBox( tr(\"Confirmation required to delete screenshot from the latest uploads\"), this); m_historyConfirmationToDelete->setToolTip( tr(\"Ask for confirmation to delete screenshot from the latest uploads\")); m_scrollAreaLayout->addWidget(m_historyConfirmationToDelete); connect(m_historyConfirmationToDelete, &QCheckBox::clicked, this, &GeneralConf::historyConfirmationToDelete); } void GeneralConf::initConfigButtons() { auto* buttonLayout = new QHBoxLayout(); auto* box = new QGroupBox(tr(\"Configuration File\")); box->setFlat(true); box->setLayout(buttonLayout); m_layout->addWidget(box); m_exportButton = new QPushButton(tr(\"Export\")); buttonLayout->addWidget(m_exportButton); connect(m_exportButton, &QPushButton::clicked, this, &GeneralConf::exportFileConfiguration); m_importButton = new QPushButton(tr(\"Import\")); buttonLayout->addWidget(m_importButton); connect(m_importButton, &QPushButton::clicked, this, &GeneralConf::importConfiguration); m_resetButton = new QPushButton(tr(\"Reset\")); buttonLayout->addWidget(m_resetButton); connect(m_resetButton, &QPushButton::clicked, this, &GeneralConf::resetConfiguration); } #if !defined(DISABLE_UPDATE_CHECKER) void GeneralConf::initCheckForUpdates() { m_checkForUpdates = new QCheckBox(tr(\"Automatic check for updates\"), this); m_checkForUpdates->setToolTip(tr(\"Check for updates automatically\")); m_scrollAreaLayout->addWidget(m_checkForUpdates); connect(m_checkForUpdates, &QCheckBox::clicked, this, &GeneralConf::checkForUpdatesChanged); } #endif void GeneralConf::initAllowMultipleGuiInstances() { m_allowMultipleGuiInstances = new QCheckBox( tr(\"Allow multiple flameshot GUI instances simultaneously\"), this); m_allowMultipleGuiInstances->setToolTip(tr( \"This allows you to take screenshots of Flameshot itself for example\")); m_scrollAreaLayout->addWidget(m_allowMultipleGuiInstances); connect(m_allowMultipleGuiInstances, &QCheckBox::clicked, this, &GeneralConf::allowMultipleGuiInstancesChanged); } void GeneralConf::initAutoCloseIdleDaemon() { m_autoCloseIdleDaemon = new QCheckBox( tr(\"Automatically unload from memory when it is not needed\"), this); m_autoCloseIdleDaemon->setToolTip(tr( \"Automatically close daemon (background process) when it is not needed\")); m_scrollAreaLayout->addWidget(m_autoCloseIdleDaemon); connect(m_autoCloseIdleDaemon, &QCheckBox::clicked, this, &GeneralConf::autoCloseIdleDaemonChanged); } void GeneralConf::initAutostart() { m_autostart = new QCheckBox(tr(\"Launch in background at startup\"), this); m_autostart->setToolTip(tr( \"Launch Flameshot daemon (background process) when computer is booted\")); m_scrollAreaLayout->addWidget(m_autostart); connect( m_autostart, &QCheckBox::clicked, this, &GeneralConf::autostartChanged); } void GeneralConf::initShowStartupLaunchMessage() { m_showStartupLaunchMessage = new QCheckBox(tr(\"Show welcome message on launch\"), this); ConfigHandler config; m_showStartupLaunchMessage->setToolTip( tr(\"Show the welcome message box in the middle of the screen while \" \"taking a screenshot\")); m_scrollAreaLayout->addWidget(m_showStartupLaunchMessage); connect(m_showStartupLaunchMessage, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setShowStartupLaunchMessage(checked); }); } void GeneralConf::initPredefinedColorPaletteLarge() { m_predefinedColorPaletteLarge = new QCheckBox(tr(\"Use large predefined color palette\"), this); m_predefinedColorPaletteLarge->setToolTip( tr(\"Use a large predefined color palette\")); m_scrollAreaLayout->addWidget(m_predefinedColorPaletteLarge); connect( m_predefinedColorPaletteLarge, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setPredefinedColorPaletteLarge(checked); }); } void GeneralConf::initCopyOnDoubleClick() { m_copyOnDoubleClick = new QCheckBox(tr(\"Copy on double click\"), this); m_copyOnDoubleClick->setToolTip( tr(\"Enable Copy to clipboard on Double Click\")); m_scrollAreaLayout->addWidget(m_copyOnDoubleClick); connect(m_copyOnDoubleClick, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyOnDoubleClick(checked); }); } void GeneralConf::initCopyAndCloseAfterUpload() { m_copyURLAfterUpload = new QCheckBox(tr(\"Copy URL after upload\"), this); m_copyURLAfterUpload->setToolTip( tr(\"Copy URL after uploading was successful\")); m_scrollAreaLayout->addWidget(m_copyURLAfterUpload); connect(m_copyURLAfterUpload, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyURLAfterUpload(checked); }); } void GeneralConf::initSaveAfterCopy() { m_saveAfterCopy = new QCheckBox(tr(\"Save image after copy\"), this); m_saveAfterCopy->setToolTip( tr(\"After copying the screenshot, save it to a file as well\")); m_scrollAreaLayout->addWidget(m_saveAfterCopy); connect(m_saveAfterCopy, &QCheckBox::clicked, this, &GeneralConf::saveAfterCopyChanged); auto* box = new QGroupBox(tr(\"Save Path\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); auto* pathLayout = new QHBoxLayout(); QString path = ConfigHandler().savePath(); m_savePath = new QLineEdit(path, this); m_savePath->setDisabled(true); QString foreground = this->palette().windowText().color().name(); m_savePath->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); pathLayout->addWidget(m_savePath); m_changeSaveButton = new QPushButton(tr(\"Change...\"), this); pathLayout->addWidget(m_changeSaveButton); connect(m_changeSaveButton, &QPushButton::clicked, this, &GeneralConf::changeSavePath); m_screenshotPathFixedCheck = new QCheckBox(tr(\"Use fixed path for screenshots to save\"), this); connect(m_screenshotPathFixedCheck, SIGNAL(toggled(bool)), this, SLOT(togglePathFixed())); vboxLayout->addLayout(pathLayout); vboxLayout->addWidget(m_screenshotPathFixedCheck); auto* extensionLayout = new QHBoxLayout(); extensionLayout->addWidget( new QLabel(tr(\"Preferred save file extension:\"))); m_setSaveAsFileExtension = new QComboBox(this); QStringList imageFormatList; foreach (auto mimeType, QImageWriter::supportedImageFormats()) imageFormatList.append(mimeType); m_setSaveAsFileExtension->addItems(imageFormatList); int currentIndex = m_setSaveAsFileExtension->findText(ConfigHandler().saveAsFileExtension()); m_setSaveAsFileExtension->setCurrentIndex(currentIndex); connect(m_setSaveAsFileExtension, SIGNAL(currentTextChanged(QString)), this, SLOT(setSaveAsFileExtension(QString))); extensionLayout->addWidget(m_setSaveAsFileExtension); vboxLayout->addLayout(extensionLayout); } void GeneralConf::historyConfirmationToDelete(bool checked) { ConfigHandler().setHistoryConfirmationToDelete(checked); } void GeneralConf::initUploadHistoryMax() { auto* box = new QGroupBox(tr(\"Latest Uploads Max Size\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_uploadHistoryMax = new QSpinBox(this); m_uploadHistoryMax->setMaximum(50); QString foreground = this->palette().windowText().color().name(); m_uploadHistoryMax->setStyleSheet( QStringLiteral(\"color: %1\").arg(foreground)); connect(m_uploadHistoryMax, SIGNAL(valueChanged(int)), this, SLOT(uploadHistoryMaxChanged(int))); vboxLayout->addWidget(m_uploadHistoryMax); } void GeneralConf::initUploadClientSecret() { auto* box = new QGroupBox(tr(\"Imgur Application Client ID\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_uploadClientKey = new QLineEdit(this); QString foreground = this->palette().windowText().color().name(); m_uploadClientKey->setStyleSheet( QStringLiteral(\"color: %1\").arg(foreground)); m_uploadClientKey->setText(ConfigHandler().uploadClientSecret()); connect(m_uploadClientKey, SIGNAL(editingFinished()), this, SLOT(uploadClientKeyEdited())); vboxLayout->addWidget(m_uploadClientKey); } void GeneralConf::uploadClientKeyEdited() { ConfigHandler().setUploadClientSecret(m_uploadClientKey->text()); } void GeneralConf::uploadHistoryMaxChanged(int max) { ConfigHandler().setUploadHistoryMax(max); } void GeneralConf::initUndoLimit() { auto* box = new QGroupBox(tr(\"Undo limit\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); m_undoLimit = new QSpinBox(this); m_undoLimit->setMinimum(1); m_undoLimit->setMaximum(999); QString foreground = this->palette().windowText().color().name(); m_undoLimit->setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground)); connect(m_undoLimit, SIGNAL(valueChanged(int)), this, SLOT(undoLimit(int))); vboxLayout->addWidget(m_undoLimit); } void GeneralConf::undoLimit(int limit) { ConfigHandler().setUndoLimit(limit); } void GeneralConf::initUseJpgForClipboard() { m_useJpgForClipboard = new QCheckBox(tr(\"Use JPG format for clipboard (PNG default)\"), this); m_useJpgForClipboard->setToolTip( tr(\"Use lossy JPG format for clipboard (lossless PNG default)\")); m_scrollAreaLayout->addWidget(m_useJpgForClipboard); #if defined(Q_OS_MACOS) // FIXME - temporary fix to disable option for MacOS m_useJpgForClipboard->hide(); #endif connect(m_useJpgForClipboard, &QCheckBox::clicked, this, &GeneralConf::useJpgForClipboardChanged); } void GeneralConf::saveAfterCopyChanged(bool checked) { ConfigHandler().setSaveAfterCopy(checked); } void GeneralConf::changeSavePath() { QString path = ConfigHandler().savePath(); path = chooseFolder(path); if (!path.isEmpty()) { m_savePath->setText(path); ConfigHandler().setSavePath(path); } } void GeneralConf::initCopyPathAfterSave() { m_copyPathAfterSave = new QCheckBox(tr(\"Copy file path after save\"), this); m_copyPathAfterSave->setToolTip(tr(\"Copy the file path to clipboard after \" \"the file is saved\")); m_scrollAreaLayout->addWidget(m_copyPathAfterSave); connect(m_copyPathAfterSave, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setCopyPathAfterSave(checked); }); } void GeneralConf::initAntialiasingPinZoom() { m_antialiasingPinZoom = new QCheckBox(tr(\"Anti-aliasing image when zoom the pinned image\"), this); m_antialiasingPinZoom->setToolTip( tr(\"After zooming the pinned image, should the image get smoothened or \" \"stay pixelated\")); m_scrollAreaLayout->addWidget(m_antialiasingPinZoom); connect(m_antialiasingPinZoom, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setAntialiasingPinZoom(checked); }); } void GeneralConf::initUploadWithoutConfirmation() { m_uploadWithoutConfirmation = new QCheckBox(tr(\"Upload image without confirmation\"), this); m_uploadWithoutConfirmation->setToolTip( tr(\"Upload image without confirmation\")); m_scrollAreaLayout->addWidget(m_uploadWithoutConfirmation); connect(m_uploadWithoutConfirmation, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setUploadWithoutConfirmation(checked); }); } const QString GeneralConf::chooseFolder(const QString pathDefault) { QString path; if (pathDefault.isEmpty()) { path = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); } path = QFileDialog::getExistingDirectory( this, tr(\"Choose a Folder\"), path, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks); if (path.isEmpty()) { return path; } if (!path.isEmpty()) { if (!QFileInfo(path).isWritable()) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to write to directory.\")); return QString(); } } return path; } void GeneralConf::initShowMagnifier() { m_showMagnifier = new QCheckBox(tr(\"Show magnifier\"), this); m_showMagnifier->setToolTip(tr(\"Enable a magnifier while selecting the \" \"screenshot area\")); m_scrollAreaLayout->addWidget(m_showMagnifier); connect(m_showMagnifier, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setShowMagnifier(checked); }); } void GeneralConf::initSquareMagnifier() { m_squareMagnifier = new QCheckBox(tr(\"Square shaped magnifier\"), this); m_squareMagnifier->setToolTip(tr(\"Make the magnifier to be square-shaped\")); m_scrollAreaLayout->addWidget(m_squareMagnifier); connect(m_squareMagnifier, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setSquareMagnifier(checked); }); } void GeneralConf::initShowSelectionGeometry() { auto* tobox = new QHBoxLayout(); int timeout = ConfigHandler().value(\"showSelectionGeometryHideTime\").toInt(); m_xywhTimeout = new QSpinBox(); m_xywhTimeout->setRange(0, INT_MAX); m_xywhTimeout->setToolTip( tr(\"Milliseconds before geometry display hides; 0 means do not hide\")); m_xywhTimeout->setValue(timeout); tobox->addWidget(m_xywhTimeout); tobox->addWidget(new QLabel(tr(\"Set geometry display timeout (ms)\"))); m_scrollAreaLayout->addLayout(tobox); connect(m_xywhTimeout, SIGNAL(valueChanged(int)), this, SLOT(setSelGeoHideTime(int))); auto* box = new QGroupBox(tr(\"Selection Geometry Display\")); box->setFlat(true); m_layout->addWidget(box); auto* vboxLayout = new QVBoxLayout(); box->setLayout(vboxLayout); auto* selGeoLayout = new QHBoxLayout(); selGeoLayout->addWidget(new QLabel(tr(\"Display Location\"))); m_selectGeometryLocation = new QComboBox(this); m_selectGeometryLocation->addItem(tr(\"None\"), GeneralConf::xywh_none); m_selectGeometryLocation->addItem(tr(\"Top Left\"), GeneralConf::xywh_top_left); m_selectGeometryLocation->addItem(tr(\"Top Right\"), GeneralConf::xywh_top_right); m_selectGeometryLocation->addItem(tr(\"Bottom Left\"), GeneralConf::xywh_bottom_left); m_selectGeometryLocation->addItem(tr(\"Bottom Right\"), GeneralConf::xywh_bottom_right); m_selectGeometryLocation->addItem(tr(\"Center\"), GeneralConf::xywh_center); // pick up int from config and use findData int pos = ConfigHandler().value(\"showSelectionGeometry\").toInt(); m_selectGeometryLocation->setCurrentIndex( m_selectGeometryLocation->findData(pos)); connect(m_selectGeometryLocation, SIGNAL(currentIndexChanged(int)), this, SLOT(setGeometryLocation(int))); selGeoLayout->addWidget(m_selectGeometryLocation); vboxLayout->addLayout(selGeoLayout); vboxLayout->addStretch(); } void GeneralConf::setSelGeoHideTime(int v) { ConfigHandler().setValue(\"showSelectionGeometryHideTime\", v); } void GeneralConf::setGeometryLocation(int index) { ConfigHandler().setValue(\"showSelectionGeometry\", m_selectGeometryLocation->itemData(index)); } void GeneralConf::togglePathFixed() { ConfigHandler().setSavePathFixed(m_screenshotPathFixedCheck->isChecked()); } void GeneralConf::setSaveAsFileExtension(QString extension) { ConfigHandler().setSaveAsFileExtension(extension); } void GeneralConf::useJpgForClipboardChanged(bool checked) { ConfigHandler().setUseJpgForClipboard(checked); }","title":"File generalconf.cpp"},{"location":"flameshot/generalconf_8h/","text":"File generalconf.h # FileList > config > generalconf.h Go to the source code of this file. #include <QScrollArea> #include <QWidget> Classes # Type Name class GeneralConf","title":"File generalconf.h"},{"location":"flameshot/generalconf_8h/#file-generalconfh","text":"FileList > config > generalconf.h Go to the source code of this file. #include <QScrollArea> #include <QWidget>","title":"File generalconf.h"},{"location":"flameshot/generalconf_8h/#classes","text":"Type Name class GeneralConf","title":"Classes"},{"location":"flameshot/generalconf_8h_source/","text":"File generalconf.h # File List > config > generalconf.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QScrollArea> #include <QWidget> class QVBoxLayout; class QCheckBox; class QPushButton; class QLabel; class QLineEdit; class QSpinBox; class QComboBox; class GeneralConf : public QWidget { Q_OBJECT public: explicit GeneralConf(QWidget* parent = nullptr); enum xywh_position { xywh_none = 0, xywh_top_left = 1, xywh_bottom_left = 2, xywh_top_right = 3, xywh_bottom_right = 4, xywh_center = 5 }; public slots: void updateComponents(); private slots: void showHelpChanged(bool checked); void saveLastRegion(bool checked); void showSidePanelButtonChanged(bool checked); void showDesktopNotificationChanged(bool checked); #if !defined(DISABLE_UPDATE_CHECKER) void checkForUpdatesChanged(bool checked); #endif void allowMultipleGuiInstancesChanged(bool checked); void autoCloseIdleDaemonChanged(bool checked); void autostartChanged(bool checked); void historyConfirmationToDelete(bool checked); void uploadHistoryMaxChanged(int max); void undoLimit(int limit); void saveAfterCopyChanged(bool checked); void changeSavePath(); void importConfiguration(); void exportFileConfiguration(); void resetConfiguration(); void togglePathFixed(); void uploadClientKeyEdited(); void useJpgForClipboardChanged(bool checked); void setSaveAsFileExtension(QString extension); void setGeometryLocation(int index); void setSelGeoHideTime(int v); private: const QString chooseFolder(const QString currentPath = \"\"); void initAllowMultipleGuiInstances(); void initAntialiasingPinZoom(); void initAutoCloseIdleDaemon(); void initAutostart(); #if !defined(DISABLE_UPDATE_CHECKER) void initCheckForUpdates(); #endif void initConfigButtons(); void initCopyAndCloseAfterUpload(); void initCopyOnDoubleClick(); void initCopyPathAfterSave(); void initHistoryConfirmationToDelete(); void initPredefinedColorPaletteLarge(); void initSaveAfterCopy(); void initScrollArea(); void initShowDesktopNotification(); void initShowHelp(); void initShowMagnifier(); void initShowSidePanelButton(); void initShowStartupLaunchMessage(); void initShowTrayIcon(); void initSquareMagnifier(); void initUndoLimit(); void initUploadWithoutConfirmation(); void initUseJpgForClipboard(); void initUploadHistoryMax(); void initUploadClientSecret(); void initSaveLastRegion(); void initShowSelectionGeometry(); void _updateComponents(bool allowEmptySavePath); // class members QVBoxLayout* m_layout; QVBoxLayout* m_scrollAreaLayout; QScrollArea* m_scrollArea; QCheckBox* m_sysNotifications; QCheckBox* m_showTray; QCheckBox* m_helpMessage; QCheckBox* m_sidePanelButton; #if !defined(DISABLE_UPDATE_CHECKER) QCheckBox* m_checkForUpdates; #endif QCheckBox* m_allowMultipleGuiInstances; QCheckBox* m_autoCloseIdleDaemon; QCheckBox* m_autostart; QCheckBox* m_showStartupLaunchMessage; QCheckBox* m_copyURLAfterUpload; QCheckBox* m_copyPathAfterSave; QCheckBox* m_antialiasingPinZoom; QCheckBox* m_saveLastRegion; QCheckBox* m_uploadWithoutConfirmation; QPushButton* m_importButton; QPushButton* m_exportButton; QPushButton* m_resetButton; QCheckBox* m_saveAfterCopy; QLineEdit* m_savePath; QLineEdit* m_uploadClientKey; QPushButton* m_changeSaveButton; QCheckBox* m_screenshotPathFixedCheck; QCheckBox* m_historyConfirmationToDelete; QCheckBox* m_useJpgForClipboard; QSpinBox* m_uploadHistoryMax; QSpinBox* m_undoLimit; QComboBox* m_setSaveAsFileExtension; QCheckBox* m_predefinedColorPaletteLarge; QCheckBox* m_showMagnifier; QCheckBox* m_squareMagnifier; QCheckBox* m_copyOnDoubleClick; QCheckBox* m_showSelectionGeometry; QComboBox* m_selectGeometryLocation; QSpinBox* m_xywhTimeout; };","title":"File generalconf.h"},{"location":"flameshot/generalconf_8h_source/#file-generalconfh","text":"File List > config > generalconf.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QScrollArea> #include <QWidget> class QVBoxLayout; class QCheckBox; class QPushButton; class QLabel; class QLineEdit; class QSpinBox; class QComboBox; class GeneralConf : public QWidget { Q_OBJECT public: explicit GeneralConf(QWidget* parent = nullptr); enum xywh_position { xywh_none = 0, xywh_top_left = 1, xywh_bottom_left = 2, xywh_top_right = 3, xywh_bottom_right = 4, xywh_center = 5 }; public slots: void updateComponents(); private slots: void showHelpChanged(bool checked); void saveLastRegion(bool checked); void showSidePanelButtonChanged(bool checked); void showDesktopNotificationChanged(bool checked); #if !defined(DISABLE_UPDATE_CHECKER) void checkForUpdatesChanged(bool checked); #endif void allowMultipleGuiInstancesChanged(bool checked); void autoCloseIdleDaemonChanged(bool checked); void autostartChanged(bool checked); void historyConfirmationToDelete(bool checked); void uploadHistoryMaxChanged(int max); void undoLimit(int limit); void saveAfterCopyChanged(bool checked); void changeSavePath(); void importConfiguration(); void exportFileConfiguration(); void resetConfiguration(); void togglePathFixed(); void uploadClientKeyEdited(); void useJpgForClipboardChanged(bool checked); void setSaveAsFileExtension(QString extension); void setGeometryLocation(int index); void setSelGeoHideTime(int v); private: const QString chooseFolder(const QString currentPath = \"\"); void initAllowMultipleGuiInstances(); void initAntialiasingPinZoom(); void initAutoCloseIdleDaemon(); void initAutostart(); #if !defined(DISABLE_UPDATE_CHECKER) void initCheckForUpdates(); #endif void initConfigButtons(); void initCopyAndCloseAfterUpload(); void initCopyOnDoubleClick(); void initCopyPathAfterSave(); void initHistoryConfirmationToDelete(); void initPredefinedColorPaletteLarge(); void initSaveAfterCopy(); void initScrollArea(); void initShowDesktopNotification(); void initShowHelp(); void initShowMagnifier(); void initShowSidePanelButton(); void initShowStartupLaunchMessage(); void initShowTrayIcon(); void initSquareMagnifier(); void initUndoLimit(); void initUploadWithoutConfirmation(); void initUseJpgForClipboard(); void initUploadHistoryMax(); void initUploadClientSecret(); void initSaveLastRegion(); void initShowSelectionGeometry(); void _updateComponents(bool allowEmptySavePath); // class members QVBoxLayout* m_layout; QVBoxLayout* m_scrollAreaLayout; QScrollArea* m_scrollArea; QCheckBox* m_sysNotifications; QCheckBox* m_showTray; QCheckBox* m_helpMessage; QCheckBox* m_sidePanelButton; #if !defined(DISABLE_UPDATE_CHECKER) QCheckBox* m_checkForUpdates; #endif QCheckBox* m_allowMultipleGuiInstances; QCheckBox* m_autoCloseIdleDaemon; QCheckBox* m_autostart; QCheckBox* m_showStartupLaunchMessage; QCheckBox* m_copyURLAfterUpload; QCheckBox* m_copyPathAfterSave; QCheckBox* m_antialiasingPinZoom; QCheckBox* m_saveLastRegion; QCheckBox* m_uploadWithoutConfirmation; QPushButton* m_importButton; QPushButton* m_exportButton; QPushButton* m_resetButton; QCheckBox* m_saveAfterCopy; QLineEdit* m_savePath; QLineEdit* m_uploadClientKey; QPushButton* m_changeSaveButton; QCheckBox* m_screenshotPathFixedCheck; QCheckBox* m_historyConfirmationToDelete; QCheckBox* m_useJpgForClipboard; QSpinBox* m_uploadHistoryMax; QSpinBox* m_undoLimit; QComboBox* m_setSaveAsFileExtension; QCheckBox* m_predefinedColorPaletteLarge; QCheckBox* m_showMagnifier; QCheckBox* m_squareMagnifier; QCheckBox* m_copyOnDoubleClick; QCheckBox* m_showSelectionGeometry; QComboBox* m_selectGeometryLocation; QSpinBox* m_xywhTimeout; };","title":"File generalconf.h"},{"location":"flameshot/setshortcutwidget_8cpp/","text":"File setshortcutwidget.cpp # FileList > config > setshortcutwidget.cpp Go to the source code of this file. #include \"setshortcutwidget.h\" #include \"src/utils/globalvalues.h\" #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QLayout> #include <QPixmap>","title":"File setshortcutwidget.cpp"},{"location":"flameshot/setshortcutwidget_8cpp/#file-setshortcutwidgetcpp","text":"FileList > config > setshortcutwidget.cpp Go to the source code of this file. #include \"setshortcutwidget.h\" #include \"src/utils/globalvalues.h\" #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QLayout> #include <QPixmap>","title":"File setshortcutwidget.cpp"},{"location":"flameshot/setshortcutwidget_8cpp_source/","text":"File setshortcutwidget.cpp # File List > config > setshortcutwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #include \"setshortcutwidget.h\" #include \"src/utils/globalvalues.h\" #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QLayout> #include <QPixmap> SetShortcutDialog::SetShortcutDialog(QDialog* parent, QString shortcutName) : QDialog(parent) { setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Set Shortcut\")); m_ks = QKeySequence(); m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignHCenter); auto* infoTop = new QLabel(tr(\"Enter new shortcut to change \")); infoTop->setMargin(10); infoTop->setAlignment(Qt::AlignCenter); m_layout->addWidget(infoTop); auto* infoIcon = new QLabel(); infoIcon->setAlignment(Qt::AlignCenter); infoIcon->setPixmap(QPixmap(\":/img/app/keyboard.svg\")); m_layout->addWidget(infoIcon); m_layout->addWidget(infoIcon); QString msg = \"\"; #if defined(Q_OS_MAC) msg = tr( \"Press Esc to cancel or \u2318+Backspace to disable the keyboard shortcut.\"); #else msg = tr(\"Press Esc to cancel or Backspace to disable the keyboard shortcut.\"); #endif if (shortcutName == \"TAKE_SCREENSHOT\" || shortcutName == \"SCREENSHOT_HISTORY\") { msg += \"\\n\" + tr(\"Flameshot must be restarted for changes to take effect.\"); } auto* infoBottom = new QLabel(msg); infoBottom->setMargin(10); infoBottom->setAlignment(Qt::AlignCenter); m_layout->addWidget(infoBottom); } const QKeySequence& SetShortcutDialog::shortcut() { return m_ks; } void SetShortcutDialog::keyPressEvent(QKeyEvent* ke) { if (ke->modifiers() & Qt::ShiftModifier) { m_modifier += \"Shift+\"; } if (ke->modifiers() & Qt::ControlModifier) { m_modifier += \"Ctrl+\"; } if (ke->modifiers() & Qt::AltModifier) { m_modifier += \"Alt+\"; } if (ke->modifiers() & Qt::MetaModifier) { m_modifier += \"Meta+\"; } QString key = QKeySequence(ke->key()).toString(); m_ks = QKeySequence(m_modifier + key); } void SetShortcutDialog::keyReleaseEvent(QKeyEvent* event) { if (m_ks == QKeySequence(Qt::Key_Escape)) { reject(); } accept(); }","title":"File setshortcutwidget.cpp"},{"location":"flameshot/setshortcutwidget_8cpp_source/#file-setshortcutwidgetcpp","text":"File List > config > setshortcutwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #include \"setshortcutwidget.h\" #include \"src/utils/globalvalues.h\" #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QLayout> #include <QPixmap> SetShortcutDialog::SetShortcutDialog(QDialog* parent, QString shortcutName) : QDialog(parent) { setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Set Shortcut\")); m_ks = QKeySequence(); m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignHCenter); auto* infoTop = new QLabel(tr(\"Enter new shortcut to change \")); infoTop->setMargin(10); infoTop->setAlignment(Qt::AlignCenter); m_layout->addWidget(infoTop); auto* infoIcon = new QLabel(); infoIcon->setAlignment(Qt::AlignCenter); infoIcon->setPixmap(QPixmap(\":/img/app/keyboard.svg\")); m_layout->addWidget(infoIcon); m_layout->addWidget(infoIcon); QString msg = \"\"; #if defined(Q_OS_MAC) msg = tr( \"Press Esc to cancel or \u2318+Backspace to disable the keyboard shortcut.\"); #else msg = tr(\"Press Esc to cancel or Backspace to disable the keyboard shortcut.\"); #endif if (shortcutName == \"TAKE_SCREENSHOT\" || shortcutName == \"SCREENSHOT_HISTORY\") { msg += \"\\n\" + tr(\"Flameshot must be restarted for changes to take effect.\"); } auto* infoBottom = new QLabel(msg); infoBottom->setMargin(10); infoBottom->setAlignment(Qt::AlignCenter); m_layout->addWidget(infoBottom); } const QKeySequence& SetShortcutDialog::shortcut() { return m_ks; } void SetShortcutDialog::keyPressEvent(QKeyEvent* ke) { if (ke->modifiers() & Qt::ShiftModifier) { m_modifier += \"Shift+\"; } if (ke->modifiers() & Qt::ControlModifier) { m_modifier += \"Ctrl+\"; } if (ke->modifiers() & Qt::AltModifier) { m_modifier += \"Alt+\"; } if (ke->modifiers() & Qt::MetaModifier) { m_modifier += \"Meta+\"; } QString key = QKeySequence(ke->key()).toString(); m_ks = QKeySequence(m_modifier + key); } void SetShortcutDialog::keyReleaseEvent(QKeyEvent* event) { if (m_ks == QKeySequence(Qt::Key_Escape)) { reject(); } accept(); }","title":"File setshortcutwidget.cpp"},{"location":"flameshot/setshortcutwidget_8h/","text":"File setshortcutwidget.h # FileList > config > setshortcutwidget.h Go to the source code of this file. #include <QDialog> #include <QKeySequence> #include <QObject> Classes # Type Name class SetShortcutDialog","title":"File setshortcutwidget.h"},{"location":"flameshot/setshortcutwidget_8h/#file-setshortcutwidgeth","text":"FileList > config > setshortcutwidget.h Go to the source code of this file. #include <QDialog> #include <QKeySequence> #include <QObject>","title":"File setshortcutwidget.h"},{"location":"flameshot/setshortcutwidget_8h/#classes","text":"Type Name class SetShortcutDialog","title":"Classes"},{"location":"flameshot/setshortcutwidget_8h_source/","text":"File setshortcutwidget.h # File List > config > setshortcutwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #ifndef SETSHORTCUTWIDGET_H #define SETSHORTCUTWIDGET_H #include <QDialog> #include <QKeySequence> #include <QObject> class QVBoxLayout; class SetShortcutDialog : public QDialog { Q_OBJECT public: explicit SetShortcutDialog(QDialog* parent = nullptr, QString shortcutName = \"\"); const QKeySequence& shortcut(); public: void keyPressEvent(QKeyEvent*); void keyReleaseEvent(QKeyEvent* event); signals: private: QVBoxLayout* m_layout; QString m_modifier; QKeySequence m_ks; }; #endif // SETSHORTCUTWIDGET_H","title":"File setshortcutwidget.h"},{"location":"flameshot/setshortcutwidget_8h_source/#file-setshortcutwidgeth","text":"File List > config > setshortcutwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #ifndef SETSHORTCUTWIDGET_H #define SETSHORTCUTWIDGET_H #include <QDialog> #include <QKeySequence> #include <QObject> class QVBoxLayout; class SetShortcutDialog : public QDialog { Q_OBJECT public: explicit SetShortcutDialog(QDialog* parent = nullptr, QString shortcutName = \"\"); const QKeySequence& shortcut(); public: void keyPressEvent(QKeyEvent*); void keyReleaseEvent(QKeyEvent* event); signals: private: QVBoxLayout* m_layout; QString m_modifier; QKeySequence m_ks; }; #endif // SETSHORTCUTWIDGET_H","title":"File setshortcutwidget.h"},{"location":"flameshot/shortcutswidget_8cpp/","text":"File shortcutswidget.cpp # FileList > config > shortcutswidget.cpp Go to the source code of this file. #include \"shortcutswidget.h\" #include \"capturetool.h\" #include \"setshortcutwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include \"toolfactory.h\" #include <QHeaderView> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QStringList> #include <QTableWidget> #include <QVBoxLayout> #include <QVector> #include <QCursor> #include <QRect> #include <QScreen>","title":"File shortcutswidget.cpp"},{"location":"flameshot/shortcutswidget_8cpp/#file-shortcutswidgetcpp","text":"FileList > config > shortcutswidget.cpp Go to the source code of this file. #include \"shortcutswidget.h\" #include \"capturetool.h\" #include \"setshortcutwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include \"toolfactory.h\" #include <QHeaderView> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QStringList> #include <QTableWidget> #include <QVBoxLayout> #include <QVector> #include <QCursor> #include <QRect> #include <QScreen>","title":"File shortcutswidget.cpp"},{"location":"flameshot/shortcutswidget_8cpp_source/","text":"File shortcutswidget.cpp # File List > config > shortcutswidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #include \"shortcutswidget.h\" #include \"capturetool.h\" #include \"setshortcutwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include \"toolfactory.h\" #include <QHeaderView> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QStringList> #include <QTableWidget> #include <QVBoxLayout> #include <QVector> #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) #include <QCursor> #include <QRect> #include <QScreen> #endif ShortcutsWidget::ShortcutsWidget(QWidget* parent) : QWidget(parent) { setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Hot Keys\")); #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) QRect position = frameGeometry(); QScreen* screen = QGuiAppCurrentScreen().currentScreen(); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); #endif m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter); initInfoTable(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, &ShortcutsWidget::populateInfoTable); show(); } void ShortcutsWidget::initInfoTable() { m_table = new QTableWidget(this); m_table->setToolTip(tr(\"Available shortcuts in the screen capture mode.\")); m_layout->addWidget(m_table); m_table->setColumnCount(2); m_table->setSelectionMode(QAbstractItemView::NoSelection); m_table->setFocusPolicy(Qt::NoFocus); m_table->verticalHeader()->hide(); // header creation QStringList names; names << tr(\"Description\") << tr(\"Key\"); m_table->setHorizontalHeaderLabels(names); connect(m_table, &QTableWidget::cellClicked, this, &ShortcutsWidget::onShortcutCellClicked); // populate with dynamic data populateInfoTable(); // adjust size m_table->horizontalHeader()->setMinimumSectionSize(200); m_table->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch); m_table->horizontalHeader()->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_table->resizeColumnsToContents(); m_table->resizeRowsToContents(); } void ShortcutsWidget::populateInfoTable() { loadShortcuts(); m_table->setRowCount(m_shortcuts.size()); // add content for (int i = 0; i < m_shortcuts.size(); ++i) { const auto current_shortcut = m_shortcuts.at(i); const auto identifier = current_shortcut.at(0); const auto description = current_shortcut.at(1); const auto key_sequence = current_shortcut.at(2); m_table->setItem(i, 0, new QTableWidgetItem(description)); #if defined(Q_OS_MACOS) auto* item = new QTableWidgetItem(nativeOSHotKeyText(key_sequence)); #else QTableWidgetItem* item = new QTableWidgetItem(key_sequence); #endif item->setTextAlignment(Qt::AlignCenter); m_table->setItem(i, 1, item); if (identifier.isEmpty()) { QFont font; font.setBold(true); item->setFont(font); item->setFlags(item->flags() ^ Qt::ItemIsEnabled); m_table->item(i, 1)->setFont(font); } } // Read-only table items for (int x = 0; x < m_table->rowCount(); ++x) { for (int y = 0; y < m_table->columnCount(); ++y) { QTableWidgetItem* item = m_table->item(x, y); item->setFlags(item->flags() ^ Qt::ItemIsEditable); } } } void ShortcutsWidget::onShortcutCellClicked(int row, int col) { if (col == 1) { // Ignore non-changable shortcuts if (Qt::ItemIsEnabled != (Qt::ItemIsEnabled & m_table->item(row, col)->flags())) { return; } QString shortcutName = m_shortcuts.at(row).at(0); auto* setShortcutDialog = new SetShortcutDialog(nullptr, shortcutName); if (0 != setShortcutDialog->exec()) { QKeySequence shortcutValue = setShortcutDialog->shortcut(); // set no shortcut is Backspace #if defined(Q_OS_MACOS) if (shortcutValue == QKeySequence(Qt::CTRL + Qt::Key_Backspace)) { shortcutValue = QKeySequence(\"\"); } #else if (shortcutValue == QKeySequence(Qt::Key_Backspace)) { shortcutValue = QKeySequence(\"\"); } #endif if (m_config.setShortcut(shortcutName, shortcutValue.toString())) { populateInfoTable(); } } delete setShortcutDialog; } } void ShortcutsWidget::loadShortcuts() { m_shortcuts.clear(); auto buttonTypes = CaptureToolButton::getIterableButtonTypes(); // get shortcuts names from capture buttons for (const CaptureTool::Type& t : buttonTypes) { CaptureTool* tool = ToolFactory().CreateTool(t); QString shortcutName = QVariant::fromValue(t).toString(); appendShortcut(shortcutName, tool->description()); if (shortcutName == \"TYPE_COPY\") { if (m_config.copyOnDoubleClick()) { m_shortcuts << (QStringList() << \"\" << tool->description() << tr(\"Left Double-click\")); } } delete tool; } // additional tools that don't have their own buttons appendShortcut(\"TYPE_TOGGLE_PANEL\", tr(\"Toggle side panel\")); appendShortcut(\"TYPE_RESIZE_LEFT\", tr(\"Resize selection left 1px\")); appendShortcut(\"TYPE_RESIZE_RIGHT\", tr(\"Resize selection right 1px\")); appendShortcut(\"TYPE_RESIZE_UP\", tr(\"Resize selection up 1px\")); appendShortcut(\"TYPE_RESIZE_DOWN\", tr(\"Resize selection down 1px\")); appendShortcut(\"TYPE_SYM_RESIZE_LEFT\", tr(\"Symmetrically decrease width by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_RIGHT\", tr(\"Symmetrically increase width by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_UP\", tr(\"Symmetrically increase height by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_DOWN\", tr(\"Symmetrically decrease height by 2px\")); appendShortcut(\"TYPE_SELECT_ALL\", tr(\"Select entire screen\")); appendShortcut(\"TYPE_MOVE_LEFT\", tr(\"Move selection left 1px\")); appendShortcut(\"TYPE_MOVE_RIGHT\", tr(\"Move selection right 1px\")); appendShortcut(\"TYPE_MOVE_UP\", tr(\"Move selection up 1px\")); appendShortcut(\"TYPE_MOVE_DOWN\", tr(\"Move selection down 1px\")); appendShortcut(\"TYPE_COMMIT_CURRENT_TOOL\", tr(\"Commit text in text area\")); appendShortcut(\"TYPE_DELETE_CURRENT_TOOL\", tr(\"Delete current tool\")); // non-editable shortcuts have an empty shortcut name m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Quit capture\") << QKeySequence(Qt::Key_Escape).toString()); // Global hotkeys #if defined(Q_OS_MACOS) appendShortcut(\"TAKE_SCREENSHOT\", tr(\"Capture screen\")); appendShortcut(\"SCREENSHOT_HISTORY\", tr(\"Screenshot history\")); #elif defined(Q_OS_WIN) m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Screenshot history\") << \"Shift+Print Screen\"); m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Capture screen\") << \"Print Screen\"); #else // TODO - Linux doesn't support global shortcuts for (XServer and Wayland), // possibly it will be solved in the QHotKey library later. So it is // disabled for now. #endif m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Show color picker\") << \"Right Click\"); m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Change the tool's size\") << \"Mouse Wheel\"); } void ShortcutsWidget::appendShortcut(const QString& shortcutName, const QString& description) { QString shortcut = ConfigHandler().shortcut(shortcutName); m_shortcuts << (QStringList() << shortcutName << QObject::tr(description.toStdString().c_str()) << shortcut.replace(\"Return\", \"Enter\")); } #if defined(Q_OS_MACOS) const QString& ShortcutsWidget::nativeOSHotKeyText(const QString& text) { m_res = text; m_res.replace(\"Ctrl+\", \"\u2318\"); m_res.replace(\"Alt+\", \"\u2325\"); m_res.replace(\"Meta+\", \"\u2303\"); m_res.replace(\"Shift+\", \"\u21e7\"); return m_res; } #endif","title":"File shortcutswidget.cpp"},{"location":"flameshot/shortcutswidget_8cpp_source/#file-shortcutswidgetcpp","text":"File List > config > shortcutswidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #include \"shortcutswidget.h\" #include \"capturetool.h\" #include \"setshortcutwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include \"toolfactory.h\" #include <QHeaderView> #include <QIcon> #include <QKeyEvent> #include <QLabel> #include <QStringList> #include <QTableWidget> #include <QVBoxLayout> #include <QVector> #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) #include <QCursor> #include <QRect> #include <QScreen> #endif ShortcutsWidget::ShortcutsWidget(QWidget* parent) : QWidget(parent) { setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Hot Keys\")); #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) QRect position = frameGeometry(); QScreen* screen = QGuiAppCurrentScreen().currentScreen(); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); #endif m_layout = new QVBoxLayout(this); m_layout->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter); initInfoTable(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, &ShortcutsWidget::populateInfoTable); show(); } void ShortcutsWidget::initInfoTable() { m_table = new QTableWidget(this); m_table->setToolTip(tr(\"Available shortcuts in the screen capture mode.\")); m_layout->addWidget(m_table); m_table->setColumnCount(2); m_table->setSelectionMode(QAbstractItemView::NoSelection); m_table->setFocusPolicy(Qt::NoFocus); m_table->verticalHeader()->hide(); // header creation QStringList names; names << tr(\"Description\") << tr(\"Key\"); m_table->setHorizontalHeaderLabels(names); connect(m_table, &QTableWidget::cellClicked, this, &ShortcutsWidget::onShortcutCellClicked); // populate with dynamic data populateInfoTable(); // adjust size m_table->horizontalHeader()->setMinimumSectionSize(200); m_table->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch); m_table->horizontalHeader()->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_table->resizeColumnsToContents(); m_table->resizeRowsToContents(); } void ShortcutsWidget::populateInfoTable() { loadShortcuts(); m_table->setRowCount(m_shortcuts.size()); // add content for (int i = 0; i < m_shortcuts.size(); ++i) { const auto current_shortcut = m_shortcuts.at(i); const auto identifier = current_shortcut.at(0); const auto description = current_shortcut.at(1); const auto key_sequence = current_shortcut.at(2); m_table->setItem(i, 0, new QTableWidgetItem(description)); #if defined(Q_OS_MACOS) auto* item = new QTableWidgetItem(nativeOSHotKeyText(key_sequence)); #else QTableWidgetItem* item = new QTableWidgetItem(key_sequence); #endif item->setTextAlignment(Qt::AlignCenter); m_table->setItem(i, 1, item); if (identifier.isEmpty()) { QFont font; font.setBold(true); item->setFont(font); item->setFlags(item->flags() ^ Qt::ItemIsEnabled); m_table->item(i, 1)->setFont(font); } } // Read-only table items for (int x = 0; x < m_table->rowCount(); ++x) { for (int y = 0; y < m_table->columnCount(); ++y) { QTableWidgetItem* item = m_table->item(x, y); item->setFlags(item->flags() ^ Qt::ItemIsEditable); } } } void ShortcutsWidget::onShortcutCellClicked(int row, int col) { if (col == 1) { // Ignore non-changable shortcuts if (Qt::ItemIsEnabled != (Qt::ItemIsEnabled & m_table->item(row, col)->flags())) { return; } QString shortcutName = m_shortcuts.at(row).at(0); auto* setShortcutDialog = new SetShortcutDialog(nullptr, shortcutName); if (0 != setShortcutDialog->exec()) { QKeySequence shortcutValue = setShortcutDialog->shortcut(); // set no shortcut is Backspace #if defined(Q_OS_MACOS) if (shortcutValue == QKeySequence(Qt::CTRL + Qt::Key_Backspace)) { shortcutValue = QKeySequence(\"\"); } #else if (shortcutValue == QKeySequence(Qt::Key_Backspace)) { shortcutValue = QKeySequence(\"\"); } #endif if (m_config.setShortcut(shortcutName, shortcutValue.toString())) { populateInfoTable(); } } delete setShortcutDialog; } } void ShortcutsWidget::loadShortcuts() { m_shortcuts.clear(); auto buttonTypes = CaptureToolButton::getIterableButtonTypes(); // get shortcuts names from capture buttons for (const CaptureTool::Type& t : buttonTypes) { CaptureTool* tool = ToolFactory().CreateTool(t); QString shortcutName = QVariant::fromValue(t).toString(); appendShortcut(shortcutName, tool->description()); if (shortcutName == \"TYPE_COPY\") { if (m_config.copyOnDoubleClick()) { m_shortcuts << (QStringList() << \"\" << tool->description() << tr(\"Left Double-click\")); } } delete tool; } // additional tools that don't have their own buttons appendShortcut(\"TYPE_TOGGLE_PANEL\", tr(\"Toggle side panel\")); appendShortcut(\"TYPE_RESIZE_LEFT\", tr(\"Resize selection left 1px\")); appendShortcut(\"TYPE_RESIZE_RIGHT\", tr(\"Resize selection right 1px\")); appendShortcut(\"TYPE_RESIZE_UP\", tr(\"Resize selection up 1px\")); appendShortcut(\"TYPE_RESIZE_DOWN\", tr(\"Resize selection down 1px\")); appendShortcut(\"TYPE_SYM_RESIZE_LEFT\", tr(\"Symmetrically decrease width by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_RIGHT\", tr(\"Symmetrically increase width by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_UP\", tr(\"Symmetrically increase height by 2px\")); appendShortcut(\"TYPE_SYM_RESIZE_DOWN\", tr(\"Symmetrically decrease height by 2px\")); appendShortcut(\"TYPE_SELECT_ALL\", tr(\"Select entire screen\")); appendShortcut(\"TYPE_MOVE_LEFT\", tr(\"Move selection left 1px\")); appendShortcut(\"TYPE_MOVE_RIGHT\", tr(\"Move selection right 1px\")); appendShortcut(\"TYPE_MOVE_UP\", tr(\"Move selection up 1px\")); appendShortcut(\"TYPE_MOVE_DOWN\", tr(\"Move selection down 1px\")); appendShortcut(\"TYPE_COMMIT_CURRENT_TOOL\", tr(\"Commit text in text area\")); appendShortcut(\"TYPE_DELETE_CURRENT_TOOL\", tr(\"Delete current tool\")); // non-editable shortcuts have an empty shortcut name m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Quit capture\") << QKeySequence(Qt::Key_Escape).toString()); // Global hotkeys #if defined(Q_OS_MACOS) appendShortcut(\"TAKE_SCREENSHOT\", tr(\"Capture screen\")); appendShortcut(\"SCREENSHOT_HISTORY\", tr(\"Screenshot history\")); #elif defined(Q_OS_WIN) m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Screenshot history\") << \"Shift+Print Screen\"); m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Capture screen\") << \"Print Screen\"); #else // TODO - Linux doesn't support global shortcuts for (XServer and Wayland), // possibly it will be solved in the QHotKey library later. So it is // disabled for now. #endif m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Show color picker\") << \"Right Click\"); m_shortcuts << (QStringList() << \"\" << QObject::tr(\"Change the tool's size\") << \"Mouse Wheel\"); } void ShortcutsWidget::appendShortcut(const QString& shortcutName, const QString& description) { QString shortcut = ConfigHandler().shortcut(shortcutName); m_shortcuts << (QStringList() << shortcutName << QObject::tr(description.toStdString().c_str()) << shortcut.replace(\"Return\", \"Enter\")); } #if defined(Q_OS_MACOS) const QString& ShortcutsWidget::nativeOSHotKeyText(const QString& text) { m_res = text; m_res.replace(\"Ctrl+\", \"\u2318\"); m_res.replace(\"Alt+\", \"\u2325\"); m_res.replace(\"Meta+\", \"\u2303\"); m_res.replace(\"Shift+\", \"\u21e7\"); return m_res; } #endif","title":"File shortcutswidget.cpp"},{"location":"flameshot/shortcutswidget_8h/","text":"File shortcutswidget.h # FileList > config > shortcutswidget.h Go to the source code of this file. #include \"src/utils/confighandler.h\" #include <QStringList> #include <QVector> #include <QWidget> Classes # Type Name class ShortcutsWidget","title":"File shortcutswidget.h"},{"location":"flameshot/shortcutswidget_8h/#file-shortcutswidgeth","text":"FileList > config > shortcutswidget.h Go to the source code of this file. #include \"src/utils/confighandler.h\" #include <QStringList> #include <QVector> #include <QWidget>","title":"File shortcutswidget.h"},{"location":"flameshot/shortcutswidget_8h/#classes","text":"Type Name class ShortcutsWidget","title":"Classes"},{"location":"flameshot/shortcutswidget_8h_source/","text":"File shortcutswidget.h # File List > config > shortcutswidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #ifndef HOTKEYSCONFIG_H #define HOTKEYSCONFIG_H #include \"src/utils/confighandler.h\" #include <QStringList> #include <QVector> #include <QWidget> class SetShortcutDialog; class QTableWidget; class QVBoxLayout; class ShortcutsWidget : public QWidget { Q_OBJECT public: explicit ShortcutsWidget(QWidget* parent = nullptr); private: void initInfoTable(); #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) const QString& nativeOSHotKeyText(const QString& text); #endif private slots: void populateInfoTable(); void onShortcutCellClicked(int, int); private: #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) QString m_res; #endif ConfigHandler m_config; QTableWidget* m_table; QVBoxLayout* m_layout; QList<QStringList> m_shortcuts; void loadShortcuts(); void appendShortcut(const QString& shortcutName, const QString& description); }; #endif // HOTKEYSCONFIG_H","title":"File shortcutswidget.h"},{"location":"flameshot/shortcutswidget_8h_source/#file-shortcutswidgeth","text":"File List > config > shortcutswidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap & Contributors #ifndef HOTKEYSCONFIG_H #define HOTKEYSCONFIG_H #include \"src/utils/confighandler.h\" #include <QStringList> #include <QVector> #include <QWidget> class SetShortcutDialog; class QTableWidget; class QVBoxLayout; class ShortcutsWidget : public QWidget { Q_OBJECT public: explicit ShortcutsWidget(QWidget* parent = nullptr); private: void initInfoTable(); #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) const QString& nativeOSHotKeyText(const QString& text); #endif private slots: void populateInfoTable(); void onShortcutCellClicked(int, int); private: #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) QString m_res; #endif ConfigHandler m_config; QTableWidget* m_table; QVBoxLayout* m_layout; QList<QStringList> m_shortcuts; void loadShortcuts(); void appendShortcut(const QString& shortcutName, const QString& description); }; #endif // HOTKEYSCONFIG_H","title":"File shortcutswidget.h"},{"location":"flameshot/strftimechooserwidget_8cpp/","text":"File strftimechooserwidget.cpp # FileList > config > strftimechooserwidget.cpp Go to the source code of this file. #include \"strftimechooserwidget.h\" #include <QGridLayout> #include <QMap> #include <QPushButton>","title":"File strftimechooserwidget.cpp"},{"location":"flameshot/strftimechooserwidget_8cpp/#file-strftimechooserwidgetcpp","text":"FileList > config > strftimechooserwidget.cpp Go to the source code of this file. #include \"strftimechooserwidget.h\" #include <QGridLayout> #include <QMap> #include <QPushButton>","title":"File strftimechooserwidget.cpp"},{"location":"flameshot/strftimechooserwidget_8cpp_source/","text":"File strftimechooserwidget.cpp # File List > config > strftimechooserwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"strftimechooserwidget.h\" #include <QGridLayout> #include <QMap> #include <QPushButton> StrftimeChooserWidget::StrftimeChooserWidget(QWidget* parent) : QWidget(parent) { auto* layout = new QGridLayout(this); auto k = m_buttonData.keys(); int middle = k.length() / 2; // add the buttons in 2 columns (they need to be even) for (int i = 0; i < 2; i++) { for (int j = 0; j < middle; j++) { QString key = k.last(); k.pop_back(); QString variable = m_buttonData.value(key); auto* button = new QPushButton(this); button->setText(tr(key.toStdString().data())); button->setToolTip(variable); button->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); button->setMinimumHeight(25); layout->addWidget(button, j, i); connect(button, &QPushButton::clicked, this, [variable, this]() { emit variableEmitted(variable); }); } } setLayout(layout); } QMap<QString, QString> StrftimeChooserWidget::m_buttonData{ { QT_TR_NOOP(\"Century (00-99)\"), \"%C\" }, { QT_TR_NOOP(\"Year (00-99)\"), \"%y\" }, { QT_TR_NOOP(\"Year (2000)\"), \"%Y\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Month Name (jan)\"), \"%b\" }, { QT_TR_NOOP(\"Month Name (january)\"), \"%B\" }, #endif { QT_TR_NOOP(\"Month (01-12)\"), \"%m\" }, { QT_TR_NOOP(\"Week Day (1-7)\"), \"%u\" }, { QT_TR_NOOP(\"Week (01-53)\"), \"%V\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Day Name (mon)\"), \"%a\" }, { QT_TR_NOOP(\"Day Name (monday)\"), \"%A\" }, #endif { QT_TR_NOOP(\"Day (01-31)\"), \"%d\" }, { QT_TR_NOOP(\"Day of Month (1-31)\"), \"%e\" }, { QT_TR_NOOP(\"Day (001-366)\"), \"%j\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Time (%H-%M-%S)\"), \"%T\" }, { QT_TR_NOOP(\"Time (%H-%M)\"), \"%R\" }, #endif { QT_TR_NOOP(\"Hour (00-23)\"), \"%H\" }, { QT_TR_NOOP(\"Hour (01-12)\"), \"%I\" }, { QT_TR_NOOP(\"Minute (00-59)\"), \"%M\" }, { QT_TR_NOOP(\"Second (00-59)\"), \"%S\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Full Date (%m/%d/%y)\"), \"%D\" }, #endif { QT_TR_NOOP(\"Full Date (%Y-%m-%d)\"), \"%F\" }, };","title":"File strftimechooserwidget.cpp"},{"location":"flameshot/strftimechooserwidget_8cpp_source/#file-strftimechooserwidgetcpp","text":"File List > config > strftimechooserwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"strftimechooserwidget.h\" #include <QGridLayout> #include <QMap> #include <QPushButton> StrftimeChooserWidget::StrftimeChooserWidget(QWidget* parent) : QWidget(parent) { auto* layout = new QGridLayout(this); auto k = m_buttonData.keys(); int middle = k.length() / 2; // add the buttons in 2 columns (they need to be even) for (int i = 0; i < 2; i++) { for (int j = 0; j < middle; j++) { QString key = k.last(); k.pop_back(); QString variable = m_buttonData.value(key); auto* button = new QPushButton(this); button->setText(tr(key.toStdString().data())); button->setToolTip(variable); button->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); button->setMinimumHeight(25); layout->addWidget(button, j, i); connect(button, &QPushButton::clicked, this, [variable, this]() { emit variableEmitted(variable); }); } } setLayout(layout); } QMap<QString, QString> StrftimeChooserWidget::m_buttonData{ { QT_TR_NOOP(\"Century (00-99)\"), \"%C\" }, { QT_TR_NOOP(\"Year (00-99)\"), \"%y\" }, { QT_TR_NOOP(\"Year (2000)\"), \"%Y\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Month Name (jan)\"), \"%b\" }, { QT_TR_NOOP(\"Month Name (january)\"), \"%B\" }, #endif { QT_TR_NOOP(\"Month (01-12)\"), \"%m\" }, { QT_TR_NOOP(\"Week Day (1-7)\"), \"%u\" }, { QT_TR_NOOP(\"Week (01-53)\"), \"%V\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Day Name (mon)\"), \"%a\" }, { QT_TR_NOOP(\"Day Name (monday)\"), \"%A\" }, #endif { QT_TR_NOOP(\"Day (01-31)\"), \"%d\" }, { QT_TR_NOOP(\"Day of Month (1-31)\"), \"%e\" }, { QT_TR_NOOP(\"Day (001-366)\"), \"%j\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Time (%H-%M-%S)\"), \"%T\" }, { QT_TR_NOOP(\"Time (%H-%M)\"), \"%R\" }, #endif { QT_TR_NOOP(\"Hour (00-23)\"), \"%H\" }, { QT_TR_NOOP(\"Hour (01-12)\"), \"%I\" }, { QT_TR_NOOP(\"Minute (00-59)\"), \"%M\" }, { QT_TR_NOOP(\"Second (00-59)\"), \"%S\" }, #ifndef Q_OS_WIN // TODO - fix localized names on windows (ex. Cyrillic) { QT_TR_NOOP(\"Full Date (%m/%d/%y)\"), \"%D\" }, #endif { QT_TR_NOOP(\"Full Date (%Y-%m-%d)\"), \"%F\" }, };","title":"File strftimechooserwidget.cpp"},{"location":"flameshot/strftimechooserwidget_8h/","text":"File strftimechooserwidget.h # FileList > config > strftimechooserwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class StrftimeChooserWidget","title":"File strftimechooserwidget.h"},{"location":"flameshot/strftimechooserwidget_8h/#file-strftimechooserwidgeth","text":"FileList > config > strftimechooserwidget.h Go to the source code of this file. #include <QWidget>","title":"File strftimechooserwidget.h"},{"location":"flameshot/strftimechooserwidget_8h/#classes","text":"Type Name class StrftimeChooserWidget","title":"Classes"},{"location":"flameshot/strftimechooserwidget_8h_source/","text":"File strftimechooserwidget.h # File List > config > strftimechooserwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class StrftimeChooserWidget : public QWidget { Q_OBJECT public: explicit StrftimeChooserWidget(QWidget* parent = nullptr); signals: void variableEmitted(const QString&); private: static QMap<QString, QString> m_buttonData; };","title":"File strftimechooserwidget.h"},{"location":"flameshot/strftimechooserwidget_8h_source/#file-strftimechooserwidgeth","text":"File List > config > strftimechooserwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class StrftimeChooserWidget : public QWidget { Q_OBJECT public: explicit StrftimeChooserWidget(QWidget* parent = nullptr); signals: void variableEmitted(const QString&); private: static QMap<QString, QString> m_buttonData; };","title":"File strftimechooserwidget.h"},{"location":"flameshot/styleoverride_8cpp/","text":"File styleoverride.cpp # FileList > config > styleoverride.cpp Go to the source code of this file. #include \"styleoverride.h\"","title":"File styleoverride.cpp"},{"location":"flameshot/styleoverride_8cpp/#file-styleoverridecpp","text":"FileList > config > styleoverride.cpp Go to the source code of this file. #include \"styleoverride.h\"","title":"File styleoverride.cpp"},{"location":"flameshot/styleoverride_8cpp_source/","text":"File styleoverride.cpp # File List > config > styleoverride.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Jeremy Borgman <borgman.jeremy@pm.me> // // Created by jeremy on 9/24/20. #include \"styleoverride.h\" int StyleOverride::styleHint(StyleHint hint, const QStyleOption* option, const QWidget* widget, QStyleHintReturn* returnData) const { if (hint == SH_ToolTip_WakeUpDelay) { return 600; } else { return baseStyle()->styleHint(hint, option, widget, returnData); } }","title":"File styleoverride.cpp"},{"location":"flameshot/styleoverride_8cpp_source/#file-styleoverridecpp","text":"File List > config > styleoverride.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Jeremy Borgman <borgman.jeremy@pm.me> // // Created by jeremy on 9/24/20. #include \"styleoverride.h\" int StyleOverride::styleHint(StyleHint hint, const QStyleOption* option, const QWidget* widget, QStyleHintReturn* returnData) const { if (hint == SH_ToolTip_WakeUpDelay) { return 600; } else { return baseStyle()->styleHint(hint, option, widget, returnData); } }","title":"File styleoverride.cpp"},{"location":"flameshot/styleoverride_8h/","text":"File styleoverride.h # FileList > config > styleoverride.h Go to the source code of this file. #include <QObject> #include <QProxyStyle> Classes # Type Name class StyleOverride","title":"File styleoverride.h"},{"location":"flameshot/styleoverride_8h/#file-styleoverrideh","text":"FileList > config > styleoverride.h Go to the source code of this file. #include <QObject> #include <QProxyStyle>","title":"File styleoverride.h"},{"location":"flameshot/styleoverride_8h/#classes","text":"Type Name class StyleOverride","title":"Classes"},{"location":"flameshot/styleoverride_8h_source/","text":"File styleoverride.h # File List > config > styleoverride.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Jeremy Borgman <borgman.jeremy@pm.me> // // Created by jeremy on 9/24/20. #ifndef FLAMESHOT_STYLEOVERRIDE_H #define FLAMESHOT_STYLEOVERRIDE_H #include <QObject> #include <QProxyStyle> class StyleOverride : public QProxyStyle { Q_OBJECT public: int styleHint(StyleHint hint, const QStyleOption* option = Q_NULLPTR, const QWidget* widget = Q_NULLPTR, QStyleHintReturn* returnData = Q_NULLPTR) const; }; #endif // FLAMESHOT_STYLEOVERRIDE_H","title":"File styleoverride.h"},{"location":"flameshot/styleoverride_8h_source/#file-styleoverrideh","text":"File List > config > styleoverride.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2020 Jeremy Borgman <borgman.jeremy@pm.me> // // Created by jeremy on 9/24/20. #ifndef FLAMESHOT_STYLEOVERRIDE_H #define FLAMESHOT_STYLEOVERRIDE_H #include <QObject> #include <QProxyStyle> class StyleOverride : public QProxyStyle { Q_OBJECT public: int styleHint(StyleHint hint, const QStyleOption* option = Q_NULLPTR, const QWidget* widget = Q_NULLPTR, QStyleHintReturn* returnData = Q_NULLPTR) const; }; #endif // FLAMESHOT_STYLEOVERRIDE_H","title":"File styleoverride.h"},{"location":"flameshot/uicoloreditor_8cpp/","text":"File uicoloreditor.cpp # FileList > config > uicoloreditor.cpp Go to the source code of this file. #include \"uicoloreditor.h\" #include \"clickablelabel.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QComboBox> #include <QHBoxLayout> #include <QMap> #include <QSpacerItem> #include <QVBoxLayout>","title":"File uicoloreditor.cpp"},{"location":"flameshot/uicoloreditor_8cpp/#file-uicoloreditorcpp","text":"FileList > config > uicoloreditor.cpp Go to the source code of this file. #include \"uicoloreditor.h\" #include \"clickablelabel.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QComboBox> #include <QHBoxLayout> #include <QMap> #include <QSpacerItem> #include <QVBoxLayout>","title":"File uicoloreditor.cpp"},{"location":"flameshot/uicoloreditor_8cpp_source/","text":"File uicoloreditor.cpp # File List > config > uicoloreditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"uicoloreditor.h\" #include \"clickablelabel.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QComboBox> #include <QHBoxLayout> #include <QMap> #include <QSpacerItem> #include <QVBoxLayout> UIcolorEditor::UIcolorEditor(QWidget* parent) : QWidget(parent) { setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_hLayout = new QHBoxLayout; m_vLayout = new QVBoxLayout; const int space = QApplication::fontMetrics().lineSpacing(); m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding)); m_vLayout->setAlignment(Qt::AlignVCenter); initButtons(); initColorWheel(); m_vLayout->addSpacing(space); m_hLayout->addLayout(m_vLayout); m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding)); setLayout(m_hLayout); updateComponents(); } void UIcolorEditor::updateComponents() { ConfigHandler config; m_uiColor = config.uiColor(); m_contrastColor = config.contrastUiColor(); m_buttonContrast->setColor(m_contrastColor); m_buttonMainColor->setColor(m_uiColor); if (m_lastButtonPressed == m_buttonMainColor) { m_colorWheel->setColor(m_uiColor); } else { m_colorWheel->setColor(m_contrastColor); } } // updateUIcolor updates the appearance of the buttons void UIcolorEditor::updateUIcolor() { ConfigHandler config; if (m_lastButtonPressed == m_buttonMainColor) { config.setUiColor(m_uiColor); } else { config.setContrastUiColor(m_contrastColor); } } // updateLocalColor updates the local button void UIcolorEditor::updateLocalColor(const QColor c) { if (m_lastButtonPressed == m_buttonMainColor) { m_uiColor = c; } else { m_contrastColor = c; } m_lastButtonPressed->setColor(c); } void UIcolorEditor::initColorWheel() { m_colorWheel = new color_widgets::ColorWheel(this); connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, &UIcolorEditor::updateUIcolor); connect(m_colorWheel, &color_widgets::ColorWheel::colorChanged, this, &UIcolorEditor::updateLocalColor); const int size = GlobalValues::buttonBaseSize() * 3; m_colorWheel->setMinimumSize(size, size); m_colorWheel->setMaximumSize(size * 2, size * 2); m_colorWheel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_colorWheel->setToolTip(tr(\"Change the color moving the selectors and see\" \" the changes in the preview buttons.\")); m_hLayout->addWidget(m_colorWheel); } void UIcolorEditor::initButtons() { const int extraSize = GlobalValues::buttonBaseSize() / 3; int frameSize = GlobalValues::buttonBaseSize() + extraSize; m_vLayout->addWidget(new QLabel(tr(\"Select a Button to modify it\"), this)); auto* frame = new QGroupBox(); frame->setFixedSize(frameSize, frameSize); m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame); m_buttonMainColor->move(m_buttonMainColor->x() + extraSize / 2, m_buttonMainColor->y() + extraSize / 2); auto* h1 = new QHBoxLayout(); h1->addWidget(frame); m_labelMain = new ClickableLabel(tr(\"Main Color\"), this); h1->addWidget(m_labelMain); m_vLayout->addLayout(h1); m_buttonMainColor->setToolTip(tr(\"Click on this button to set the edition\" \" mode of the main color.\")); auto* frame2 = new QGroupBox(); m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2); m_buttonContrast->move(m_buttonContrast->x() + extraSize / 2, m_buttonContrast->y() + extraSize / 2); auto* h2 = new QHBoxLayout(); h2->addWidget(frame2); frame2->setFixedSize(frameSize, frameSize); m_labelContrast = new ClickableLabel(tr(\"Contrast Color\"), this); m_labelContrast->setStyleSheet(QStringLiteral(\"color : gray\")); h2->addWidget(m_labelContrast); m_vLayout->addLayout(h2); m_buttonContrast->setToolTip(tr(\"Click on this button to set the edition\" \" mode of the contrast color.\")); connect(m_buttonMainColor, &CaptureToolButton::pressedButtonLeftClick, this, &UIcolorEditor::changeLastButton); connect(m_buttonContrast, &CaptureToolButton::pressedButtonLeftClick, this, &UIcolorEditor::changeLastButton); // clicking the labels changes the button too connect(m_labelMain, &ClickableLabel::clicked, this, [this] { changeLastButton(m_buttonMainColor); }); connect(m_labelContrast, &ClickableLabel::clicked, this, [this] { changeLastButton(m_buttonContrast); }); m_lastButtonPressed = m_buttonMainColor; } // visual update for the selected button void UIcolorEditor::changeLastButton(CaptureToolButton* b) { if (m_lastButtonPressed != b) { m_lastButtonPressed = b; QString offStyle(QStringLiteral(\"QLabel { color : gray; }\")); if (b == m_buttonMainColor) { m_colorWheel->setColor(m_uiColor); m_labelContrast->setStyleSheet(offStyle); m_labelMain->setStyleSheet(styleSheet()); } else { m_colorWheel->setColor(m_contrastColor); m_labelContrast->setStyleSheet(styleSheet()); m_labelMain->setStyleSheet(offStyle); } b->setIcon(b->icon()); } }","title":"File uicoloreditor.cpp"},{"location":"flameshot/uicoloreditor_8cpp_source/#file-uicoloreditorcpp","text":"File List > config > uicoloreditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"uicoloreditor.h\" #include \"clickablelabel.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QComboBox> #include <QHBoxLayout> #include <QMap> #include <QSpacerItem> #include <QVBoxLayout> UIcolorEditor::UIcolorEditor(QWidget* parent) : QWidget(parent) { setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_hLayout = new QHBoxLayout; m_vLayout = new QVBoxLayout; const int space = QApplication::fontMetrics().lineSpacing(); m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding)); m_vLayout->setAlignment(Qt::AlignVCenter); initButtons(); initColorWheel(); m_vLayout->addSpacing(space); m_hLayout->addLayout(m_vLayout); m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding)); setLayout(m_hLayout); updateComponents(); } void UIcolorEditor::updateComponents() { ConfigHandler config; m_uiColor = config.uiColor(); m_contrastColor = config.contrastUiColor(); m_buttonContrast->setColor(m_contrastColor); m_buttonMainColor->setColor(m_uiColor); if (m_lastButtonPressed == m_buttonMainColor) { m_colorWheel->setColor(m_uiColor); } else { m_colorWheel->setColor(m_contrastColor); } } // updateUIcolor updates the appearance of the buttons void UIcolorEditor::updateUIcolor() { ConfigHandler config; if (m_lastButtonPressed == m_buttonMainColor) { config.setUiColor(m_uiColor); } else { config.setContrastUiColor(m_contrastColor); } } // updateLocalColor updates the local button void UIcolorEditor::updateLocalColor(const QColor c) { if (m_lastButtonPressed == m_buttonMainColor) { m_uiColor = c; } else { m_contrastColor = c; } m_lastButtonPressed->setColor(c); } void UIcolorEditor::initColorWheel() { m_colorWheel = new color_widgets::ColorWheel(this); connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, &UIcolorEditor::updateUIcolor); connect(m_colorWheel, &color_widgets::ColorWheel::colorChanged, this, &UIcolorEditor::updateLocalColor); const int size = GlobalValues::buttonBaseSize() * 3; m_colorWheel->setMinimumSize(size, size); m_colorWheel->setMaximumSize(size * 2, size * 2); m_colorWheel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); m_colorWheel->setToolTip(tr(\"Change the color moving the selectors and see\" \" the changes in the preview buttons.\")); m_hLayout->addWidget(m_colorWheel); } void UIcolorEditor::initButtons() { const int extraSize = GlobalValues::buttonBaseSize() / 3; int frameSize = GlobalValues::buttonBaseSize() + extraSize; m_vLayout->addWidget(new QLabel(tr(\"Select a Button to modify it\"), this)); auto* frame = new QGroupBox(); frame->setFixedSize(frameSize, frameSize); m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame); m_buttonMainColor->move(m_buttonMainColor->x() + extraSize / 2, m_buttonMainColor->y() + extraSize / 2); auto* h1 = new QHBoxLayout(); h1->addWidget(frame); m_labelMain = new ClickableLabel(tr(\"Main Color\"), this); h1->addWidget(m_labelMain); m_vLayout->addLayout(h1); m_buttonMainColor->setToolTip(tr(\"Click on this button to set the edition\" \" mode of the main color.\")); auto* frame2 = new QGroupBox(); m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2); m_buttonContrast->move(m_buttonContrast->x() + extraSize / 2, m_buttonContrast->y() + extraSize / 2); auto* h2 = new QHBoxLayout(); h2->addWidget(frame2); frame2->setFixedSize(frameSize, frameSize); m_labelContrast = new ClickableLabel(tr(\"Contrast Color\"), this); m_labelContrast->setStyleSheet(QStringLiteral(\"color : gray\")); h2->addWidget(m_labelContrast); m_vLayout->addLayout(h2); m_buttonContrast->setToolTip(tr(\"Click on this button to set the edition\" \" mode of the contrast color.\")); connect(m_buttonMainColor, &CaptureToolButton::pressedButtonLeftClick, this, &UIcolorEditor::changeLastButton); connect(m_buttonContrast, &CaptureToolButton::pressedButtonLeftClick, this, &UIcolorEditor::changeLastButton); // clicking the labels changes the button too connect(m_labelMain, &ClickableLabel::clicked, this, [this] { changeLastButton(m_buttonMainColor); }); connect(m_labelContrast, &ClickableLabel::clicked, this, [this] { changeLastButton(m_buttonContrast); }); m_lastButtonPressed = m_buttonMainColor; } // visual update for the selected button void UIcolorEditor::changeLastButton(CaptureToolButton* b) { if (m_lastButtonPressed != b) { m_lastButtonPressed = b; QString offStyle(QStringLiteral(\"QLabel { color : gray; }\")); if (b == m_buttonMainColor) { m_colorWheel->setColor(m_uiColor); m_labelContrast->setStyleSheet(offStyle); m_labelMain->setStyleSheet(styleSheet()); } else { m_colorWheel->setColor(m_contrastColor); m_labelContrast->setStyleSheet(styleSheet()); m_labelMain->setStyleSheet(offStyle); } b->setIcon(b->icon()); } }","title":"File uicoloreditor.cpp"},{"location":"flameshot/uicoloreditor_8h/","text":"File uicoloreditor.h # FileList > config > uicoloreditor.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QGroupBox> Classes # Type Name class UIcolorEditor","title":"File uicoloreditor.h"},{"location":"flameshot/uicoloreditor_8h/#file-uicoloreditorh","text":"FileList > config > uicoloreditor.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QGroupBox>","title":"File uicoloreditor.h"},{"location":"flameshot/uicoloreditor_8h/#classes","text":"Type Name class UIcolorEditor","title":"Classes"},{"location":"flameshot/uicoloreditor_8h_source/","text":"File uicoloreditor.h # File List > config > uicoloreditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QGroupBox> class QVBoxLayout; class QHBoxLayout; class CaptureToolButton; class ClickableLabel; class UIcolorEditor : public QWidget { Q_OBJECT public: explicit UIcolorEditor(QWidget* parent = nullptr); public slots: void updateComponents(); private slots: void updateUIcolor(); void updateLocalColor(const QColor); void changeLastButton(CaptureToolButton*); private: QColor m_uiColor, m_contrastColor; CaptureToolButton* m_buttonMainColor; ClickableLabel* m_labelMain; CaptureToolButton* m_buttonContrast; ClickableLabel* m_labelContrast; CaptureToolButton* m_lastButtonPressed; color_widgets::ColorWheel* m_colorWheel; static const CaptureTool::Type m_buttonIconType = CaptureTool::TYPE_CIRCLE; QHBoxLayout* m_hLayout; QVBoxLayout* m_vLayout; void initColorWheel(); void initButtons(); };","title":"File uicoloreditor.h"},{"location":"flameshot/uicoloreditor_8h_source/#file-uicoloreditorh","text":"File List > config > uicoloreditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QGroupBox> class QVBoxLayout; class QHBoxLayout; class CaptureToolButton; class ClickableLabel; class UIcolorEditor : public QWidget { Q_OBJECT public: explicit UIcolorEditor(QWidget* parent = nullptr); public slots: void updateComponents(); private slots: void updateUIcolor(); void updateLocalColor(const QColor); void changeLastButton(CaptureToolButton*); private: QColor m_uiColor, m_contrastColor; CaptureToolButton* m_buttonMainColor; ClickableLabel* m_labelMain; CaptureToolButton* m_buttonContrast; ClickableLabel* m_labelContrast; CaptureToolButton* m_lastButtonPressed; color_widgets::ColorWheel* m_colorWheel; static const CaptureTool::Type m_buttonIconType = CaptureTool::TYPE_CIRCLE; QHBoxLayout* m_hLayout; QVBoxLayout* m_vLayout; void initColorWheel(); void initButtons(); };","title":"File uicoloreditor.h"},{"location":"flameshot/visualseditor_8cpp/","text":"File visualseditor.cpp # FileList > config > visualseditor.cpp Go to the source code of this file. #include \"visualseditor.h\" #include \"src/config/buttonlistview.h\" #include \"src/config/colorpickereditor.h\" #include \"src/config/extendedslider.h\" #include \"src/config/uicoloreditor.h\" #include \"src/utils/confighandler.h\" #include <QHBoxLayout> #include <QLabel>","title":"File visualseditor.cpp"},{"location":"flameshot/visualseditor_8cpp/#file-visualseditorcpp","text":"FileList > config > visualseditor.cpp Go to the source code of this file. #include \"visualseditor.h\" #include \"src/config/buttonlistview.h\" #include \"src/config/colorpickereditor.h\" #include \"src/config/extendedslider.h\" #include \"src/config/uicoloreditor.h\" #include \"src/utils/confighandler.h\" #include <QHBoxLayout> #include <QLabel>","title":"File visualseditor.cpp"},{"location":"flameshot/visualseditor_8cpp_source/","text":"File visualseditor.cpp # File List > config > visualseditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"visualseditor.h\" #include \"src/config/buttonlistview.h\" #include \"src/config/colorpickereditor.h\" #include \"src/config/extendedslider.h\" #include \"src/config/uicoloreditor.h\" #include \"src/utils/confighandler.h\" #include <QHBoxLayout> #include <QLabel> VisualsEditor::VisualsEditor(QWidget* parent) : QWidget(parent) { m_layout = new QVBoxLayout(); setLayout(m_layout); initWidgets(); } void VisualsEditor::updateComponents() { m_buttonList->updateComponents(); m_colorEditor->updateComponents(); int opacity = ConfigHandler().contrastOpacity(); m_opacitySlider->setMapedValue(0, opacity, 255); } void VisualsEditor::initOpacitySlider() { m_opacitySlider = new ExtendedSlider(); m_opacitySlider->setFocusPolicy(Qt::NoFocus); m_opacitySlider->setOrientation(Qt::Horizontal); m_opacitySlider->setRange(0, 100); auto* localLayout = new QHBoxLayout(); localLayout->addWidget(new QLabel(QStringLiteral(\"0%\"))); localLayout->addWidget(m_opacitySlider); localLayout->addWidget(new QLabel(QStringLiteral(\"100%\"))); auto* label = new QLabel(); QString labelMsg = tr(\"Opacity of area outside selection:\") + \" %1%\"; ExtendedSlider* opacitySlider = m_opacitySlider; connect(m_opacitySlider, &ExtendedSlider::valueChanged, this, [labelMsg, label, opacitySlider](int val) { label->setText(labelMsg.arg(val)); ConfigHandler().setContrastOpacity( opacitySlider->mappedValue(0, 255)); }); m_layout->addWidget(label); m_layout->addLayout(localLayout); int opacity = ConfigHandler().contrastOpacity(); m_opacitySlider->setMapedValue(0, opacity, 255); } void VisualsEditor::initWidgets() { m_tabWidget = new QTabWidget(); m_layout->addWidget(m_tabWidget); m_colorEditor = new UIcolorEditor(); m_colorEditorTab = new QWidget(); auto* colorEditorLayout = new QVBoxLayout(m_colorEditorTab); m_colorEditorTab->setLayout(colorEditorLayout); colorEditorLayout->addWidget(m_colorEditor); m_tabWidget->addTab(m_colorEditorTab, tr(\"UI Color Editor\")); m_colorpickerEditor = new ColorPickerEditor(); m_colorpickerEditorTab = new QWidget(); auto* colorpickerEditorLayout = new QVBoxLayout(m_colorpickerEditorTab); colorpickerEditorLayout->addWidget(m_colorpickerEditor); m_tabWidget->addTab(m_colorpickerEditorTab, tr(\"Colorpicker Editor\")); initOpacitySlider(); auto* boxButtons = new QGroupBox(); boxButtons->setTitle(tr(\"Button Selection\")); auto* listLayout = new QVBoxLayout(boxButtons); m_buttonList = new ButtonListView(); m_layout->addWidget(boxButtons); listLayout->addWidget(m_buttonList); auto* setAllButtons = new QPushButton(tr(\"Select All\")); connect(setAllButtons, &QPushButton::clicked, m_buttonList, &ButtonListView::selectAll); listLayout->addWidget(setAllButtons); }","title":"File visualseditor.cpp"},{"location":"flameshot/visualseditor_8cpp_source/#file-visualseditorcpp","text":"File List > config > visualseditor.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"visualseditor.h\" #include \"src/config/buttonlistview.h\" #include \"src/config/colorpickereditor.h\" #include \"src/config/extendedslider.h\" #include \"src/config/uicoloreditor.h\" #include \"src/utils/confighandler.h\" #include <QHBoxLayout> #include <QLabel> VisualsEditor::VisualsEditor(QWidget* parent) : QWidget(parent) { m_layout = new QVBoxLayout(); setLayout(m_layout); initWidgets(); } void VisualsEditor::updateComponents() { m_buttonList->updateComponents(); m_colorEditor->updateComponents(); int opacity = ConfigHandler().contrastOpacity(); m_opacitySlider->setMapedValue(0, opacity, 255); } void VisualsEditor::initOpacitySlider() { m_opacitySlider = new ExtendedSlider(); m_opacitySlider->setFocusPolicy(Qt::NoFocus); m_opacitySlider->setOrientation(Qt::Horizontal); m_opacitySlider->setRange(0, 100); auto* localLayout = new QHBoxLayout(); localLayout->addWidget(new QLabel(QStringLiteral(\"0%\"))); localLayout->addWidget(m_opacitySlider); localLayout->addWidget(new QLabel(QStringLiteral(\"100%\"))); auto* label = new QLabel(); QString labelMsg = tr(\"Opacity of area outside selection:\") + \" %1%\"; ExtendedSlider* opacitySlider = m_opacitySlider; connect(m_opacitySlider, &ExtendedSlider::valueChanged, this, [labelMsg, label, opacitySlider](int val) { label->setText(labelMsg.arg(val)); ConfigHandler().setContrastOpacity( opacitySlider->mappedValue(0, 255)); }); m_layout->addWidget(label); m_layout->addLayout(localLayout); int opacity = ConfigHandler().contrastOpacity(); m_opacitySlider->setMapedValue(0, opacity, 255); } void VisualsEditor::initWidgets() { m_tabWidget = new QTabWidget(); m_layout->addWidget(m_tabWidget); m_colorEditor = new UIcolorEditor(); m_colorEditorTab = new QWidget(); auto* colorEditorLayout = new QVBoxLayout(m_colorEditorTab); m_colorEditorTab->setLayout(colorEditorLayout); colorEditorLayout->addWidget(m_colorEditor); m_tabWidget->addTab(m_colorEditorTab, tr(\"UI Color Editor\")); m_colorpickerEditor = new ColorPickerEditor(); m_colorpickerEditorTab = new QWidget(); auto* colorpickerEditorLayout = new QVBoxLayout(m_colorpickerEditorTab); colorpickerEditorLayout->addWidget(m_colorpickerEditor); m_tabWidget->addTab(m_colorpickerEditorTab, tr(\"Colorpicker Editor\")); initOpacitySlider(); auto* boxButtons = new QGroupBox(); boxButtons->setTitle(tr(\"Button Selection\")); auto* listLayout = new QVBoxLayout(boxButtons); m_buttonList = new ButtonListView(); m_layout->addWidget(boxButtons); listLayout->addWidget(m_buttonList); auto* setAllButtons = new QPushButton(tr(\"Select All\")); connect(setAllButtons, &QPushButton::clicked, m_buttonList, &ButtonListView::selectAll); listLayout->addWidget(setAllButtons); }","title":"File visualseditor.cpp"},{"location":"flameshot/visualseditor_8h/","text":"File visualseditor.h # FileList > config > visualseditor.h Go to the source code of this file. #include <QTabWidget> #include <QWidget> Classes # Type Name class VisualsEditor","title":"File visualseditor.h"},{"location":"flameshot/visualseditor_8h/#file-visualseditorh","text":"FileList > config > visualseditor.h Go to the source code of this file. #include <QTabWidget> #include <QWidget>","title":"File visualseditor.h"},{"location":"flameshot/visualseditor_8h/#classes","text":"Type Name class VisualsEditor","title":"Classes"},{"location":"flameshot/visualseditor_8h_source/","text":"File visualseditor.h # File List > config > visualseditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTabWidget> #include <QWidget> class ExtendedSlider; class QVBoxLayout; class ButtonListView; class UIcolorEditor; class ColorPickerEditor; class VisualsEditor : public QWidget { Q_OBJECT public: explicit VisualsEditor(QWidget* parent = nullptr); public slots: void updateComponents(); private: QVBoxLayout* m_layout; QTabWidget* m_tabWidget; UIcolorEditor* m_colorEditor; QWidget* m_colorEditorTab; ColorPickerEditor* m_colorpickerEditor; QWidget* m_colorpickerEditorTab; ButtonListView* m_buttonList; ExtendedSlider* m_opacitySlider; void initWidgets(); void initOpacitySlider(); };","title":"File visualseditor.h"},{"location":"flameshot/visualseditor_8h_source/#file-visualseditorh","text":"File List > config > visualseditor.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTabWidget> #include <QWidget> class ExtendedSlider; class QVBoxLayout; class ButtonListView; class UIcolorEditor; class ColorPickerEditor; class VisualsEditor : public QWidget { Q_OBJECT public: explicit VisualsEditor(QWidget* parent = nullptr); public slots: void updateComponents(); private: QVBoxLayout* m_layout; QTabWidget* m_tabWidget; UIcolorEditor* m_colorEditor; QWidget* m_colorEditorTab; ColorPickerEditor* m_colorpickerEditor; QWidget* m_colorpickerEditorTab; ButtonListView* m_buttonList; ExtendedSlider* m_opacitySlider; void initWidgets(); void initOpacitySlider(); };","title":"File visualseditor.h"},{"location":"flameshot/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"Dir core # FileList > core Files # Type Name file capturerequest.cpp file capturerequest.h file flameshot.cpp file flameshot.h file flameshotdaemon.cpp file flameshotdaemon.h file flameshotdbusadapter.cpp file flameshotdbusadapter.h file globalshortcutfilter.cpp file globalshortcutfilter.h file qguiappcurrentscreen.cpp file qguiappcurrentscreen.h","title":"Dir core"},{"location":"flameshot/dir_aebb8dcc11953d78e620bbef0b9e2183/#dir-core","text":"FileList > core","title":"Dir core"},{"location":"flameshot/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Type Name file capturerequest.cpp file capturerequest.h file flameshot.cpp file flameshot.h file flameshotdaemon.cpp file flameshotdaemon.h file flameshotdbusadapter.cpp file flameshotdbusadapter.h file globalshortcutfilter.cpp file globalshortcutfilter.h file qguiappcurrentscreen.cpp file qguiappcurrentscreen.h","title":"Files"},{"location":"flameshot/capturerequest_8cpp/","text":"File capturerequest.cpp # FileList > core > capturerequest.cpp Go to the source code of this file. #include \"capturerequest.h\" #include \"confighandler.h\" #include \"imgupload/imguploadermanager.h\" #include \"pinwidget.h\" #include \"src/config/cacheutils.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QClipboard> #include <QDateTime> #include <stdexcept> #include <utility>","title":"File capturerequest.cpp"},{"location":"flameshot/capturerequest_8cpp/#file-capturerequestcpp","text":"FileList > core > capturerequest.cpp Go to the source code of this file. #include \"capturerequest.h\" #include \"confighandler.h\" #include \"imgupload/imguploadermanager.h\" #include \"pinwidget.h\" #include \"src/config/cacheutils.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QClipboard> #include <QDateTime> #include <stdexcept> #include <utility>","title":"File capturerequest.cpp"},{"location":"flameshot/capturerequest_8cpp_source/","text":"File capturerequest.cpp # File List > core > capturerequest.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturerequest.h\" #include \"confighandler.h\" #include \"imgupload/imguploadermanager.h\" #include \"pinwidget.h\" #include \"src/config/cacheutils.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QClipboard> #include <QDateTime> #include <stdexcept> #include <utility> CaptureRequest::CaptureRequest(CaptureRequest::CaptureMode mode, const uint delay, QVariant data, CaptureRequest::ExportTask tasks) : m_mode(mode) , m_delay(delay) , m_tasks(tasks) , m_data(std::move(data)) { ConfigHandler config; if (config.saveLastRegion()) { setInitialSelection(getLastRegion()); } } CaptureRequest::CaptureMode CaptureRequest::captureMode() const { return m_mode; } uint CaptureRequest::delay() const { return m_delay; } QString CaptureRequest::path() const { return m_path; } QVariant CaptureRequest::data() const { return m_data; } CaptureRequest::ExportTask CaptureRequest::tasks() const { return m_tasks; } QRect CaptureRequest::initialSelection() const { return m_initialSelection; } void CaptureRequest::addTask(CaptureRequest::ExportTask task) { if (task == SAVE) { throw std::logic_error(\"SAVE task must be added using addSaveTask\"); } m_tasks |= task; } void CaptureRequest::removeTask(ExportTask task) { ((int&)m_tasks) &= ~task; } void CaptureRequest::addSaveTask(const QString& path) { m_tasks |= SAVE; m_path = path; } void CaptureRequest::addPinTask(const QRect& pinWindowGeometry) { m_tasks |= PIN; m_pinWindowGeometry = pinWindowGeometry; } void CaptureRequest::setInitialSelection(const QRect& selection) { m_initialSelection = selection; }","title":"File capturerequest.cpp"},{"location":"flameshot/capturerequest_8cpp_source/#file-capturerequestcpp","text":"File List > core > capturerequest.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturerequest.h\" #include \"confighandler.h\" #include \"imgupload/imguploadermanager.h\" #include \"pinwidget.h\" #include \"src/config/cacheutils.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QClipboard> #include <QDateTime> #include <stdexcept> #include <utility> CaptureRequest::CaptureRequest(CaptureRequest::CaptureMode mode, const uint delay, QVariant data, CaptureRequest::ExportTask tasks) : m_mode(mode) , m_delay(delay) , m_tasks(tasks) , m_data(std::move(data)) { ConfigHandler config; if (config.saveLastRegion()) { setInitialSelection(getLastRegion()); } } CaptureRequest::CaptureMode CaptureRequest::captureMode() const { return m_mode; } uint CaptureRequest::delay() const { return m_delay; } QString CaptureRequest::path() const { return m_path; } QVariant CaptureRequest::data() const { return m_data; } CaptureRequest::ExportTask CaptureRequest::tasks() const { return m_tasks; } QRect CaptureRequest::initialSelection() const { return m_initialSelection; } void CaptureRequest::addTask(CaptureRequest::ExportTask task) { if (task == SAVE) { throw std::logic_error(\"SAVE task must be added using addSaveTask\"); } m_tasks |= task; } void CaptureRequest::removeTask(ExportTask task) { ((int&)m_tasks) &= ~task; } void CaptureRequest::addSaveTask(const QString& path) { m_tasks |= SAVE; m_path = path; } void CaptureRequest::addPinTask(const QRect& pinWindowGeometry) { m_tasks |= PIN; m_pinWindowGeometry = pinWindowGeometry; } void CaptureRequest::setInitialSelection(const QRect& selection) { m_initialSelection = selection; }","title":"File capturerequest.cpp"},{"location":"flameshot/capturerequest_8h/","text":"File capturerequest.h # FileList > core > capturerequest.h Go to the source code of this file. #include <QPixmap> #include <QString> #include <QVariant> Classes # Type Name class CaptureRequest Public Types # Type Name typedef CaptureRequest::ExportTask eTask Public Functions # Type Name eTask operator& (const eTask & a, const eTask & b) eTask operator| (const eTask & a, const eTask & b) eTask & operator|= (eTask & a, const eTask & b) Public Types Documentation # typedef eTask # using eTask = CaptureRequest::ExportTask; Public Functions Documentation # function operator& # inline eTask operator& ( const eTask & a, const eTask & b ) function operator| # inline eTask operator| ( const eTask & a, const eTask & b ) function operator|= # inline eTask & operator|= ( eTask & a, const eTask & b )","title":"File capturerequest.h"},{"location":"flameshot/capturerequest_8h/#file-capturerequesth","text":"FileList > core > capturerequest.h Go to the source code of this file. #include <QPixmap> #include <QString> #include <QVariant>","title":"File capturerequest.h"},{"location":"flameshot/capturerequest_8h/#classes","text":"Type Name class CaptureRequest","title":"Classes"},{"location":"flameshot/capturerequest_8h/#public-types","text":"Type Name typedef CaptureRequest::ExportTask eTask","title":"Public Types"},{"location":"flameshot/capturerequest_8h/#public-functions","text":"Type Name eTask operator& (const eTask & a, const eTask & b) eTask operator| (const eTask & a, const eTask & b) eTask & operator|= (eTask & a, const eTask & b)","title":"Public Functions"},{"location":"flameshot/capturerequest_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/capturerequest_8h/#typedef-etask","text":"using eTask = CaptureRequest::ExportTask;","title":"typedef eTask"},{"location":"flameshot/capturerequest_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/capturerequest_8h/#function-operator","text":"inline eTask operator& ( const eTask & a, const eTask & b )","title":"function operator&amp;"},{"location":"flameshot/capturerequest_8h/#function-operator_1","text":"inline eTask operator| ( const eTask & a, const eTask & b )","title":"function operator|"},{"location":"flameshot/capturerequest_8h/#function-operator_2","text":"inline eTask & operator|= ( eTask & a, const eTask & b )","title":"function operator|="},{"location":"flameshot/capturerequest_8h_source/","text":"File capturerequest.h # File List > core > capturerequest.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPixmap> #include <QString> #include <QVariant> class CaptureRequest { public: enum CaptureMode { FULLSCREEN_MODE, GRAPHICAL_MODE, SCREEN_MODE, }; enum ExportTask { NO_TASK = 0, COPY = 1, SAVE = 2, PRINT_RAW = 4, PRINT_GEOMETRY = 8, PIN = 16, UPLOAD = 32, ACCEPT_ON_SELECT = 64, }; CaptureRequest(CaptureMode mode, const uint delay = 0, QVariant data = QVariant(), ExportTask tasks = NO_TASK); void setStaticID(uint id); uint id() const; uint delay() const; QString path() const; QVariant data() const; CaptureMode captureMode() const; ExportTask tasks() const; QRect initialSelection() const; void addTask(ExportTask task); void removeTask(ExportTask task); void addSaveTask(const QString& path = QString()); void addPinTask(const QRect& pinWindowGeometry); void setInitialSelection(const QRect& selection); private: CaptureMode m_mode; uint m_delay; QString m_path; ExportTask m_tasks; QVariant m_data; QRect m_pinWindowGeometry, m_initialSelection; CaptureRequest() {} }; using eTask = CaptureRequest::ExportTask; inline eTask operator|(const eTask& a, const eTask& b) { return static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b)); } inline eTask operator&(const eTask& a, const eTask& b) { return static_cast<eTask>(static_cast<int>(a) & static_cast<int>(b)); } inline eTask& operator|=(eTask& a, const eTask& b) { a = static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b)); return a; }","title":"File capturerequest.h"},{"location":"flameshot/capturerequest_8h_source/#file-capturerequesth","text":"File List > core > capturerequest.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPixmap> #include <QString> #include <QVariant> class CaptureRequest { public: enum CaptureMode { FULLSCREEN_MODE, GRAPHICAL_MODE, SCREEN_MODE, }; enum ExportTask { NO_TASK = 0, COPY = 1, SAVE = 2, PRINT_RAW = 4, PRINT_GEOMETRY = 8, PIN = 16, UPLOAD = 32, ACCEPT_ON_SELECT = 64, }; CaptureRequest(CaptureMode mode, const uint delay = 0, QVariant data = QVariant(), ExportTask tasks = NO_TASK); void setStaticID(uint id); uint id() const; uint delay() const; QString path() const; QVariant data() const; CaptureMode captureMode() const; ExportTask tasks() const; QRect initialSelection() const; void addTask(ExportTask task); void removeTask(ExportTask task); void addSaveTask(const QString& path = QString()); void addPinTask(const QRect& pinWindowGeometry); void setInitialSelection(const QRect& selection); private: CaptureMode m_mode; uint m_delay; QString m_path; ExportTask m_tasks; QVariant m_data; QRect m_pinWindowGeometry, m_initialSelection; CaptureRequest() {} }; using eTask = CaptureRequest::ExportTask; inline eTask operator|(const eTask& a, const eTask& b) { return static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b)); } inline eTask operator&(const eTask& a, const eTask& b) { return static_cast<eTask>(static_cast<int>(a) & static_cast<int>(b)); } inline eTask& operator|=(eTask& a, const eTask& b) { a = static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b)); return a; }","title":"File capturerequest.h"},{"location":"flameshot/flameshot_8cpp/","text":"File flameshot.cpp # FileList > core > flameshot.cpp Go to the source code of this file. #include \"flameshot.h\" #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"screenshotsaver.h\" #include \"src/config/configresolver.h\" #include \"src/config/configwindow.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/screengrabber.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/capturelauncher.h\" #include \"src/widgets/imguploaddialog.h\" #include \"src/widgets/infowindow.h\" #include \"src/widgets/uploadhistory.h\" #include <QApplication> #include <QBuffer> #include <QDebug> #include <QDesktopWidget> #include <QFile> #include <QMessageBox> #include <QThread> #include <QTimer> #include <QVersionNumber>","title":"File flameshot.cpp"},{"location":"flameshot/flameshot_8cpp/#file-flameshotcpp","text":"FileList > core > flameshot.cpp Go to the source code of this file. #include \"flameshot.h\" #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"screenshotsaver.h\" #include \"src/config/configresolver.h\" #include \"src/config/configwindow.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/screengrabber.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/capturelauncher.h\" #include \"src/widgets/imguploaddialog.h\" #include \"src/widgets/infowindow.h\" #include \"src/widgets/uploadhistory.h\" #include <QApplication> #include <QBuffer> #include <QDebug> #include <QDesktopWidget> #include <QFile> #include <QMessageBox> #include <QThread> #include <QTimer> #include <QVersionNumber>","title":"File flameshot.cpp"},{"location":"flameshot/flameshot_8cpp_source/","text":"File flameshot.cpp # File List > core > flameshot.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"flameshot.h\" #include \"flameshotdaemon.h\" #if defined(Q_OS_MACOS) #include \"external/QHotkey/QHotkey\" #endif #include \"abstractlogger.h\" #include \"screenshotsaver.h\" #include \"src/config/configresolver.h\" #include \"src/config/configwindow.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/screengrabber.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/capturelauncher.h\" #include \"src/widgets/imguploaddialog.h\" #include \"src/widgets/infowindow.h\" #include \"src/widgets/uploadhistory.h\" #include <QApplication> #include <QBuffer> #include <QDebug> #include <QDesktopWidget> #include <QFile> #include <QMessageBox> #include <QThread> #include <QTimer> #include <QVersionNumber> #if defined(Q_OS_MACOS) #include <QScreen> #endif Flameshot::Flameshot() : m_captureWindow(nullptr) , m_haveExternalWidget(false) #if defined(Q_OS_MACOS) , m_HotkeyScreenshotCapture(nullptr) , m_HotkeyScreenshotHistory(nullptr) #endif { QString StyleSheet = CaptureButton::globalStyleSheet(); qApp->setStyleSheet(StyleSheet); #if defined(Q_OS_MACOS) // Try to take a test screenshot, MacOS will request a \"Screen Recording\" // permissions on the first run. Otherwise it will be hidden under the // CaptureWidget QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); currentScreen->grabWindow(QApplication::desktop()->winId(), 0, 0, 1, 1); // set global shortcuts for MacOS m_HotkeyScreenshotCapture = new QHotkey( QKeySequence(ConfigHandler().shortcut(\"TAKE_SCREENSHOT\")), true, this); QObject::connect(m_HotkeyScreenshotCapture, &QHotkey::activated, qApp, [this]() { gui(); }); m_HotkeyScreenshotHistory = new QHotkey( QKeySequence(ConfigHandler().shortcut(\"SCREENSHOT_HISTORY\")), true, this); QObject::connect(m_HotkeyScreenshotHistory, &QHotkey::activated, qApp, [this]() { history(); }); #endif } Flameshot* Flameshot::instance() { static Flameshot c; return &c; } CaptureWidget* Flameshot::gui(const CaptureRequest& req) { if (!resolveAnyConfigErrors()) { return nullptr; } #if defined(Q_OS_MACOS) // This is required on MacOS because of Mission Control. If you'll switch to // another Desktop you cannot take a new screenshot from the tray, you have // to switch back to the Flameshot Desktop manually. It is not obvious and a // large number of users are confused and report a bug. if (m_captureWindow != nullptr) { m_captureWindow->close(); delete m_captureWindow; m_captureWindow = nullptr; } #endif if (nullptr == m_captureWindow) { // TODO is this unnecessary now? int timeout = 5000; // 5 seconds const int delay = 100; QWidget* modalWidget = nullptr; for (; timeout >= 0; timeout -= delay) { modalWidget = qApp->activeModalWidget(); if (nullptr == modalWidget) { break; } modalWidget->close(); modalWidget->deleteLater(); QThread::msleep(delay); } if (0 == timeout) { QMessageBox::warning( nullptr, tr(\"Error\"), tr(\"Unable to close active modal widgets\")); return nullptr; } m_captureWindow = new CaptureWidget(req); #ifdef Q_OS_WIN m_captureWindow->show(); #elif defined(Q_OS_MACOS) // In \"Emulate fullscreen mode\" m_captureWindow->showFullScreen(); m_captureWindow->activateWindow(); m_captureWindow->raise(); #else m_captureWindow->showFullScreen(); // m_captureWindow->show(); // For CaptureWidget Debugging under Linux #endif return m_captureWindow; } else { emit captureFailed(); return nullptr; } } void Flameshot::screen(CaptureRequest req, const int screenNumber) { if (!resolveAnyConfigErrors()) { return; } bool ok = true; QScreen* screen; if (screenNumber < 0) { QPoint globalCursorPos = QCursor::pos(); screen = qApp->screenAt(globalCursorPos); } else if (screenNumber >= qApp->screens().count()) { AbstractLogger() << QObject::tr( \"Requested screen exceeds screen count\"); emit captureFailed(); return; } else { screen = qApp->screens()[screenNumber]; } QPixmap p(ScreenGrabber().grabScreen(screen, ok)); if (ok) { QRect geometry = ScreenGrabber().screenGeometry(screen); QRect region = req.initialSelection(); if (region.isNull()) { region = ScreenGrabber().screenGeometry(screen); } else { QRect screenGeom = ScreenGrabber().screenGeometry(screen); screenGeom.moveTopLeft({ 0, 0 }); region = region.intersected(screenGeom); p = p.copy(region); } if (req.tasks() & CaptureRequest::PIN) { // change geometry for pin task req.addPinTask(region); } exportCapture(p, geometry, req); } else { emit captureFailed(); } } void Flameshot::full(const CaptureRequest& req) { if (!resolveAnyConfigErrors()) { return; } bool ok = true; QPixmap p(ScreenGrabber().grabEntireDesktop(ok)); QRect region = req.initialSelection(); if (!region.isNull()) { p = p.copy(region); } if (ok) { QRect selection; // `flameshot full` does not support --selection exportCapture(p, selection, req); } else { emit captureFailed(); } } void Flameshot::launcher() { if (!resolveAnyConfigErrors()) { return; } if (m_launcherWindow == nullptr) { m_launcherWindow = new CaptureLauncher(); } m_launcherWindow->show(); #if defined(Q_OS_MACOS) m_launcherWindow->activateWindow(); m_launcherWindow->raise(); #endif } void Flameshot::config() { if (!resolveAnyConfigErrors()) { return; } if (m_configWindow == nullptr) { m_configWindow = new ConfigWindow(); m_configWindow->show(); #if defined(Q_OS_MACOS) m_configWindow->activateWindow(); m_configWindow->raise(); #endif } } void Flameshot::info() { if (m_infoWindow == nullptr) { m_infoWindow = new InfoWindow(); #if defined(Q_OS_MACOS) m_infoWindow->activateWindow(); m_infoWindow->raise(); #endif } } void Flameshot::history() { static UploadHistory* historyWidget = nullptr; if (historyWidget == nullptr) { historyWidget = new UploadHistory; historyWidget->loadHistory(); connect(historyWidget, &QObject::destroyed, this, []() { historyWidget = nullptr; }); } historyWidget->show(); #if defined(Q_OS_MACOS) historyWidget->activateWindow(); historyWidget->raise(); #endif } QVersionNumber Flameshot::getVersion() { return QVersionNumber::fromString( QStringLiteral(APP_VERSION).replace(\"v\", \"\")); } void Flameshot::setOrigin(Origin origin) { m_origin = origin; } Flameshot::Origin Flameshot::origin() { return m_origin; } bool Flameshot::resolveAnyConfigErrors() { bool resolved = true; ConfigHandler config; if (!config.checkUnrecognizedSettings() || !config.checkSemantics()) { auto* resolver = new ConfigResolver(); QObject::connect( resolver, &ConfigResolver::rejected, [resolver, &resolved]() { resolved = false; resolver->deleteLater(); if (origin() == CLI) { exit(1); } }); QObject::connect( resolver, &ConfigResolver::accepted, [resolver, &resolved]() { resolved = true; resolver->close(); resolver->deleteLater(); // Ensure that the dialog is closed before starting capture qApp->processEvents(); }); resolver->exec(); qApp->processEvents(); } return resolved; } void Flameshot::requestCapture(const CaptureRequest& request) { if (!resolveAnyConfigErrors()) { return; } switch (request.captureMode()) { case CaptureRequest::FULLSCREEN_MODE: QTimer::singleShot(request.delay(), [this, request] { full(request); }); break; case CaptureRequest::SCREEN_MODE: { int&& number = request.data().toInt(); QTimer::singleShot(request.delay(), [this, request, number]() { screen(request, number); }); break; } case CaptureRequest::GRAPHICAL_MODE: { QTimer::singleShot( request.delay(), this, [this, request]() { gui(request); }); break; } default: emit captureFailed(); break; } } void Flameshot::exportCapture(QPixmap capture, QRect& selection, const CaptureRequest& req) { using CR = CaptureRequest; int tasks = req.tasks(), mode = req.captureMode(); QString path = req.path(); if (tasks & CR::PRINT_GEOMETRY) { QByteArray byteArray; QBuffer buffer(&byteArray); QTextStream(stdout) << selection.width() << \"x\" << selection.height() << \"+\" << selection.x() << \"+\" << selection.y() << \"\\n\"; } if (tasks & CR::PRINT_RAW) { QByteArray byteArray; QBuffer buffer(&byteArray); capture.save(&buffer, \"PNG\"); QFile file; file.open(stdout, QIODevice::WriteOnly); file.write(byteArray); file.close(); } if (tasks & CR::SAVE) { if (req.path().isEmpty()) { saveToFilesystemGUI(capture); } else { saveToFilesystem(capture, path); } } if (tasks & CR::COPY) { FlameshotDaemon::copyToClipboard(capture); } if (tasks & CR::PIN) { FlameshotDaemon::createPin(capture, selection); if (mode == CR::SCREEN_MODE || mode == CR::FULLSCREEN_MODE) { AbstractLogger::info() << QObject::tr(\"Full screen screenshot pinned to screen\"); } } if (tasks & CR::UPLOAD) { if (!ConfigHandler().uploadWithoutConfirmation()) { auto* dialog = new ImgUploadDialog(); if (dialog->exec() == QDialog::Rejected) { return; } } ImgUploaderBase* widget = ImgUploaderManager().uploader(capture); widget->show(); widget->activateWindow(); // NOTE: lambda can't capture 'this' because it might be destroyed later CR::ExportTask tasks = tasks; QObject::connect( widget, &ImgUploaderBase::uploadOk, [=](const QUrl& url) { if (ConfigHandler().copyURLAfterUpload()) { if (!(tasks & CR::COPY)) { FlameshotDaemon::copyToClipboard( url.toString(), tr(\"URL copied to clipboard.\")); } widget->showPostUploadDialog(); } }); } if (!(tasks & CR::UPLOAD)) { emit captureTaken(capture); } } void Flameshot::setExternalWidget(bool b) { m_haveExternalWidget = b; } bool Flameshot::haveExternalWidget() { return m_haveExternalWidget; } // STATIC ATTRIBUTES Flameshot::Origin Flameshot::m_origin = Flameshot::DAEMON;","title":"File flameshot.cpp"},{"location":"flameshot/flameshot_8cpp_source/#file-flameshotcpp","text":"File List > core > flameshot.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"flameshot.h\" #include \"flameshotdaemon.h\" #if defined(Q_OS_MACOS) #include \"external/QHotkey/QHotkey\" #endif #include \"abstractlogger.h\" #include \"screenshotsaver.h\" #include \"src/config/configresolver.h\" #include \"src/config/configwindow.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/screengrabber.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/capturelauncher.h\" #include \"src/widgets/imguploaddialog.h\" #include \"src/widgets/infowindow.h\" #include \"src/widgets/uploadhistory.h\" #include <QApplication> #include <QBuffer> #include <QDebug> #include <QDesktopWidget> #include <QFile> #include <QMessageBox> #include <QThread> #include <QTimer> #include <QVersionNumber> #if defined(Q_OS_MACOS) #include <QScreen> #endif Flameshot::Flameshot() : m_captureWindow(nullptr) , m_haveExternalWidget(false) #if defined(Q_OS_MACOS) , m_HotkeyScreenshotCapture(nullptr) , m_HotkeyScreenshotHistory(nullptr) #endif { QString StyleSheet = CaptureButton::globalStyleSheet(); qApp->setStyleSheet(StyleSheet); #if defined(Q_OS_MACOS) // Try to take a test screenshot, MacOS will request a \"Screen Recording\" // permissions on the first run. Otherwise it will be hidden under the // CaptureWidget QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); currentScreen->grabWindow(QApplication::desktop()->winId(), 0, 0, 1, 1); // set global shortcuts for MacOS m_HotkeyScreenshotCapture = new QHotkey( QKeySequence(ConfigHandler().shortcut(\"TAKE_SCREENSHOT\")), true, this); QObject::connect(m_HotkeyScreenshotCapture, &QHotkey::activated, qApp, [this]() { gui(); }); m_HotkeyScreenshotHistory = new QHotkey( QKeySequence(ConfigHandler().shortcut(\"SCREENSHOT_HISTORY\")), true, this); QObject::connect(m_HotkeyScreenshotHistory, &QHotkey::activated, qApp, [this]() { history(); }); #endif } Flameshot* Flameshot::instance() { static Flameshot c; return &c; } CaptureWidget* Flameshot::gui(const CaptureRequest& req) { if (!resolveAnyConfigErrors()) { return nullptr; } #if defined(Q_OS_MACOS) // This is required on MacOS because of Mission Control. If you'll switch to // another Desktop you cannot take a new screenshot from the tray, you have // to switch back to the Flameshot Desktop manually. It is not obvious and a // large number of users are confused and report a bug. if (m_captureWindow != nullptr) { m_captureWindow->close(); delete m_captureWindow; m_captureWindow = nullptr; } #endif if (nullptr == m_captureWindow) { // TODO is this unnecessary now? int timeout = 5000; // 5 seconds const int delay = 100; QWidget* modalWidget = nullptr; for (; timeout >= 0; timeout -= delay) { modalWidget = qApp->activeModalWidget(); if (nullptr == modalWidget) { break; } modalWidget->close(); modalWidget->deleteLater(); QThread::msleep(delay); } if (0 == timeout) { QMessageBox::warning( nullptr, tr(\"Error\"), tr(\"Unable to close active modal widgets\")); return nullptr; } m_captureWindow = new CaptureWidget(req); #ifdef Q_OS_WIN m_captureWindow->show(); #elif defined(Q_OS_MACOS) // In \"Emulate fullscreen mode\" m_captureWindow->showFullScreen(); m_captureWindow->activateWindow(); m_captureWindow->raise(); #else m_captureWindow->showFullScreen(); // m_captureWindow->show(); // For CaptureWidget Debugging under Linux #endif return m_captureWindow; } else { emit captureFailed(); return nullptr; } } void Flameshot::screen(CaptureRequest req, const int screenNumber) { if (!resolveAnyConfigErrors()) { return; } bool ok = true; QScreen* screen; if (screenNumber < 0) { QPoint globalCursorPos = QCursor::pos(); screen = qApp->screenAt(globalCursorPos); } else if (screenNumber >= qApp->screens().count()) { AbstractLogger() << QObject::tr( \"Requested screen exceeds screen count\"); emit captureFailed(); return; } else { screen = qApp->screens()[screenNumber]; } QPixmap p(ScreenGrabber().grabScreen(screen, ok)); if (ok) { QRect geometry = ScreenGrabber().screenGeometry(screen); QRect region = req.initialSelection(); if (region.isNull()) { region = ScreenGrabber().screenGeometry(screen); } else { QRect screenGeom = ScreenGrabber().screenGeometry(screen); screenGeom.moveTopLeft({ 0, 0 }); region = region.intersected(screenGeom); p = p.copy(region); } if (req.tasks() & CaptureRequest::PIN) { // change geometry for pin task req.addPinTask(region); } exportCapture(p, geometry, req); } else { emit captureFailed(); } } void Flameshot::full(const CaptureRequest& req) { if (!resolveAnyConfigErrors()) { return; } bool ok = true; QPixmap p(ScreenGrabber().grabEntireDesktop(ok)); QRect region = req.initialSelection(); if (!region.isNull()) { p = p.copy(region); } if (ok) { QRect selection; // `flameshot full` does not support --selection exportCapture(p, selection, req); } else { emit captureFailed(); } } void Flameshot::launcher() { if (!resolveAnyConfigErrors()) { return; } if (m_launcherWindow == nullptr) { m_launcherWindow = new CaptureLauncher(); } m_launcherWindow->show(); #if defined(Q_OS_MACOS) m_launcherWindow->activateWindow(); m_launcherWindow->raise(); #endif } void Flameshot::config() { if (!resolveAnyConfigErrors()) { return; } if (m_configWindow == nullptr) { m_configWindow = new ConfigWindow(); m_configWindow->show(); #if defined(Q_OS_MACOS) m_configWindow->activateWindow(); m_configWindow->raise(); #endif } } void Flameshot::info() { if (m_infoWindow == nullptr) { m_infoWindow = new InfoWindow(); #if defined(Q_OS_MACOS) m_infoWindow->activateWindow(); m_infoWindow->raise(); #endif } } void Flameshot::history() { static UploadHistory* historyWidget = nullptr; if (historyWidget == nullptr) { historyWidget = new UploadHistory; historyWidget->loadHistory(); connect(historyWidget, &QObject::destroyed, this, []() { historyWidget = nullptr; }); } historyWidget->show(); #if defined(Q_OS_MACOS) historyWidget->activateWindow(); historyWidget->raise(); #endif } QVersionNumber Flameshot::getVersion() { return QVersionNumber::fromString( QStringLiteral(APP_VERSION).replace(\"v\", \"\")); } void Flameshot::setOrigin(Origin origin) { m_origin = origin; } Flameshot::Origin Flameshot::origin() { return m_origin; } bool Flameshot::resolveAnyConfigErrors() { bool resolved = true; ConfigHandler config; if (!config.checkUnrecognizedSettings() || !config.checkSemantics()) { auto* resolver = new ConfigResolver(); QObject::connect( resolver, &ConfigResolver::rejected, [resolver, &resolved]() { resolved = false; resolver->deleteLater(); if (origin() == CLI) { exit(1); } }); QObject::connect( resolver, &ConfigResolver::accepted, [resolver, &resolved]() { resolved = true; resolver->close(); resolver->deleteLater(); // Ensure that the dialog is closed before starting capture qApp->processEvents(); }); resolver->exec(); qApp->processEvents(); } return resolved; } void Flameshot::requestCapture(const CaptureRequest& request) { if (!resolveAnyConfigErrors()) { return; } switch (request.captureMode()) { case CaptureRequest::FULLSCREEN_MODE: QTimer::singleShot(request.delay(), [this, request] { full(request); }); break; case CaptureRequest::SCREEN_MODE: { int&& number = request.data().toInt(); QTimer::singleShot(request.delay(), [this, request, number]() { screen(request, number); }); break; } case CaptureRequest::GRAPHICAL_MODE: { QTimer::singleShot( request.delay(), this, [this, request]() { gui(request); }); break; } default: emit captureFailed(); break; } } void Flameshot::exportCapture(QPixmap capture, QRect& selection, const CaptureRequest& req) { using CR = CaptureRequest; int tasks = req.tasks(), mode = req.captureMode(); QString path = req.path(); if (tasks & CR::PRINT_GEOMETRY) { QByteArray byteArray; QBuffer buffer(&byteArray); QTextStream(stdout) << selection.width() << \"x\" << selection.height() << \"+\" << selection.x() << \"+\" << selection.y() << \"\\n\"; } if (tasks & CR::PRINT_RAW) { QByteArray byteArray; QBuffer buffer(&byteArray); capture.save(&buffer, \"PNG\"); QFile file; file.open(stdout, QIODevice::WriteOnly); file.write(byteArray); file.close(); } if (tasks & CR::SAVE) { if (req.path().isEmpty()) { saveToFilesystemGUI(capture); } else { saveToFilesystem(capture, path); } } if (tasks & CR::COPY) { FlameshotDaemon::copyToClipboard(capture); } if (tasks & CR::PIN) { FlameshotDaemon::createPin(capture, selection); if (mode == CR::SCREEN_MODE || mode == CR::FULLSCREEN_MODE) { AbstractLogger::info() << QObject::tr(\"Full screen screenshot pinned to screen\"); } } if (tasks & CR::UPLOAD) { if (!ConfigHandler().uploadWithoutConfirmation()) { auto* dialog = new ImgUploadDialog(); if (dialog->exec() == QDialog::Rejected) { return; } } ImgUploaderBase* widget = ImgUploaderManager().uploader(capture); widget->show(); widget->activateWindow(); // NOTE: lambda can't capture 'this' because it might be destroyed later CR::ExportTask tasks = tasks; QObject::connect( widget, &ImgUploaderBase::uploadOk, [=](const QUrl& url) { if (ConfigHandler().copyURLAfterUpload()) { if (!(tasks & CR::COPY)) { FlameshotDaemon::copyToClipboard( url.toString(), tr(\"URL copied to clipboard.\")); } widget->showPostUploadDialog(); } }); } if (!(tasks & CR::UPLOAD)) { emit captureTaken(capture); } } void Flameshot::setExternalWidget(bool b) { m_haveExternalWidget = b; } bool Flameshot::haveExternalWidget() { return m_haveExternalWidget; } // STATIC ATTRIBUTES Flameshot::Origin Flameshot::m_origin = Flameshot::DAEMON;","title":"File flameshot.cpp"},{"location":"flameshot/flameshot_8h/","text":"File flameshot.h # FileList > core > flameshot.h Go to the source code of this file. #include \"src/core/capturerequest.h\" #include <QObject> #include <QPointer> #include <QVersionNumber> Classes # Type Name class Flameshot","title":"File flameshot.h"},{"location":"flameshot/flameshot_8h/#file-flameshoth","text":"FileList > core > flameshot.h Go to the source code of this file. #include \"src/core/capturerequest.h\" #include <QObject> #include <QPointer> #include <QVersionNumber>","title":"File flameshot.h"},{"location":"flameshot/flameshot_8h/#classes","text":"Type Name class Flameshot","title":"Classes"},{"location":"flameshot/flameshot_8h_source/","text":"File flameshot.h # File List > core > flameshot.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/core/capturerequest.h\" #include <QObject> #include <QPointer> #include <QVersionNumber> class CaptureWidget; class ConfigWindow; class InfoWindow; class CaptureLauncher; class UploadHistory; #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) class QHotkey; #endif class Flameshot : public QObject { Q_OBJECT public: enum Origin { CLI, DAEMON }; static Flameshot* instance(); public slots: CaptureWidget* gui( const CaptureRequest& req = CaptureRequest::GRAPHICAL_MODE); void screen(CaptureRequest req, int const screenNumber = -1); void full(const CaptureRequest& req); void launcher(); void config(); void info(); void history(); QVersionNumber getVersion(); public: static void setOrigin(Origin origin); static Origin origin(); void setExternalWidget(bool b); bool haveExternalWidget(); signals: void captureTaken(QPixmap p); void captureFailed(); public slots: void requestCapture(const CaptureRequest& request); void exportCapture(QPixmap p, QRect& selection, const CaptureRequest& req); private: Flameshot(); bool resolveAnyConfigErrors(); // class members static Origin m_origin; bool m_haveExternalWidget; QPointer<CaptureWidget> m_captureWindow; QPointer<InfoWindow> m_infoWindow; QPointer<CaptureLauncher> m_launcherWindow; QPointer<ConfigWindow> m_configWindow; #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) QHotkey* m_HotkeyScreenshotCapture; QHotkey* m_HotkeyScreenshotHistory; #endif };","title":"File flameshot.h"},{"location":"flameshot/flameshot_8h_source/#file-flameshoth","text":"File List > core > flameshot.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/core/capturerequest.h\" #include <QObject> #include <QPointer> #include <QVersionNumber> class CaptureWidget; class ConfigWindow; class InfoWindow; class CaptureLauncher; class UploadHistory; #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) class QHotkey; #endif class Flameshot : public QObject { Q_OBJECT public: enum Origin { CLI, DAEMON }; static Flameshot* instance(); public slots: CaptureWidget* gui( const CaptureRequest& req = CaptureRequest::GRAPHICAL_MODE); void screen(CaptureRequest req, int const screenNumber = -1); void full(const CaptureRequest& req); void launcher(); void config(); void info(); void history(); QVersionNumber getVersion(); public: static void setOrigin(Origin origin); static Origin origin(); void setExternalWidget(bool b); bool haveExternalWidget(); signals: void captureTaken(QPixmap p); void captureFailed(); public slots: void requestCapture(const CaptureRequest& request); void exportCapture(QPixmap p, QRect& selection, const CaptureRequest& req); private: Flameshot(); bool resolveAnyConfigErrors(); // class members static Origin m_origin; bool m_haveExternalWidget; QPointer<CaptureWidget> m_captureWindow; QPointer<InfoWindow> m_infoWindow; QPointer<CaptureLauncher> m_launcherWindow; QPointer<ConfigWindow> m_configWindow; #if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) || \\ defined(Q_OS_MACX)) QHotkey* m_HotkeyScreenshotCapture; QHotkey* m_HotkeyScreenshotHistory; #endif };","title":"File flameshot.h"},{"location":"flameshot/flameshotdaemon_8cpp/","text":"File flameshotdaemon.cpp # FileList > core > flameshotdaemon.cpp Go to the source code of this file. #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"confighandler.h\" #include \"flameshot.h\" #include \"pinwidget.h\" #include \"screenshotsaver.h\" #include \"src/utils/globalvalues.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/trayicon.h\" #include <QApplication> #include <QClipboard> #include <QDBusConnection> #include <QDBusMessage> #include <QPixmap> #include <QRect> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QTimer> #include <QUrl>","title":"File flameshotdaemon.cpp"},{"location":"flameshot/flameshotdaemon_8cpp/#file-flameshotdaemoncpp","text":"FileList > core > flameshotdaemon.cpp Go to the source code of this file. #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"confighandler.h\" #include \"flameshot.h\" #include \"pinwidget.h\" #include \"screenshotsaver.h\" #include \"src/utils/globalvalues.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/trayicon.h\" #include <QApplication> #include <QClipboard> #include <QDBusConnection> #include <QDBusMessage> #include <QPixmap> #include <QRect> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QTimer> #include <QUrl>","title":"File flameshotdaemon.cpp"},{"location":"flameshot/flameshotdaemon_8cpp_source/","text":"File flameshotdaemon.cpp # File List > core > flameshotdaemon.cpp Go to the documentation of this file. #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"confighandler.h\" #include \"flameshot.h\" #include \"pinwidget.h\" #include \"screenshotsaver.h\" #include \"src/utils/globalvalues.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/trayicon.h\" #include <QApplication> #include <QClipboard> #include <QDBusConnection> #include <QDBusMessage> #include <QPixmap> #include <QRect> #if !defined(DISABLE_UPDATE_CHECKER) #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QTimer> #include <QUrl> #endif #ifdef Q_OS_WIN #include \"src/core/globalshortcutfilter.h\" #endif FlameshotDaemon::FlameshotDaemon() : m_persist(false) , m_hostingClipboard(false) , m_clipboardSignalBlocked(false) , m_trayIcon(nullptr) #if !defined(DISABLE_UPDATE_CHECKER) , m_networkCheckUpdates(nullptr) , m_showCheckAppUpdateStatus(false) , m_appLatestVersion(QStringLiteral(APP_VERSION).replace(\"v\", \"\")) #endif { connect( QApplication::clipboard(), &QClipboard::dataChanged, this, [this]() { if (!m_hostingClipboard || m_clipboardSignalBlocked) { m_clipboardSignalBlocked = false; return; } m_hostingClipboard = false; quitIfIdle(); }); #ifdef Q_OS_WIN m_persist = true; #else m_persist = !ConfigHandler().autoCloseIdleDaemon(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() { ConfigHandler config; if (config.disabledTrayIcon()) { enableTrayIcon(false); } else { enableTrayIcon(true); } m_persist = !config.autoCloseIdleDaemon(); }); #endif #if !defined(DISABLE_UPDATE_CHECKER) if (ConfigHandler().checkForUpdates()) { getLatestAvailableVersion(); } #endif } void FlameshotDaemon::start() { if (!m_instance) { m_instance = new FlameshotDaemon(); // Tray icon needs FlameshotDaemon::instance() to be non-null m_instance->initTrayIcon(); qApp->setQuitOnLastWindowClosed(false); } } void FlameshotDaemon::createPin(QPixmap capture, QRect geometry) { if (instance()) { instance()->attachPin(capture, geometry); return; } QByteArray data; QDataStream stream(&data, QIODevice::WriteOnly); stream << capture; stream << geometry; QDBusMessage m = createMethodCall(QStringLiteral(\"attachPin\")); m << data; call(m); } void FlameshotDaemon::copyToClipboard(QPixmap capture) { if (instance()) { instance()->attachScreenshotToClipboard(capture); return; } QDBusMessage m = createMethodCall(QStringLiteral(\"attachScreenshotToClipboard\")); QByteArray data; QDataStream stream(&data, QIODevice::WriteOnly); stream << capture; m << data; call(m); } void FlameshotDaemon::copyToClipboard(QString text, QString notification) { if (instance()) { instance()->attachTextToClipboard(text, notification); return; } auto m = createMethodCall(QStringLiteral(\"attachTextToClipboard\")); m << text << notification; QDBusConnection sessionBus = QDBusConnection::sessionBus(); checkDBusConnection(sessionBus); sessionBus.call(m); } bool FlameshotDaemon::isThisInstanceHostingWidgets() { return instance() && !instance()->m_widgets.isEmpty(); } void FlameshotDaemon::sendTrayNotification(const QString& text, const QString& title, const int timeout) { if (m_trayIcon) { m_trayIcon->showMessage( title, text, QIcon(GlobalValues::iconPath()), timeout); } } #if !defined(DISABLE_UPDATE_CHECKER) void FlameshotDaemon::showUpdateNotificationIfAvailable(CaptureWidget* widget) { if (!m_appLatestUrl.isEmpty() && ConfigHandler().ignoreUpdateToVersion().compare(m_appLatestVersion) < 0) { widget->showAppUpdateNotification(m_appLatestVersion, m_appLatestUrl); } } void FlameshotDaemon::getLatestAvailableVersion() { // This features is required for MacOS and Windows user and for Linux users // who installed Flameshot not from the repository. m_networkCheckUpdates = new QNetworkAccessManager(this); QNetworkRequest requestCheckUpdates(QUrl(FLAMESHOT_APP_VERSION_URL)); connect(m_networkCheckUpdates, &QNetworkAccessManager::finished, this, &FlameshotDaemon::handleReplyCheckUpdates); m_networkCheckUpdates->get(requestCheckUpdates); // check for updates each 24 hours QTimer::singleShot(1000 * 60 * 60 * 24, [this]() { if (ConfigHandler().checkForUpdates()) { this->getLatestAvailableVersion(); } }); } void FlameshotDaemon::checkForUpdates() { if (m_appLatestUrl.isEmpty()) { m_showCheckAppUpdateStatus = true; getLatestAvailableVersion(); } else { QDesktopServices::openUrl(QUrl(m_appLatestUrl)); } } #endif FlameshotDaemon* FlameshotDaemon::instance() { // Because we don't use DBus on MacOS, each instance of flameshot is its own // mini-daemon, responsible for hosting its own persistent widgets (e.g. // pins). #if defined(Q_OS_MACOS) start(); #endif return m_instance; } void FlameshotDaemon::quitIfIdle() { if (m_persist) { return; } if (!m_hostingClipboard && m_widgets.isEmpty()) { qApp->exit(0); } } // SERVICE METHODS void FlameshotDaemon::attachPin(QPixmap pixmap, QRect geometry) { auto* pinWidget = new PinWidget(pixmap, geometry); m_widgets.append(pinWidget); connect(pinWidget, &QObject::destroyed, this, [=]() { m_widgets.removeOne(pinWidget); quitIfIdle(); }); pinWidget->show(); pinWidget->activateWindow(); } void FlameshotDaemon::attachScreenshotToClipboard(QPixmap pixmap) { m_hostingClipboard = true; QClipboard* clipboard = QApplication::clipboard(); clipboard->blockSignals(true); // This variable is necessary because the signal doesn't get blocked on // windows for some reason m_clipboardSignalBlocked = true; saveToClipboard(pixmap); clipboard->blockSignals(false); } // D-BUS ADAPTER METHODS void FlameshotDaemon::attachPin(const QByteArray& data) { QDataStream stream(data); QPixmap pixmap; QRect geometry; stream >> pixmap; stream >> geometry; attachPin(pixmap, geometry); } void FlameshotDaemon::attachScreenshotToClipboard(const QByteArray& screenshot) { QDataStream stream(screenshot); QPixmap p; stream >> p; attachScreenshotToClipboard(p); } void FlameshotDaemon::attachTextToClipboard(QString text, QString notification) { // Must send notification before clipboard modification on linux if (!notification.isEmpty()) { AbstractLogger::info() << notification; } m_hostingClipboard = true; QClipboard* clipboard = QApplication::clipboard(); clipboard->blockSignals(true); // This variable is necessary because the signal doesn't get blocked on // windows for some reason m_clipboardSignalBlocked = true; clipboard->setText(text); clipboard->blockSignals(false); } void FlameshotDaemon::initTrayIcon() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (!ConfigHandler().disabledTrayIcon()) { enableTrayIcon(true); } #elif defined(Q_OS_WIN) enableTrayIcon(true); GlobalShortcutFilter* nativeFilter = new GlobalShortcutFilter(this); qApp->installNativeEventFilter(nativeFilter); connect(nativeFilter, &GlobalShortcutFilter::printPressed, this, [this]() { Flameshot::instance()->gui(); }); #endif } void FlameshotDaemon::enableTrayIcon(bool enable) { if (enable) { if (m_trayIcon == nullptr) { m_trayIcon = new TrayIcon(); } else { m_trayIcon->show(); return; } } else if (m_trayIcon) { m_trayIcon->hide(); } } #if !defined(DISABLE_UPDATE_CHECKER) void FlameshotDaemon::handleReplyCheckUpdates(QNetworkReply* reply) { if (!ConfigHandler().checkForUpdates()) { return; } if (reply->error() == QNetworkReply::NoError) { QJsonDocument response = QJsonDocument::fromJson(reply->readAll()); QJsonObject json = response.object(); m_appLatestVersion = json[\"tag_name\"].toString().replace(\"v\", \"\"); QVersionNumber appLatestVersion = QVersionNumber::fromString(m_appLatestVersion); if (Flameshot::instance()->getVersion() < appLatestVersion) { emit newVersionAvailable(appLatestVersion); m_appLatestUrl = json[\"html_url\"].toString(); QString newVersion = tr(\"New version %1 is available\").arg(m_appLatestVersion); if (m_showCheckAppUpdateStatus) { sendTrayNotification(newVersion, \"Flameshot\"); QDesktopServices::openUrl(QUrl(m_appLatestUrl)); } } else if (m_showCheckAppUpdateStatus) { sendTrayNotification(tr(\"You have the latest version\"), \"Flameshot\"); } } else { qWarning() << \"Failed to get information about the latest version. \" << reply->errorString(); if (m_showCheckAppUpdateStatus) { if (FlameshotDaemon::instance()) { FlameshotDaemon::instance()->sendTrayNotification( tr(\"Failed to get information about the latest version.\"), \"Flameshot\"); } } } m_showCheckAppUpdateStatus = false; } #endif QDBusMessage FlameshotDaemon::createMethodCall(QString method) { QDBusMessage m = QDBusMessage::createMethodCall(QStringLiteral(\"org.flameshot.Flameshot\"), QStringLiteral(\"/\"), QLatin1String(\"\"), method); return m; } void FlameshotDaemon::checkDBusConnection(const QDBusConnection& connection) { if (!connection.isConnected()) { AbstractLogger::error() << tr(\"Unable to connect via DBus\"); qApp->exit(1); } } void FlameshotDaemon::call(const QDBusMessage& m) { QDBusConnection sessionBus = QDBusConnection::sessionBus(); checkDBusConnection(sessionBus); sessionBus.call(m); } // STATIC ATTRIBUTES FlameshotDaemon* FlameshotDaemon::m_instance = nullptr;","title":"File flameshotdaemon.cpp"},{"location":"flameshot/flameshotdaemon_8cpp_source/#file-flameshotdaemoncpp","text":"File List > core > flameshotdaemon.cpp Go to the documentation of this file. #include \"flameshotdaemon.h\" #include \"abstractlogger.h\" #include \"confighandler.h\" #include \"flameshot.h\" #include \"pinwidget.h\" #include \"screenshotsaver.h\" #include \"src/utils/globalvalues.h\" #include \"src/widgets/capture/capturewidget.h\" #include \"src/widgets/trayicon.h\" #include <QApplication> #include <QClipboard> #include <QDBusConnection> #include <QDBusMessage> #include <QPixmap> #include <QRect> #if !defined(DISABLE_UPDATE_CHECKER) #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QTimer> #include <QUrl> #endif #ifdef Q_OS_WIN #include \"src/core/globalshortcutfilter.h\" #endif FlameshotDaemon::FlameshotDaemon() : m_persist(false) , m_hostingClipboard(false) , m_clipboardSignalBlocked(false) , m_trayIcon(nullptr) #if !defined(DISABLE_UPDATE_CHECKER) , m_networkCheckUpdates(nullptr) , m_showCheckAppUpdateStatus(false) , m_appLatestVersion(QStringLiteral(APP_VERSION).replace(\"v\", \"\")) #endif { connect( QApplication::clipboard(), &QClipboard::dataChanged, this, [this]() { if (!m_hostingClipboard || m_clipboardSignalBlocked) { m_clipboardSignalBlocked = false; return; } m_hostingClipboard = false; quitIfIdle(); }); #ifdef Q_OS_WIN m_persist = true; #else m_persist = !ConfigHandler().autoCloseIdleDaemon(); connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() { ConfigHandler config; if (config.disabledTrayIcon()) { enableTrayIcon(false); } else { enableTrayIcon(true); } m_persist = !config.autoCloseIdleDaemon(); }); #endif #if !defined(DISABLE_UPDATE_CHECKER) if (ConfigHandler().checkForUpdates()) { getLatestAvailableVersion(); } #endif } void FlameshotDaemon::start() { if (!m_instance) { m_instance = new FlameshotDaemon(); // Tray icon needs FlameshotDaemon::instance() to be non-null m_instance->initTrayIcon(); qApp->setQuitOnLastWindowClosed(false); } } void FlameshotDaemon::createPin(QPixmap capture, QRect geometry) { if (instance()) { instance()->attachPin(capture, geometry); return; } QByteArray data; QDataStream stream(&data, QIODevice::WriteOnly); stream << capture; stream << geometry; QDBusMessage m = createMethodCall(QStringLiteral(\"attachPin\")); m << data; call(m); } void FlameshotDaemon::copyToClipboard(QPixmap capture) { if (instance()) { instance()->attachScreenshotToClipboard(capture); return; } QDBusMessage m = createMethodCall(QStringLiteral(\"attachScreenshotToClipboard\")); QByteArray data; QDataStream stream(&data, QIODevice::WriteOnly); stream << capture; m << data; call(m); } void FlameshotDaemon::copyToClipboard(QString text, QString notification) { if (instance()) { instance()->attachTextToClipboard(text, notification); return; } auto m = createMethodCall(QStringLiteral(\"attachTextToClipboard\")); m << text << notification; QDBusConnection sessionBus = QDBusConnection::sessionBus(); checkDBusConnection(sessionBus); sessionBus.call(m); } bool FlameshotDaemon::isThisInstanceHostingWidgets() { return instance() && !instance()->m_widgets.isEmpty(); } void FlameshotDaemon::sendTrayNotification(const QString& text, const QString& title, const int timeout) { if (m_trayIcon) { m_trayIcon->showMessage( title, text, QIcon(GlobalValues::iconPath()), timeout); } } #if !defined(DISABLE_UPDATE_CHECKER) void FlameshotDaemon::showUpdateNotificationIfAvailable(CaptureWidget* widget) { if (!m_appLatestUrl.isEmpty() && ConfigHandler().ignoreUpdateToVersion().compare(m_appLatestVersion) < 0) { widget->showAppUpdateNotification(m_appLatestVersion, m_appLatestUrl); } } void FlameshotDaemon::getLatestAvailableVersion() { // This features is required for MacOS and Windows user and for Linux users // who installed Flameshot not from the repository. m_networkCheckUpdates = new QNetworkAccessManager(this); QNetworkRequest requestCheckUpdates(QUrl(FLAMESHOT_APP_VERSION_URL)); connect(m_networkCheckUpdates, &QNetworkAccessManager::finished, this, &FlameshotDaemon::handleReplyCheckUpdates); m_networkCheckUpdates->get(requestCheckUpdates); // check for updates each 24 hours QTimer::singleShot(1000 * 60 * 60 * 24, [this]() { if (ConfigHandler().checkForUpdates()) { this->getLatestAvailableVersion(); } }); } void FlameshotDaemon::checkForUpdates() { if (m_appLatestUrl.isEmpty()) { m_showCheckAppUpdateStatus = true; getLatestAvailableVersion(); } else { QDesktopServices::openUrl(QUrl(m_appLatestUrl)); } } #endif FlameshotDaemon* FlameshotDaemon::instance() { // Because we don't use DBus on MacOS, each instance of flameshot is its own // mini-daemon, responsible for hosting its own persistent widgets (e.g. // pins). #if defined(Q_OS_MACOS) start(); #endif return m_instance; } void FlameshotDaemon::quitIfIdle() { if (m_persist) { return; } if (!m_hostingClipboard && m_widgets.isEmpty()) { qApp->exit(0); } } // SERVICE METHODS void FlameshotDaemon::attachPin(QPixmap pixmap, QRect geometry) { auto* pinWidget = new PinWidget(pixmap, geometry); m_widgets.append(pinWidget); connect(pinWidget, &QObject::destroyed, this, [=]() { m_widgets.removeOne(pinWidget); quitIfIdle(); }); pinWidget->show(); pinWidget->activateWindow(); } void FlameshotDaemon::attachScreenshotToClipboard(QPixmap pixmap) { m_hostingClipboard = true; QClipboard* clipboard = QApplication::clipboard(); clipboard->blockSignals(true); // This variable is necessary because the signal doesn't get blocked on // windows for some reason m_clipboardSignalBlocked = true; saveToClipboard(pixmap); clipboard->blockSignals(false); } // D-BUS ADAPTER METHODS void FlameshotDaemon::attachPin(const QByteArray& data) { QDataStream stream(data); QPixmap pixmap; QRect geometry; stream >> pixmap; stream >> geometry; attachPin(pixmap, geometry); } void FlameshotDaemon::attachScreenshotToClipboard(const QByteArray& screenshot) { QDataStream stream(screenshot); QPixmap p; stream >> p; attachScreenshotToClipboard(p); } void FlameshotDaemon::attachTextToClipboard(QString text, QString notification) { // Must send notification before clipboard modification on linux if (!notification.isEmpty()) { AbstractLogger::info() << notification; } m_hostingClipboard = true; QClipboard* clipboard = QApplication::clipboard(); clipboard->blockSignals(true); // This variable is necessary because the signal doesn't get blocked on // windows for some reason m_clipboardSignalBlocked = true; clipboard->setText(text); clipboard->blockSignals(false); } void FlameshotDaemon::initTrayIcon() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (!ConfigHandler().disabledTrayIcon()) { enableTrayIcon(true); } #elif defined(Q_OS_WIN) enableTrayIcon(true); GlobalShortcutFilter* nativeFilter = new GlobalShortcutFilter(this); qApp->installNativeEventFilter(nativeFilter); connect(nativeFilter, &GlobalShortcutFilter::printPressed, this, [this]() { Flameshot::instance()->gui(); }); #endif } void FlameshotDaemon::enableTrayIcon(bool enable) { if (enable) { if (m_trayIcon == nullptr) { m_trayIcon = new TrayIcon(); } else { m_trayIcon->show(); return; } } else if (m_trayIcon) { m_trayIcon->hide(); } } #if !defined(DISABLE_UPDATE_CHECKER) void FlameshotDaemon::handleReplyCheckUpdates(QNetworkReply* reply) { if (!ConfigHandler().checkForUpdates()) { return; } if (reply->error() == QNetworkReply::NoError) { QJsonDocument response = QJsonDocument::fromJson(reply->readAll()); QJsonObject json = response.object(); m_appLatestVersion = json[\"tag_name\"].toString().replace(\"v\", \"\"); QVersionNumber appLatestVersion = QVersionNumber::fromString(m_appLatestVersion); if (Flameshot::instance()->getVersion() < appLatestVersion) { emit newVersionAvailable(appLatestVersion); m_appLatestUrl = json[\"html_url\"].toString(); QString newVersion = tr(\"New version %1 is available\").arg(m_appLatestVersion); if (m_showCheckAppUpdateStatus) { sendTrayNotification(newVersion, \"Flameshot\"); QDesktopServices::openUrl(QUrl(m_appLatestUrl)); } } else if (m_showCheckAppUpdateStatus) { sendTrayNotification(tr(\"You have the latest version\"), \"Flameshot\"); } } else { qWarning() << \"Failed to get information about the latest version. \" << reply->errorString(); if (m_showCheckAppUpdateStatus) { if (FlameshotDaemon::instance()) { FlameshotDaemon::instance()->sendTrayNotification( tr(\"Failed to get information about the latest version.\"), \"Flameshot\"); } } } m_showCheckAppUpdateStatus = false; } #endif QDBusMessage FlameshotDaemon::createMethodCall(QString method) { QDBusMessage m = QDBusMessage::createMethodCall(QStringLiteral(\"org.flameshot.Flameshot\"), QStringLiteral(\"/\"), QLatin1String(\"\"), method); return m; } void FlameshotDaemon::checkDBusConnection(const QDBusConnection& connection) { if (!connection.isConnected()) { AbstractLogger::error() << tr(\"Unable to connect via DBus\"); qApp->exit(1); } } void FlameshotDaemon::call(const QDBusMessage& m) { QDBusConnection sessionBus = QDBusConnection::sessionBus(); checkDBusConnection(sessionBus); sessionBus.call(m); } // STATIC ATTRIBUTES FlameshotDaemon* FlameshotDaemon::m_instance = nullptr;","title":"File flameshotdaemon.cpp"},{"location":"flameshot/flameshotdaemon_8h/","text":"File flameshotdaemon.h # FileList > core > flameshotdaemon.h Go to the source code of this file. #include <QByteArray> #include <QObject> #include <QtDBus/QDBusAbstractAdaptor> Classes # Type Name class FlameshotDaemon","title":"File flameshotdaemon.h"},{"location":"flameshot/flameshotdaemon_8h/#file-flameshotdaemonh","text":"FileList > core > flameshotdaemon.h Go to the source code of this file. #include <QByteArray> #include <QObject> #include <QtDBus/QDBusAbstractAdaptor>","title":"File flameshotdaemon.h"},{"location":"flameshot/flameshotdaemon_8h/#classes","text":"Type Name class FlameshotDaemon","title":"Classes"},{"location":"flameshot/flameshotdaemon_8h_source/","text":"File flameshotdaemon.h # File List > core > flameshotdaemon.h Go to the documentation of this file. #pragma once #include <QByteArray> #include <QObject> #include <QtDBus/QDBusAbstractAdaptor> class QPixmap; class QRect; class QDBusMessage; class QDBusConnection; class TrayIcon; class CaptureWidget; #if !defined(DISABLE_UPDATE_CHECKER) class QNetworkAccessManager; class QNetworkReply; class QVersionNumber; #endif class FlameshotDaemon : public QObject { Q_OBJECT public: static void start(); static FlameshotDaemon* instance(); static void createPin(QPixmap capture, QRect geometry); static void copyToClipboard(QPixmap capture); static void copyToClipboard(QString text, QString notification = \"\"); static bool isThisInstanceHostingWidgets(); void sendTrayNotification( const QString& text, const QString& title = QStringLiteral(\"Flameshot Info\"), const int timeout = 5000); #if !defined(DISABLE_UPDATE_CHECKER) void showUpdateNotificationIfAvailable(CaptureWidget* widget); public slots: void checkForUpdates(); void getLatestAvailableVersion(); private slots: void handleReplyCheckUpdates(QNetworkReply* reply); signals: void newVersionAvailable(QVersionNumber version); #endif private: FlameshotDaemon(); void quitIfIdle(); void attachPin(QPixmap pixmap, QRect geometry); void attachScreenshotToClipboard(QPixmap pixmap); void attachPin(const QByteArray& data); void attachScreenshotToClipboard(const QByteArray& screenshot); void attachTextToClipboard(QString text, QString notification); void initTrayIcon(); void enableTrayIcon(bool enable); static QDBusMessage createMethodCall(QString method); static void checkDBusConnection(const QDBusConnection& connection); static void call(const QDBusMessage& m); bool m_persist; bool m_hostingClipboard; bool m_clipboardSignalBlocked; QList<QWidget*> m_widgets; TrayIcon* m_trayIcon; #if !defined(DISABLE_UPDATE_CHECKER) QString m_appLatestUrl; QString m_appLatestVersion; bool m_showCheckAppUpdateStatus; QNetworkAccessManager* m_networkCheckUpdates; #endif static FlameshotDaemon* m_instance; friend class FlameshotDBusAdapter; };","title":"File flameshotdaemon.h"},{"location":"flameshot/flameshotdaemon_8h_source/#file-flameshotdaemonh","text":"File List > core > flameshotdaemon.h Go to the documentation of this file. #pragma once #include <QByteArray> #include <QObject> #include <QtDBus/QDBusAbstractAdaptor> class QPixmap; class QRect; class QDBusMessage; class QDBusConnection; class TrayIcon; class CaptureWidget; #if !defined(DISABLE_UPDATE_CHECKER) class QNetworkAccessManager; class QNetworkReply; class QVersionNumber; #endif class FlameshotDaemon : public QObject { Q_OBJECT public: static void start(); static FlameshotDaemon* instance(); static void createPin(QPixmap capture, QRect geometry); static void copyToClipboard(QPixmap capture); static void copyToClipboard(QString text, QString notification = \"\"); static bool isThisInstanceHostingWidgets(); void sendTrayNotification( const QString& text, const QString& title = QStringLiteral(\"Flameshot Info\"), const int timeout = 5000); #if !defined(DISABLE_UPDATE_CHECKER) void showUpdateNotificationIfAvailable(CaptureWidget* widget); public slots: void checkForUpdates(); void getLatestAvailableVersion(); private slots: void handleReplyCheckUpdates(QNetworkReply* reply); signals: void newVersionAvailable(QVersionNumber version); #endif private: FlameshotDaemon(); void quitIfIdle(); void attachPin(QPixmap pixmap, QRect geometry); void attachScreenshotToClipboard(QPixmap pixmap); void attachPin(const QByteArray& data); void attachScreenshotToClipboard(const QByteArray& screenshot); void attachTextToClipboard(QString text, QString notification); void initTrayIcon(); void enableTrayIcon(bool enable); static QDBusMessage createMethodCall(QString method); static void checkDBusConnection(const QDBusConnection& connection); static void call(const QDBusMessage& m); bool m_persist; bool m_hostingClipboard; bool m_clipboardSignalBlocked; QList<QWidget*> m_widgets; TrayIcon* m_trayIcon; #if !defined(DISABLE_UPDATE_CHECKER) QString m_appLatestUrl; QString m_appLatestVersion; bool m_showCheckAppUpdateStatus; QNetworkAccessManager* m_networkCheckUpdates; #endif static FlameshotDaemon* m_instance; friend class FlameshotDBusAdapter; };","title":"File flameshotdaemon.h"},{"location":"flameshot/flameshotdbusadapter_8cpp/","text":"File flameshotdbusadapter.cpp # FileList > core > flameshotdbusadapter.cpp Go to the source code of this file. #include \"flameshotdbusadapter.h\" #include \"src/core/flameshotdaemon.h\"","title":"File flameshotdbusadapter.cpp"},{"location":"flameshot/flameshotdbusadapter_8cpp/#file-flameshotdbusadaptercpp","text":"FileList > core > flameshotdbusadapter.cpp Go to the source code of this file. #include \"flameshotdbusadapter.h\" #include \"src/core/flameshotdaemon.h\"","title":"File flameshotdbusadapter.cpp"},{"location":"flameshot/flameshotdbusadapter_8cpp_source/","text":"File flameshotdbusadapter.cpp # File List > core > flameshotdbusadapter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"flameshotdbusadapter.h\" #include \"src/core/flameshotdaemon.h\" FlameshotDBusAdapter::FlameshotDBusAdapter(QObject* parent) : QDBusAbstractAdaptor(parent) {} FlameshotDBusAdapter::~FlameshotDBusAdapter() = default; void FlameshotDBusAdapter::attachScreenshotToClipboard(const QByteArray& data) { FlameshotDaemon::instance()->attachScreenshotToClipboard(data); } void FlameshotDBusAdapter::attachTextToClipboard(QString text, QString notification) { FlameshotDaemon::instance()->attachTextToClipboard(text, notification); } void FlameshotDBusAdapter::attachPin(const QByteArray& data) { FlameshotDaemon::instance()->attachPin(data); }","title":"File flameshotdbusadapter.cpp"},{"location":"flameshot/flameshotdbusadapter_8cpp_source/#file-flameshotdbusadaptercpp","text":"File List > core > flameshotdbusadapter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"flameshotdbusadapter.h\" #include \"src/core/flameshotdaemon.h\" FlameshotDBusAdapter::FlameshotDBusAdapter(QObject* parent) : QDBusAbstractAdaptor(parent) {} FlameshotDBusAdapter::~FlameshotDBusAdapter() = default; void FlameshotDBusAdapter::attachScreenshotToClipboard(const QByteArray& data) { FlameshotDaemon::instance()->attachScreenshotToClipboard(data); } void FlameshotDBusAdapter::attachTextToClipboard(QString text, QString notification) { FlameshotDaemon::instance()->attachTextToClipboard(text, notification); } void FlameshotDBusAdapter::attachPin(const QByteArray& data) { FlameshotDaemon::instance()->attachPin(data); }","title":"File flameshotdbusadapter.cpp"},{"location":"flameshot/flameshotdbusadapter_8h/","text":"File flameshotdbusadapter.h # FileList > core > flameshotdbusadapter.h Go to the source code of this file. #include <QtDBus/QDBusAbstractAdaptor> Classes # Type Name class FlameshotDBusAdapter","title":"File flameshotdbusadapter.h"},{"location":"flameshot/flameshotdbusadapter_8h/#file-flameshotdbusadapterh","text":"FileList > core > flameshotdbusadapter.h Go to the source code of this file. #include <QtDBus/QDBusAbstractAdaptor>","title":"File flameshotdbusadapter.h"},{"location":"flameshot/flameshotdbusadapter_8h/#classes","text":"Type Name class FlameshotDBusAdapter","title":"Classes"},{"location":"flameshot/flameshotdbusadapter_8h_source/","text":"File flameshotdbusadapter.h # File List > core > flameshotdbusadapter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QtDBus/QDBusAbstractAdaptor> class FlameshotDBusAdapter : public QDBusAbstractAdaptor { Q_OBJECT Q_CLASSINFO(\"D-Bus Interface\", \"org.flameshot.Flameshot\") public: explicit FlameshotDBusAdapter(QObject* parent = nullptr); virtual ~FlameshotDBusAdapter(); public slots: Q_NOREPLY void attachScreenshotToClipboard(const QByteArray& data); Q_NOREPLY void attachTextToClipboard(QString text, QString notification); Q_NOREPLY void attachPin(const QByteArray& data); };","title":"File flameshotdbusadapter.h"},{"location":"flameshot/flameshotdbusadapter_8h_source/#file-flameshotdbusadapterh","text":"File List > core > flameshotdbusadapter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QtDBus/QDBusAbstractAdaptor> class FlameshotDBusAdapter : public QDBusAbstractAdaptor { Q_OBJECT Q_CLASSINFO(\"D-Bus Interface\", \"org.flameshot.Flameshot\") public: explicit FlameshotDBusAdapter(QObject* parent = nullptr); virtual ~FlameshotDBusAdapter(); public slots: Q_NOREPLY void attachScreenshotToClipboard(const QByteArray& data); Q_NOREPLY void attachTextToClipboard(QString text, QString notification); Q_NOREPLY void attachPin(const QByteArray& data); };","title":"File flameshotdbusadapter.h"},{"location":"flameshot/globalshortcutfilter_8cpp/","text":"File globalshortcutfilter.cpp # FileList > core > globalshortcutfilter.cpp Go to the source code of this file. #include \"globalshortcutfilter.h\" #include \"src/core/flameshot.h\" #include <qt_windows.h>","title":"File globalshortcutfilter.cpp"},{"location":"flameshot/globalshortcutfilter_8cpp/#file-globalshortcutfiltercpp","text":"FileList > core > globalshortcutfilter.cpp Go to the source code of this file. #include \"globalshortcutfilter.h\" #include \"src/core/flameshot.h\" #include <qt_windows.h>","title":"File globalshortcutfilter.cpp"},{"location":"flameshot/globalshortcutfilter_8cpp_source/","text":"File globalshortcutfilter.cpp # File List > core > globalshortcutfilter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"globalshortcutfilter.h\" #include \"src/core/flameshot.h\" #include <qt_windows.h> GlobalShortcutFilter::GlobalShortcutFilter(QObject* parent) : QObject(parent) { // Forced Print Screen if (RegisterHotKey(NULL, 1, 0, VK_SNAPSHOT)) { // ok - capture screen } if (RegisterHotKey(NULL, 2, MOD_SHIFT, VK_SNAPSHOT)) { // ok - show screenshots history } } bool GlobalShortcutFilter::nativeEventFilter(const QByteArray& eventType, void* message, long* result) { Q_UNUSED(eventType) Q_UNUSED(result) MSG* msg = static_cast<MSG*>(message); if (msg->message == WM_HOTKEY) { // TODO: this is just a temporal workwrround, proper global // support would need custom shortcuts defined by the user. const quint32 keycode = HIWORD(msg->lParam); const quint32 modifiers = LOWORD(msg->lParam); // Show screenshots history if (VK_SNAPSHOT == keycode && MOD_SHIFT == modifiers) { Flameshot::instance()->history(); } // Capture screen if (VK_SNAPSHOT == keycode && 0 == modifiers) { Flameshot::instance()->requestCapture( CaptureRequest(CaptureRequest::GRAPHICAL_MODE)); } return true; } return false; }","title":"File globalshortcutfilter.cpp"},{"location":"flameshot/globalshortcutfilter_8cpp_source/#file-globalshortcutfiltercpp","text":"File List > core > globalshortcutfilter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"globalshortcutfilter.h\" #include \"src/core/flameshot.h\" #include <qt_windows.h> GlobalShortcutFilter::GlobalShortcutFilter(QObject* parent) : QObject(parent) { // Forced Print Screen if (RegisterHotKey(NULL, 1, 0, VK_SNAPSHOT)) { // ok - capture screen } if (RegisterHotKey(NULL, 2, MOD_SHIFT, VK_SNAPSHOT)) { // ok - show screenshots history } } bool GlobalShortcutFilter::nativeEventFilter(const QByteArray& eventType, void* message, long* result) { Q_UNUSED(eventType) Q_UNUSED(result) MSG* msg = static_cast<MSG*>(message); if (msg->message == WM_HOTKEY) { // TODO: this is just a temporal workwrround, proper global // support would need custom shortcuts defined by the user. const quint32 keycode = HIWORD(msg->lParam); const quint32 modifiers = LOWORD(msg->lParam); // Show screenshots history if (VK_SNAPSHOT == keycode && MOD_SHIFT == modifiers) { Flameshot::instance()->history(); } // Capture screen if (VK_SNAPSHOT == keycode && 0 == modifiers) { Flameshot::instance()->requestCapture( CaptureRequest(CaptureRequest::GRAPHICAL_MODE)); } return true; } return false; }","title":"File globalshortcutfilter.cpp"},{"location":"flameshot/globalshortcutfilter_8h/","text":"File globalshortcutfilter.h # FileList > core > globalshortcutfilter.h Go to the source code of this file. #include <QAbstractNativeEventFilter> #include <QObject> Classes # Type Name class GlobalShortcutFilter","title":"File globalshortcutfilter.h"},{"location":"flameshot/globalshortcutfilter_8h/#file-globalshortcutfilterh","text":"FileList > core > globalshortcutfilter.h Go to the source code of this file. #include <QAbstractNativeEventFilter> #include <QObject>","title":"File globalshortcutfilter.h"},{"location":"flameshot/globalshortcutfilter_8h/#classes","text":"Type Name class GlobalShortcutFilter","title":"Classes"},{"location":"flameshot/globalshortcutfilter_8h_source/","text":"File globalshortcutfilter.h # File List > core > globalshortcutfilter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QAbstractNativeEventFilter> #include <QObject> class GlobalShortcutFilter : public QObject , public QAbstractNativeEventFilter { Q_OBJECT public: explicit GlobalShortcutFilter(QObject* parent = nullptr); bool nativeEventFilter(const QByteArray& eventType, void* message, long* result); signals: void printPressed(); private: quint32 getNativeModifier(Qt::KeyboardModifiers modifiers); quint32 nativeKeycode(Qt::Key key); bool registerShortcut(quint32 nativeKey, quint32 nativeMods); bool unregisterShortcut(quint32 nativeKey, quint32 nativeMods); };","title":"File globalshortcutfilter.h"},{"location":"flameshot/globalshortcutfilter_8h_source/#file-globalshortcutfilterh","text":"File List > core > globalshortcutfilter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QAbstractNativeEventFilter> #include <QObject> class GlobalShortcutFilter : public QObject , public QAbstractNativeEventFilter { Q_OBJECT public: explicit GlobalShortcutFilter(QObject* parent = nullptr); bool nativeEventFilter(const QByteArray& eventType, void* message, long* result); signals: void printPressed(); private: quint32 getNativeModifier(Qt::KeyboardModifiers modifiers); quint32 nativeKeycode(Qt::Key key); bool registerShortcut(quint32 nativeKey, quint32 nativeMods); bool unregisterShortcut(quint32 nativeKey, quint32 nativeMods); };","title":"File globalshortcutfilter.h"},{"location":"flameshot/qguiappcurrentscreen_8cpp/","text":"File qguiappcurrentscreen.cpp # FileList > core > qguiappcurrentscreen.cpp Go to the source code of this file. #include \"qguiappcurrentscreen.h\" #include <QCursor> #include <QDesktopWidget> #include <QGuiApplication> #include <QPoint> #include <QScreen>","title":"File qguiappcurrentscreen.cpp"},{"location":"flameshot/qguiappcurrentscreen_8cpp/#file-qguiappcurrentscreencpp","text":"FileList > core > qguiappcurrentscreen.cpp Go to the source code of this file. #include \"qguiappcurrentscreen.h\" #include <QCursor> #include <QDesktopWidget> #include <QGuiApplication> #include <QPoint> #include <QScreen>","title":"File qguiappcurrentscreen.cpp"},{"location":"flameshot/qguiappcurrentscreen_8cpp_source/","text":"File qguiappcurrentscreen.cpp # File List > core > qguiappcurrentscreen.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yuriy Puchkov <yuriy.puchkov@namecheap.com> #include \"qguiappcurrentscreen.h\" #include <QCursor> #include <QDesktopWidget> #include <QGuiApplication> #include <QPoint> #include <QScreen> QGuiAppCurrentScreen::QGuiAppCurrentScreen() { m_currentScreen = nullptr; } QScreen* QGuiAppCurrentScreen::currentScreen() { return currentScreen(QCursor::pos()); } QScreen* QGuiAppCurrentScreen::currentScreen(const QPoint& pos) { m_currentScreen = screenAt(pos); #if defined(Q_OS_MACOS) // On the MacOS if mouse position is at the edge of bottom or right sides // qGuiApp->screenAt will return nullptr, so we need to try to find current // screen by moving 1 pixel inside to the current desktop area if (!m_currentScreen && pos.x() > 0) { QPoint posCorrected(pos.x() - 1, pos.y()); m_currentScreen = screenAt(posCorrected); } if (!m_currentScreen && pos.y() > 0) { QPoint posCorrected(pos.x(), pos.y() - 1); m_currentScreen = screenAt(posCorrected); } if (!m_currentScreen && pos.x() > 0 && pos.y() > 0) { QPoint posCorrected(pos.x() - 1, pos.y() - 1); m_currentScreen = screenAt(posCorrected); } #endif if (!m_currentScreen) { qCritical(\"Unable to get current screen, starting to use primary \" \"screen. It may be a cause of logical error and working with \" \"a wrong screen.\"); m_currentScreen = qGuiApp->primaryScreen(); } return m_currentScreen; } QScreen* QGuiAppCurrentScreen::screenAt(const QPoint& pos) { #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) m_currentScreen = qGuiApp->screenAt(pos); #else for (QScreen* const screen : QGuiApplication::screens()) { m_currentScreen = screen; if (screen->geometry().contains(pos)) { break; } } #endif return m_currentScreen; }","title":"File qguiappcurrentscreen.cpp"},{"location":"flameshot/qguiappcurrentscreen_8cpp_source/#file-qguiappcurrentscreencpp","text":"File List > core > qguiappcurrentscreen.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yuriy Puchkov <yuriy.puchkov@namecheap.com> #include \"qguiappcurrentscreen.h\" #include <QCursor> #include <QDesktopWidget> #include <QGuiApplication> #include <QPoint> #include <QScreen> QGuiAppCurrentScreen::QGuiAppCurrentScreen() { m_currentScreen = nullptr; } QScreen* QGuiAppCurrentScreen::currentScreen() { return currentScreen(QCursor::pos()); } QScreen* QGuiAppCurrentScreen::currentScreen(const QPoint& pos) { m_currentScreen = screenAt(pos); #if defined(Q_OS_MACOS) // On the MacOS if mouse position is at the edge of bottom or right sides // qGuiApp->screenAt will return nullptr, so we need to try to find current // screen by moving 1 pixel inside to the current desktop area if (!m_currentScreen && pos.x() > 0) { QPoint posCorrected(pos.x() - 1, pos.y()); m_currentScreen = screenAt(posCorrected); } if (!m_currentScreen && pos.y() > 0) { QPoint posCorrected(pos.x(), pos.y() - 1); m_currentScreen = screenAt(posCorrected); } if (!m_currentScreen && pos.x() > 0 && pos.y() > 0) { QPoint posCorrected(pos.x() - 1, pos.y() - 1); m_currentScreen = screenAt(posCorrected); } #endif if (!m_currentScreen) { qCritical(\"Unable to get current screen, starting to use primary \" \"screen. It may be a cause of logical error and working with \" \"a wrong screen.\"); m_currentScreen = qGuiApp->primaryScreen(); } return m_currentScreen; } QScreen* QGuiAppCurrentScreen::screenAt(const QPoint& pos) { #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) m_currentScreen = qGuiApp->screenAt(pos); #else for (QScreen* const screen : QGuiApplication::screens()) { m_currentScreen = screen; if (screen->geometry().contains(pos)) { break; } } #endif return m_currentScreen; }","title":"File qguiappcurrentscreen.cpp"},{"location":"flameshot/qguiappcurrentscreen_8h/","text":"File qguiappcurrentscreen.h # FileList > core > qguiappcurrentscreen.h Go to the source code of this file. #include <QPoint> Classes # Type Name class QGuiAppCurrentScreen","title":"File qguiappcurrentscreen.h"},{"location":"flameshot/qguiappcurrentscreen_8h/#file-qguiappcurrentscreenh","text":"FileList > core > qguiappcurrentscreen.h Go to the source code of this file. #include <QPoint>","title":"File qguiappcurrentscreen.h"},{"location":"flameshot/qguiappcurrentscreen_8h/#classes","text":"Type Name class QGuiAppCurrentScreen","title":"Classes"},{"location":"flameshot/qguiappcurrentscreen_8h_source/","text":"File qguiappcurrentscreen.h # File List > core > qguiappcurrentscreen.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yuriy Puchkov <yuriy.puchkov@namecheap.com> #ifndef FLAMESHOT_QGUIAPPCURRENTSCREEN_H #define FLAMESHOT_QGUIAPPCURRENTSCREEN_H #include <QPoint> class QScreen; class QGuiAppCurrentScreen { public: explicit QGuiAppCurrentScreen(); QScreen* currentScreen(); QScreen* currentScreen(const QPoint& pos); private: QScreen* screenAt(const QPoint& pos); // class members private: QScreen* m_currentScreen; }; #endif // FLAMESHOT_QGUIAPPCURRENTSCREEN_H","title":"File qguiappcurrentscreen.h"},{"location":"flameshot/qguiappcurrentscreen_8h_source/#file-qguiappcurrentscreenh","text":"File List > core > qguiappcurrentscreen.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yuriy Puchkov <yuriy.puchkov@namecheap.com> #ifndef FLAMESHOT_QGUIAPPCURRENTSCREEN_H #define FLAMESHOT_QGUIAPPCURRENTSCREEN_H #include <QPoint> class QScreen; class QGuiAppCurrentScreen { public: explicit QGuiAppCurrentScreen(); QScreen* currentScreen(); QScreen* currentScreen(const QPoint& pos); private: QScreen* screenAt(const QPoint& pos); // class members private: QScreen* m_currentScreen; }; #endif // FLAMESHOT_QGUIAPPCURRENTSCREEN_H","title":"File qguiappcurrentscreen.h"},{"location":"flameshot/main_8cpp/","text":"File main.cpp # FileList > src > main.cpp Go to the source code of this file. #include \"singleapplication.h\" #include \"abstractlogger.h\" #include \"src/cli/commandlineparser.h\" #include \"src/config/cacheutils.h\" #include \"src/config/styleoverride.h\" #include \"src/core/capturerequest.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/pathinfo.h\" #include \"src/utils/valuehandler.h\" #include <QApplication> #include <QDir> #include <QLibraryInfo> #include <QSharedMemory> #include <QTimer> #include <QTranslator> Public Functions # Type Name QSharedMemory * guiMutexLock () int main (int argc, char * argv) void requestCaptureAndWait (const CaptureRequest & req) Public Functions Documentation # function guiMutexLock # QSharedMemory * guiMutexLock () function main # int main ( int argc, char * argv ) function requestCaptureAndWait # void requestCaptureAndWait ( const CaptureRequest & req )","title":"File main.cpp"},{"location":"flameshot/main_8cpp/#file-maincpp","text":"FileList > src > main.cpp Go to the source code of this file. #include \"singleapplication.h\" #include \"abstractlogger.h\" #include \"src/cli/commandlineparser.h\" #include \"src/config/cacheutils.h\" #include \"src/config/styleoverride.h\" #include \"src/core/capturerequest.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/pathinfo.h\" #include \"src/utils/valuehandler.h\" #include <QApplication> #include <QDir> #include <QLibraryInfo> #include <QSharedMemory> #include <QTimer> #include <QTranslator>","title":"File main.cpp"},{"location":"flameshot/main_8cpp/#public-functions","text":"Type Name QSharedMemory * guiMutexLock () int main (int argc, char * argv) void requestCaptureAndWait (const CaptureRequest & req)","title":"Public Functions"},{"location":"flameshot/main_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/main_8cpp/#function-guimutexlock","text":"QSharedMemory * guiMutexLock ()","title":"function guiMutexLock"},{"location":"flameshot/main_8cpp/#function-main","text":"int main ( int argc, char * argv )","title":"function main"},{"location":"flameshot/main_8cpp/#function-requestcaptureandwait","text":"void requestCaptureAndWait ( const CaptureRequest & req )","title":"function requestCaptureAndWait"},{"location":"flameshot/main_8cpp_source/","text":"File main.cpp # File List > src > main.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #ifndef USE_EXTERNAL_SINGLEAPPLICATION #include \"singleapplication.h\" #else #include \"QtSolutions/qtsingleapplication.h\" #endif #include \"abstractlogger.h\" #include \"src/cli/commandlineparser.h\" #include \"src/config/cacheutils.h\" #include \"src/config/styleoverride.h\" #include \"src/core/capturerequest.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/pathinfo.h\" #include \"src/utils/valuehandler.h\" #include <QApplication> #include <QDir> #include <QLibraryInfo> #include <QSharedMemory> #include <QTimer> #include <QTranslator> #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) #include \"abstractlogger.h\" #include \"src/core/flameshotdbusadapter.h\" #include <QApplication> #include <QDBusConnection> #include <QDBusMessage> #include <desktopinfo.h> #endif #ifdef Q_OS_LINUX // source: https://github.com/ksnip/ksnip/issues/416 void wayland_hacks() { // Workaround to https://github.com/ksnip/ksnip/issues/416 DesktopInfo info; if (info.windowManager() == DesktopInfo::GNOME) { qputenv(\"QT_QPA_PLATFORM\", \"xcb\"); } } #endif void requestCaptureAndWait(const CaptureRequest& req) { Flameshot* flameshot = Flameshot::instance(); flameshot->requestCapture(req); QObject::connect(flameshot, &Flameshot::captureTaken, [&](const QPixmap&) { #if defined(Q_OS_MACOS) // Only useful on MacOS because each instance hosts its own widgets if (!FlameshotDaemon::isThisInstanceHostingWidgets()) { qApp->exit(0); } #else // if this instance is not daemon, make sure it exit after caputre finish if (FlameshotDaemon::instance() == nullptr && !Flameshot::instance()->haveExternalWidget()) { qApp->exit(0); } #endif }); QObject::connect(flameshot, &Flameshot::captureFailed, []() { AbstractLogger::info() << \"Screenshot aborted.\"; qApp->exit(1); }); qApp->exec(); } QSharedMemory* guiMutexLock() { QString key = \"org.flameshot.Flameshot-\" APP_VERSION; auto* shm = new QSharedMemory(key); #ifdef Q_OS_UNIX // Destroy shared memory if the last instance crashed on Unix shm->attach(); delete shm; shm = new QSharedMemory(key); #endif if (!shm->create(1)) { return nullptr; } return shm; } int main(int argc, char* argv[]) { #ifdef Q_OS_LINUX wayland_hacks(); #endif // required for the button serialization // TODO: change to QVector in v1.0 qRegisterMetaTypeStreamOperators<QList<int>>(\"QList<int>\"); QCoreApplication::setApplicationVersion(APP_VERSION); QCoreApplication::setApplicationName(QStringLiteral(\"flameshot\")); QCoreApplication::setOrganizationName(QStringLiteral(\"flameshot\")); // no arguments, just launch Flameshot if (argc == 1) { #ifndef USE_EXTERNAL_SINGLEAPPLICATION SingleApplication app(argc, argv); #else QtSingleApplication app(argc, argv); #endif QApplication::setStyle(new StyleOverride); QTranslator translator, qtTranslator; QStringList trPaths = PathInfo::translationsPaths(); for (const QString& path : trPaths) { bool match = translator.load(QLocale(), QStringLiteral(\"Internationalization\"), QStringLiteral(\"_\"), path); if (match) { break; } } qtTranslator.load( QLocale::system(), \"qt\", \"_\", QLibraryInfo::location(QLibraryInfo::TranslationsPath)); qApp->installTranslator(&translator); qApp->installTranslator(&qtTranslator); qApp->setAttribute(Qt::AA_DontCreateNativeWidgetSiblings, true); auto c = Flameshot::instance(); FlameshotDaemon::start(); #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) new FlameshotDBusAdapter(c); QDBusConnection dbus = QDBusConnection::sessionBus(); if (!dbus.isConnected()) { AbstractLogger::error() << QObject::tr(\"Unable to connect via DBus\"); } dbus.registerObject(QStringLiteral(\"/\"), c); dbus.registerService(QStringLiteral(\"org.flameshot.Flameshot\")); #endif return qApp->exec(); } #if !defined(Q_OS_WIN) /*--------------| * CLI parsing | * ------------*/ new QCoreApplication(argc, argv); CommandLineParser parser; // Add description parser.setDescription( QObject::tr(\"Powerful yet simple to use screenshot software.\")); parser.setGeneralErrorMessage(QObject::tr(\"See\") + \" flameshot --help.\"); // Arguments CommandArgument fullArgument(QStringLiteral(\"full\"), QObject::tr(\"Capture the entire desktop.\")); CommandArgument launcherArgument(QStringLiteral(\"launcher\"), QObject::tr(\"Open the capture launcher.\")); CommandArgument guiArgument( QStringLiteral(\"gui\"), QObject::tr(\"Start a manual capture in GUI mode.\")); CommandArgument configArgument(QStringLiteral(\"config\"), QObject::tr(\"Configure\") + \" flameshot.\"); CommandArgument screenArgument(QStringLiteral(\"screen\"), QObject::tr(\"Capture a single screen.\")); // Options CommandOption pathOption( { \"p\", \"path\" }, QObject::tr(\"Existing directory or new file to save to\"), QStringLiteral(\"path\")); CommandOption clipboardOption( { \"c\", \"clipboard\" }, QObject::tr(\"Save the capture to the clipboard\")); CommandOption pinOption(\"pin\", QObject::tr(\"Pin the capture to the screen\")); CommandOption uploadOption({ \"u\", \"upload\" }, QObject::tr(\"Upload screenshot\")); CommandOption delayOption({ \"d\", \"delay\" }, QObject::tr(\"Delay time in milliseconds\"), QStringLiteral(\"milliseconds\")); CommandOption useLastRegionOption( \"last-region\", QObject::tr(\"Repeat screenshot with previously selected region\")); CommandOption regionOption(\"region\", QObject::tr(\"Screenshot region to select\"), QStringLiteral(\"WxH+X+Y or string\")); CommandOption filenameOption({ \"f\", \"filename\" }, QObject::tr(\"Set the filename pattern\"), QStringLiteral(\"pattern\")); CommandOption acceptOnSelectOption( { \"s\", \"accept-on-select\" }, QObject::tr(\"Accept capture as soon as a selection is made\")); CommandOption trayOption({ \"t\", \"trayicon\" }, QObject::tr(\"Enable or disable the trayicon\"), QStringLiteral(\"bool\")); CommandOption autostartOption( { \"a\", \"autostart\" }, QObject::tr(\"Enable or disable run at startup\"), QStringLiteral(\"bool\")); CommandOption checkOption( \"check\", QObject::tr(\"Check the configuration for errors\")); CommandOption showHelpOption( { \"s\", \"showhelp\" }, QObject::tr(\"Show the help message in the capture mode\"), QStringLiteral(\"bool\")); CommandOption mainColorOption({ \"m\", \"maincolor\" }, QObject::tr(\"Define the main UI color\"), QStringLiteral(\"color-code\")); CommandOption contrastColorOption( { \"k\", \"contrastcolor\" }, QObject::tr(\"Define the contrast UI color\"), QStringLiteral(\"color-code\")); CommandOption rawImageOption({ \"r\", \"raw\" }, QObject::tr(\"Print raw PNG capture\")); CommandOption selectionOption( { \"g\", \"print-geometry\" }, QObject::tr(\"Print geometry of the selection in the format WxH+X+Y. Does \" \"nothing if raw is specified\")); CommandOption screenNumberOption( { \"n\", \"number\" }, QObject::tr(\"Define the screen to capture (starting from 0)\") + \",\\n\" + QObject::tr(\"default: screen containing the cursor\"), QObject::tr(\"Screen number\"), QStringLiteral(\"-1\")); // Add checkers auto colorChecker = [](const QString& colorCode) -> bool { QColor parsedColor(colorCode); return parsedColor.isValid() && parsedColor.alphaF() == 1.0; }; QString colorErr = QObject::tr(\"Invalid color, \" \"this flag supports the following formats:\\n\" \"- #RGB (each of R, G, and B is a single hex digit)\\n\" \"- #RRGGBB\\n- #RRRGGGBBB\\n\" \"- #RRRRGGGGBBBB\\n\" \"- Named colors like 'blue' or 'red'\\n\" \"You may need to escape the '#' sign as in '\\\\#FFF'\"); const QString delayErr = QObject::tr(\"Invalid delay, it must be a number greater than 0\"); const QString numberErr = QObject::tr(\"Invalid screen number, it must be non negative\"); const QString regionErr = QObject::tr( \"Invalid region, use 'WxH+X+Y' or 'all' or 'screen0/screen1/...'.\"); auto numericChecker = [](const QString& delayValue) -> bool { bool ok; int value = delayValue.toInt(&ok); return ok && value >= 0; }; auto regionChecker = [](const QString& region) -> bool { Region valueHandler; return valueHandler.check(region); }; const QString pathErr = QObject::tr(\"Invalid path, must be an existing directory or a new file \" \"in an existing directory\"); auto pathChecker = [pathErr](const QString& pathValue) -> bool { QFileInfo fileInfo(pathValue); if (fileInfo.isDir() || fileInfo.dir().exists()) { return true; } else { AbstractLogger::error() << QObject::tr(pathErr.toLatin1().data()); return false; } }; const QString booleanErr = QObject::tr(\"Invalid value, it must be defined as 'true' or 'false'\"); auto booleanChecker = [](const QString& value) -> bool { return value == QLatin1String(\"true\") || value == QLatin1String(\"false\"); }; contrastColorOption.addChecker(colorChecker, colorErr); mainColorOption.addChecker(colorChecker, colorErr); delayOption.addChecker(numericChecker, delayErr); regionOption.addChecker(regionChecker, regionErr); useLastRegionOption.addChecker(booleanChecker, booleanErr); pathOption.addChecker(pathChecker, pathErr); trayOption.addChecker(booleanChecker, booleanErr); autostartOption.addChecker(booleanChecker, booleanErr); showHelpOption.addChecker(booleanChecker, booleanErr); screenNumberOption.addChecker(numericChecker, numberErr); // Relationships parser.AddArgument(guiArgument); parser.AddArgument(screenArgument); parser.AddArgument(fullArgument); parser.AddArgument(launcherArgument); parser.AddArgument(configArgument); auto helpOption = parser.addHelpOption(); auto versionOption = parser.addVersionOption(); parser.AddOptions({ pathOption, clipboardOption, delayOption, regionOption, useLastRegionOption, rawImageOption, selectionOption, uploadOption, pinOption, acceptOnSelectOption }, guiArgument); parser.AddOptions({ screenNumberOption, clipboardOption, pathOption, delayOption, regionOption, rawImageOption, uploadOption, pinOption }, screenArgument); parser.AddOptions({ pathOption, clipboardOption, delayOption, regionOption, rawImageOption, uploadOption }, fullArgument); parser.AddOptions({ autostartOption, filenameOption, trayOption, showHelpOption, mainColorOption, contrastColorOption, checkOption }, configArgument); // Parse if (!parser.parse(qApp->arguments())) { goto finish; } // PROCESS DATA //-------------- Flameshot::setOrigin(Flameshot::CLI); if (parser.isSet(helpOption) || parser.isSet(versionOption)) { } else if (parser.isSet(launcherArgument)) { // LAUNCHER delete qApp; new QApplication(argc, argv); Flameshot* flameshot = Flameshot::instance(); flameshot->launcher(); qApp->exec(); } else if (parser.isSet(guiArgument)) { // GUI delete qApp; new QApplication(argc, argv); // Prevent multiple instances of 'flameshot gui' from running if not // configured to do so. if (!ConfigHandler().allowMultipleGuiInstances()) { auto* mutex = guiMutexLock(); if (!mutex) { return 1; } QObject::connect( qApp, &QCoreApplication::aboutToQuit, qApp, [mutex]() { mutex->detach(); delete mutex; }); } // Option values QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool useLastRegion = parser.isSet(useLastRegionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool printGeometry = parser.isSet(selectionOption); bool pin = parser.isSet(pinOption); bool upload = parser.isSet(uploadOption); bool acceptOnSelect = parser.isSet(acceptOnSelectOption); CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, path); if (!region.isEmpty()) { auto selectionRegion = Region().value(region).toRect(); req.setInitialSelection(selectionRegion); } else if (useLastRegion) { req.setInitialSelection(getLastRegion()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (!path.isEmpty()) { req.addSaveTask(path); } if (printGeometry) { req.addTask(CaptureRequest::PRINT_GEOMETRY); } if (pin) { req.addTask(CaptureRequest::PIN); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (acceptOnSelect) { req.addTask(CaptureRequest::ACCEPT_ON_SELECT); if (!clipboard && !raw && path.isEmpty() && !printGeometry && !pin && !upload) { req.addSaveTask(); } } requestCaptureAndWait(req); } else if (parser.isSet(fullArgument)) { // FULL // Recreate the application as a QApplication // TODO find a way so we don't have to do this delete qApp; new QApplication(argc, argv); // Option values QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool upload = parser.isSet(uploadOption); // Not a valid command CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay); if (!region.isEmpty()) { req.setInitialSelection(Region().value(region).toRect()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (!path.isEmpty()) { req.addSaveTask(path); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (!clipboard && path.isEmpty() && !raw && !upload) { req.addSaveTask(); } requestCaptureAndWait(req); } else if (parser.isSet(screenArgument)) { // SCREEN // Recreate the application as a QApplication // TODO find a way so we don't have to do this delete qApp; new QApplication(argc, argv); QString numberStr = parser.value(screenNumberOption); // Option values int screenNumber = numberStr.startsWith(QLatin1String(\"-\")) ? -1 : numberStr.toInt(); QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool pin = parser.isSet(pinOption); bool upload = parser.isSet(uploadOption); CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, screenNumber); if (!region.isEmpty()) { if (region.startsWith(\"screen\")) { // TODO use abstract logger QTextStream(stderr) << \"The 'screen' command does not support \" \"'--region screen<N>'.\\n\" \"See flameshot --help.\\n\"; exit(1); } req.setInitialSelection(Region().value(region).toRect()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (!path.isEmpty()) { req.addSaveTask(path); } if (pin) { req.addTask(CaptureRequest::PIN); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (!clipboard && !raw && path.isEmpty() && !pin && !upload) { req.addSaveTask(); } requestCaptureAndWait(req); } else if (parser.isSet(configArgument)) { // CONFIG bool autostart = parser.isSet(autostartOption); bool filename = parser.isSet(filenameOption); bool tray = parser.isSet(trayOption); bool mainColor = parser.isSet(mainColorOption); bool contrastColor = parser.isSet(contrastColorOption); bool check = parser.isSet(checkOption); bool someFlagSet = (filename || tray || mainColor || contrastColor || check); if (check) { AbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr); bool ok = ConfigHandler().checkForErrors(&err); if (ok) { AbstractLogger::info() << QStringLiteral(\"No errors detected.\\n\"); goto finish; } else { return 1; } } if (!someFlagSet) { // Open gui when no options are given delete qApp; new QApplication(argc, argv); QObject::connect( qApp, &QApplication::lastWindowClosed, qApp, &QApplication::quit); Flameshot::instance()->config(); qApp->exec(); } else { ConfigHandler config; if (autostart) { config.setStartupLaunch(parser.value(autostartOption) == \"true\"); } if (filename) { QString newFilename(parser.value(filenameOption)); config.setFilenamePattern(newFilename); FileNameHandler fh; QTextStream(stdout) << QStringLiteral(\"The new pattern is '%1'\\n\" \"Parsed pattern example: %2\\n\") .arg(newFilename) .arg(fh.parsedPattern()); } if (tray) { config.setDisabledTrayIcon(parser.value(trayOption) == \"false\"); } if (mainColor) { // TODO use value handler QString colorCode = parser.value(mainColorOption); QColor parsedColor(colorCode); config.setUiColor(parsedColor); } if (contrastColor) { QString colorCode = parser.value(contrastColorOption); QColor parsedColor(colorCode); config.setContrastUiColor(parsedColor); } } } finish: #endif return 0; }","title":"File main.cpp"},{"location":"flameshot/main_8cpp_source/#file-maincpp","text":"File List > src > main.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #ifndef USE_EXTERNAL_SINGLEAPPLICATION #include \"singleapplication.h\" #else #include \"QtSolutions/qtsingleapplication.h\" #endif #include \"abstractlogger.h\" #include \"src/cli/commandlineparser.h\" #include \"src/config/cacheutils.h\" #include \"src/config/styleoverride.h\" #include \"src/core/capturerequest.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/pathinfo.h\" #include \"src/utils/valuehandler.h\" #include <QApplication> #include <QDir> #include <QLibraryInfo> #include <QSharedMemory> #include <QTimer> #include <QTranslator> #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) #include \"abstractlogger.h\" #include \"src/core/flameshotdbusadapter.h\" #include <QApplication> #include <QDBusConnection> #include <QDBusMessage> #include <desktopinfo.h> #endif #ifdef Q_OS_LINUX // source: https://github.com/ksnip/ksnip/issues/416 void wayland_hacks() { // Workaround to https://github.com/ksnip/ksnip/issues/416 DesktopInfo info; if (info.windowManager() == DesktopInfo::GNOME) { qputenv(\"QT_QPA_PLATFORM\", \"xcb\"); } } #endif void requestCaptureAndWait(const CaptureRequest& req) { Flameshot* flameshot = Flameshot::instance(); flameshot->requestCapture(req); QObject::connect(flameshot, &Flameshot::captureTaken, [&](const QPixmap&) { #if defined(Q_OS_MACOS) // Only useful on MacOS because each instance hosts its own widgets if (!FlameshotDaemon::isThisInstanceHostingWidgets()) { qApp->exit(0); } #else // if this instance is not daemon, make sure it exit after caputre finish if (FlameshotDaemon::instance() == nullptr && !Flameshot::instance()->haveExternalWidget()) { qApp->exit(0); } #endif }); QObject::connect(flameshot, &Flameshot::captureFailed, []() { AbstractLogger::info() << \"Screenshot aborted.\"; qApp->exit(1); }); qApp->exec(); } QSharedMemory* guiMutexLock() { QString key = \"org.flameshot.Flameshot-\" APP_VERSION; auto* shm = new QSharedMemory(key); #ifdef Q_OS_UNIX // Destroy shared memory if the last instance crashed on Unix shm->attach(); delete shm; shm = new QSharedMemory(key); #endif if (!shm->create(1)) { return nullptr; } return shm; } int main(int argc, char* argv[]) { #ifdef Q_OS_LINUX wayland_hacks(); #endif // required for the button serialization // TODO: change to QVector in v1.0 qRegisterMetaTypeStreamOperators<QList<int>>(\"QList<int>\"); QCoreApplication::setApplicationVersion(APP_VERSION); QCoreApplication::setApplicationName(QStringLiteral(\"flameshot\")); QCoreApplication::setOrganizationName(QStringLiteral(\"flameshot\")); // no arguments, just launch Flameshot if (argc == 1) { #ifndef USE_EXTERNAL_SINGLEAPPLICATION SingleApplication app(argc, argv); #else QtSingleApplication app(argc, argv); #endif QApplication::setStyle(new StyleOverride); QTranslator translator, qtTranslator; QStringList trPaths = PathInfo::translationsPaths(); for (const QString& path : trPaths) { bool match = translator.load(QLocale(), QStringLiteral(\"Internationalization\"), QStringLiteral(\"_\"), path); if (match) { break; } } qtTranslator.load( QLocale::system(), \"qt\", \"_\", QLibraryInfo::location(QLibraryInfo::TranslationsPath)); qApp->installTranslator(&translator); qApp->installTranslator(&qtTranslator); qApp->setAttribute(Qt::AA_DontCreateNativeWidgetSiblings, true); auto c = Flameshot::instance(); FlameshotDaemon::start(); #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) new FlameshotDBusAdapter(c); QDBusConnection dbus = QDBusConnection::sessionBus(); if (!dbus.isConnected()) { AbstractLogger::error() << QObject::tr(\"Unable to connect via DBus\"); } dbus.registerObject(QStringLiteral(\"/\"), c); dbus.registerService(QStringLiteral(\"org.flameshot.Flameshot\")); #endif return qApp->exec(); } #if !defined(Q_OS_WIN) /*--------------| * CLI parsing | * ------------*/ new QCoreApplication(argc, argv); CommandLineParser parser; // Add description parser.setDescription( QObject::tr(\"Powerful yet simple to use screenshot software.\")); parser.setGeneralErrorMessage(QObject::tr(\"See\") + \" flameshot --help.\"); // Arguments CommandArgument fullArgument(QStringLiteral(\"full\"), QObject::tr(\"Capture the entire desktop.\")); CommandArgument launcherArgument(QStringLiteral(\"launcher\"), QObject::tr(\"Open the capture launcher.\")); CommandArgument guiArgument( QStringLiteral(\"gui\"), QObject::tr(\"Start a manual capture in GUI mode.\")); CommandArgument configArgument(QStringLiteral(\"config\"), QObject::tr(\"Configure\") + \" flameshot.\"); CommandArgument screenArgument(QStringLiteral(\"screen\"), QObject::tr(\"Capture a single screen.\")); // Options CommandOption pathOption( { \"p\", \"path\" }, QObject::tr(\"Existing directory or new file to save to\"), QStringLiteral(\"path\")); CommandOption clipboardOption( { \"c\", \"clipboard\" }, QObject::tr(\"Save the capture to the clipboard\")); CommandOption pinOption(\"pin\", QObject::tr(\"Pin the capture to the screen\")); CommandOption uploadOption({ \"u\", \"upload\" }, QObject::tr(\"Upload screenshot\")); CommandOption delayOption({ \"d\", \"delay\" }, QObject::tr(\"Delay time in milliseconds\"), QStringLiteral(\"milliseconds\")); CommandOption useLastRegionOption( \"last-region\", QObject::tr(\"Repeat screenshot with previously selected region\")); CommandOption regionOption(\"region\", QObject::tr(\"Screenshot region to select\"), QStringLiteral(\"WxH+X+Y or string\")); CommandOption filenameOption({ \"f\", \"filename\" }, QObject::tr(\"Set the filename pattern\"), QStringLiteral(\"pattern\")); CommandOption acceptOnSelectOption( { \"s\", \"accept-on-select\" }, QObject::tr(\"Accept capture as soon as a selection is made\")); CommandOption trayOption({ \"t\", \"trayicon\" }, QObject::tr(\"Enable or disable the trayicon\"), QStringLiteral(\"bool\")); CommandOption autostartOption( { \"a\", \"autostart\" }, QObject::tr(\"Enable or disable run at startup\"), QStringLiteral(\"bool\")); CommandOption checkOption( \"check\", QObject::tr(\"Check the configuration for errors\")); CommandOption showHelpOption( { \"s\", \"showhelp\" }, QObject::tr(\"Show the help message in the capture mode\"), QStringLiteral(\"bool\")); CommandOption mainColorOption({ \"m\", \"maincolor\" }, QObject::tr(\"Define the main UI color\"), QStringLiteral(\"color-code\")); CommandOption contrastColorOption( { \"k\", \"contrastcolor\" }, QObject::tr(\"Define the contrast UI color\"), QStringLiteral(\"color-code\")); CommandOption rawImageOption({ \"r\", \"raw\" }, QObject::tr(\"Print raw PNG capture\")); CommandOption selectionOption( { \"g\", \"print-geometry\" }, QObject::tr(\"Print geometry of the selection in the format WxH+X+Y. Does \" \"nothing if raw is specified\")); CommandOption screenNumberOption( { \"n\", \"number\" }, QObject::tr(\"Define the screen to capture (starting from 0)\") + \",\\n\" + QObject::tr(\"default: screen containing the cursor\"), QObject::tr(\"Screen number\"), QStringLiteral(\"-1\")); // Add checkers auto colorChecker = [](const QString& colorCode) -> bool { QColor parsedColor(colorCode); return parsedColor.isValid() && parsedColor.alphaF() == 1.0; }; QString colorErr = QObject::tr(\"Invalid color, \" \"this flag supports the following formats:\\n\" \"- #RGB (each of R, G, and B is a single hex digit)\\n\" \"- #RRGGBB\\n- #RRRGGGBBB\\n\" \"- #RRRRGGGGBBBB\\n\" \"- Named colors like 'blue' or 'red'\\n\" \"You may need to escape the '#' sign as in '\\\\#FFF'\"); const QString delayErr = QObject::tr(\"Invalid delay, it must be a number greater than 0\"); const QString numberErr = QObject::tr(\"Invalid screen number, it must be non negative\"); const QString regionErr = QObject::tr( \"Invalid region, use 'WxH+X+Y' or 'all' or 'screen0/screen1/...'.\"); auto numericChecker = [](const QString& delayValue) -> bool { bool ok; int value = delayValue.toInt(&ok); return ok && value >= 0; }; auto regionChecker = [](const QString& region) -> bool { Region valueHandler; return valueHandler.check(region); }; const QString pathErr = QObject::tr(\"Invalid path, must be an existing directory or a new file \" \"in an existing directory\"); auto pathChecker = [pathErr](const QString& pathValue) -> bool { QFileInfo fileInfo(pathValue); if (fileInfo.isDir() || fileInfo.dir().exists()) { return true; } else { AbstractLogger::error() << QObject::tr(pathErr.toLatin1().data()); return false; } }; const QString booleanErr = QObject::tr(\"Invalid value, it must be defined as 'true' or 'false'\"); auto booleanChecker = [](const QString& value) -> bool { return value == QLatin1String(\"true\") || value == QLatin1String(\"false\"); }; contrastColorOption.addChecker(colorChecker, colorErr); mainColorOption.addChecker(colorChecker, colorErr); delayOption.addChecker(numericChecker, delayErr); regionOption.addChecker(regionChecker, regionErr); useLastRegionOption.addChecker(booleanChecker, booleanErr); pathOption.addChecker(pathChecker, pathErr); trayOption.addChecker(booleanChecker, booleanErr); autostartOption.addChecker(booleanChecker, booleanErr); showHelpOption.addChecker(booleanChecker, booleanErr); screenNumberOption.addChecker(numericChecker, numberErr); // Relationships parser.AddArgument(guiArgument); parser.AddArgument(screenArgument); parser.AddArgument(fullArgument); parser.AddArgument(launcherArgument); parser.AddArgument(configArgument); auto helpOption = parser.addHelpOption(); auto versionOption = parser.addVersionOption(); parser.AddOptions({ pathOption, clipboardOption, delayOption, regionOption, useLastRegionOption, rawImageOption, selectionOption, uploadOption, pinOption, acceptOnSelectOption }, guiArgument); parser.AddOptions({ screenNumberOption, clipboardOption, pathOption, delayOption, regionOption, rawImageOption, uploadOption, pinOption }, screenArgument); parser.AddOptions({ pathOption, clipboardOption, delayOption, regionOption, rawImageOption, uploadOption }, fullArgument); parser.AddOptions({ autostartOption, filenameOption, trayOption, showHelpOption, mainColorOption, contrastColorOption, checkOption }, configArgument); // Parse if (!parser.parse(qApp->arguments())) { goto finish; } // PROCESS DATA //-------------- Flameshot::setOrigin(Flameshot::CLI); if (parser.isSet(helpOption) || parser.isSet(versionOption)) { } else if (parser.isSet(launcherArgument)) { // LAUNCHER delete qApp; new QApplication(argc, argv); Flameshot* flameshot = Flameshot::instance(); flameshot->launcher(); qApp->exec(); } else if (parser.isSet(guiArgument)) { // GUI delete qApp; new QApplication(argc, argv); // Prevent multiple instances of 'flameshot gui' from running if not // configured to do so. if (!ConfigHandler().allowMultipleGuiInstances()) { auto* mutex = guiMutexLock(); if (!mutex) { return 1; } QObject::connect( qApp, &QCoreApplication::aboutToQuit, qApp, [mutex]() { mutex->detach(); delete mutex; }); } // Option values QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool useLastRegion = parser.isSet(useLastRegionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool printGeometry = parser.isSet(selectionOption); bool pin = parser.isSet(pinOption); bool upload = parser.isSet(uploadOption); bool acceptOnSelect = parser.isSet(acceptOnSelectOption); CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, path); if (!region.isEmpty()) { auto selectionRegion = Region().value(region).toRect(); req.setInitialSelection(selectionRegion); } else if (useLastRegion) { req.setInitialSelection(getLastRegion()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (!path.isEmpty()) { req.addSaveTask(path); } if (printGeometry) { req.addTask(CaptureRequest::PRINT_GEOMETRY); } if (pin) { req.addTask(CaptureRequest::PIN); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (acceptOnSelect) { req.addTask(CaptureRequest::ACCEPT_ON_SELECT); if (!clipboard && !raw && path.isEmpty() && !printGeometry && !pin && !upload) { req.addSaveTask(); } } requestCaptureAndWait(req); } else if (parser.isSet(fullArgument)) { // FULL // Recreate the application as a QApplication // TODO find a way so we don't have to do this delete qApp; new QApplication(argc, argv); // Option values QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool upload = parser.isSet(uploadOption); // Not a valid command CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay); if (!region.isEmpty()) { req.setInitialSelection(Region().value(region).toRect()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (!path.isEmpty()) { req.addSaveTask(path); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (!clipboard && path.isEmpty() && !raw && !upload) { req.addSaveTask(); } requestCaptureAndWait(req); } else if (parser.isSet(screenArgument)) { // SCREEN // Recreate the application as a QApplication // TODO find a way so we don't have to do this delete qApp; new QApplication(argc, argv); QString numberStr = parser.value(screenNumberOption); // Option values int screenNumber = numberStr.startsWith(QLatin1String(\"-\")) ? -1 : numberStr.toInt(); QString path = parser.value(pathOption); if (!path.isEmpty()) { path = QDir(path).absolutePath(); } int delay = parser.value(delayOption).toInt(); QString region = parser.value(regionOption); bool clipboard = parser.isSet(clipboardOption); bool raw = parser.isSet(rawImageOption); bool pin = parser.isSet(pinOption); bool upload = parser.isSet(uploadOption); CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, screenNumber); if (!region.isEmpty()) { if (region.startsWith(\"screen\")) { // TODO use abstract logger QTextStream(stderr) << \"The 'screen' command does not support \" \"'--region screen<N>'.\\n\" \"See flameshot --help.\\n\"; exit(1); } req.setInitialSelection(Region().value(region).toRect()); } if (clipboard) { req.addTask(CaptureRequest::COPY); } if (raw) { req.addTask(CaptureRequest::PRINT_RAW); } if (!path.isEmpty()) { req.addSaveTask(path); } if (pin) { req.addTask(CaptureRequest::PIN); } if (upload) { req.addTask(CaptureRequest::UPLOAD); } if (!clipboard && !raw && path.isEmpty() && !pin && !upload) { req.addSaveTask(); } requestCaptureAndWait(req); } else if (parser.isSet(configArgument)) { // CONFIG bool autostart = parser.isSet(autostartOption); bool filename = parser.isSet(filenameOption); bool tray = parser.isSet(trayOption); bool mainColor = parser.isSet(mainColorOption); bool contrastColor = parser.isSet(contrastColorOption); bool check = parser.isSet(checkOption); bool someFlagSet = (filename || tray || mainColor || contrastColor || check); if (check) { AbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr); bool ok = ConfigHandler().checkForErrors(&err); if (ok) { AbstractLogger::info() << QStringLiteral(\"No errors detected.\\n\"); goto finish; } else { return 1; } } if (!someFlagSet) { // Open gui when no options are given delete qApp; new QApplication(argc, argv); QObject::connect( qApp, &QApplication::lastWindowClosed, qApp, &QApplication::quit); Flameshot::instance()->config(); qApp->exec(); } else { ConfigHandler config; if (autostart) { config.setStartupLaunch(parser.value(autostartOption) == \"true\"); } if (filename) { QString newFilename(parser.value(filenameOption)); config.setFilenamePattern(newFilename); FileNameHandler fh; QTextStream(stdout) << QStringLiteral(\"The new pattern is '%1'\\n\" \"Parsed pattern example: %2\\n\") .arg(newFilename) .arg(fh.parsedPattern()); } if (tray) { config.setDisabledTrayIcon(parser.value(trayOption) == \"false\"); } if (mainColor) { // TODO use value handler QString colorCode = parser.value(mainColorOption); QColor parsedColor(colorCode); config.setUiColor(parsedColor); } if (contrastColor) { QString colorCode = parser.value(contrastColorOption); QColor parsedColor(colorCode); config.setContrastUiColor(parsedColor); } } } finish: #endif return 0; }","title":"File main.cpp"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/","text":"Dir tools # FileList > src > tools Files # Type Name file abstractactiontool.cpp file abstractactiontool.h file abstractpathtool.cpp file abstractpathtool.h file abstracttwopointtool.cpp file abstracttwopointtool.h file capturecontext.cpp file capturecontext.h file toolfactory.cpp file toolfactory.h Directories # Type Name dir accept dir arrow dir circle dir circlecount dir copy dir exit dir imgupload dir invert dir launcher dir line dir marker dir move dir pencil dir pin dir pixelate dir rectangle dir redo dir save dir selection dir sizedecrease dir sizeincrease dir text dir undo","title":"Dir tools"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/#dir-tools","text":"FileList > src > tools","title":"Dir tools"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/#files","text":"Type Name file abstractactiontool.cpp file abstractactiontool.h file abstractpathtool.cpp file abstractpathtool.h file abstracttwopointtool.cpp file abstracttwopointtool.h file capturecontext.cpp file capturecontext.h file toolfactory.cpp file toolfactory.h","title":"Files"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/#directories","text":"Type Name dir accept dir arrow dir circle dir circlecount dir copy dir exit dir imgupload dir invert dir launcher dir line dir marker dir move dir pencil dir pin dir pixelate dir rectangle dir redo dir save dir selection dir sizedecrease dir sizeincrease dir text dir undo","title":"Directories"},{"location":"flameshot/abstractactiontool_8cpp/","text":"File abstractactiontool.cpp # FileList > src > tools > abstractactiontool.cpp Go to the source code of this file. #include \"abstractactiontool.h\"","title":"File abstractactiontool.cpp"},{"location":"flameshot/abstractactiontool_8cpp/#file-abstractactiontoolcpp","text":"FileList > src > tools > abstractactiontool.cpp Go to the source code of this file. #include \"abstractactiontool.h\"","title":"File abstractactiontool.cpp"},{"location":"flameshot/abstractactiontool_8cpp_source/","text":"File abstractactiontool.cpp # File List > src > tools > abstractactiontool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstractactiontool.h\" AbstractActionTool::AbstractActionTool(QObject* parent) : CaptureTool(parent) {} bool AbstractActionTool::isValid() const { return true; } bool AbstractActionTool::isSelectable() const { return false; } bool AbstractActionTool::showMousePreview() const { return false; } QRect AbstractActionTool::boundingRect() const { return {}; } void AbstractActionTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(painter) Q_UNUSED(pixmap) } void AbstractActionTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(painter) Q_UNUSED(context) } void AbstractActionTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractActionTool::drawMove(const QPoint& p) { Q_UNUSED(p) } void AbstractActionTool::drawStart(const CaptureContext& context) { Q_UNUSED(context) } void AbstractActionTool::onColorChanged(const QColor& c) { Q_UNUSED(c) } void AbstractActionTool::onSizeChanged(int size) { Q_UNUSED(size) }","title":"File abstractactiontool.cpp"},{"location":"flameshot/abstractactiontool_8cpp_source/#file-abstractactiontoolcpp","text":"File List > src > tools > abstractactiontool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstractactiontool.h\" AbstractActionTool::AbstractActionTool(QObject* parent) : CaptureTool(parent) {} bool AbstractActionTool::isValid() const { return true; } bool AbstractActionTool::isSelectable() const { return false; } bool AbstractActionTool::showMousePreview() const { return false; } QRect AbstractActionTool::boundingRect() const { return {}; } void AbstractActionTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(painter) Q_UNUSED(pixmap) } void AbstractActionTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(painter) Q_UNUSED(context) } void AbstractActionTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractActionTool::drawMove(const QPoint& p) { Q_UNUSED(p) } void AbstractActionTool::drawStart(const CaptureContext& context) { Q_UNUSED(context) } void AbstractActionTool::onColorChanged(const QColor& c) { Q_UNUSED(c) } void AbstractActionTool::onSizeChanged(int size) { Q_UNUSED(size) }","title":"File abstractactiontool.cpp"},{"location":"flameshot/abstractactiontool_8h/","text":"File abstractactiontool.h # FileList > src > tools > abstractactiontool.h Go to the source code of this file. #include \"capturetool.h\" Classes # Type Name class AbstractActionTool","title":"File abstractactiontool.h"},{"location":"flameshot/abstractactiontool_8h/#file-abstractactiontoolh","text":"FileList > src > tools > abstractactiontool.h Go to the source code of this file. #include \"capturetool.h\"","title":"File abstractactiontool.h"},{"location":"flameshot/abstractactiontool_8h/#classes","text":"Type Name class AbstractActionTool","title":"Classes"},{"location":"flameshot/abstractactiontool_8h_source/","text":"File abstractactiontool.h # File List > src > tools > abstractactiontool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractActionTool : public CaptureTool { Q_OBJECT public: explicit AbstractActionTool(QObject* parent = nullptr); bool isValid() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect boundingRect() const override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void drawStart(const CaptureContext& context) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; };","title":"File abstractactiontool.h"},{"location":"flameshot/abstractactiontool_8h_source/#file-abstractactiontoolh","text":"File List > src > tools > abstractactiontool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractActionTool : public CaptureTool { Q_OBJECT public: explicit AbstractActionTool(QObject* parent = nullptr); bool isValid() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect boundingRect() const override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void drawStart(const CaptureContext& context) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; };","title":"File abstractactiontool.h"},{"location":"flameshot/abstractpathtool_8cpp/","text":"File abstractpathtool.cpp # FileList > src > tools > abstractpathtool.cpp Go to the source code of this file. #include \"abstractpathtool.h\" #include <cmath>","title":"File abstractpathtool.cpp"},{"location":"flameshot/abstractpathtool_8cpp/#file-abstractpathtoolcpp","text":"FileList > src > tools > abstractpathtool.cpp Go to the source code of this file. #include \"abstractpathtool.h\" #include <cmath>","title":"File abstractpathtool.cpp"},{"location":"flameshot/abstractpathtool_8cpp_source/","text":"File abstractpathtool.cpp # File List > src > tools > abstractpathtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstractpathtool.h\" #include <cmath> AbstractPathTool::AbstractPathTool(QObject* parent) : CaptureTool(parent) , m_thickness(1) , m_padding(0) {} void AbstractPathTool::copyParams(const AbstractPathTool* from, AbstractPathTool* to) { to->m_color = from->m_color; to->m_thickness = from->m_thickness; to->m_padding = from->m_padding; to->m_pos = from->m_pos; to->m_points.clear(); for (auto point : from->m_points) { to->m_points.append(point); } } bool AbstractPathTool::isValid() const { return m_points.length() > 1; } bool AbstractPathTool::closeOnButtonPressed() const { return false; } bool AbstractPathTool::isSelectable() const { return true; } bool AbstractPathTool::showMousePreview() const { return true; } QRect AbstractPathTool::mousePreviewRect(const CaptureContext& context) const { QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2); rect.moveCenter(context.mousePos); return rect; } QRect AbstractPathTool::boundingRect() const { if (m_points.isEmpty()) { return {}; } int min_x = m_points.at(0).x(); int min_y = m_points.at(0).y(); int max_x = m_points.at(0).x(); int max_y = m_points.at(0).y(); for (auto point : m_points) { if (point.x() < min_x) { min_x = point.x(); } if (point.y() < min_y) { min_y = point.y(); } if (point.x() > max_x) { max_x = point.x(); } if (point.y() > max_y) { max_y = point.y(); } } int offset = m_thickness <= 1 ? 1 : static_cast<int>(round(m_thickness * 0.7 + 0.5)); return QRect(min_x - offset, min_y - offset, std::abs(min_x - max_x) + offset * 2, std::abs(min_y - max_y) + offset * 2) .normalized(); } void AbstractPathTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractPathTool::drawMove(const QPoint& p) { addPoint(p); } void AbstractPathTool::onColorChanged(const QColor& c) { m_color = c; } void AbstractPathTool::onSizeChanged(int size) { m_thickness = size; } void AbstractPathTool::addPoint(const QPoint& point) { if (m_pathArea.left() > point.x()) { m_pathArea.setLeft(point.x()); } else if (m_pathArea.right() < point.x()) { m_pathArea.setRight(point.x()); } if (m_pathArea.top() > point.y()) { m_pathArea.setTop(point.y()); } else if (m_pathArea.bottom() < point.y()) { m_pathArea.setBottom(point.y()); } m_points.append(point); } void AbstractPathTool::move(const QPoint& mousePos) { if (m_points.empty()) { return; } QPoint basePos = *pos(); QPoint offset = mousePos - basePos; for (auto& m_point : m_points) { m_point += offset; } } const QPoint* AbstractPathTool::pos() { if (m_points.empty()) { m_pos = QPoint(); return &m_pos; } int x = m_points.at(0).x(); int y = m_points.at(0).y(); for (auto point : m_points) { if (point.x() < x) { x = point.x(); } if (point.y() < y) { y = point.y(); } } m_pos.setX(x); m_pos.setY(y); return &m_pos; }","title":"File abstractpathtool.cpp"},{"location":"flameshot/abstractpathtool_8cpp_source/#file-abstractpathtoolcpp","text":"File List > src > tools > abstractpathtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstractpathtool.h\" #include <cmath> AbstractPathTool::AbstractPathTool(QObject* parent) : CaptureTool(parent) , m_thickness(1) , m_padding(0) {} void AbstractPathTool::copyParams(const AbstractPathTool* from, AbstractPathTool* to) { to->m_color = from->m_color; to->m_thickness = from->m_thickness; to->m_padding = from->m_padding; to->m_pos = from->m_pos; to->m_points.clear(); for (auto point : from->m_points) { to->m_points.append(point); } } bool AbstractPathTool::isValid() const { return m_points.length() > 1; } bool AbstractPathTool::closeOnButtonPressed() const { return false; } bool AbstractPathTool::isSelectable() const { return true; } bool AbstractPathTool::showMousePreview() const { return true; } QRect AbstractPathTool::mousePreviewRect(const CaptureContext& context) const { QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2); rect.moveCenter(context.mousePos); return rect; } QRect AbstractPathTool::boundingRect() const { if (m_points.isEmpty()) { return {}; } int min_x = m_points.at(0).x(); int min_y = m_points.at(0).y(); int max_x = m_points.at(0).x(); int max_y = m_points.at(0).y(); for (auto point : m_points) { if (point.x() < min_x) { min_x = point.x(); } if (point.y() < min_y) { min_y = point.y(); } if (point.x() > max_x) { max_x = point.x(); } if (point.y() > max_y) { max_y = point.y(); } } int offset = m_thickness <= 1 ? 1 : static_cast<int>(round(m_thickness * 0.7 + 0.5)); return QRect(min_x - offset, min_y - offset, std::abs(min_x - max_x) + offset * 2, std::abs(min_y - max_y) + offset * 2) .normalized(); } void AbstractPathTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractPathTool::drawMove(const QPoint& p) { addPoint(p); } void AbstractPathTool::onColorChanged(const QColor& c) { m_color = c; } void AbstractPathTool::onSizeChanged(int size) { m_thickness = size; } void AbstractPathTool::addPoint(const QPoint& point) { if (m_pathArea.left() > point.x()) { m_pathArea.setLeft(point.x()); } else if (m_pathArea.right() < point.x()) { m_pathArea.setRight(point.x()); } if (m_pathArea.top() > point.y()) { m_pathArea.setTop(point.y()); } else if (m_pathArea.bottom() < point.y()) { m_pathArea.setBottom(point.y()); } m_points.append(point); } void AbstractPathTool::move(const QPoint& mousePos) { if (m_points.empty()) { return; } QPoint basePos = *pos(); QPoint offset = mousePos - basePos; for (auto& m_point : m_points) { m_point += offset; } } const QPoint* AbstractPathTool::pos() { if (m_points.empty()) { m_pos = QPoint(); return &m_pos; } int x = m_points.at(0).x(); int y = m_points.at(0).y(); for (auto point : m_points) { if (point.x() < x) { x = point.x(); } if (point.y() < y) { y = point.y(); } } m_pos.setX(x); m_pos.setY(y); return &m_pos; }","title":"File abstractpathtool.cpp"},{"location":"flameshot/abstractpathtool_8h/","text":"File abstractpathtool.h # FileList > src > tools > abstractpathtool.h Go to the source code of this file. #include \"capturetool.h\" Classes # Type Name class AbstractPathTool","title":"File abstractpathtool.h"},{"location":"flameshot/abstractpathtool_8h/#file-abstractpathtoolh","text":"FileList > src > tools > abstractpathtool.h Go to the source code of this file. #include \"capturetool.h\"","title":"File abstractpathtool.h"},{"location":"flameshot/abstractpathtool_8h/#classes","text":"Type Name class AbstractPathTool","title":"Classes"},{"location":"flameshot/abstractpathtool_8h_source/","text":"File abstractpathtool.h # File List > src > tools > abstractpathtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractPathTool : public CaptureTool { Q_OBJECT public: explicit AbstractPathTool(QObject* parent = nullptr); bool isValid() const override; bool closeOnButtonPressed() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; void move(const QPoint& mousePos) override; const QPoint* pos() override; int size() const override { return m_thickness; }; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; protected: void copyParams(const AbstractPathTool* from, AbstractPathTool* to); void addPoint(const QPoint& point); // class members QRect m_pathArea; QColor m_color; QVector<QPoint> m_points; // use m_padding to extend the area of the backup int m_padding; QPoint m_pos; private: int m_thickness; };","title":"File abstractpathtool.h"},{"location":"flameshot/abstractpathtool_8h_source/#file-abstractpathtoolh","text":"File List > src > tools > abstractpathtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractPathTool : public CaptureTool { Q_OBJECT public: explicit AbstractPathTool(QObject* parent = nullptr); bool isValid() const override; bool closeOnButtonPressed() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; void move(const QPoint& mousePos) override; const QPoint* pos() override; int size() const override { return m_thickness; }; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; protected: void copyParams(const AbstractPathTool* from, AbstractPathTool* to); void addPoint(const QPoint& point); // class members QRect m_pathArea; QColor m_color; QVector<QPoint> m_points; // use m_padding to extend the area of the backup int m_padding; QPoint m_pos; private: int m_thickness; };","title":"File abstractpathtool.h"},{"location":"flameshot/abstracttwopointtool_8cpp/","text":"File abstracttwopointtool.cpp # FileList > src > tools > abstracttwopointtool.cpp Go to the source code of this file. #include \"abstracttwopointtool.h\" #include <QCursor> #include <QScreen> #include <cmath>","title":"File abstracttwopointtool.cpp"},{"location":"flameshot/abstracttwopointtool_8cpp/#file-abstracttwopointtoolcpp","text":"FileList > src > tools > abstracttwopointtool.cpp Go to the source code of this file. #include \"abstracttwopointtool.h\" #include <QCursor> #include <QScreen> #include <cmath>","title":"File abstracttwopointtool.cpp"},{"location":"flameshot/abstracttwopointtool_8cpp_source/","text":"File abstracttwopointtool.cpp # File List > src > tools > abstracttwopointtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstracttwopointtool.h\" #include <QCursor> #include <QScreen> #include <cmath> namespace { const double ADJ_UNIT = std::atan(1.0); const int DIRS_NUMBER = 4; enum UNIT { HORIZ_DIR = 0, DIAG1_DIR = 1, VERT_DIR = 2 }; const double ADJ_DIAG_UNIT = 2 * ADJ_UNIT; const int DIAG_DIRS_NUMBER = 2; enum DIAG_UNIT { DIR1 = 0 }; } AbstractTwoPointTool::AbstractTwoPointTool(QObject* parent) : CaptureTool(parent) , m_thickness(1) , m_padding(0) {} void AbstractTwoPointTool::copyParams(const AbstractTwoPointTool* from, AbstractTwoPointTool* to) { CaptureTool::copyParams(from, to); to->m_points.first = from->m_points.first; to->m_points.second = from->m_points.second; to->m_color = from->m_color; to->m_thickness = from->m_thickness; to->m_padding = from->m_padding; to->m_supportsOrthogonalAdj = from->m_supportsOrthogonalAdj; to->m_supportsDiagonalAdj = from->m_supportsDiagonalAdj; } bool AbstractTwoPointTool::isValid() const { return (m_points.first != m_points.second); } bool AbstractTwoPointTool::closeOnButtonPressed() const { return false; } bool AbstractTwoPointTool::isSelectable() const { return true; } bool AbstractTwoPointTool::showMousePreview() const { return true; } QRect AbstractTwoPointTool::mousePreviewRect( const CaptureContext& context) const { QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2); rect.moveCenter(context.mousePos); return rect; } QRect AbstractTwoPointTool::boundingRect() const { if (!isValid()) { return {}; } int offset = m_thickness <= 1 ? 1 : static_cast<int>(round(m_thickness * 0.7 + 0.5)); QRect rect = QRect(std::min(m_points.first.x(), m_points.second.x()) - offset, std::min(m_points.first.y(), m_points.second.y()) - offset, std::abs(m_points.first.x() - m_points.second.x()) + offset * 2, std::abs(m_points.first.y() - m_points.second.y()) + offset * 2); return rect.normalized(); } void AbstractTwoPointTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractTwoPointTool::drawMove(const QPoint& p) { m_points.second = p; } void AbstractTwoPointTool::drawMoveWithAdjustment(const QPoint& p) { m_points.second = m_points.first + adjustedVector(p - m_points.first); } void AbstractTwoPointTool::onColorChanged(const QColor& c) { m_color = c; } void AbstractTwoPointTool::onSizeChanged(int size) { m_thickness = size; } void AbstractTwoPointTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { painter.setPen(QPen(context.color, context.toolSize)); painter.drawLine(context.mousePos, context.mousePos); } void AbstractTwoPointTool::drawStart(const CaptureContext& context) { onColorChanged(context.color); m_points.first = context.mousePos; m_points.second = context.mousePos; onSizeChanged(context.toolSize); } QPoint AbstractTwoPointTool::adjustedVector(QPoint v) const { if (m_supportsOrthogonalAdj && m_supportsDiagonalAdj) { int dir = (static_cast<int>(round(atan2(-v.y(), v.x()) / ADJ_UNIT)) + DIRS_NUMBER) % DIRS_NUMBER; if (dir == UNIT::HORIZ_DIR) { v.setY(0); } else if (dir == UNIT::VERT_DIR) { v.setX(0); } else if (dir == UNIT::DIAG1_DIR) { int newX = (v.x() - v.y()) / 2; int newY = -newX; v.setX(newX); v.setY(newY); } else { int newX = (v.x() + v.y()) / 2; int newY = newX; v.setX(newX); v.setY(newY); } } else if (m_supportsDiagonalAdj) { int dir = (static_cast<int>(round((atan2(-v.y(), v.x()) - ADJ_DIAG_UNIT / 2) / ADJ_DIAG_UNIT)) + DIAG_DIRS_NUMBER) % DIAG_DIRS_NUMBER; if (dir == DIAG_UNIT::DIR1) { int newX = (v.x() - v.y()) / 2; int newY = -newX; v.setX(newX); v.setY(newY); } else { int newX = (v.x() + v.y()) / 2; int newY = newX; v.setX(newX); v.setY(newY); } } return v; } void AbstractTwoPointTool::move(const QPoint& pos) { QPoint offset = m_points.second - m_points.first; m_points.first = pos; m_points.second = m_points.first + offset; } const QPoint* AbstractTwoPointTool::pos() { return &m_points.first; }","title":"File abstracttwopointtool.cpp"},{"location":"flameshot/abstracttwopointtool_8cpp_source/#file-abstracttwopointtoolcpp","text":"File List > src > tools > abstracttwopointtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"abstracttwopointtool.h\" #include <QCursor> #include <QScreen> #include <cmath> namespace { const double ADJ_UNIT = std::atan(1.0); const int DIRS_NUMBER = 4; enum UNIT { HORIZ_DIR = 0, DIAG1_DIR = 1, VERT_DIR = 2 }; const double ADJ_DIAG_UNIT = 2 * ADJ_UNIT; const int DIAG_DIRS_NUMBER = 2; enum DIAG_UNIT { DIR1 = 0 }; } AbstractTwoPointTool::AbstractTwoPointTool(QObject* parent) : CaptureTool(parent) , m_thickness(1) , m_padding(0) {} void AbstractTwoPointTool::copyParams(const AbstractTwoPointTool* from, AbstractTwoPointTool* to) { CaptureTool::copyParams(from, to); to->m_points.first = from->m_points.first; to->m_points.second = from->m_points.second; to->m_color = from->m_color; to->m_thickness = from->m_thickness; to->m_padding = from->m_padding; to->m_supportsOrthogonalAdj = from->m_supportsOrthogonalAdj; to->m_supportsDiagonalAdj = from->m_supportsDiagonalAdj; } bool AbstractTwoPointTool::isValid() const { return (m_points.first != m_points.second); } bool AbstractTwoPointTool::closeOnButtonPressed() const { return false; } bool AbstractTwoPointTool::isSelectable() const { return true; } bool AbstractTwoPointTool::showMousePreview() const { return true; } QRect AbstractTwoPointTool::mousePreviewRect( const CaptureContext& context) const { QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2); rect.moveCenter(context.mousePos); return rect; } QRect AbstractTwoPointTool::boundingRect() const { if (!isValid()) { return {}; } int offset = m_thickness <= 1 ? 1 : static_cast<int>(round(m_thickness * 0.7 + 0.5)); QRect rect = QRect(std::min(m_points.first.x(), m_points.second.x()) - offset, std::min(m_points.first.y(), m_points.second.y()) - offset, std::abs(m_points.first.x() - m_points.second.x()) + offset * 2, std::abs(m_points.first.y() - m_points.second.y()) + offset * 2); return rect.normalized(); } void AbstractTwoPointTool::drawEnd(const QPoint& p) { Q_UNUSED(p) } void AbstractTwoPointTool::drawMove(const QPoint& p) { m_points.second = p; } void AbstractTwoPointTool::drawMoveWithAdjustment(const QPoint& p) { m_points.second = m_points.first + adjustedVector(p - m_points.first); } void AbstractTwoPointTool::onColorChanged(const QColor& c) { m_color = c; } void AbstractTwoPointTool::onSizeChanged(int size) { m_thickness = size; } void AbstractTwoPointTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { painter.setPen(QPen(context.color, context.toolSize)); painter.drawLine(context.mousePos, context.mousePos); } void AbstractTwoPointTool::drawStart(const CaptureContext& context) { onColorChanged(context.color); m_points.first = context.mousePos; m_points.second = context.mousePos; onSizeChanged(context.toolSize); } QPoint AbstractTwoPointTool::adjustedVector(QPoint v) const { if (m_supportsOrthogonalAdj && m_supportsDiagonalAdj) { int dir = (static_cast<int>(round(atan2(-v.y(), v.x()) / ADJ_UNIT)) + DIRS_NUMBER) % DIRS_NUMBER; if (dir == UNIT::HORIZ_DIR) { v.setY(0); } else if (dir == UNIT::VERT_DIR) { v.setX(0); } else if (dir == UNIT::DIAG1_DIR) { int newX = (v.x() - v.y()) / 2; int newY = -newX; v.setX(newX); v.setY(newY); } else { int newX = (v.x() + v.y()) / 2; int newY = newX; v.setX(newX); v.setY(newY); } } else if (m_supportsDiagonalAdj) { int dir = (static_cast<int>(round((atan2(-v.y(), v.x()) - ADJ_DIAG_UNIT / 2) / ADJ_DIAG_UNIT)) + DIAG_DIRS_NUMBER) % DIAG_DIRS_NUMBER; if (dir == DIAG_UNIT::DIR1) { int newX = (v.x() - v.y()) / 2; int newY = -newX; v.setX(newX); v.setY(newY); } else { int newX = (v.x() + v.y()) / 2; int newY = newX; v.setX(newX); v.setY(newY); } } return v; } void AbstractTwoPointTool::move(const QPoint& pos) { QPoint offset = m_points.second - m_points.first; m_points.first = pos; m_points.second = m_points.first + offset; } const QPoint* AbstractTwoPointTool::pos() { return &m_points.first; }","title":"File abstracttwopointtool.cpp"},{"location":"flameshot/abstracttwopointtool_8h/","text":"File abstracttwopointtool.h # FileList > src > tools > abstracttwopointtool.h Go to the source code of this file. #include \"capturetool.h\" Classes # Type Name class AbstractTwoPointTool","title":"File abstracttwopointtool.h"},{"location":"flameshot/abstracttwopointtool_8h/#file-abstracttwopointtoolh","text":"FileList > src > tools > abstracttwopointtool.h Go to the source code of this file. #include \"capturetool.h\"","title":"File abstracttwopointtool.h"},{"location":"flameshot/abstracttwopointtool_8h/#classes","text":"Type Name class AbstractTwoPointTool","title":"Classes"},{"location":"flameshot/abstracttwopointtool_8h_source/","text":"File abstracttwopointtool.h # File List > src > tools > abstracttwopointtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractTwoPointTool : public CaptureTool { Q_OBJECT public: explicit AbstractTwoPointTool(QObject* parent = nullptr); bool isValid() const override; bool closeOnButtonPressed() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; void move(const QPoint& pos) override; const QPoint* pos() override; int size() const override { return m_thickness; }; const QColor& color() { return m_color; }; const QPair<QPoint, QPoint> points() const { return m_points; }; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void drawMoveWithAdjustment(const QPoint& p) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; virtual void drawStart(const CaptureContext& context) override; private: QPoint adjustedVector(QPoint v) const; protected: void copyParams(const AbstractTwoPointTool* from, AbstractTwoPointTool* to); void setPadding(int padding) { m_padding = padding; }; private: // class members int m_thickness; int m_padding; QColor m_color; QPair<QPoint, QPoint> m_points; protected: // use m_padding to extend the area of the backup bool m_supportsOrthogonalAdj = false; bool m_supportsDiagonalAdj = false; };","title":"File abstracttwopointtool.h"},{"location":"flameshot/abstracttwopointtool_8h_source/#file-abstracttwopointtoolh","text":"File List > src > tools > abstracttwopointtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetool.h\" class AbstractTwoPointTool : public CaptureTool { Q_OBJECT public: explicit AbstractTwoPointTool(QObject* parent = nullptr); bool isValid() const override; bool closeOnButtonPressed() const override; bool isSelectable() const override; bool showMousePreview() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; void move(const QPoint& pos) override; const QPoint* pos() override; int size() const override { return m_thickness; }; const QColor& color() { return m_color; }; const QPair<QPoint, QPoint> points() const { return m_points; }; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; public slots: void drawEnd(const QPoint& p) override; void drawMove(const QPoint& p) override; void drawMoveWithAdjustment(const QPoint& p) override; void onColorChanged(const QColor& c) override; void onSizeChanged(int size) override; virtual void drawStart(const CaptureContext& context) override; private: QPoint adjustedVector(QPoint v) const; protected: void copyParams(const AbstractTwoPointTool* from, AbstractTwoPointTool* to); void setPadding(int padding) { m_padding = padding; }; private: // class members int m_thickness; int m_padding; QColor m_color; QPair<QPoint, QPoint> m_points; protected: // use m_padding to extend the area of the backup bool m_supportsOrthogonalAdj = false; bool m_supportsDiagonalAdj = false; };","title":"File abstracttwopointtool.h"},{"location":"flameshot/dir_d43dfd7d21bc513213a1e5551bc75fb6/","text":"Dir accept # FileList > accept Files # Type Name file accepttool.cpp file accepttool.h","title":"Dir accept"},{"location":"flameshot/dir_d43dfd7d21bc513213a1e5551bc75fb6/#dir-accept","text":"FileList > accept","title":"Dir accept"},{"location":"flameshot/dir_d43dfd7d21bc513213a1e5551bc75fb6/#files","text":"Type Name file accepttool.cpp file accepttool.h","title":"Files"},{"location":"flameshot/accepttool_8cpp/","text":"File accepttool.cpp # FileList > accept > accepttool.cpp Go to the source code of this file. #include \"accepttool.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QPainter> #include <QStyle>","title":"File accepttool.cpp"},{"location":"flameshot/accepttool_8cpp/#file-accepttoolcpp","text":"FileList > accept > accepttool.cpp Go to the source code of this file. #include \"accepttool.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QPainter> #include <QStyle>","title":"File accepttool.cpp"},{"location":"flameshot/accepttool_8cpp_source/","text":"File accepttool.cpp # File List > accept > accepttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"accepttool.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QPainter> #include <QStyle> #if defined(Q_OS_MACOS) #include \"src/widgets/capture/capturewidget.h\" #include <QWidget> #endif AcceptTool::AcceptTool(QObject* parent) : AbstractActionTool(parent) {} bool AcceptTool::closeOnButtonPressed() const { return true; } QIcon AcceptTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"accept.svg\"); } QString AcceptTool::name() const { return tr(\"Accept\"); } CaptureTool::Type AcceptTool::type() const { return CaptureTool::TYPE_ACCEPT; } QString AcceptTool::description() const { return tr(\"Accept the capture\"); } CaptureTool* AcceptTool::copy(QObject* parent) { return new AcceptTool(parent); } void AcceptTool::pressed(CaptureContext& context) { emit requestAction(REQ_CAPTURE_DONE_OK); if (context.request.tasks() & CaptureRequest::PIN) { QRect geometry = context.selection; geometry.moveTopLeft(geometry.topLeft() + context.widgetOffset); context.request.addTask(CaptureRequest::PIN); } emit requestAction(REQ_CLOSE_GUI); }","title":"File accepttool.cpp"},{"location":"flameshot/accepttool_8cpp_source/#file-accepttoolcpp","text":"File List > accept > accepttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"accepttool.h\" #include \"src/utils/screenshotsaver.h\" #include <QApplication> #include <QPainter> #include <QStyle> #if defined(Q_OS_MACOS) #include \"src/widgets/capture/capturewidget.h\" #include <QWidget> #endif AcceptTool::AcceptTool(QObject* parent) : AbstractActionTool(parent) {} bool AcceptTool::closeOnButtonPressed() const { return true; } QIcon AcceptTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"accept.svg\"); } QString AcceptTool::name() const { return tr(\"Accept\"); } CaptureTool::Type AcceptTool::type() const { return CaptureTool::TYPE_ACCEPT; } QString AcceptTool::description() const { return tr(\"Accept the capture\"); } CaptureTool* AcceptTool::copy(QObject* parent) { return new AcceptTool(parent); } void AcceptTool::pressed(CaptureContext& context) { emit requestAction(REQ_CAPTURE_DONE_OK); if (context.request.tasks() & CaptureRequest::PIN) { QRect geometry = context.selection; geometry.moveTopLeft(geometry.topLeft() + context.widgetOffset); context.request.addTask(CaptureRequest::PIN); } emit requestAction(REQ_CLOSE_GUI); }","title":"File accepttool.cpp"},{"location":"flameshot/accepttool_8h/","text":"File accepttool.h # FileList > accept > accepttool.h Go to the source code of this file. #include \"abstractactiontool.h\" Classes # Type Name class AcceptTool","title":"File accepttool.h"},{"location":"flameshot/accepttool_8h/#file-accepttoolh","text":"FileList > accept > accepttool.h Go to the source code of this file. #include \"abstractactiontool.h\"","title":"File accepttool.h"},{"location":"flameshot/accepttool_8h/#classes","text":"Type Name class AcceptTool","title":"Classes"},{"location":"flameshot/accepttool_8h_source/","text":"File accepttool.h # File List > accept > accepttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"abstractactiontool.h\" class AcceptTool : public AbstractActionTool { Q_OBJECT public: explicit AcceptTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File accepttool.h"},{"location":"flameshot/accepttool_8h_source/#file-accepttoolh","text":"File List > accept > accepttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"abstractactiontool.h\" class AcceptTool : public AbstractActionTool { Q_OBJECT public: explicit AcceptTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File accepttool.h"},{"location":"flameshot/dir_3269000d382afc6cc2ac04d1522956b4/","text":"Dir arrow # FileList > arrow Files # Type Name file arrowtool.cpp file arrowtool.h","title":"Dir arrow"},{"location":"flameshot/dir_3269000d382afc6cc2ac04d1522956b4/#dir-arrow","text":"FileList > arrow","title":"Dir arrow"},{"location":"flameshot/dir_3269000d382afc6cc2ac04d1522956b4/#files","text":"Type Name file arrowtool.cpp file arrowtool.h","title":"Files"},{"location":"flameshot/arrowtool_8cpp/","text":"File arrowtool.cpp # FileList > arrow > arrowtool.cpp Go to the source code of this file. #include \"arrowtool.h\" #include <cmath>","title":"File arrowtool.cpp"},{"location":"flameshot/arrowtool_8cpp/#file-arrowtoolcpp","text":"FileList > arrow > arrowtool.cpp Go to the source code of this file. #include \"arrowtool.h\" #include <cmath>","title":"File arrowtool.cpp"},{"location":"flameshot/arrowtool_8cpp_source/","text":"File arrowtool.cpp # File List > arrow > arrowtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"arrowtool.h\" #include <cmath> namespace { const int ArrowWidth = 10; const int ArrowHeight = 18; QPainterPath getArrowHead(QPoint p1, QPoint p2, const int thickness) { QLineF base(p1, p2); // Create the vector for the position of the base of the arrowhead QLineF temp(QPoint(0, 0), p2 - p1); int val = ArrowHeight + thickness * 4; if (base.length() < (val - thickness * 2)) { val = static_cast<int>(base.length() + thickness * 2); } temp.setLength(base.length() + thickness * 2 - val); // Move across the line up to the head QPointF bottomTranslation(temp.p2()); // Rotate base of the arrowhead base.setLength(ArrowWidth + thickness * 2); base.setAngle(base.angle() + 90); // Move to the correct point QPointF temp2 = p1 - base.p2(); // Center it QPointF centerTranslation((temp2.x() / 2), (temp2.y() / 2)); base.translate(bottomTranslation); base.translate(centerTranslation); QPainterPath path; path.moveTo(p2); path.lineTo(base.p1()); path.lineTo(base.p2()); path.lineTo(p2); return path; } // gets a shorter line to prevent overlap in the point of the arrow QLine getShorterLine(QPoint p1, QPoint p2, const int thickness) { QLineF l(p1, p2); int val = ArrowHeight + thickness * 4; if (l.length() < (val - thickness * 2)) { // here should be 0, but then we lose \"angle\", so this is hack, but // looks not very bad val = thickness / 4; l.setLength(val); } else { l.setLength(l.length() + thickness * 2 - val); } return l.toLine(); } } // unnamed namespace ArrowTool::ArrowTool(QObject* parent) : AbstractTwoPointTool(parent) { setPadding(ArrowWidth / 2); m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon ArrowTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"arrow-bottom-left.svg\"); } QString ArrowTool::name() const { return tr(\"Arrow\"); } CaptureTool::Type ArrowTool::type() const { return CaptureTool::TYPE_ARROW; } QString ArrowTool::description() const { return tr(\"Set the Arrow as the paint tool\"); } QRect ArrowTool::boundingRect() const { if (!isValid()) { return {}; } int offset = size() <= 1 ? 1 : static_cast<int>(round(size() / 2 + 0.5)); // get min and max arrow pos int min_x = points().first.x(); int min_y = points().first.y(); int max_x = points().first.x(); int max_y = points().first.y(); for (int i = 0; i < m_arrowPath.elementCount(); i++) { QPointF pt = m_arrowPath.elementAt(i); if (static_cast<int>(pt.x()) < min_x) { min_x = static_cast<int>(pt.x()); } if (static_cast<int>(pt.y()) < min_y) { min_y = static_cast<int>(pt.y()); } if (static_cast<int>(pt.x()) > max_x) { max_x = static_cast<int>(pt.x()); } if (static_cast<int>(pt.y()) > max_y) { max_y = static_cast<int>(pt.y()); } } // get min and max line pos int line_pos_min_x = std::min(std::min(points().first.x(), points().second.x()), min_x); int line_pos_min_y = std::min(std::min(points().first.y(), points().second.y()), min_y); int line_pos_max_x = std::max(std::max(points().first.x(), points().second.x()), max_x); int line_pos_max_y = std::max(std::max(points().first.y(), points().second.y()), max_y); QRect rect = QRect(line_pos_min_x - offset, line_pos_min_y - offset, line_pos_max_x - line_pos_min_x + offset * 2, line_pos_max_y - line_pos_min_y + offset * 2); return rect.normalized(); } CaptureTool* ArrowTool::copy(QObject* parent) { auto* tool = new ArrowTool(parent); copyParams(this, tool); return tool; } void ArrowTool::copyParams(const ArrowTool* from, ArrowTool* to) { AbstractTwoPointTool::copyParams(from, to); to->m_arrowPath = this->m_arrowPath; } void ArrowTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawLine(getShorterLine(points().first, points().second, size())); m_arrowPath = getArrowHead(points().first, points().second, size()); painter.fillPath(m_arrowPath, QBrush(color())); } void ArrowTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File arrowtool.cpp"},{"location":"flameshot/arrowtool_8cpp_source/#file-arrowtoolcpp","text":"File List > arrow > arrowtool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"arrowtool.h\" #include <cmath> namespace { const int ArrowWidth = 10; const int ArrowHeight = 18; QPainterPath getArrowHead(QPoint p1, QPoint p2, const int thickness) { QLineF base(p1, p2); // Create the vector for the position of the base of the arrowhead QLineF temp(QPoint(0, 0), p2 - p1); int val = ArrowHeight + thickness * 4; if (base.length() < (val - thickness * 2)) { val = static_cast<int>(base.length() + thickness * 2); } temp.setLength(base.length() + thickness * 2 - val); // Move across the line up to the head QPointF bottomTranslation(temp.p2()); // Rotate base of the arrowhead base.setLength(ArrowWidth + thickness * 2); base.setAngle(base.angle() + 90); // Move to the correct point QPointF temp2 = p1 - base.p2(); // Center it QPointF centerTranslation((temp2.x() / 2), (temp2.y() / 2)); base.translate(bottomTranslation); base.translate(centerTranslation); QPainterPath path; path.moveTo(p2); path.lineTo(base.p1()); path.lineTo(base.p2()); path.lineTo(p2); return path; } // gets a shorter line to prevent overlap in the point of the arrow QLine getShorterLine(QPoint p1, QPoint p2, const int thickness) { QLineF l(p1, p2); int val = ArrowHeight + thickness * 4; if (l.length() < (val - thickness * 2)) { // here should be 0, but then we lose \"angle\", so this is hack, but // looks not very bad val = thickness / 4; l.setLength(val); } else { l.setLength(l.length() + thickness * 2 - val); } return l.toLine(); } } // unnamed namespace ArrowTool::ArrowTool(QObject* parent) : AbstractTwoPointTool(parent) { setPadding(ArrowWidth / 2); m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon ArrowTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"arrow-bottom-left.svg\"); } QString ArrowTool::name() const { return tr(\"Arrow\"); } CaptureTool::Type ArrowTool::type() const { return CaptureTool::TYPE_ARROW; } QString ArrowTool::description() const { return tr(\"Set the Arrow as the paint tool\"); } QRect ArrowTool::boundingRect() const { if (!isValid()) { return {}; } int offset = size() <= 1 ? 1 : static_cast<int>(round(size() / 2 + 0.5)); // get min and max arrow pos int min_x = points().first.x(); int min_y = points().first.y(); int max_x = points().first.x(); int max_y = points().first.y(); for (int i = 0; i < m_arrowPath.elementCount(); i++) { QPointF pt = m_arrowPath.elementAt(i); if (static_cast<int>(pt.x()) < min_x) { min_x = static_cast<int>(pt.x()); } if (static_cast<int>(pt.y()) < min_y) { min_y = static_cast<int>(pt.y()); } if (static_cast<int>(pt.x()) > max_x) { max_x = static_cast<int>(pt.x()); } if (static_cast<int>(pt.y()) > max_y) { max_y = static_cast<int>(pt.y()); } } // get min and max line pos int line_pos_min_x = std::min(std::min(points().first.x(), points().second.x()), min_x); int line_pos_min_y = std::min(std::min(points().first.y(), points().second.y()), min_y); int line_pos_max_x = std::max(std::max(points().first.x(), points().second.x()), max_x); int line_pos_max_y = std::max(std::max(points().first.y(), points().second.y()), max_y); QRect rect = QRect(line_pos_min_x - offset, line_pos_min_y - offset, line_pos_max_x - line_pos_min_x + offset * 2, line_pos_max_y - line_pos_min_y + offset * 2); return rect.normalized(); } CaptureTool* ArrowTool::copy(QObject* parent) { auto* tool = new ArrowTool(parent); copyParams(this, tool); return tool; } void ArrowTool::copyParams(const ArrowTool* from, ArrowTool* to) { AbstractTwoPointTool::copyParams(from, to); to->m_arrowPath = this->m_arrowPath; } void ArrowTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawLine(getShorterLine(points().first, points().second, size())); m_arrowPath = getArrowHead(points().first, points().second, size()); painter.fillPath(m_arrowPath, QBrush(color())); } void ArrowTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File arrowtool.cpp"},{"location":"flameshot/arrowtool_8h/","text":"File arrowtool.h # FileList > arrow > arrowtool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" #include <QPainter> #include <QPainterPath> Classes # Type Name class ArrowTool","title":"File arrowtool.h"},{"location":"flameshot/arrowtool_8h/#file-arrowtoolh","text":"FileList > arrow > arrowtool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" #include <QPainter> #include <QPainterPath>","title":"File arrowtool.h"},{"location":"flameshot/arrowtool_8h/#classes","text":"Type Name class ArrowTool","title":"Classes"},{"location":"flameshot/arrowtool_8h_source/","text":"File arrowtool.h # File List > arrow > arrowtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" #include <QPainter> #include <QPainterPath> class ArrowTool : public AbstractTwoPointTool { Q_OBJECT public: explicit ArrowTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: void copyParams(const ArrowTool* from, ArrowTool* to); CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPainterPath m_arrowPath; };","title":"File arrowtool.h"},{"location":"flameshot/arrowtool_8h_source/#file-arrowtoolh","text":"File List > arrow > arrowtool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" #include <QPainter> #include <QPainterPath> class ArrowTool : public AbstractTwoPointTool { Q_OBJECT public: explicit ArrowTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: void copyParams(const ArrowTool* from, ArrowTool* to); CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPainterPath m_arrowPath; };","title":"File arrowtool.h"},{"location":"flameshot/capturecontext_8cpp/","text":"File capturecontext.cpp # FileList > src > tools > capturecontext.cpp Go to the source code of this file. #include \"capturecontext.h\" #include \"capturerequest.h\" #include \"flameshot.h\"","title":"File capturecontext.cpp"},{"location":"flameshot/capturecontext_8cpp/#file-capturecontextcpp","text":"FileList > src > tools > capturecontext.cpp Go to the source code of this file. #include \"capturecontext.h\" #include \"capturerequest.h\" #include \"flameshot.h\"","title":"File capturecontext.cpp"},{"location":"flameshot/capturecontext_8cpp_source/","text":"File capturecontext.cpp # File List > src > tools > capturecontext.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturecontext.h\" #include \"capturerequest.h\" #include \"flameshot.h\" // TODO rename QPixmap CaptureContext::selectedScreenshotArea() const { if (selection.isNull()) { return screenshot; } else { return screenshot.copy(selection); } }","title":"File capturecontext.cpp"},{"location":"flameshot/capturecontext_8cpp_source/#file-capturecontextcpp","text":"File List > src > tools > capturecontext.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturecontext.h\" #include \"capturerequest.h\" #include \"flameshot.h\" // TODO rename QPixmap CaptureContext::selectedScreenshotArea() const { if (selection.isNull()) { return screenshot; } else { return screenshot.copy(selection); } }","title":"File capturecontext.cpp"},{"location":"flameshot/capturecontext_8h/","text":"File capturecontext.h # FileList > src > tools > capturecontext.h Go to the source code of this file. #include \"capturerequest.h\" #include <QPainter> #include <QPixmap> #include <QPoint> #include <QRect> Classes # Type Name struct CaptureContext","title":"File capturecontext.h"},{"location":"flameshot/capturecontext_8h/#file-capturecontexth","text":"FileList > src > tools > capturecontext.h Go to the source code of this file. #include \"capturerequest.h\" #include <QPainter> #include <QPixmap> #include <QPoint> #include <QRect>","title":"File capturecontext.h"},{"location":"flameshot/capturecontext_8h/#classes","text":"Type Name struct CaptureContext","title":"Classes"},{"location":"flameshot/capturecontext_8h_source/","text":"File capturecontext.h # File List > src > tools > capturecontext.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturerequest.h\" #include <QPainter> #include <QPixmap> #include <QPoint> #include <QRect> struct CaptureContext { // screenshot with modifications QPixmap screenshot; // unmodified screenshot QPixmap origScreenshot; // Selection area QRect selection; // Selected tool color QColor color; // Path where the content has to be saved QString savePath; // Offset of the capture widget based on the system's screen (top-left) QPoint widgetOffset; // Mouse position inside the widget QPoint mousePos; // Size of the active tool int toolSize; // Current circle count int circleCount; // Mode of the capture widget bool fullscreen; CaptureRequest request = CaptureRequest::GRAPHICAL_MODE; QPixmap selectedScreenshotArea() const; };","title":"File capturecontext.h"},{"location":"flameshot/capturecontext_8h_source/#file-capturecontexth","text":"File List > src > tools > capturecontext.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturerequest.h\" #include <QPainter> #include <QPixmap> #include <QPoint> #include <QRect> struct CaptureContext { // screenshot with modifications QPixmap screenshot; // unmodified screenshot QPixmap origScreenshot; // Selection area QRect selection; // Selected tool color QColor color; // Path where the content has to be saved QString savePath; // Offset of the capture widget based on the system's screen (top-left) QPoint widgetOffset; // Mouse position inside the widget QPoint mousePos; // Size of the active tool int toolSize; // Current circle count int circleCount; // Mode of the capture widget bool fullscreen; CaptureRequest request = CaptureRequest::GRAPHICAL_MODE; QPixmap selectedScreenshotArea() const; };","title":"File capturecontext.h"},{"location":"flameshot/dir_98f2a39c4a3830cd05b8a97635f25cec/","text":"Dir circle # FileList > circle Files # Type Name file circletool.cpp file circletool.h","title":"Dir circle"},{"location":"flameshot/dir_98f2a39c4a3830cd05b8a97635f25cec/#dir-circle","text":"FileList > circle","title":"Dir circle"},{"location":"flameshot/dir_98f2a39c4a3830cd05b8a97635f25cec/#files","text":"Type Name file circletool.cpp file circletool.h","title":"Files"},{"location":"flameshot/circletool_8cpp/","text":"File circletool.cpp # FileList > circle > circletool.cpp Go to the source code of this file. #include \"circletool.h\" #include <QPainter>","title":"File circletool.cpp"},{"location":"flameshot/circletool_8cpp/#file-circletoolcpp","text":"FileList > circle > circletool.cpp Go to the source code of this file. #include \"circletool.h\" #include <QPainter>","title":"File circletool.cpp"},{"location":"flameshot/circletool_8cpp_source/","text":"File circletool.cpp # File List > circle > circletool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"circletool.h\" #include <QPainter> CircleTool::CircleTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } QIcon CircleTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"circle-outline.svg\"); } QString CircleTool::name() const { return tr(\"Circle\"); } CaptureTool::Type CircleTool::type() const { return CaptureTool::TYPE_CIRCLE; } QString CircleTool::description() const { return tr(\"Set the Circle as the paint tool\"); } CaptureTool* CircleTool::copy(QObject* parent) { auto* tool = new CircleTool(parent); copyParams(this, tool); return tool; } void CircleTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawEllipse(QRect(points().first, points().second)); } void CircleTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File circletool.cpp"},{"location":"flameshot/circletool_8cpp_source/#file-circletoolcpp","text":"File List > circle > circletool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"circletool.h\" #include <QPainter> CircleTool::CircleTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } QIcon CircleTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"circle-outline.svg\"); } QString CircleTool::name() const { return tr(\"Circle\"); } CaptureTool::Type CircleTool::type() const { return CaptureTool::TYPE_CIRCLE; } QString CircleTool::description() const { return tr(\"Set the Circle as the paint tool\"); } CaptureTool* CircleTool::copy(QObject* parent) { auto* tool = new CircleTool(parent); copyParams(this, tool); return tool; } void CircleTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawEllipse(QRect(points().first, points().second)); } void CircleTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File circletool.cpp"},{"location":"flameshot/circletool_8h/","text":"File circletool.h # FileList > circle > circletool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class CircleTool","title":"File circletool.h"},{"location":"flameshot/circletool_8h/#file-circletoolh","text":"FileList > circle > circletool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File circletool.h"},{"location":"flameshot/circletool_8h/#classes","text":"Type Name class CircleTool","title":"Classes"},{"location":"flameshot/circletool_8h_source/","text":"File circletool.h # File List > circle > circletool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class CircleTool : public AbstractTwoPointTool { Q_OBJECT public: explicit CircleTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File circletool.h"},{"location":"flameshot/circletool_8h_source/#file-circletoolh","text":"File List > circle > circletool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class CircleTool : public AbstractTwoPointTool { Q_OBJECT public: explicit CircleTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File circletool.h"},{"location":"flameshot/dir_c88b4d2ebcdc55a35960885b013042e2/","text":"Dir circlecount # FileList > circlecount Files # Type Name file circlecounttool.cpp file circlecounttool.h","title":"Dir circlecount"},{"location":"flameshot/dir_c88b4d2ebcdc55a35960885b013042e2/#dir-circlecount","text":"FileList > circlecount","title":"Dir circlecount"},{"location":"flameshot/dir_c88b4d2ebcdc55a35960885b013042e2/#files","text":"Type Name file circlecounttool.cpp file circlecounttool.h","title":"Files"},{"location":"flameshot/circlecounttool_8cpp/","text":"File circlecounttool.cpp # FileList > circlecount > circlecounttool.cpp Go to the source code of this file. #include \"circlecounttool.h\" #include \"colorutils.h\" #include <QPainter> #include <QPainterPath> Macros # Type Name define PADDING_VALUE 2 define THICKNESS_OFFSET 15 Macro Definition Documentation # define PADDING_VALUE # #define PADDING_VALUE 2 define THICKNESS_OFFSET # #define THICKNESS_OFFSET 15","title":"File circlecounttool.cpp"},{"location":"flameshot/circlecounttool_8cpp/#file-circlecounttoolcpp","text":"FileList > circlecount > circlecounttool.cpp Go to the source code of this file. #include \"circlecounttool.h\" #include \"colorutils.h\" #include <QPainter> #include <QPainterPath>","title":"File circlecounttool.cpp"},{"location":"flameshot/circlecounttool_8cpp/#macros","text":"Type Name define PADDING_VALUE 2 define THICKNESS_OFFSET 15","title":"Macros"},{"location":"flameshot/circlecounttool_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/circlecounttool_8cpp/#define-padding_value","text":"#define PADDING_VALUE 2","title":"define PADDING_VALUE"},{"location":"flameshot/circlecounttool_8cpp/#define-thickness_offset","text":"#define THICKNESS_OFFSET 15","title":"define THICKNESS_OFFSET"},{"location":"flameshot/circlecounttool_8cpp_source/","text":"File circlecounttool.cpp # File List > circlecount > circlecounttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"circlecounttool.h\" #include \"colorutils.h\" #include <QPainter> #include <QPainterPath> namespace { #define PADDING_VALUE 2 #define THICKNESS_OFFSET 15 } CircleCountTool::CircleCountTool(QObject* parent) : AbstractTwoPointTool(parent) , m_valid(false) {} QIcon CircleCountTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"circlecount-outline.svg\"); } QString CircleCountTool::info() { m_tempString = QString(\"%1 - %2\").arg(name()).arg(count()); return m_tempString; } bool CircleCountTool::isValid() const { return m_valid; } QRect CircleCountTool::mousePreviewRect(const CaptureContext& context) const { int width = (context.toolSize + THICKNESS_OFFSET) * 2; QRect rect(0, 0, width, width); rect.moveCenter(context.mousePos); return rect; } QRect CircleCountTool::boundingRect() const { if (!isValid()) { return {}; } int bubble_size = size() + THICKNESS_OFFSET + PADDING_VALUE; int line_pos_min_x = std::min(points().first.x() - bubble_size, points().second.x()); int line_pos_min_y = std::min(points().first.y() - bubble_size, points().second.y()); int line_pos_max_x = std::max(points().first.x() + bubble_size, points().second.x()); int line_pos_max_y = std::max(points().first.y() + bubble_size, points().second.y()); return { line_pos_min_x, line_pos_min_y, line_pos_max_x - line_pos_min_x, line_pos_max_y - line_pos_min_y }; } QString CircleCountTool::name() const { return tr(\"Circle Counter\"); } CaptureTool::Type CircleCountTool::type() const { return CaptureTool::TYPE_CIRCLECOUNT; } void CircleCountTool::copyParams(const CircleCountTool* from, CircleCountTool* to) { AbstractTwoPointTool::copyParams(from, to); to->setCount(from->count()); to->m_valid = from->m_valid; } QString CircleCountTool::description() const { return tr(\"Add an autoincrementing counter bubble\"); } CaptureTool* CircleCountTool::copy(QObject* parent) { auto* tool = new CircleCountTool(parent); copyParams(this, tool); return tool; } void CircleCountTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) // save current pen, brush, and font state auto orig_pen = painter.pen(); auto orig_brush = painter.brush(); auto orig_font = painter.font(); QColor contrastColor = ColorUtils::colorIsDark(color()) ? Qt::white : Qt::black; QColor antiContrastColor = ColorUtils::colorIsDark(color()) ? Qt::black : Qt::white; int bubble_size = size() + THICKNESS_OFFSET; QLineF line(points().first, points().second); // if the mouse is outside of the bubble, draw the pointer if (line.length() > bubble_size) { painter.setPen(QPen(color(), 0)); painter.setBrush(color()); int middleX = points().first.x(); int middleY = points().first.y(); QLineF normal = line.normalVector(); normal.setLength(bubble_size); QPoint p1 = normal.p2().toPoint(); QPoint p2(middleX - (p1.x() - middleX), middleY - (p1.y() - middleY)); QPainterPath path; path.moveTo(points().first); path.lineTo(p1); path.lineTo(points().second); path.lineTo(p2); path.lineTo(points().first); painter.drawPath(path); } painter.setPen(contrastColor); painter.setBrush(antiContrastColor); painter.drawEllipse( points().first, bubble_size + PADDING_VALUE, bubble_size + PADDING_VALUE); painter.setBrush(color()); painter.drawEllipse(points().first, bubble_size, bubble_size); QRect textRect = QRect(points().first.x() - bubble_size / 2, points().first.y() - bubble_size / 2, bubble_size, bubble_size); auto new_font = orig_font; auto fontSize = bubble_size; new_font.setPixelSize(fontSize); new_font.setBold(true); painter.setFont(new_font); // Draw bounding circle QRect bRect = painter.boundingRect(textRect, Qt::AlignCenter, QString::number(count())); // Calculate font size while (bRect.width() > textRect.width()) { fontSize--; if (fontSize == 0) { break; } new_font.setPixelSize(fontSize); painter.setFont(new_font); bRect = painter.boundingRect( textRect, Qt::AlignCenter, QString::number(count())); } // Draw text painter.setPen(contrastColor); painter.drawText(textRect, Qt::AlignCenter, QString::number(count())); // restore original font, brush, and pen painter.setFont(orig_font); painter.setBrush(orig_brush); painter.setPen(orig_pen); } void CircleCountTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { onSizeChanged(context.toolSize + PADDING_VALUE); // Thickness for pen is *2 to range from radius to diameter to match the // ellipse draw function auto orig_pen = painter.pen(); auto orig_opacity = painter.opacity(); painter.setOpacity(0.35); painter.setPen(QPen(context.color, (size() + THICKNESS_OFFSET) * 2, Qt::SolidLine, Qt::RoundCap)); painter.drawLine(context.mousePos, { context.mousePos.x() + 1, context.mousePos.y() + 1 }); painter.setOpacity(orig_opacity); painter.setPen(orig_pen); } void CircleCountTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); m_valid = true; } void CircleCountTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File circlecounttool.cpp"},{"location":"flameshot/circlecounttool_8cpp_source/#file-circlecounttoolcpp","text":"File List > circlecount > circlecounttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"circlecounttool.h\" #include \"colorutils.h\" #include <QPainter> #include <QPainterPath> namespace { #define PADDING_VALUE 2 #define THICKNESS_OFFSET 15 } CircleCountTool::CircleCountTool(QObject* parent) : AbstractTwoPointTool(parent) , m_valid(false) {} QIcon CircleCountTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"circlecount-outline.svg\"); } QString CircleCountTool::info() { m_tempString = QString(\"%1 - %2\").arg(name()).arg(count()); return m_tempString; } bool CircleCountTool::isValid() const { return m_valid; } QRect CircleCountTool::mousePreviewRect(const CaptureContext& context) const { int width = (context.toolSize + THICKNESS_OFFSET) * 2; QRect rect(0, 0, width, width); rect.moveCenter(context.mousePos); return rect; } QRect CircleCountTool::boundingRect() const { if (!isValid()) { return {}; } int bubble_size = size() + THICKNESS_OFFSET + PADDING_VALUE; int line_pos_min_x = std::min(points().first.x() - bubble_size, points().second.x()); int line_pos_min_y = std::min(points().first.y() - bubble_size, points().second.y()); int line_pos_max_x = std::max(points().first.x() + bubble_size, points().second.x()); int line_pos_max_y = std::max(points().first.y() + bubble_size, points().second.y()); return { line_pos_min_x, line_pos_min_y, line_pos_max_x - line_pos_min_x, line_pos_max_y - line_pos_min_y }; } QString CircleCountTool::name() const { return tr(\"Circle Counter\"); } CaptureTool::Type CircleCountTool::type() const { return CaptureTool::TYPE_CIRCLECOUNT; } void CircleCountTool::copyParams(const CircleCountTool* from, CircleCountTool* to) { AbstractTwoPointTool::copyParams(from, to); to->setCount(from->count()); to->m_valid = from->m_valid; } QString CircleCountTool::description() const { return tr(\"Add an autoincrementing counter bubble\"); } CaptureTool* CircleCountTool::copy(QObject* parent) { auto* tool = new CircleCountTool(parent); copyParams(this, tool); return tool; } void CircleCountTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) // save current pen, brush, and font state auto orig_pen = painter.pen(); auto orig_brush = painter.brush(); auto orig_font = painter.font(); QColor contrastColor = ColorUtils::colorIsDark(color()) ? Qt::white : Qt::black; QColor antiContrastColor = ColorUtils::colorIsDark(color()) ? Qt::black : Qt::white; int bubble_size = size() + THICKNESS_OFFSET; QLineF line(points().first, points().second); // if the mouse is outside of the bubble, draw the pointer if (line.length() > bubble_size) { painter.setPen(QPen(color(), 0)); painter.setBrush(color()); int middleX = points().first.x(); int middleY = points().first.y(); QLineF normal = line.normalVector(); normal.setLength(bubble_size); QPoint p1 = normal.p2().toPoint(); QPoint p2(middleX - (p1.x() - middleX), middleY - (p1.y() - middleY)); QPainterPath path; path.moveTo(points().first); path.lineTo(p1); path.lineTo(points().second); path.lineTo(p2); path.lineTo(points().first); painter.drawPath(path); } painter.setPen(contrastColor); painter.setBrush(antiContrastColor); painter.drawEllipse( points().first, bubble_size + PADDING_VALUE, bubble_size + PADDING_VALUE); painter.setBrush(color()); painter.drawEllipse(points().first, bubble_size, bubble_size); QRect textRect = QRect(points().first.x() - bubble_size / 2, points().first.y() - bubble_size / 2, bubble_size, bubble_size); auto new_font = orig_font; auto fontSize = bubble_size; new_font.setPixelSize(fontSize); new_font.setBold(true); painter.setFont(new_font); // Draw bounding circle QRect bRect = painter.boundingRect(textRect, Qt::AlignCenter, QString::number(count())); // Calculate font size while (bRect.width() > textRect.width()) { fontSize--; if (fontSize == 0) { break; } new_font.setPixelSize(fontSize); painter.setFont(new_font); bRect = painter.boundingRect( textRect, Qt::AlignCenter, QString::number(count())); } // Draw text painter.setPen(contrastColor); painter.drawText(textRect, Qt::AlignCenter, QString::number(count())); // restore original font, brush, and pen painter.setFont(orig_font); painter.setBrush(orig_brush); painter.setPen(orig_pen); } void CircleCountTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { onSizeChanged(context.toolSize + PADDING_VALUE); // Thickness for pen is *2 to range from radius to diameter to match the // ellipse draw function auto orig_pen = painter.pen(); auto orig_opacity = painter.opacity(); painter.setOpacity(0.35); painter.setPen(QPen(context.color, (size() + THICKNESS_OFFSET) * 2, Qt::SolidLine, Qt::RoundCap)); painter.drawLine(context.mousePos, { context.mousePos.x() + 1, context.mousePos.y() + 1 }); painter.setOpacity(orig_opacity); painter.setPen(orig_pen); } void CircleCountTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); m_valid = true; } void CircleCountTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File circlecounttool.cpp"},{"location":"flameshot/circlecounttool_8h/","text":"File circlecounttool.h # FileList > circlecount > circlecounttool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class CircleCountTool","title":"File circlecounttool.h"},{"location":"flameshot/circlecounttool_8h/#file-circlecounttoolh","text":"FileList > circlecount > circlecounttool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File circlecounttool.h"},{"location":"flameshot/circlecounttool_8h/#classes","text":"Type Name class CircleCountTool","title":"Classes"},{"location":"flameshot/circlecounttool_8h_source/","text":"File circlecounttool.h # File List > circlecount > circlecounttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class CircleCountTool : public AbstractTwoPointTool { Q_OBJECT public: explicit CircleCountTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QString info() override; bool isValid() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; void copyParams(const CircleCountTool* from, CircleCountTool* to); public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; private: QString m_tempString; bool m_valid; };","title":"File circlecounttool.h"},{"location":"flameshot/circlecounttool_8h_source/#file-circlecounttoolh","text":"File List > circlecount > circlecounttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class CircleCountTool : public AbstractTwoPointTool { Q_OBJECT public: explicit CircleCountTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QString info() override; bool isValid() const override; QRect mousePreviewRect(const CaptureContext& context) const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; void copyParams(const CircleCountTool* from, CircleCountTool* to); public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; private: QString m_tempString; bool m_valid; };","title":"File circlecounttool.h"},{"location":"flameshot/dir_ed36feeccfea7f6658339eb729ac3194/","text":"Dir copy # FileList > copy Files # Type Name file copytool.cpp file copytool.h","title":"Dir copy"},{"location":"flameshot/dir_ed36feeccfea7f6658339eb729ac3194/#dir-copy","text":"FileList > copy","title":"Dir copy"},{"location":"flameshot/dir_ed36feeccfea7f6658339eb729ac3194/#files","text":"Type Name file copytool.cpp file copytool.h","title":"Files"},{"location":"flameshot/copytool_8cpp/","text":"File copytool.cpp # FileList > copy > copytool.cpp Go to the source code of this file. #include \"copytool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter>","title":"File copytool.cpp"},{"location":"flameshot/copytool_8cpp/#file-copytoolcpp","text":"FileList > copy > copytool.cpp Go to the source code of this file. #include \"copytool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter>","title":"File copytool.cpp"},{"location":"flameshot/copytool_8cpp_source/","text":"File copytool.cpp # File List > copy > copytool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"copytool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter> CopyTool::CopyTool(QObject* parent) : AbstractActionTool(parent) {} bool CopyTool::closeOnButtonPressed() const { return true; } QIcon CopyTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"content-copy.svg\"); } QString CopyTool::name() const { return tr(\"Copy\"); } CaptureTool::Type CopyTool::type() const { return CaptureTool::TYPE_COPY; } QString CopyTool::description() const { return tr(\"Copy selection to clipboard\"); } CaptureTool* CopyTool::copy(QObject* parent) { return new CopyTool(parent); } void CopyTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); context.request.addTask(CaptureRequest::COPY); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_CLOSE_GUI); }","title":"File copytool.cpp"},{"location":"flameshot/copytool_8cpp_source/#file-copytoolcpp","text":"File List > copy > copytool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"copytool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter> CopyTool::CopyTool(QObject* parent) : AbstractActionTool(parent) {} bool CopyTool::closeOnButtonPressed() const { return true; } QIcon CopyTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"content-copy.svg\"); } QString CopyTool::name() const { return tr(\"Copy\"); } CaptureTool::Type CopyTool::type() const { return CaptureTool::TYPE_COPY; } QString CopyTool::description() const { return tr(\"Copy selection to clipboard\"); } CaptureTool* CopyTool::copy(QObject* parent) { return new CopyTool(parent); } void CopyTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); context.request.addTask(CaptureRequest::COPY); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_CLOSE_GUI); }","title":"File copytool.cpp"},{"location":"flameshot/copytool_8h/","text":"File copytool.h # FileList > copy > copytool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class CopyTool","title":"File copytool.h"},{"location":"flameshot/copytool_8h/#file-copytoolh","text":"FileList > copy > copytool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File copytool.h"},{"location":"flameshot/copytool_8h/#classes","text":"Type Name class CopyTool","title":"Classes"},{"location":"flameshot/copytool_8h_source/","text":"File copytool.h # File List > copy > copytool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class CopyTool : public AbstractActionTool { Q_OBJECT public: explicit CopyTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File copytool.h"},{"location":"flameshot/copytool_8h_source/#file-copytoolh","text":"File List > copy > copytool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class CopyTool : public AbstractActionTool { Q_OBJECT public: explicit CopyTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File copytool.h"},{"location":"flameshot/dir_6080df60932419c2e0eb96a6bf9cd630/","text":"Dir exit # FileList > exit Files # Type Name file exittool.cpp file exittool.h","title":"Dir exit"},{"location":"flameshot/dir_6080df60932419c2e0eb96a6bf9cd630/#dir-exit","text":"FileList > exit","title":"Dir exit"},{"location":"flameshot/dir_6080df60932419c2e0eb96a6bf9cd630/#files","text":"Type Name file exittool.cpp file exittool.h","title":"Files"},{"location":"flameshot/exittool_8cpp/","text":"File exittool.cpp # FileList > exit > exittool.cpp Go to the source code of this file. #include \"exittool.h\" #include <QPainter>","title":"File exittool.cpp"},{"location":"flameshot/exittool_8cpp/#file-exittoolcpp","text":"FileList > exit > exittool.cpp Go to the source code of this file. #include \"exittool.h\" #include <QPainter>","title":"File exittool.cpp"},{"location":"flameshot/exittool_8cpp_source/","text":"File exittool.cpp # File List > exit > exittool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"exittool.h\" #include <QPainter> ExitTool::ExitTool(QObject* parent) : AbstractActionTool(parent) {} bool ExitTool::closeOnButtonPressed() const { return true; } QIcon ExitTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"close.svg\"); } QString ExitTool::name() const { return tr(\"Exit\"); } CaptureTool::Type ExitTool::type() const { return CaptureTool::TYPE_EXIT; } QString ExitTool::description() const { return tr(\"Leave the capture screen\"); } CaptureTool* ExitTool::copy(QObject* parent) { return new ExitTool(parent); } void ExitTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_CLOSE_GUI); }","title":"File exittool.cpp"},{"location":"flameshot/exittool_8cpp_source/#file-exittoolcpp","text":"File List > exit > exittool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"exittool.h\" #include <QPainter> ExitTool::ExitTool(QObject* parent) : AbstractActionTool(parent) {} bool ExitTool::closeOnButtonPressed() const { return true; } QIcon ExitTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"close.svg\"); } QString ExitTool::name() const { return tr(\"Exit\"); } CaptureTool::Type ExitTool::type() const { return CaptureTool::TYPE_EXIT; } QString ExitTool::description() const { return tr(\"Leave the capture screen\"); } CaptureTool* ExitTool::copy(QObject* parent) { return new ExitTool(parent); } void ExitTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_CLOSE_GUI); }","title":"File exittool.cpp"},{"location":"flameshot/exittool_8h/","text":"File exittool.h # FileList > exit > exittool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class ExitTool","title":"File exittool.h"},{"location":"flameshot/exittool_8h/#file-exittoolh","text":"FileList > exit > exittool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File exittool.h"},{"location":"flameshot/exittool_8h/#classes","text":"Type Name class ExitTool","title":"Classes"},{"location":"flameshot/exittool_8h_source/","text":"File exittool.h # File List > exit > exittool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class ExitTool : public AbstractActionTool { Q_OBJECT public: explicit ExitTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; // TODO create a new abstract class to get rid of such baggage CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File exittool.h"},{"location":"flameshot/exittool_8h_source/#file-exittoolh","text":"File List > exit > exittool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class ExitTool : public AbstractActionTool { Q_OBJECT public: explicit ExitTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; // TODO create a new abstract class to get rid of such baggage CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File exittool.h"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/","text":"Dir imgupload # FileList > imgupload Files # Type Name file imguploadermanager.cpp file imguploadermanager.h file imguploadertool.cpp file imguploadertool.h Directories # Type Name dir storages","title":"Dir imgupload"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/#dir-imgupload","text":"FileList > imgupload","title":"Dir imgupload"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/#files","text":"Type Name file imguploadermanager.cpp file imguploadermanager.h file imguploadertool.cpp file imguploadertool.h","title":"Files"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/#directories","text":"Type Name dir storages","title":"Directories"},{"location":"flameshot/imguploadermanager_8cpp/","text":"File imguploadermanager.cpp # FileList > imgupload > imguploadermanager.cpp Go to the source code of this file. #include \"imguploadermanager.h\" #include <QPixmap> #include <QWidget> #include \"storages/imgur/imguruploader.h\"","title":"File imguploadermanager.cpp"},{"location":"flameshot/imguploadermanager_8cpp/#file-imguploadermanagercpp","text":"FileList > imgupload > imguploadermanager.cpp Go to the source code of this file. #include \"imguploadermanager.h\" #include <QPixmap> #include <QWidget> #include \"storages/imgur/imguruploader.h\"","title":"File imguploadermanager.cpp"},{"location":"flameshot/imguploadermanager_8cpp_source/","text":"File imguploadermanager.cpp # File List > imgupload > imguploadermanager.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: Yurii Puchkov & Contributors // #include \"imguploadermanager.h\" #include <QPixmap> #include <QWidget> // TODO - remove this hard-code and create plugin manager in the future, you may // include other storage headers here #include \"storages/imgur/imguruploader.h\" ImgUploaderManager::ImgUploaderManager(QObject* parent) : QObject(parent) , m_imgUploaderBase(nullptr) { // TODO - implement ImgUploader for other Storages and selection among them m_imgUploaderPlugin = IMG_UPLOADER_STORAGE_DEFAULT; init(); } void ImgUploaderManager::init() { // TODO - implement ImgUploader for other Storages and selection among them, // example: // if (uploaderPlugin().compare(\"s3\") == 0) { // m_qstrUrl = ImgS3Settings().value(\"S3\", \"S3_URL\").toString(); //} else { // m_qstrUrl = \"https://imgur.com/\"; // m_imgUploaderPlugin = \"imgur\"; //} m_urlString = \"https://imgur.com/\"; m_imgUploaderPlugin = \"imgur\"; } ImgUploaderBase* ImgUploaderManager::uploader(const QPixmap& capture, QWidget* parent) { // TODO - implement ImgUploader for other Storages and selection among them, // example: // if (uploaderPlugin().compare(\"s3\") == 0) { // m_imgUploaderBase = // (ImgUploaderBase*)(new ImgS3Uploader(capture, parent)); //} else { // m_imgUploaderBase = // (ImgUploaderBase*)(new ImgurUploader(capture, parent)); //} m_imgUploaderBase = (ImgUploaderBase*)(new ImgurUploader(capture, parent)); if (m_imgUploaderBase && !capture.isNull()) { m_imgUploaderBase->upload(); } return m_imgUploaderBase; } ImgUploaderBase* ImgUploaderManager::uploader(const QString& imgUploaderPlugin) { m_imgUploaderPlugin = imgUploaderPlugin; init(); return uploader(QPixmap()); } const QString& ImgUploaderManager::uploaderPlugin() { return m_imgUploaderPlugin; } const QString& ImgUploaderManager::url() { return m_urlString; }","title":"File imguploadermanager.cpp"},{"location":"flameshot/imguploadermanager_8cpp_source/#file-imguploadermanagercpp","text":"File List > imgupload > imguploadermanager.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: Yurii Puchkov & Contributors // #include \"imguploadermanager.h\" #include <QPixmap> #include <QWidget> // TODO - remove this hard-code and create plugin manager in the future, you may // include other storage headers here #include \"storages/imgur/imguruploader.h\" ImgUploaderManager::ImgUploaderManager(QObject* parent) : QObject(parent) , m_imgUploaderBase(nullptr) { // TODO - implement ImgUploader for other Storages and selection among them m_imgUploaderPlugin = IMG_UPLOADER_STORAGE_DEFAULT; init(); } void ImgUploaderManager::init() { // TODO - implement ImgUploader for other Storages and selection among them, // example: // if (uploaderPlugin().compare(\"s3\") == 0) { // m_qstrUrl = ImgS3Settings().value(\"S3\", \"S3_URL\").toString(); //} else { // m_qstrUrl = \"https://imgur.com/\"; // m_imgUploaderPlugin = \"imgur\"; //} m_urlString = \"https://imgur.com/\"; m_imgUploaderPlugin = \"imgur\"; } ImgUploaderBase* ImgUploaderManager::uploader(const QPixmap& capture, QWidget* parent) { // TODO - implement ImgUploader for other Storages and selection among them, // example: // if (uploaderPlugin().compare(\"s3\") == 0) { // m_imgUploaderBase = // (ImgUploaderBase*)(new ImgS3Uploader(capture, parent)); //} else { // m_imgUploaderBase = // (ImgUploaderBase*)(new ImgurUploader(capture, parent)); //} m_imgUploaderBase = (ImgUploaderBase*)(new ImgurUploader(capture, parent)); if (m_imgUploaderBase && !capture.isNull()) { m_imgUploaderBase->upload(); } return m_imgUploaderBase; } ImgUploaderBase* ImgUploaderManager::uploader(const QString& imgUploaderPlugin) { m_imgUploaderPlugin = imgUploaderPlugin; init(); return uploader(QPixmap()); } const QString& ImgUploaderManager::uploaderPlugin() { return m_imgUploaderPlugin; } const QString& ImgUploaderManager::url() { return m_urlString; }","title":"File imguploadermanager.cpp"},{"location":"flameshot/imguploadermanager_8h/","text":"File imguploadermanager.h # FileList > imgupload > imguploadermanager.h Go to the source code of this file. #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QObject> Classes # Type Name class ImgUploaderManager Macros # Type Name define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\" Macro Definition Documentation # define IMG_UPLOADER_STORAGE_DEFAULT # #define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\"","title":"File imguploadermanager.h"},{"location":"flameshot/imguploadermanager_8h/#file-imguploadermanagerh","text":"FileList > imgupload > imguploadermanager.h Go to the source code of this file. #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QObject>","title":"File imguploadermanager.h"},{"location":"flameshot/imguploadermanager_8h/#classes","text":"Type Name class ImgUploaderManager","title":"Classes"},{"location":"flameshot/imguploadermanager_8h/#macros","text":"Type Name define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\"","title":"Macros"},{"location":"flameshot/imguploadermanager_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/imguploadermanager_8h/#define-img_uploader_storage_default","text":"#define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\"","title":"define IMG_UPLOADER_STORAGE_DEFAULT"},{"location":"flameshot/imguploadermanager_8h_source/","text":"File imguploadermanager.h # File List > imgupload > imguploadermanager.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: Yurii Puchkov & Contributors // #ifndef FLAMESHOT_IMGUPLOADERMANAGER_H #define FLAMESHOT_IMGUPLOADERMANAGER_H #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QObject> #define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\" class QPixmap; class QWidget; class ImgUploaderManager : public QObject { Q_OBJECT public: explicit ImgUploaderManager(QObject* parent = nullptr); ImgUploaderBase* uploader(const QPixmap& capture, QWidget* parent = nullptr); ImgUploaderBase* uploader(const QString& imgUploaderPlugin); const QString& url(); const QString& uploaderPlugin(); private: void init(); private: ImgUploaderBase* m_imgUploaderBase; QString m_urlString; QString m_imgUploaderPlugin; }; #endif // FLAMESHOT_IMGUPLOADERMANAGER_H","title":"File imguploadermanager.h"},{"location":"flameshot/imguploadermanager_8h_source/#file-imguploadermanagerh","text":"File List > imgupload > imguploadermanager.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: Yurii Puchkov & Contributors // #ifndef FLAMESHOT_IMGUPLOADERMANAGER_H #define FLAMESHOT_IMGUPLOADERMANAGER_H #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QObject> #define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\" class QPixmap; class QWidget; class ImgUploaderManager : public QObject { Q_OBJECT public: explicit ImgUploaderManager(QObject* parent = nullptr); ImgUploaderBase* uploader(const QPixmap& capture, QWidget* parent = nullptr); ImgUploaderBase* uploader(const QString& imgUploaderPlugin); const QString& url(); const QString& uploaderPlugin(); private: void init(); private: ImgUploaderBase* m_imgUploaderBase; QString m_urlString; QString m_imgUploaderPlugin; }; #endif // FLAMESHOT_IMGUPLOADERMANAGER_H","title":"File imguploadermanager.h"},{"location":"flameshot/imguploadertool_8cpp/","text":"File imguploadertool.cpp # FileList > imgupload > imguploadertool.cpp Go to the source code of this file. #include \"imguploadertool.h\"","title":"File imguploadertool.cpp"},{"location":"flameshot/imguploadertool_8cpp/#file-imguploadertoolcpp","text":"FileList > imgupload > imguploadertool.cpp Go to the source code of this file. #include \"imguploadertool.h\"","title":"File imguploadertool.cpp"},{"location":"flameshot/imguploadertool_8cpp_source/","text":"File imguploadertool.cpp # File List > imgupload > imguploadertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploadertool.h\" ImgUploaderTool::ImgUploaderTool(QObject* parent) : AbstractActionTool(parent) {} bool ImgUploaderTool::closeOnButtonPressed() const { return true; } QIcon ImgUploaderTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor); return QIcon(iconPath(background) + \"cloud-upload.svg\"); } QString ImgUploaderTool::name() const { return tr(\"Image Uploader\"); } CaptureTool::Type ImgUploaderTool::type() const { return CaptureTool::TYPE_IMAGEUPLOADER; } QString ImgUploaderTool::description() const { return tr(\"Upload the selection\"); } CaptureTool* ImgUploaderTool::copy(QObject* parent) { return new ImgUploaderTool(parent); } void ImgUploaderTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); emit requestAction(REQ_CAPTURE_DONE_OK); context.request.addTask(CaptureRequest::UPLOAD); emit requestAction(REQ_CLOSE_GUI); }","title":"File imguploadertool.cpp"},{"location":"flameshot/imguploadertool_8cpp_source/#file-imguploadertoolcpp","text":"File List > imgupload > imguploadertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploadertool.h\" ImgUploaderTool::ImgUploaderTool(QObject* parent) : AbstractActionTool(parent) {} bool ImgUploaderTool::closeOnButtonPressed() const { return true; } QIcon ImgUploaderTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor); return QIcon(iconPath(background) + \"cloud-upload.svg\"); } QString ImgUploaderTool::name() const { return tr(\"Image Uploader\"); } CaptureTool::Type ImgUploaderTool::type() const { return CaptureTool::TYPE_IMAGEUPLOADER; } QString ImgUploaderTool::description() const { return tr(\"Upload the selection\"); } CaptureTool* ImgUploaderTool::copy(QObject* parent) { return new ImgUploaderTool(parent); } void ImgUploaderTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); emit requestAction(REQ_CAPTURE_DONE_OK); context.request.addTask(CaptureRequest::UPLOAD); emit requestAction(REQ_CLOSE_GUI); }","title":"File imguploadertool.cpp"},{"location":"flameshot/imguploadertool_8h/","text":"File imguploadertool.h # FileList > imgupload > imguploadertool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class ImgUploaderTool","title":"File imguploadertool.h"},{"location":"flameshot/imguploadertool_8h/#file-imguploadertoolh","text":"FileList > imgupload > imguploadertool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File imguploadertool.h"},{"location":"flameshot/imguploadertool_8h/#classes","text":"Type Name class ImgUploaderTool","title":"Classes"},{"location":"flameshot/imguploadertool_8h_source/","text":"File imguploadertool.h # File List > imgupload > imguploadertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class ImgUploaderTool : public AbstractActionTool { Q_OBJECT public: explicit ImgUploaderTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPixmap capture; };","title":"File imguploadertool.h"},{"location":"flameshot/imguploadertool_8h_source/#file-imguploadertoolh","text":"File List > imgupload > imguploadertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class ImgUploaderTool : public AbstractActionTool { Q_OBJECT public: explicit ImgUploaderTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPixmap capture; };","title":"File imguploadertool.h"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/","text":"Dir storages # FileList > imgupload > storages Files # Type Name file imguploaderbase.cpp file imguploaderbase.h Directories # Type Name dir imgur","title":"Dir storages"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/#dir-storages","text":"FileList > imgupload > storages","title":"Dir storages"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/#files","text":"Type Name file imguploaderbase.cpp file imguploaderbase.h","title":"Files"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/#directories","text":"Type Name dir imgur","title":"Directories"},{"location":"flameshot/imguploaderbase_8cpp/","text":"File imguploaderbase.cpp # FileList > imgupload > storages > imguploaderbase.cpp Go to the source code of this file. #include \"imguploaderbase.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/history.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QApplication> #include <QClipboard> #include <QCursor> #include <QDesktopServices> #include <QDrag> #include <QGuiApplication> #include <QJsonDocument> #include <QJsonObject> #include <QLabel> #include <QMimeData> #include <QNetworkAccessManager> #include <QPushButton> #include <QRect> #include <QScreen> #include <QShortcut> #include <QTimer> #include <QUrlQuery> #include <QVBoxLayout>","title":"File imguploaderbase.cpp"},{"location":"flameshot/imguploaderbase_8cpp/#file-imguploaderbasecpp","text":"FileList > imgupload > storages > imguploaderbase.cpp Go to the source code of this file. #include \"imguploaderbase.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/history.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QApplication> #include <QClipboard> #include <QCursor> #include <QDesktopServices> #include <QDrag> #include <QGuiApplication> #include <QJsonDocument> #include <QJsonObject> #include <QLabel> #include <QMimeData> #include <QNetworkAccessManager> #include <QPushButton> #include <QRect> #include <QScreen> #include <QShortcut> #include <QTimer> #include <QUrlQuery> #include <QVBoxLayout>","title":"File imguploaderbase.cpp"},{"location":"flameshot/imguploaderbase_8cpp_source/","text":"File imguploaderbase.cpp # File List > imgupload > storages > imguploaderbase.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploaderbase.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/history.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QApplication> // FIXME #include <QBuffer> #include <QClipboard> #include <QCursor> #include <QDesktopServices> #include <QDrag> #include <QGuiApplication> #include <QJsonDocument> #include <QJsonObject> #include <QLabel> #include <QMimeData> #include <QNetworkAccessManager> #include <QPushButton> #include <QRect> #include <QScreen> #include <QShortcut> #include <QTimer> #include <QUrlQuery> #include <QVBoxLayout> ImgUploaderBase::ImgUploaderBase(const QPixmap& capture, QWidget* parent) : QWidget(parent) , m_pixmap(capture) { setWindowTitle(tr(\"Upload image\")); setWindowIcon(QIcon(GlobalValues::iconPath())); QRect position = frameGeometry(); QScreen* screen = QGuiApplication::screenAt(QCursor::pos()); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); m_spinner = new LoadSpinner(this); m_spinner->setColor(ConfigHandler().uiColor()); m_spinner->start(); m_infoLabel = new QLabel(tr(\"Uploading Image\")); m_infoLabel->setTextInteractionFlags(Qt::TextSelectableByMouse); m_infoLabel->setCursor(QCursor(Qt::IBeamCursor)); m_vLayout = new QVBoxLayout(); setLayout(m_vLayout); m_vLayout->addWidget(m_spinner, 0, Qt::AlignHCenter); m_vLayout->addWidget(m_infoLabel); setAttribute(Qt::WA_DeleteOnClose); } LoadSpinner* ImgUploaderBase::spinner() { return m_spinner; } const QUrl& ImgUploaderBase::imageURL() { return m_imageURL; } void ImgUploaderBase::setImageURL(const QUrl& imageURL) { m_imageURL = imageURL; } const QPixmap& ImgUploaderBase::pixmap() { return m_pixmap; } void ImgUploaderBase::setPixmap(const QPixmap& pixmap) { m_pixmap = pixmap; } NotificationWidget* ImgUploaderBase::notification() { return m_notification; } void ImgUploaderBase::setInfoLabelText(const QString& text) { m_infoLabel->setText(text); } void ImgUploaderBase::startDrag() { auto* mimeData = new QMimeData; mimeData->setUrls(QList<QUrl>{ m_imageURL }); mimeData->setImageData(m_pixmap); auto* dragHandler = new QDrag(this); dragHandler->setMimeData(mimeData); dragHandler->setPixmap(m_pixmap.scaled( 256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation)); dragHandler->exec(); } void ImgUploaderBase::showPostUploadDialog() { m_infoLabel->deleteLater(); m_notification = new NotificationWidget(); m_vLayout->addWidget(m_notification); auto* imageLabel = new ImageLabel(); imageLabel->setScreenshot(m_pixmap); imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); connect(imageLabel, &ImageLabel::dragInitiated, this, &ImgUploaderBase::startDrag); m_vLayout->addWidget(imageLabel); m_hLayout = new QHBoxLayout(); m_vLayout->addLayout(m_hLayout); m_copyUrlButton = new QPushButton(tr(\"Copy URL\")); m_openUrlButton = new QPushButton(tr(\"Open URL\")); m_openDeleteUrlButton = new QPushButton(tr(\"Delete image\")); m_toClipboardButton = new QPushButton(tr(\"Image to Clipboard.\")); m_saveToFilesystemButton = new QPushButton(tr(\"Save image\")); m_hLayout->addWidget(m_copyUrlButton); m_hLayout->addWidget(m_openUrlButton); m_hLayout->addWidget(m_openDeleteUrlButton); m_hLayout->addWidget(m_toClipboardButton); m_hLayout->addWidget(m_saveToFilesystemButton); connect( m_copyUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::copyURL); connect( m_openUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::openURL); connect(m_openDeleteUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::deleteCurrentImage); connect(m_toClipboardButton, &QPushButton::clicked, this, &ImgUploaderBase::copyImage); QObject::connect(m_saveToFilesystemButton, &QPushButton::clicked, this, &ImgUploaderBase::saveScreenshotToFilesystem); } void ImgUploaderBase::openURL() { bool successful = QDesktopServices::openUrl(m_imageURL); if (!successful) { m_notification->showMessage(tr(\"Unable to open the URL.\")); } } void ImgUploaderBase::copyURL() { FlameshotDaemon::copyToClipboard(m_imageURL.toString()); m_notification->showMessage(tr(\"URL copied to clipboard.\")); } void ImgUploaderBase::copyImage() { FlameshotDaemon::copyToClipboard(m_pixmap); m_notification->showMessage(tr(\"Screenshot copied to clipboard.\")); } void ImgUploaderBase::deleteCurrentImage() { History history; HistoryFileName unpackFileName = history.unpackFileName(m_currentImageName); deleteImage(unpackFileName.file, unpackFileName.token); } void ImgUploaderBase::saveScreenshotToFilesystem() { if (!saveToFilesystemGUI(m_pixmap)) { m_notification->showMessage( tr(\"Unable to save the screenshot to disk.\")); return; } m_notification->showMessage(tr(\"Screenshot saved.\")); }","title":"File imguploaderbase.cpp"},{"location":"flameshot/imguploaderbase_8cpp_source/#file-imguploaderbasecpp","text":"File List > imgupload > storages > imguploaderbase.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploaderbase.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/history.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QApplication> // FIXME #include <QBuffer> #include <QClipboard> #include <QCursor> #include <QDesktopServices> #include <QDrag> #include <QGuiApplication> #include <QJsonDocument> #include <QJsonObject> #include <QLabel> #include <QMimeData> #include <QNetworkAccessManager> #include <QPushButton> #include <QRect> #include <QScreen> #include <QShortcut> #include <QTimer> #include <QUrlQuery> #include <QVBoxLayout> ImgUploaderBase::ImgUploaderBase(const QPixmap& capture, QWidget* parent) : QWidget(parent) , m_pixmap(capture) { setWindowTitle(tr(\"Upload image\")); setWindowIcon(QIcon(GlobalValues::iconPath())); QRect position = frameGeometry(); QScreen* screen = QGuiApplication::screenAt(QCursor::pos()); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); m_spinner = new LoadSpinner(this); m_spinner->setColor(ConfigHandler().uiColor()); m_spinner->start(); m_infoLabel = new QLabel(tr(\"Uploading Image\")); m_infoLabel->setTextInteractionFlags(Qt::TextSelectableByMouse); m_infoLabel->setCursor(QCursor(Qt::IBeamCursor)); m_vLayout = new QVBoxLayout(); setLayout(m_vLayout); m_vLayout->addWidget(m_spinner, 0, Qt::AlignHCenter); m_vLayout->addWidget(m_infoLabel); setAttribute(Qt::WA_DeleteOnClose); } LoadSpinner* ImgUploaderBase::spinner() { return m_spinner; } const QUrl& ImgUploaderBase::imageURL() { return m_imageURL; } void ImgUploaderBase::setImageURL(const QUrl& imageURL) { m_imageURL = imageURL; } const QPixmap& ImgUploaderBase::pixmap() { return m_pixmap; } void ImgUploaderBase::setPixmap(const QPixmap& pixmap) { m_pixmap = pixmap; } NotificationWidget* ImgUploaderBase::notification() { return m_notification; } void ImgUploaderBase::setInfoLabelText(const QString& text) { m_infoLabel->setText(text); } void ImgUploaderBase::startDrag() { auto* mimeData = new QMimeData; mimeData->setUrls(QList<QUrl>{ m_imageURL }); mimeData->setImageData(m_pixmap); auto* dragHandler = new QDrag(this); dragHandler->setMimeData(mimeData); dragHandler->setPixmap(m_pixmap.scaled( 256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation)); dragHandler->exec(); } void ImgUploaderBase::showPostUploadDialog() { m_infoLabel->deleteLater(); m_notification = new NotificationWidget(); m_vLayout->addWidget(m_notification); auto* imageLabel = new ImageLabel(); imageLabel->setScreenshot(m_pixmap); imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); connect(imageLabel, &ImageLabel::dragInitiated, this, &ImgUploaderBase::startDrag); m_vLayout->addWidget(imageLabel); m_hLayout = new QHBoxLayout(); m_vLayout->addLayout(m_hLayout); m_copyUrlButton = new QPushButton(tr(\"Copy URL\")); m_openUrlButton = new QPushButton(tr(\"Open URL\")); m_openDeleteUrlButton = new QPushButton(tr(\"Delete image\")); m_toClipboardButton = new QPushButton(tr(\"Image to Clipboard.\")); m_saveToFilesystemButton = new QPushButton(tr(\"Save image\")); m_hLayout->addWidget(m_copyUrlButton); m_hLayout->addWidget(m_openUrlButton); m_hLayout->addWidget(m_openDeleteUrlButton); m_hLayout->addWidget(m_toClipboardButton); m_hLayout->addWidget(m_saveToFilesystemButton); connect( m_copyUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::copyURL); connect( m_openUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::openURL); connect(m_openDeleteUrlButton, &QPushButton::clicked, this, &ImgUploaderBase::deleteCurrentImage); connect(m_toClipboardButton, &QPushButton::clicked, this, &ImgUploaderBase::copyImage); QObject::connect(m_saveToFilesystemButton, &QPushButton::clicked, this, &ImgUploaderBase::saveScreenshotToFilesystem); } void ImgUploaderBase::openURL() { bool successful = QDesktopServices::openUrl(m_imageURL); if (!successful) { m_notification->showMessage(tr(\"Unable to open the URL.\")); } } void ImgUploaderBase::copyURL() { FlameshotDaemon::copyToClipboard(m_imageURL.toString()); m_notification->showMessage(tr(\"URL copied to clipboard.\")); } void ImgUploaderBase::copyImage() { FlameshotDaemon::copyToClipboard(m_pixmap); m_notification->showMessage(tr(\"Screenshot copied to clipboard.\")); } void ImgUploaderBase::deleteCurrentImage() { History history; HistoryFileName unpackFileName = history.unpackFileName(m_currentImageName); deleteImage(unpackFileName.file, unpackFileName.token); } void ImgUploaderBase::saveScreenshotToFilesystem() { if (!saveToFilesystemGUI(m_pixmap)) { m_notification->showMessage( tr(\"Unable to save the screenshot to disk.\")); return; } m_notification->showMessage(tr(\"Screenshot saved.\")); }","title":"File imguploaderbase.cpp"},{"location":"flameshot/imguploaderbase_8h/","text":"File imguploaderbase.h # FileList > imgupload > storages > imguploaderbase.h Go to the source code of this file. #include <QUrl> #include <QWidget> Classes # Type Name class ImgUploaderBase","title":"File imguploaderbase.h"},{"location":"flameshot/imguploaderbase_8h/#file-imguploaderbaseh","text":"FileList > imgupload > storages > imguploaderbase.h Go to the source code of this file. #include <QUrl> #include <QWidget>","title":"File imguploaderbase.h"},{"location":"flameshot/imguploaderbase_8h/#classes","text":"Type Name class ImgUploaderBase","title":"Classes"},{"location":"flameshot/imguploaderbase_8h_source/","text":"File imguploaderbase.h # File List > imgupload > storages > imguploaderbase.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QUrl> #include <QWidget> class QNetworkReply; class QNetworkAccessManager; class QHBoxLayout; class QVBoxLayout; class QLabel; class LoadSpinner; class QPushButton; class QUrl; class NotificationWidget; class ImgUploaderBase : public QWidget { Q_OBJECT public: explicit ImgUploaderBase(const QPixmap& capture, QWidget* parent = nullptr); LoadSpinner* spinner(); const QUrl& imageURL(); void setImageURL(const QUrl&); const QPixmap& pixmap(); void setPixmap(const QPixmap&); void setInfoLabelText(const QString&); NotificationWidget* notification(); virtual void deleteImage(const QString& fileName, const QString& deleteToken) = 0; virtual void upload() = 0; signals: void uploadOk(const QUrl& url); void deleteOk(); public slots: void showPostUploadDialog(); private slots: void startDrag(); void openURL(); void copyURL(); void copyImage(); void deleteCurrentImage(); void saveScreenshotToFilesystem(); private: QPixmap m_pixmap; QVBoxLayout* m_vLayout; QHBoxLayout* m_hLayout; // loading QLabel* m_infoLabel; LoadSpinner* m_spinner; // uploaded QPushButton* m_openUrlButton; QPushButton* m_openDeleteUrlButton; QPushButton* m_copyUrlButton; QPushButton* m_toClipboardButton; QPushButton* m_saveToFilesystemButton; QUrl m_imageURL; NotificationWidget* m_notification; public: QString m_currentImageName; };","title":"File imguploaderbase.h"},{"location":"flameshot/imguploaderbase_8h_source/#file-imguploaderbaseh","text":"File List > imgupload > storages > imguploaderbase.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QUrl> #include <QWidget> class QNetworkReply; class QNetworkAccessManager; class QHBoxLayout; class QVBoxLayout; class QLabel; class LoadSpinner; class QPushButton; class QUrl; class NotificationWidget; class ImgUploaderBase : public QWidget { Q_OBJECT public: explicit ImgUploaderBase(const QPixmap& capture, QWidget* parent = nullptr); LoadSpinner* spinner(); const QUrl& imageURL(); void setImageURL(const QUrl&); const QPixmap& pixmap(); void setPixmap(const QPixmap&); void setInfoLabelText(const QString&); NotificationWidget* notification(); virtual void deleteImage(const QString& fileName, const QString& deleteToken) = 0; virtual void upload() = 0; signals: void uploadOk(const QUrl& url); void deleteOk(); public slots: void showPostUploadDialog(); private slots: void startDrag(); void openURL(); void copyURL(); void copyImage(); void deleteCurrentImage(); void saveScreenshotToFilesystem(); private: QPixmap m_pixmap; QVBoxLayout* m_vLayout; QHBoxLayout* m_hLayout; // loading QLabel* m_infoLabel; LoadSpinner* m_spinner; // uploaded QPushButton* m_openUrlButton; QPushButton* m_openDeleteUrlButton; QPushButton* m_copyUrlButton; QPushButton* m_toClipboardButton; QPushButton* m_saveToFilesystemButton; QUrl m_imageURL; NotificationWidget* m_notification; public: QString m_currentImageName; };","title":"File imguploaderbase.h"},{"location":"flameshot/dir_9d663866a83f7a9d0218a5da0003e3bb/","text":"Dir imgur # FileList > imgupload > storages > imgur Files # Type Name file imguruploader.cpp file imguruploader.h","title":"Dir imgur"},{"location":"flameshot/dir_9d663866a83f7a9d0218a5da0003e3bb/#dir-imgur","text":"FileList > imgupload > storages > imgur","title":"Dir imgur"},{"location":"flameshot/dir_9d663866a83f7a9d0218a5da0003e3bb/#files","text":"Type Name file imguruploader.cpp file imguruploader.h","title":"Files"},{"location":"flameshot/imguruploader_8cpp/","text":"File imguruploader.cpp # FileList > imgupload > storages > imgur > imguruploader.cpp Go to the source code of this file. #include \"imguruploader.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QBuffer> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QNetworkRequest> #include <QShortcut> #include <QUrlQuery>","title":"File imguruploader.cpp"},{"location":"flameshot/imguruploader_8cpp/#file-imguruploadercpp","text":"FileList > imgupload > storages > imgur > imguruploader.cpp Go to the source code of this file. #include \"imguruploader.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QBuffer> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QNetworkRequest> #include <QShortcut> #include <QUrlQuery>","title":"File imguruploader.cpp"},{"location":"flameshot/imguruploader_8cpp_source/","text":"File imguruploader.cpp # File List > imgupload > storages > imgur > imguruploader.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguruploader.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QBuffer> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QNetworkRequest> #include <QShortcut> #include <QUrlQuery> ImgurUploader::ImgurUploader(const QPixmap& capture, QWidget* parent) : ImgUploaderBase(capture, parent) { m_NetworkAM = new QNetworkAccessManager(this); connect(m_NetworkAM, &QNetworkAccessManager::finished, this, &ImgurUploader::handleReply); } void ImgurUploader::handleReply(QNetworkReply* reply) { spinner()->deleteLater(); m_currentImageName.clear(); if (reply->error() == QNetworkReply::NoError) { QJsonDocument response = QJsonDocument::fromJson(reply->readAll()); QJsonObject json = response.object(); QJsonObject data = json[QStringLiteral(\"data\")].toObject(); setImageURL(data[QStringLiteral(\"link\")].toString()); auto deleteToken = data[QStringLiteral(\"deletehash\")].toString(); // save history m_currentImageName = imageURL().toString(); int lastSlash = m_currentImageName.lastIndexOf(\"/\"); if (lastSlash >= 0) { m_currentImageName = m_currentImageName.mid(lastSlash + 1); } // save image to history History history; m_currentImageName = history.packFileName(\"imgur\", deleteToken, m_currentImageName); history.save(pixmap(), m_currentImageName); emit uploadOk(imageURL()); } else { setInfoLabelText(reply->errorString()); } new QShortcut(Qt::Key_Escape, this, SLOT(close())); } void ImgurUploader::upload() { QByteArray byteArray; QBuffer buffer(&byteArray); pixmap().save(&buffer, \"PNG\"); QUrlQuery urlQuery; urlQuery.addQueryItem(QStringLiteral(\"title\"), QStringLiteral(\"\")); QString description = FileNameHandler().parsedPattern(); urlQuery.addQueryItem(QStringLiteral(\"description\"), description); QUrl url(QStringLiteral(\"https://api.imgur.com/3/image\")); url.setQuery(urlQuery); QNetworkRequest request(url); request.setHeader(QNetworkRequest::ContentTypeHeader, \"application/application/x-www-form-urlencoded\"); request.setRawHeader(\"Authorization\", QStringLiteral(\"Client-ID %1\") .arg(ConfigHandler().uploadClientSecret()) .toUtf8()); m_NetworkAM->post(request, byteArray); } void ImgurUploader::deleteImage(const QString& fileName, const QString& deleteToken) { Q_UNUSED(fileName) bool successful = QDesktopServices::openUrl( QUrl(QStringLiteral(\"https://imgur.com/delete/%1\").arg(deleteToken))); if (!successful) { notification()->showMessage(tr(\"Unable to open the URL.\")); } emit deleteOk(); }","title":"File imguruploader.cpp"},{"location":"flameshot/imguruploader_8cpp_source/#file-imguruploadercpp","text":"File List > imgupload > storages > imgur > imguruploader.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguruploader.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/loadspinner.h\" #include \"src/widgets/notificationwidget.h\" #include <QBuffer> #include <QDesktopServices> #include <QJsonDocument> #include <QJsonObject> #include <QNetworkAccessManager> #include <QNetworkReply> #include <QNetworkRequest> #include <QShortcut> #include <QUrlQuery> ImgurUploader::ImgurUploader(const QPixmap& capture, QWidget* parent) : ImgUploaderBase(capture, parent) { m_NetworkAM = new QNetworkAccessManager(this); connect(m_NetworkAM, &QNetworkAccessManager::finished, this, &ImgurUploader::handleReply); } void ImgurUploader::handleReply(QNetworkReply* reply) { spinner()->deleteLater(); m_currentImageName.clear(); if (reply->error() == QNetworkReply::NoError) { QJsonDocument response = QJsonDocument::fromJson(reply->readAll()); QJsonObject json = response.object(); QJsonObject data = json[QStringLiteral(\"data\")].toObject(); setImageURL(data[QStringLiteral(\"link\")].toString()); auto deleteToken = data[QStringLiteral(\"deletehash\")].toString(); // save history m_currentImageName = imageURL().toString(); int lastSlash = m_currentImageName.lastIndexOf(\"/\"); if (lastSlash >= 0) { m_currentImageName = m_currentImageName.mid(lastSlash + 1); } // save image to history History history; m_currentImageName = history.packFileName(\"imgur\", deleteToken, m_currentImageName); history.save(pixmap(), m_currentImageName); emit uploadOk(imageURL()); } else { setInfoLabelText(reply->errorString()); } new QShortcut(Qt::Key_Escape, this, SLOT(close())); } void ImgurUploader::upload() { QByteArray byteArray; QBuffer buffer(&byteArray); pixmap().save(&buffer, \"PNG\"); QUrlQuery urlQuery; urlQuery.addQueryItem(QStringLiteral(\"title\"), QStringLiteral(\"\")); QString description = FileNameHandler().parsedPattern(); urlQuery.addQueryItem(QStringLiteral(\"description\"), description); QUrl url(QStringLiteral(\"https://api.imgur.com/3/image\")); url.setQuery(urlQuery); QNetworkRequest request(url); request.setHeader(QNetworkRequest::ContentTypeHeader, \"application/application/x-www-form-urlencoded\"); request.setRawHeader(\"Authorization\", QStringLiteral(\"Client-ID %1\") .arg(ConfigHandler().uploadClientSecret()) .toUtf8()); m_NetworkAM->post(request, byteArray); } void ImgurUploader::deleteImage(const QString& fileName, const QString& deleteToken) { Q_UNUSED(fileName) bool successful = QDesktopServices::openUrl( QUrl(QStringLiteral(\"https://imgur.com/delete/%1\").arg(deleteToken))); if (!successful) { notification()->showMessage(tr(\"Unable to open the URL.\")); } emit deleteOk(); }","title":"File imguruploader.cpp"},{"location":"flameshot/imguruploader_8h/","text":"File imguruploader.h # FileList > imgupload > storages > imgur > imguruploader.h Go to the source code of this file. #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QUrl> #include <QWidget> Classes # Type Name class ImgurUploader","title":"File imguruploader.h"},{"location":"flameshot/imguruploader_8h/#file-imguruploaderh","text":"FileList > imgupload > storages > imgur > imguruploader.h Go to the source code of this file. #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QUrl> #include <QWidget>","title":"File imguruploader.h"},{"location":"flameshot/imguruploader_8h/#classes","text":"Type Name class ImgurUploader","title":"Classes"},{"location":"flameshot/imguruploader_8h_source/","text":"File imguruploader.h # File List > imgupload > storages > imgur > imguruploader.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QUrl> #include <QWidget> class QNetworkReply; class QNetworkAccessManager; class QUrl; class ImgurUploader : public ImgUploaderBase { Q_OBJECT public: explicit ImgurUploader(const QPixmap& capture, QWidget* parent = nullptr); void deleteImage(const QString& fileName, const QString& deleteToken); private slots: void handleReply(QNetworkReply* reply); private: void upload(); private: QNetworkAccessManager* m_NetworkAM; };","title":"File imguruploader.h"},{"location":"flameshot/imguruploader_8h_source/#file-imguruploaderh","text":"File List > imgupload > storages > imgur > imguruploader.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/imgupload/storages/imguploaderbase.h\" #include <QUrl> #include <QWidget> class QNetworkReply; class QNetworkAccessManager; class QUrl; class ImgurUploader : public ImgUploaderBase { Q_OBJECT public: explicit ImgurUploader(const QPixmap& capture, QWidget* parent = nullptr); void deleteImage(const QString& fileName, const QString& deleteToken); private slots: void handleReply(QNetworkReply* reply); private: void upload(); private: QNetworkAccessManager* m_NetworkAM; };","title":"File imguruploader.h"},{"location":"flameshot/dir_3786b04329c06854f20683676e14a832/","text":"Dir invert # FileList > invert Files # Type Name file inverttool.cpp file inverttool.h","title":"Dir invert"},{"location":"flameshot/dir_3786b04329c06854f20683676e14a832/#dir-invert","text":"FileList > invert","title":"Dir invert"},{"location":"flameshot/dir_3786b04329c06854f20683676e14a832/#files","text":"Type Name file inverttool.cpp file inverttool.h","title":"Files"},{"location":"flameshot/inverttool_8cpp/","text":"File inverttool.cpp # FileList > invert > inverttool.cpp Go to the source code of this file. #include \"inverttool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> #include <QPixmap>","title":"File inverttool.cpp"},{"location":"flameshot/inverttool_8cpp/#file-inverttoolcpp","text":"FileList > invert > inverttool.cpp Go to the source code of this file. #include \"inverttool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> #include <QPixmap>","title":"File inverttool.cpp"},{"location":"flameshot/inverttool_8cpp_source/","text":"File inverttool.cpp # File List > invert > inverttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"inverttool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> #include <QPixmap> InvertTool::InvertTool(QObject* parent) : AbstractTwoPointTool(parent) {} QIcon InvertTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"invert.svg\"); } QString InvertTool::name() const { return tr(\"Invert\"); } CaptureTool::Type InvertTool::type() const { return CaptureTool::TYPE_INVERT; } QString InvertTool::description() const { return tr(\"Set Inverter as the paint tool\"); } QRect InvertTool::boundingRect() const { return QRect(points().first, points().second).normalized(); } CaptureTool* InvertTool::copy(QObject* parent) { auto* tool = new InvertTool(parent); copyParams(this, tool); return tool; } void InvertTool::process(QPainter& painter, const QPixmap& pixmap) { QRect selection = boundingRect().intersected(pixmap.rect()); auto pixelRatio = pixmap.devicePixelRatio(); QRect selectionScaled = QRect(selection.topLeft() * pixelRatio, selection.bottomRight() * pixelRatio); // Invert selection QPixmap inv = pixmap.copy(selectionScaled); QImage img = inv.toImage(); img.invertPixels(); painter.drawImage(selection, img); } void InvertTool::drawSearchArea(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.fillRect(boundingRect(), QBrush(Qt::black)); } void InvertTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(context) Q_UNUSED(painter) } void InvertTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File inverttool.cpp"},{"location":"flameshot/inverttool_8cpp_source/#file-inverttoolcpp","text":"File List > invert > inverttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"inverttool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> #include <QPixmap> InvertTool::InvertTool(QObject* parent) : AbstractTwoPointTool(parent) {} QIcon InvertTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"invert.svg\"); } QString InvertTool::name() const { return tr(\"Invert\"); } CaptureTool::Type InvertTool::type() const { return CaptureTool::TYPE_INVERT; } QString InvertTool::description() const { return tr(\"Set Inverter as the paint tool\"); } QRect InvertTool::boundingRect() const { return QRect(points().first, points().second).normalized(); } CaptureTool* InvertTool::copy(QObject* parent) { auto* tool = new InvertTool(parent); copyParams(this, tool); return tool; } void InvertTool::process(QPainter& painter, const QPixmap& pixmap) { QRect selection = boundingRect().intersected(pixmap.rect()); auto pixelRatio = pixmap.devicePixelRatio(); QRect selectionScaled = QRect(selection.topLeft() * pixelRatio, selection.bottomRight() * pixelRatio); // Invert selection QPixmap inv = pixmap.copy(selectionScaled); QImage img = inv.toImage(); img.invertPixels(); painter.drawImage(selection, img); } void InvertTool::drawSearchArea(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.fillRect(boundingRect(), QBrush(Qt::black)); } void InvertTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(context) Q_UNUSED(painter) } void InvertTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File inverttool.cpp"},{"location":"flameshot/inverttool_8h/","text":"File inverttool.h # FileList > invert > inverttool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class InvertTool","title":"File inverttool.h"},{"location":"flameshot/inverttool_8h/#file-inverttoolh","text":"FileList > invert > inverttool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File inverttool.h"},{"location":"flameshot/inverttool_8h/#classes","text":"Type Name class InvertTool","title":"Classes"},{"location":"flameshot/inverttool_8h_source/","text":"File inverttool.h # File List > invert > inverttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class InvertTool : public AbstractTwoPointTool { Q_OBJECT public: explicit InvertTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void drawSearchArea(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File inverttool.h"},{"location":"flameshot/inverttool_8h_source/#file-inverttoolh","text":"File List > invert > inverttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class InvertTool : public AbstractTwoPointTool { Q_OBJECT public: explicit InvertTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void drawSearchArea(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File inverttool.h"},{"location":"flameshot/dir_326deb5008ae61e8c45a344032652c44/","text":"Dir launcher # FileList > launcher Files # Type Name file applaunchertool.cpp file applaunchertool.h file applauncherwidget.cpp file applauncherwidget.h file launcheritemdelegate.cpp file launcheritemdelegate.h file openwithprogram.cpp file openwithprogram.h file terminallauncher.cpp file terminallauncher.h","title":"Dir launcher"},{"location":"flameshot/dir_326deb5008ae61e8c45a344032652c44/#dir-launcher","text":"FileList > launcher","title":"Dir launcher"},{"location":"flameshot/dir_326deb5008ae61e8c45a344032652c44/#files","text":"Type Name file applaunchertool.cpp file applaunchertool.h file applauncherwidget.cpp file applauncherwidget.h file launcheritemdelegate.cpp file launcheritemdelegate.h file openwithprogram.cpp file openwithprogram.h file terminallauncher.cpp file terminallauncher.h","title":"Files"},{"location":"flameshot/applaunchertool_8cpp/","text":"File applaunchertool.cpp # FileList > launcher > applaunchertool.cpp Go to the source code of this file. #include \"applaunchertool.h\" #include \"applauncherwidget.h\"","title":"File applaunchertool.cpp"},{"location":"flameshot/applaunchertool_8cpp/#file-applaunchertoolcpp","text":"FileList > launcher > applaunchertool.cpp Go to the source code of this file. #include \"applaunchertool.h\" #include \"applauncherwidget.h\"","title":"File applaunchertool.cpp"},{"location":"flameshot/applaunchertool_8cpp_source/","text":"File applaunchertool.cpp # File List > launcher > applaunchertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"applaunchertool.h\" #include \"applauncherwidget.h\" AppLauncher::AppLauncher(QObject* parent) : AbstractActionTool(parent) {} bool AppLauncher::closeOnButtonPressed() const { return true; } QIcon AppLauncher::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"open_with.svg\"); } QString AppLauncher::name() const { return tr(\"App Launcher\"); } CaptureTool::Type AppLauncher::type() const { return CaptureTool::TYPE_OPEN_APP; } QString AppLauncher::description() const { return tr(\"Choose an app to open the capture\"); } QWidget* AppLauncher::widget() { return new AppLauncherWidget(capture); } CaptureTool* AppLauncher::copy(QObject* parent) { return new AppLauncher(parent); } void AppLauncher::pressed(CaptureContext& context) { capture = context.selectedScreenshotArea(); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_ADD_EXTERNAL_WIDGETS); emit requestAction(REQ_CLOSE_GUI); }","title":"File applaunchertool.cpp"},{"location":"flameshot/applaunchertool_8cpp_source/#file-applaunchertoolcpp","text":"File List > launcher > applaunchertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"applaunchertool.h\" #include \"applauncherwidget.h\" AppLauncher::AppLauncher(QObject* parent) : AbstractActionTool(parent) {} bool AppLauncher::closeOnButtonPressed() const { return true; } QIcon AppLauncher::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"open_with.svg\"); } QString AppLauncher::name() const { return tr(\"App Launcher\"); } CaptureTool::Type AppLauncher::type() const { return CaptureTool::TYPE_OPEN_APP; } QString AppLauncher::description() const { return tr(\"Choose an app to open the capture\"); } QWidget* AppLauncher::widget() { return new AppLauncherWidget(capture); } CaptureTool* AppLauncher::copy(QObject* parent) { return new AppLauncher(parent); } void AppLauncher::pressed(CaptureContext& context) { capture = context.selectedScreenshotArea(); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_ADD_EXTERNAL_WIDGETS); emit requestAction(REQ_CLOSE_GUI); }","title":"File applaunchertool.cpp"},{"location":"flameshot/applaunchertool_8h/","text":"File applaunchertool.h # FileList > launcher > applaunchertool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class AppLauncher","title":"File applaunchertool.h"},{"location":"flameshot/applaunchertool_8h/#file-applaunchertoolh","text":"FileList > launcher > applaunchertool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File applaunchertool.h"},{"location":"flameshot/applaunchertool_8h/#classes","text":"Type Name class AppLauncher","title":"Classes"},{"location":"flameshot/applaunchertool_8h_source/","text":"File applaunchertool.h # File List > launcher > applaunchertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class AppLauncher : public AbstractActionTool { Q_OBJECT public: explicit AppLauncher(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QWidget* widget() override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPixmap capture; };","title":"File applaunchertool.h"},{"location":"flameshot/applaunchertool_8h_source/#file-applaunchertoolh","text":"File List > launcher > applaunchertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class AppLauncher : public AbstractActionTool { Q_OBJECT public: explicit AppLauncher(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QWidget* widget() override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QPixmap capture; };","title":"File applaunchertool.h"},{"location":"flameshot/applauncherwidget_8cpp/","text":"File applauncherwidget.cpp # FileList > launcher > applauncherwidget.cpp Go to the source code of this file. #include \"applauncherwidget.h\" #include \"src/tools/launcher/launcheritemdelegate.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"terminallauncher.h\" #include <QCheckBox> #include <QDir> #include <QHBoxLayout> #include <QKeyEvent> #include <QLineEdit> #include <QList> #include <QListView> #include <QListWidgetItem> #include <QMessageBox> #include <QPixmap> #include <QProcess> #include <QStandardPaths> #include <QTabWidget>","title":"File applauncherwidget.cpp"},{"location":"flameshot/applauncherwidget_8cpp/#file-applauncherwidgetcpp","text":"FileList > launcher > applauncherwidget.cpp Go to the source code of this file. #include \"applauncherwidget.h\" #include \"src/tools/launcher/launcheritemdelegate.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"terminallauncher.h\" #include <QCheckBox> #include <QDir> #include <QHBoxLayout> #include <QKeyEvent> #include <QLineEdit> #include <QList> #include <QListView> #include <QListWidgetItem> #include <QMessageBox> #include <QPixmap> #include <QProcess> #include <QStandardPaths> #include <QTabWidget>","title":"File applauncherwidget.cpp"},{"location":"flameshot/applauncherwidget_8cpp_source/","text":"File applauncherwidget.cpp # File List > launcher > applauncherwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"applauncherwidget.h\" #include \"src/tools/launcher/launcheritemdelegate.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"terminallauncher.h\" #include <QCheckBox> #include <QDir> #include <QHBoxLayout> #include <QKeyEvent> #include <QLineEdit> #include <QList> #include <QListView> #include <QListWidgetItem> #include <QMessageBox> #include <QPixmap> #include <QProcess> #include <QStandardPaths> #include <QTabWidget> namespace { #if defined(Q_OS_WIN) QMap<QString, QString> catIconNames({ { \"Graphics\", \"image.svg\" }, { \"Utility\", \"apps.svg\" } }); } #else QMap<QString, QString> catIconNames( { { \"Multimedia\", \"applications-multimedia\" }, { \"Development\", \"applications-development\" }, { \"Graphics\", \"applications-graphics\" }, { \"Network\", \"preferences-system-network\" }, { \"Office\", \"applications-office\" }, { \"Science\", \"applications-science\" }, { \"Settings\", \"preferences-desktop\" }, { \"System\", \"preferences-system\" }, { \"Utility\", \"applications-utilities\" } }); } #endif AppLauncherWidget::AppLauncherWidget(const QPixmap& p, QWidget* parent) : QWidget(parent) , m_pixmap(p) { setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Open With\")); m_keepOpen = ConfigHandler().keepOpenAppLauncher(); #if defined(Q_OS_WIN) QDir userAppsFolder( QStandardPaths::standardLocations(QStandardPaths::ApplicationsLocation) .at(0)); m_parser.processDirectory(userAppsFolder); QString dir(m_parser.getAllUsersStartMenuPath()); if (!dir.isEmpty()) { QDir allUserAppsFolder(dir); m_parser.processDirectory(allUserAppsFolder); } #else QString dirLocal = QDir::homePath() + \"/.local/share/applications/\"; QDir appsDirLocal(dirLocal); m_parser.processDirectory(appsDirLocal); QString dir = QStringLiteral(\"/usr/share/applications/\"); QDir appsDir(dir); m_parser.processDirectory(appsDir); #endif initAppMap(); initListWidget(); m_terminalCheckbox = new QCheckBox(tr(\"Launch in terminal\"), this); m_keepOpenCheckbox = new QCheckBox(tr(\"Keep open after selection\"), this); m_keepOpenCheckbox->setChecked(ConfigHandler().keepOpenAppLauncher()); connect(m_keepOpenCheckbox, &QCheckBox::clicked, this, &AppLauncherWidget::checkboxClicked); // search items m_lineEdit = new QLineEdit; connect(m_lineEdit, &QLineEdit::textChanged, this, &AppLauncherWidget::searchChanged); m_filterList = new QListWidget; m_filterList->hide(); configureListView(m_filterList); connect( m_filterList, &QListWidget::clicked, this, &AppLauncherWidget::launch); m_layout = new QVBoxLayout(this); m_layout->addWidget(m_filterList); m_layout->addWidget(m_tabWidget); m_layout->addWidget(m_lineEdit); m_layout->addWidget(m_keepOpenCheckbox); m_layout->addWidget(m_terminalCheckbox); m_lineEdit->setFocus(); } void AppLauncherWidget::launch(const QModelIndex& index) { if (!QFileInfo(m_tempFile).isReadable()) { m_tempFile = FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\"); bool ok = m_pixmap.save(m_tempFile); if (!ok) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to write in\") + QDir::tempPath()); return; } } // Heuristically, if there is a % in the command we assume it is the file // name slot QString command = index.data(Qt::UserRole).toString(); #if defined(Q_OS_WIN) // Do not split on Windows, since file path can contain spaces // and % is not used in lnk files QStringList prog_args; prog_args << command; #else QStringList prog_args = command.split(\" \"); #endif // no quotes because it is going in an array! if (command.contains(\"%\")) { // but that means we need to substitute IN the array not the string! for (auto& i : prog_args) { if (i.contains(\"%\")) i.replace(QRegExp(\"(\\\\%.)\"), m_tempFile); } } else { // we really should append the file name if there prog_args.append(m_tempFile); // were no replacements } QString app_name = prog_args.at(0); bool inTerminal = index.data(Qt::UserRole + 1).toBool() || m_terminalCheckbox->isChecked(); if (inTerminal) { bool ok = TerminalLauncher::launchDetached(command); if (!ok) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to launch in terminal.\")); } } else { QFileInfo fi(m_tempFile); QString workingDir = fi.absolutePath(); prog_args.removeAt(0); // strip program name out QProcess::startDetached(app_name, prog_args, workingDir); } if (!m_keepOpen) { close(); } } void AppLauncherWidget::checkboxClicked(const bool enabled) { m_keepOpen = enabled; ConfigHandler().setKeepOpenAppLauncher(enabled); m_keepOpenCheckbox->setChecked(enabled); } void AppLauncherWidget::searchChanged(const QString& text) { if (text.isEmpty()) { m_filterList->hide(); m_tabWidget->show(); } else { m_tabWidget->hide(); m_filterList->show(); m_filterList->clear(); QRegExp regexp(text, Qt::CaseInsensitive, QRegExp::Wildcard); QVector<DesktopAppData> apps; for (auto const& i : catIconNames.toStdMap()) { const QString& cat = i.first; if (!m_appsMap.contains(cat)) { continue; } const QVector<DesktopAppData>& appList = m_appsMap[cat]; for (const DesktopAppData& app : appList) { if (!apps.contains(app) && (app.name.contains(regexp) || app.description.contains(regexp))) { apps.append(app); } } } addAppsToListWidget(m_filterList, apps); } } void AppLauncherWidget::initListWidget() { m_tabWidget = new QTabWidget; const int size = GlobalValues::buttonBaseSize(); m_tabWidget->setIconSize(QSize(size, size)); for (auto const& i : catIconNames.toStdMap()) { const QString& cat = i.first; const QString& iconName = i.second; if (!m_appsMap.contains(cat)) { continue; } auto* itemsWidget = new QListWidget(); configureListView(itemsWidget); const QVector<DesktopAppData>& appList = m_appsMap[cat]; addAppsToListWidget(itemsWidget, appList); #if defined(Q_OS_WIN) QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); m_tabWidget->addTab( itemsWidget, QIcon(modifier + iconName), QLatin1String(\"\")); #else m_tabWidget->addTab( itemsWidget, QIcon::fromTheme(iconName), QLatin1String(\"\")); #endif m_tabWidget->setTabToolTip(m_tabWidget->count(), cat); if (cat == QLatin1String(\"Graphics\")) { m_tabWidget->setCurrentIndex(m_tabWidget->count() - 1); } } } void AppLauncherWidget::initAppMap() { QStringList categories({ \"AudioVideo\", \"Audio\", \"Video\", \"Development\", \"Graphics\", \"Network\", \"Office\", \"Science\", \"Settings\", \"System\", \"Utility\" }); m_appsMap = m_parser.getAppsByCategory(categories); // Unify multimedia. QVector<DesktopAppData> multimediaList; QStringList multimediaNames; multimediaNames << QStringLiteral(\"AudioVideo\") << QStringLiteral(\"Audio\") << QStringLiteral(\"Video\"); for (const QString& name : qAsConst(multimediaNames)) { if (!m_appsMap.contains(name)) { continue; } for (const auto& i : m_appsMap[name]) { if (!multimediaList.contains(i)) { multimediaList.append(i); } } m_appsMap.remove(name); } if (!multimediaList.isEmpty()) { m_appsMap.insert(QStringLiteral(\"Multimedia\"), multimediaList); } } void AppLauncherWidget::configureListView(QListWidget* widget) { widget->setItemDelegate(new LauncherItemDelegate()); widget->setViewMode(QListWidget::IconMode); widget->setResizeMode(QListView::Adjust); widget->setSpacing(4); widget->setFlow(QListView::LeftToRight); widget->setDragEnabled(false); widget->setMinimumWidth(GlobalValues::buttonBaseSize() * 11); connect(widget, &QListWidget::clicked, this, &AppLauncherWidget::launch); } void AppLauncherWidget::addAppsToListWidget( QListWidget* widget, const QVector<DesktopAppData>& appList) { for (const DesktopAppData& app : appList) { auto* buttonItem = new QListWidgetItem(widget); buttonItem->setData(Qt::DecorationRole, app.icon); buttonItem->setData(Qt::DisplayRole, app.name); buttonItem->setData(Qt::UserRole, app.exec); buttonItem->setData(Qt::UserRole + 1, app.showInTerminal); QColor foregroundColor = this->palette().color(QWidget::foregroundRole()); buttonItem->setForeground(foregroundColor); buttonItem->setIcon(app.icon); buttonItem->setText(app.name); buttonItem->setToolTip(app.description); } } void AppLauncherWidget::keyPressEvent(QKeyEvent* keyEvent) { if (keyEvent->key() == Qt::Key_Escape) { close(); } else { QWidget::keyPressEvent(keyEvent); } }","title":"File applauncherwidget.cpp"},{"location":"flameshot/applauncherwidget_8cpp_source/#file-applauncherwidgetcpp","text":"File List > launcher > applauncherwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"applauncherwidget.h\" #include \"src/tools/launcher/launcheritemdelegate.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"terminallauncher.h\" #include <QCheckBox> #include <QDir> #include <QHBoxLayout> #include <QKeyEvent> #include <QLineEdit> #include <QList> #include <QListView> #include <QListWidgetItem> #include <QMessageBox> #include <QPixmap> #include <QProcess> #include <QStandardPaths> #include <QTabWidget> namespace { #if defined(Q_OS_WIN) QMap<QString, QString> catIconNames({ { \"Graphics\", \"image.svg\" }, { \"Utility\", \"apps.svg\" } }); } #else QMap<QString, QString> catIconNames( { { \"Multimedia\", \"applications-multimedia\" }, { \"Development\", \"applications-development\" }, { \"Graphics\", \"applications-graphics\" }, { \"Network\", \"preferences-system-network\" }, { \"Office\", \"applications-office\" }, { \"Science\", \"applications-science\" }, { \"Settings\", \"preferences-desktop\" }, { \"System\", \"preferences-system\" }, { \"Utility\", \"applications-utilities\" } }); } #endif AppLauncherWidget::AppLauncherWidget(const QPixmap& p, QWidget* parent) : QWidget(parent) , m_pixmap(p) { setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Open With\")); m_keepOpen = ConfigHandler().keepOpenAppLauncher(); #if defined(Q_OS_WIN) QDir userAppsFolder( QStandardPaths::standardLocations(QStandardPaths::ApplicationsLocation) .at(0)); m_parser.processDirectory(userAppsFolder); QString dir(m_parser.getAllUsersStartMenuPath()); if (!dir.isEmpty()) { QDir allUserAppsFolder(dir); m_parser.processDirectory(allUserAppsFolder); } #else QString dirLocal = QDir::homePath() + \"/.local/share/applications/\"; QDir appsDirLocal(dirLocal); m_parser.processDirectory(appsDirLocal); QString dir = QStringLiteral(\"/usr/share/applications/\"); QDir appsDir(dir); m_parser.processDirectory(appsDir); #endif initAppMap(); initListWidget(); m_terminalCheckbox = new QCheckBox(tr(\"Launch in terminal\"), this); m_keepOpenCheckbox = new QCheckBox(tr(\"Keep open after selection\"), this); m_keepOpenCheckbox->setChecked(ConfigHandler().keepOpenAppLauncher()); connect(m_keepOpenCheckbox, &QCheckBox::clicked, this, &AppLauncherWidget::checkboxClicked); // search items m_lineEdit = new QLineEdit; connect(m_lineEdit, &QLineEdit::textChanged, this, &AppLauncherWidget::searchChanged); m_filterList = new QListWidget; m_filterList->hide(); configureListView(m_filterList); connect( m_filterList, &QListWidget::clicked, this, &AppLauncherWidget::launch); m_layout = new QVBoxLayout(this); m_layout->addWidget(m_filterList); m_layout->addWidget(m_tabWidget); m_layout->addWidget(m_lineEdit); m_layout->addWidget(m_keepOpenCheckbox); m_layout->addWidget(m_terminalCheckbox); m_lineEdit->setFocus(); } void AppLauncherWidget::launch(const QModelIndex& index) { if (!QFileInfo(m_tempFile).isReadable()) { m_tempFile = FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\"); bool ok = m_pixmap.save(m_tempFile); if (!ok) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to write in\") + QDir::tempPath()); return; } } // Heuristically, if there is a % in the command we assume it is the file // name slot QString command = index.data(Qt::UserRole).toString(); #if defined(Q_OS_WIN) // Do not split on Windows, since file path can contain spaces // and % is not used in lnk files QStringList prog_args; prog_args << command; #else QStringList prog_args = command.split(\" \"); #endif // no quotes because it is going in an array! if (command.contains(\"%\")) { // but that means we need to substitute IN the array not the string! for (auto& i : prog_args) { if (i.contains(\"%\")) i.replace(QRegExp(\"(\\\\%.)\"), m_tempFile); } } else { // we really should append the file name if there prog_args.append(m_tempFile); // were no replacements } QString app_name = prog_args.at(0); bool inTerminal = index.data(Qt::UserRole + 1).toBool() || m_terminalCheckbox->isChecked(); if (inTerminal) { bool ok = TerminalLauncher::launchDetached(command); if (!ok) { QMessageBox::about( this, tr(\"Error\"), tr(\"Unable to launch in terminal.\")); } } else { QFileInfo fi(m_tempFile); QString workingDir = fi.absolutePath(); prog_args.removeAt(0); // strip program name out QProcess::startDetached(app_name, prog_args, workingDir); } if (!m_keepOpen) { close(); } } void AppLauncherWidget::checkboxClicked(const bool enabled) { m_keepOpen = enabled; ConfigHandler().setKeepOpenAppLauncher(enabled); m_keepOpenCheckbox->setChecked(enabled); } void AppLauncherWidget::searchChanged(const QString& text) { if (text.isEmpty()) { m_filterList->hide(); m_tabWidget->show(); } else { m_tabWidget->hide(); m_filterList->show(); m_filterList->clear(); QRegExp regexp(text, Qt::CaseInsensitive, QRegExp::Wildcard); QVector<DesktopAppData> apps; for (auto const& i : catIconNames.toStdMap()) { const QString& cat = i.first; if (!m_appsMap.contains(cat)) { continue; } const QVector<DesktopAppData>& appList = m_appsMap[cat]; for (const DesktopAppData& app : appList) { if (!apps.contains(app) && (app.name.contains(regexp) || app.description.contains(regexp))) { apps.append(app); } } } addAppsToListWidget(m_filterList, apps); } } void AppLauncherWidget::initListWidget() { m_tabWidget = new QTabWidget; const int size = GlobalValues::buttonBaseSize(); m_tabWidget->setIconSize(QSize(size, size)); for (auto const& i : catIconNames.toStdMap()) { const QString& cat = i.first; const QString& iconName = i.second; if (!m_appsMap.contains(cat)) { continue; } auto* itemsWidget = new QListWidget(); configureListView(itemsWidget); const QVector<DesktopAppData>& appList = m_appsMap[cat]; addAppsToListWidget(itemsWidget, appList); #if defined(Q_OS_WIN) QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); m_tabWidget->addTab( itemsWidget, QIcon(modifier + iconName), QLatin1String(\"\")); #else m_tabWidget->addTab( itemsWidget, QIcon::fromTheme(iconName), QLatin1String(\"\")); #endif m_tabWidget->setTabToolTip(m_tabWidget->count(), cat); if (cat == QLatin1String(\"Graphics\")) { m_tabWidget->setCurrentIndex(m_tabWidget->count() - 1); } } } void AppLauncherWidget::initAppMap() { QStringList categories({ \"AudioVideo\", \"Audio\", \"Video\", \"Development\", \"Graphics\", \"Network\", \"Office\", \"Science\", \"Settings\", \"System\", \"Utility\" }); m_appsMap = m_parser.getAppsByCategory(categories); // Unify multimedia. QVector<DesktopAppData> multimediaList; QStringList multimediaNames; multimediaNames << QStringLiteral(\"AudioVideo\") << QStringLiteral(\"Audio\") << QStringLiteral(\"Video\"); for (const QString& name : qAsConst(multimediaNames)) { if (!m_appsMap.contains(name)) { continue; } for (const auto& i : m_appsMap[name]) { if (!multimediaList.contains(i)) { multimediaList.append(i); } } m_appsMap.remove(name); } if (!multimediaList.isEmpty()) { m_appsMap.insert(QStringLiteral(\"Multimedia\"), multimediaList); } } void AppLauncherWidget::configureListView(QListWidget* widget) { widget->setItemDelegate(new LauncherItemDelegate()); widget->setViewMode(QListWidget::IconMode); widget->setResizeMode(QListView::Adjust); widget->setSpacing(4); widget->setFlow(QListView::LeftToRight); widget->setDragEnabled(false); widget->setMinimumWidth(GlobalValues::buttonBaseSize() * 11); connect(widget, &QListWidget::clicked, this, &AppLauncherWidget::launch); } void AppLauncherWidget::addAppsToListWidget( QListWidget* widget, const QVector<DesktopAppData>& appList) { for (const DesktopAppData& app : appList) { auto* buttonItem = new QListWidgetItem(widget); buttonItem->setData(Qt::DecorationRole, app.icon); buttonItem->setData(Qt::DisplayRole, app.name); buttonItem->setData(Qt::UserRole, app.exec); buttonItem->setData(Qt::UserRole + 1, app.showInTerminal); QColor foregroundColor = this->palette().color(QWidget::foregroundRole()); buttonItem->setForeground(foregroundColor); buttonItem->setIcon(app.icon); buttonItem->setText(app.name); buttonItem->setToolTip(app.description); } } void AppLauncherWidget::keyPressEvent(QKeyEvent* keyEvent) { if (keyEvent->key() == Qt::Key_Escape) { close(); } else { QWidget::keyPressEvent(keyEvent); } }","title":"File applauncherwidget.cpp"},{"location":"flameshot/applauncherwidget_8h/","text":"File applauncherwidget.h # FileList > launcher > applauncherwidget.h Go to the source code of this file. #include <QMap> #include <QWidget> #include \"src/utils/desktopfileparse.h\" Classes # Type Name class AppLauncherWidget","title":"File applauncherwidget.h"},{"location":"flameshot/applauncherwidget_8h/#file-applauncherwidgeth","text":"FileList > launcher > applauncherwidget.h Go to the source code of this file. #include <QMap> #include <QWidget> #include \"src/utils/desktopfileparse.h\"","title":"File applauncherwidget.h"},{"location":"flameshot/applauncherwidget_8h/#classes","text":"Type Name class AppLauncherWidget","title":"Classes"},{"location":"flameshot/applauncherwidget_8h_source/","text":"File applauncherwidget.h # File List > launcher > applauncherwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QMap> #include <QWidget> #if defined(Q_OS_WIN) #include \"src/utils/winlnkfileparse.h\" #else #include \"src/utils/desktopfileparse.h\" #endif class QTabWidget; class QCheckBox; class QVBoxLayout; class QLineEdit; class QListWidget; class AppLauncherWidget : public QWidget { Q_OBJECT public: explicit AppLauncherWidget(const QPixmap& p, QWidget* parent = nullptr); private slots: void launch(const QModelIndex& index); void checkboxClicked(const bool enabled); void searchChanged(const QString& text); private: void initListWidget(); void initAppMap(); void configureListView(QListWidget* widget); void addAppsToListWidget(QListWidget* widget, const QVector<DesktopAppData>& appList); void keyPressEvent(QKeyEvent* keyEvent) override; #if defined(Q_OS_WIN) WinLnkFileParser m_parser; #else DesktopFileParser m_parser; #endif QPixmap m_pixmap; QString m_tempFile; bool m_keepOpen; QMap<QString, QVector<DesktopAppData>> m_appsMap; QCheckBox* m_keepOpenCheckbox; QCheckBox* m_terminalCheckbox; QVBoxLayout* m_layout; QLineEdit* m_lineEdit; QListWidget* m_filterList; QTabWidget* m_tabWidget; };","title":"File applauncherwidget.h"},{"location":"flameshot/applauncherwidget_8h_source/#file-applauncherwidgeth","text":"File List > launcher > applauncherwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QMap> #include <QWidget> #if defined(Q_OS_WIN) #include \"src/utils/winlnkfileparse.h\" #else #include \"src/utils/desktopfileparse.h\" #endif class QTabWidget; class QCheckBox; class QVBoxLayout; class QLineEdit; class QListWidget; class AppLauncherWidget : public QWidget { Q_OBJECT public: explicit AppLauncherWidget(const QPixmap& p, QWidget* parent = nullptr); private slots: void launch(const QModelIndex& index); void checkboxClicked(const bool enabled); void searchChanged(const QString& text); private: void initListWidget(); void initAppMap(); void configureListView(QListWidget* widget); void addAppsToListWidget(QListWidget* widget, const QVector<DesktopAppData>& appList); void keyPressEvent(QKeyEvent* keyEvent) override; #if defined(Q_OS_WIN) WinLnkFileParser m_parser; #else DesktopFileParser m_parser; #endif QPixmap m_pixmap; QString m_tempFile; bool m_keepOpen; QMap<QString, QVector<DesktopAppData>> m_appsMap; QCheckBox* m_keepOpenCheckbox; QCheckBox* m_terminalCheckbox; QVBoxLayout* m_layout; QLineEdit* m_lineEdit; QListWidget* m_filterList; QTabWidget* m_tabWidget; };","title":"File applauncherwidget.h"},{"location":"flameshot/launcheritemdelegate_8cpp/","text":"File launcheritemdelegate.cpp # FileList > launcher > launcheritemdelegate.cpp Go to the source code of this file. #include \"launcheritemdelegate.h\" #include \"src/utils/globalvalues.h\" #include <QPainter>","title":"File launcheritemdelegate.cpp"},{"location":"flameshot/launcheritemdelegate_8cpp/#file-launcheritemdelegatecpp","text":"FileList > launcher > launcheritemdelegate.cpp Go to the source code of this file. #include \"launcheritemdelegate.h\" #include \"src/utils/globalvalues.h\" #include <QPainter>","title":"File launcheritemdelegate.cpp"},{"location":"flameshot/launcheritemdelegate_8cpp_source/","text":"File launcheritemdelegate.cpp # File List > launcher > launcheritemdelegate.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"launcheritemdelegate.h\" #include \"src/utils/globalvalues.h\" #include <QPainter> LauncherItemDelegate::LauncherItemDelegate(QObject* parent) : QStyledItemDelegate(parent) {} void LauncherItemDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const { const QRect& rect = option.rect; if (option.state & (QStyle::State_Selected | QStyle::State_MouseOver)) { painter->save(); painter->setPen(Qt::transparent); painter->setBrush(QPalette().highlight()); painter->drawRect( rect.x(), rect.y(), rect.width() - 1, rect.height() - 1); painter->restore(); } auto icon = index.data(Qt::DecorationRole).value<QIcon>(); const int iconSide = static_cast<int>(GlobalValues::buttonBaseSize() * 1.3); const int halfIcon = iconSide / 2; const int halfWidth = rect.width() / 2; const int halfHeight = rect.height() / 2; QSize size(iconSide, iconSide); QPixmap pixIcon = icon.pixmap(size).scaled( size, Qt::KeepAspectRatio, Qt::SmoothTransformation); painter->drawPixmap(rect.x() + (halfWidth - halfIcon), rect.y() + (halfHeight / 2 - halfIcon), iconSide, iconSide, pixIcon); const QRect textRect( rect.x(), rect.y() + halfHeight, rect.width(), halfHeight); painter->drawText(textRect, Qt::TextWordWrap | Qt::AlignHCenter, index.data(Qt::DisplayRole).toString()); } QSize LauncherItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const { Q_UNUSED(option) Q_UNUSED(index) const int size = GlobalValues::buttonBaseSize(); return { static_cast<int>(size * 3.2), static_cast<int>(size * 3.7) }; }","title":"File launcheritemdelegate.cpp"},{"location":"flameshot/launcheritemdelegate_8cpp_source/#file-launcheritemdelegatecpp","text":"File List > launcher > launcheritemdelegate.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"launcheritemdelegate.h\" #include \"src/utils/globalvalues.h\" #include <QPainter> LauncherItemDelegate::LauncherItemDelegate(QObject* parent) : QStyledItemDelegate(parent) {} void LauncherItemDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const { const QRect& rect = option.rect; if (option.state & (QStyle::State_Selected | QStyle::State_MouseOver)) { painter->save(); painter->setPen(Qt::transparent); painter->setBrush(QPalette().highlight()); painter->drawRect( rect.x(), rect.y(), rect.width() - 1, rect.height() - 1); painter->restore(); } auto icon = index.data(Qt::DecorationRole).value<QIcon>(); const int iconSide = static_cast<int>(GlobalValues::buttonBaseSize() * 1.3); const int halfIcon = iconSide / 2; const int halfWidth = rect.width() / 2; const int halfHeight = rect.height() / 2; QSize size(iconSide, iconSide); QPixmap pixIcon = icon.pixmap(size).scaled( size, Qt::KeepAspectRatio, Qt::SmoothTransformation); painter->drawPixmap(rect.x() + (halfWidth - halfIcon), rect.y() + (halfHeight / 2 - halfIcon), iconSide, iconSide, pixIcon); const QRect textRect( rect.x(), rect.y() + halfHeight, rect.width(), halfHeight); painter->drawText(textRect, Qt::TextWordWrap | Qt::AlignHCenter, index.data(Qt::DisplayRole).toString()); } QSize LauncherItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const { Q_UNUSED(option) Q_UNUSED(index) const int size = GlobalValues::buttonBaseSize(); return { static_cast<int>(size * 3.2), static_cast<int>(size * 3.7) }; }","title":"File launcheritemdelegate.cpp"},{"location":"flameshot/launcheritemdelegate_8h/","text":"File launcheritemdelegate.h # FileList > launcher > launcheritemdelegate.h Go to the source code of this file. #include \"src/utils/desktopfileparse.h\" #include <QStyledItemDelegate> Classes # Type Name class LauncherItemDelegate","title":"File launcheritemdelegate.h"},{"location":"flameshot/launcheritemdelegate_8h/#file-launcheritemdelegateh","text":"FileList > launcher > launcheritemdelegate.h Go to the source code of this file. #include \"src/utils/desktopfileparse.h\" #include <QStyledItemDelegate>","title":"File launcheritemdelegate.h"},{"location":"flameshot/launcheritemdelegate_8h/#classes","text":"Type Name class LauncherItemDelegate","title":"Classes"},{"location":"flameshot/launcheritemdelegate_8h_source/","text":"File launcheritemdelegate.h # File List > launcher > launcheritemdelegate.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/utils/desktopfileparse.h\" #include <QStyledItemDelegate> class LauncherItemDelegate : public QStyledItemDelegate { Q_OBJECT public: explicit LauncherItemDelegate(QObject* parent = nullptr); void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override; QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override; };","title":"File launcheritemdelegate.h"},{"location":"flameshot/launcheritemdelegate_8h_source/#file-launcheritemdelegateh","text":"File List > launcher > launcheritemdelegate.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/utils/desktopfileparse.h\" #include <QStyledItemDelegate> class LauncherItemDelegate : public QStyledItemDelegate { Q_OBJECT public: explicit LauncherItemDelegate(QObject* parent = nullptr); void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override; QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override; };","title":"File launcheritemdelegate.h"},{"location":"flameshot/openwithprogram_8cpp/","text":"File openwithprogram.cpp # FileList > launcher > openwithprogram.cpp Go to the source code of this file. #include \"openwithprogram.h\" #include \"src/tools/launcher/applauncherwidget.h\" Public Functions # Type Name void showOpenWithMenu (const QPixmap & capture) Public Functions Documentation # function showOpenWithMenu # void showOpenWithMenu ( const QPixmap & capture )","title":"File openwithprogram.cpp"},{"location":"flameshot/openwithprogram_8cpp/#file-openwithprogramcpp","text":"FileList > launcher > openwithprogram.cpp Go to the source code of this file. #include \"openwithprogram.h\" #include \"src/tools/launcher/applauncherwidget.h\"","title":"File openwithprogram.cpp"},{"location":"flameshot/openwithprogram_8cpp/#public-functions","text":"Type Name void showOpenWithMenu (const QPixmap & capture)","title":"Public Functions"},{"location":"flameshot/openwithprogram_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/openwithprogram_8cpp/#function-showopenwithmenu","text":"void showOpenWithMenu ( const QPixmap & capture )","title":"function showOpenWithMenu"},{"location":"flameshot/openwithprogram_8cpp_source/","text":"File openwithprogram.cpp # File List > launcher > openwithprogram.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"openwithprogram.h\" #if defined(Q_OS_WIN) #include \"src/utils/filenamehandler.h\" #include <QDir> #include <QMessageBox> #include <windows.h> #ifdef _WIN32_WINNT #undef _WIN32_WINNT #define _WIN32_WINNT 0x601 #endif #include <Shlobj.h> #pragma comment(lib, \"Shell32.lib\") #else #include \"src/tools/launcher/applauncherwidget.h\" #endif void showOpenWithMenu(const QPixmap& capture) { #if defined(Q_OS_WIN) QString tempFile = FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\"); bool ok = capture.save(tempFile); if (!ok) { QMessageBox::about(nullptr, QObject::tr(\"Error\"), QObject::tr(\"Unable to write in\") + QDir::tempPath()); return; } OPENASINFO info; auto wStringFile = tempFile.replace(\"/\", \"\\\\\").toStdWString(); info.pcszFile = wStringFile.c_str(); info.pcszClass = nullptr; info.oaifInFlags = OAIF_ALLOW_REGISTRATION | OAIF_EXEC; SHOpenWithDialog(nullptr, &info); #else auto* w = new AppLauncherWidget(capture); w->show(); #endif }","title":"File openwithprogram.cpp"},{"location":"flameshot/openwithprogram_8cpp_source/#file-openwithprogramcpp","text":"File List > launcher > openwithprogram.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"openwithprogram.h\" #if defined(Q_OS_WIN) #include \"src/utils/filenamehandler.h\" #include <QDir> #include <QMessageBox> #include <windows.h> #ifdef _WIN32_WINNT #undef _WIN32_WINNT #define _WIN32_WINNT 0x601 #endif #include <Shlobj.h> #pragma comment(lib, \"Shell32.lib\") #else #include \"src/tools/launcher/applauncherwidget.h\" #endif void showOpenWithMenu(const QPixmap& capture) { #if defined(Q_OS_WIN) QString tempFile = FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\"); bool ok = capture.save(tempFile); if (!ok) { QMessageBox::about(nullptr, QObject::tr(\"Error\"), QObject::tr(\"Unable to write in\") + QDir::tempPath()); return; } OPENASINFO info; auto wStringFile = tempFile.replace(\"/\", \"\\\\\").toStdWString(); info.pcszFile = wStringFile.c_str(); info.pcszClass = nullptr; info.oaifInFlags = OAIF_ALLOW_REGISTRATION | OAIF_EXEC; SHOpenWithDialog(nullptr, &info); #else auto* w = new AppLauncherWidget(capture); w->show(); #endif }","title":"File openwithprogram.cpp"},{"location":"flameshot/openwithprogram_8h/","text":"File openwithprogram.h # FileList > launcher > openwithprogram.h Go to the source code of this file. #include <QPixmap> Public Functions # Type Name void showOpenWithMenu (const QPixmap & capture) Public Functions Documentation # function showOpenWithMenu # void showOpenWithMenu ( const QPixmap & capture )","title":"File openwithprogram.h"},{"location":"flameshot/openwithprogram_8h/#file-openwithprogramh","text":"FileList > launcher > openwithprogram.h Go to the source code of this file. #include <QPixmap>","title":"File openwithprogram.h"},{"location":"flameshot/openwithprogram_8h/#public-functions","text":"Type Name void showOpenWithMenu (const QPixmap & capture)","title":"Public Functions"},{"location":"flameshot/openwithprogram_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/openwithprogram_8h/#function-showopenwithmenu","text":"void showOpenWithMenu ( const QPixmap & capture )","title":"function showOpenWithMenu"},{"location":"flameshot/openwithprogram_8h_source/","text":"File openwithprogram.h # File List > launcher > openwithprogram.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPixmap> void showOpenWithMenu(const QPixmap& capture);","title":"File openwithprogram.h"},{"location":"flameshot/openwithprogram_8h_source/#file-openwithprogramh","text":"File List > launcher > openwithprogram.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPixmap> void showOpenWithMenu(const QPixmap& capture);","title":"File openwithprogram.h"},{"location":"flameshot/terminallauncher_8cpp/","text":"File terminallauncher.cpp # FileList > launcher > terminallauncher.cpp Go to the source code of this file. #include \"terminallauncher.h\" #include <QDir> #include <QProcess> #include <QProcessEnvironment> #include <QStandardPaths>","title":"File terminallauncher.cpp"},{"location":"flameshot/terminallauncher_8cpp/#file-terminallaunchercpp","text":"FileList > launcher > terminallauncher.cpp Go to the source code of this file. #include \"terminallauncher.h\" #include <QDir> #include <QProcess> #include <QProcessEnvironment> #include <QStandardPaths>","title":"File terminallauncher.cpp"},{"location":"flameshot/terminallauncher_8cpp_source/","text":"File terminallauncher.cpp # File List > launcher > terminallauncher.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"terminallauncher.h\" #include <QDir> #include <QProcess> #include <QProcessEnvironment> #include <QStandardPaths> namespace { static const TerminalApp terminalApps[] = { { \"x-terminal-emulator\", \"-e\" }, { \"xfce4-terminal\", \"-x\" }, { \"konsole\", \"-e\" }, { \"gnome-terminal\", \"--\" }, { \"terminator\", \"-e\" }, { \"terminology\", \"-e\" }, { \"tilix\", \"-e\" }, { \"xterm\", \"-e\" }, { \"aterm\", \"-e\" }, { \"Eterm\", \"-e\" }, { \"rxvt\", \"-e\" }, { \"urxvt\", \"-e\" }, }; } TerminalLauncher::TerminalLauncher(QObject* parent) : QObject(parent) {} TerminalApp TerminalLauncher::getPreferedTerminal() { TerminalApp res; for (const TerminalApp& app : terminalApps) { QString path = QStandardPaths::findExecutable(app.name); if (!path.isEmpty()) { res = app; break; } } return res; } bool TerminalLauncher::launchDetached(const QString& command) { TerminalApp app = getPreferedTerminal(); QString s = app.name + \" \" + app.arg + \" \" + command; return QProcess::startDetached(app.name, { app.arg, command }); }","title":"File terminallauncher.cpp"},{"location":"flameshot/terminallauncher_8cpp_source/#file-terminallaunchercpp","text":"File List > launcher > terminallauncher.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"terminallauncher.h\" #include <QDir> #include <QProcess> #include <QProcessEnvironment> #include <QStandardPaths> namespace { static const TerminalApp terminalApps[] = { { \"x-terminal-emulator\", \"-e\" }, { \"xfce4-terminal\", \"-x\" }, { \"konsole\", \"-e\" }, { \"gnome-terminal\", \"--\" }, { \"terminator\", \"-e\" }, { \"terminology\", \"-e\" }, { \"tilix\", \"-e\" }, { \"xterm\", \"-e\" }, { \"aterm\", \"-e\" }, { \"Eterm\", \"-e\" }, { \"rxvt\", \"-e\" }, { \"urxvt\", \"-e\" }, }; } TerminalLauncher::TerminalLauncher(QObject* parent) : QObject(parent) {} TerminalApp TerminalLauncher::getPreferedTerminal() { TerminalApp res; for (const TerminalApp& app : terminalApps) { QString path = QStandardPaths::findExecutable(app.name); if (!path.isEmpty()) { res = app; break; } } return res; } bool TerminalLauncher::launchDetached(const QString& command) { TerminalApp app = getPreferedTerminal(); QString s = app.name + \" \" + app.arg + \" \" + command; return QProcess::startDetached(app.name, { app.arg, command }); }","title":"File terminallauncher.cpp"},{"location":"flameshot/terminallauncher_8h/","text":"File terminallauncher.h # FileList > launcher > terminallauncher.h Go to the source code of this file. #include <QObject> Classes # Type Name struct TerminalApp class TerminalLauncher","title":"File terminallauncher.h"},{"location":"flameshot/terminallauncher_8h/#file-terminallauncherh","text":"FileList > launcher > terminallauncher.h Go to the source code of this file. #include <QObject>","title":"File terminallauncher.h"},{"location":"flameshot/terminallauncher_8h/#classes","text":"Type Name struct TerminalApp class TerminalLauncher","title":"Classes"},{"location":"flameshot/terminallauncher_8h_source/","text":"File terminallauncher.h # File List > launcher > terminallauncher.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> struct TerminalApp { QString name; QString arg; }; class TerminalLauncher : public QObject { Q_OBJECT public: explicit TerminalLauncher(QObject* parent = nullptr); static bool launchDetached(const QString& command); private: static TerminalApp getPreferedTerminal(); };","title":"File terminallauncher.h"},{"location":"flameshot/terminallauncher_8h_source/#file-terminallauncherh","text":"File List > launcher > terminallauncher.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> struct TerminalApp { QString name; QString arg; }; class TerminalLauncher : public QObject { Q_OBJECT public: explicit TerminalLauncher(QObject* parent = nullptr); static bool launchDetached(const QString& command); private: static TerminalApp getPreferedTerminal(); };","title":"File terminallauncher.h"},{"location":"flameshot/dir_0d0caafe2e9a89cac97883145bdb356a/","text":"Dir line # FileList > line Files # Type Name file linetool.cpp file linetool.h","title":"Dir line"},{"location":"flameshot/dir_0d0caafe2e9a89cac97883145bdb356a/#dir-line","text":"FileList > line","title":"Dir line"},{"location":"flameshot/dir_0d0caafe2e9a89cac97883145bdb356a/#files","text":"Type Name file linetool.cpp file linetool.h","title":"Files"},{"location":"flameshot/linetool_8cpp/","text":"File linetool.cpp # FileList > line > linetool.cpp Go to the source code of this file. #include \"linetool.h\" #include <QPainter>","title":"File linetool.cpp"},{"location":"flameshot/linetool_8cpp/#file-linetoolcpp","text":"FileList > line > linetool.cpp Go to the source code of this file. #include \"linetool.h\" #include <QPainter>","title":"File linetool.cpp"},{"location":"flameshot/linetool_8cpp_source/","text":"File linetool.cpp # File List > line > linetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"linetool.h\" #include <QPainter> LineTool::LineTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon LineTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"line.svg\"); } QString LineTool::name() const { return tr(\"Line\"); } CaptureTool::Type LineTool::type() const { return CaptureTool::TYPE_DRAWER; } QString LineTool::description() const { return tr(\"Set the Line as the paint tool\"); } CaptureTool* LineTool::copy(QObject* parent) { auto* tool = new LineTool(parent); copyParams(this, tool); return tool; } void LineTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawLine(points().first, points().second); } void LineTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File linetool.cpp"},{"location":"flameshot/linetool_8cpp_source/#file-linetoolcpp","text":"File List > line > linetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"linetool.h\" #include <QPainter> LineTool::LineTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon LineTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"line.svg\"); } QString LineTool::name() const { return tr(\"Line\"); } CaptureTool::Type LineTool::type() const { return CaptureTool::TYPE_DRAWER; } QString LineTool::description() const { return tr(\"Set the Line as the paint tool\"); } CaptureTool* LineTool::copy(QObject* parent) { auto* tool = new LineTool(parent); copyParams(this, tool); return tool; } void LineTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(color(), size())); painter.drawLine(points().first, points().second); } void LineTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File linetool.cpp"},{"location":"flameshot/linetool_8h/","text":"File linetool.h # FileList > line > linetool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class LineTool","title":"File linetool.h"},{"location":"flameshot/linetool_8h/#file-linetoolh","text":"FileList > line > linetool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File linetool.h"},{"location":"flameshot/linetool_8h/#classes","text":"Type Name class LineTool","title":"Classes"},{"location":"flameshot/linetool_8h_source/","text":"File linetool.h # File List > line > linetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class LineTool : public AbstractTwoPointTool { Q_OBJECT public: explicit LineTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File linetool.h"},{"location":"flameshot/linetool_8h_source/#file-linetoolh","text":"File List > line > linetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class LineTool : public AbstractTwoPointTool { Q_OBJECT public: explicit LineTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File linetool.h"},{"location":"flameshot/dir_216b21e4e5ad693563f55da5d6bf2868/","text":"Dir marker # FileList > marker Files # Type Name file markertool.cpp file markertool.h","title":"Dir marker"},{"location":"flameshot/dir_216b21e4e5ad693563f55da5d6bf2868/#dir-marker","text":"FileList > marker","title":"Dir marker"},{"location":"flameshot/dir_216b21e4e5ad693563f55da5d6bf2868/#files","text":"Type Name file markertool.cpp file markertool.h","title":"Files"},{"location":"flameshot/markertool_8cpp/","text":"File markertool.cpp # FileList > marker > markertool.cpp Go to the source code of this file. #include \"markertool.h\" #include <QPainter> Macros # Type Name define PADDING_VALUE 14 Macro Definition Documentation # define PADDING_VALUE # #define PADDING_VALUE 14","title":"File markertool.cpp"},{"location":"flameshot/markertool_8cpp/#file-markertoolcpp","text":"FileList > marker > markertool.cpp Go to the source code of this file. #include \"markertool.h\" #include <QPainter>","title":"File markertool.cpp"},{"location":"flameshot/markertool_8cpp/#macros","text":"Type Name define PADDING_VALUE 14","title":"Macros"},{"location":"flameshot/markertool_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/markertool_8cpp/#define-padding_value","text":"#define PADDING_VALUE 14","title":"define PADDING_VALUE"},{"location":"flameshot/markertool_8cpp_source/","text":"File markertool.cpp # File List > marker > markertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"markertool.h\" #include <QPainter> #define PADDING_VALUE 14 MarkerTool::MarkerTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon MarkerTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"marker.svg\"); } QString MarkerTool::name() const { return tr(\"Marker\"); } CaptureTool::Type MarkerTool::type() const { return CaptureTool::TYPE_MARKER; } QString MarkerTool::description() const { return tr(\"Set the Marker as the paint tool\"); } QRect MarkerTool::mousePreviewRect(const CaptureContext& context) const { int width = PADDING_VALUE + context.toolSize; QRect rect(0, 0, width + 2, width + 2); rect.moveCenter(context.mousePos); return rect; } CaptureTool* MarkerTool::copy(QObject* parent) { auto* tool = new MarkerTool(parent); copyParams(this, tool); return tool; } void MarkerTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) auto compositionMode = painter.compositionMode(); qreal opacity = painter.opacity(); auto pen = painter.pen(); painter.setCompositionMode(QPainter::CompositionMode_Multiply); painter.setOpacity(0.35); painter.setPen(QPen(color(), size())); painter.drawLine(points().first, points().second); painter.setPen(pen); painter.setOpacity(opacity); painter.setCompositionMode(compositionMode); } void MarkerTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { auto compositionMode = painter.compositionMode(); qreal opacity = painter.opacity(); auto pen = painter.pen(); painter.setCompositionMode(QPainter::CompositionMode_Multiply); painter.setOpacity(0.35); painter.setPen(QPen(context.color, PADDING_VALUE + context.toolSize)); painter.drawLine(context.mousePos, context.mousePos); painter.setPen(pen); painter.setOpacity(opacity); painter.setCompositionMode(compositionMode); } void MarkerTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); onSizeChanged(context.toolSize + PADDING_VALUE); } void MarkerTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File markertool.cpp"},{"location":"flameshot/markertool_8cpp_source/#file-markertoolcpp","text":"File List > marker > markertool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"markertool.h\" #include <QPainter> #define PADDING_VALUE 14 MarkerTool::MarkerTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsOrthogonalAdj = true; m_supportsDiagonalAdj = true; } QIcon MarkerTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"marker.svg\"); } QString MarkerTool::name() const { return tr(\"Marker\"); } CaptureTool::Type MarkerTool::type() const { return CaptureTool::TYPE_MARKER; } QString MarkerTool::description() const { return tr(\"Set the Marker as the paint tool\"); } QRect MarkerTool::mousePreviewRect(const CaptureContext& context) const { int width = PADDING_VALUE + context.toolSize; QRect rect(0, 0, width + 2, width + 2); rect.moveCenter(context.mousePos); return rect; } CaptureTool* MarkerTool::copy(QObject* parent) { auto* tool = new MarkerTool(parent); copyParams(this, tool); return tool; } void MarkerTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) auto compositionMode = painter.compositionMode(); qreal opacity = painter.opacity(); auto pen = painter.pen(); painter.setCompositionMode(QPainter::CompositionMode_Multiply); painter.setOpacity(0.35); painter.setPen(QPen(color(), size())); painter.drawLine(points().first, points().second); painter.setPen(pen); painter.setOpacity(opacity); painter.setCompositionMode(compositionMode); } void MarkerTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { auto compositionMode = painter.compositionMode(); qreal opacity = painter.opacity(); auto pen = painter.pen(); painter.setCompositionMode(QPainter::CompositionMode_Multiply); painter.setOpacity(0.35); painter.setPen(QPen(context.color, PADDING_VALUE + context.toolSize)); painter.drawLine(context.mousePos, context.mousePos); painter.setPen(pen); painter.setOpacity(opacity); painter.setCompositionMode(compositionMode); } void MarkerTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); onSizeChanged(context.toolSize + PADDING_VALUE); } void MarkerTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File markertool.cpp"},{"location":"flameshot/markertool_8h/","text":"File markertool.h # FileList > marker > markertool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class MarkerTool","title":"File markertool.h"},{"location":"flameshot/markertool_8h/#file-markertoolh","text":"FileList > marker > markertool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File markertool.h"},{"location":"flameshot/markertool_8h/#classes","text":"Type Name class MarkerTool","title":"Classes"},{"location":"flameshot/markertool_8h_source/","text":"File markertool.h # File List > marker > markertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class MarkerTool : public AbstractTwoPointTool { Q_OBJECT public: explicit MarkerTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect mousePreviewRect(const CaptureContext& context) const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File markertool.h"},{"location":"flameshot/markertool_8h_source/#file-markertoolh","text":"File List > marker > markertool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class MarkerTool : public AbstractTwoPointTool { Q_OBJECT public: explicit MarkerTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect mousePreviewRect(const CaptureContext& context) const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File markertool.h"},{"location":"flameshot/dir_9298e764bfa4f928068ef838f950b224/","text":"Dir move # FileList > move Files # Type Name file movetool.cpp file movetool.h","title":"Dir move"},{"location":"flameshot/dir_9298e764bfa4f928068ef838f950b224/#dir-move","text":"FileList > move","title":"Dir move"},{"location":"flameshot/dir_9298e764bfa4f928068ef838f950b224/#files","text":"Type Name file movetool.cpp file movetool.h","title":"Files"},{"location":"flameshot/movetool_8cpp/","text":"File movetool.cpp # FileList > move > movetool.cpp Go to the source code of this file. #include \"movetool.h\" #include <QPainter>","title":"File movetool.cpp"},{"location":"flameshot/movetool_8cpp/#file-movetoolcpp","text":"FileList > move > movetool.cpp Go to the source code of this file. #include \"movetool.h\" #include <QPainter>","title":"File movetool.cpp"},{"location":"flameshot/movetool_8cpp_source/","text":"File movetool.cpp # File List > move > movetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"movetool.h\" #include <QPainter> MoveTool::MoveTool(QObject* parent) : AbstractActionTool(parent) {} bool MoveTool::closeOnButtonPressed() const { return false; } QIcon MoveTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"cursor-move.svg\"); } QString MoveTool::name() const { return tr(\"Move\"); } CaptureTool::Type MoveTool::type() const { return CaptureTool::TYPE_MOVESELECTION; } QString MoveTool::description() const { return tr(\"Move the selection area\"); } CaptureTool* MoveTool::copy(QObject* parent) { return new MoveTool(parent); } void MoveTool::pressed(CaptureContext& context) { Q_UNUSED(context) } bool MoveTool::isSelectable() const { return true; }","title":"File movetool.cpp"},{"location":"flameshot/movetool_8cpp_source/#file-movetoolcpp","text":"File List > move > movetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"movetool.h\" #include <QPainter> MoveTool::MoveTool(QObject* parent) : AbstractActionTool(parent) {} bool MoveTool::closeOnButtonPressed() const { return false; } QIcon MoveTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"cursor-move.svg\"); } QString MoveTool::name() const { return tr(\"Move\"); } CaptureTool::Type MoveTool::type() const { return CaptureTool::TYPE_MOVESELECTION; } QString MoveTool::description() const { return tr(\"Move the selection area\"); } CaptureTool* MoveTool::copy(QObject* parent) { return new MoveTool(parent); } void MoveTool::pressed(CaptureContext& context) { Q_UNUSED(context) } bool MoveTool::isSelectable() const { return true; }","title":"File movetool.cpp"},{"location":"flameshot/movetool_8h/","text":"File movetool.h # FileList > move > movetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class MoveTool","title":"File movetool.h"},{"location":"flameshot/movetool_8h/#file-movetoolh","text":"FileList > move > movetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File movetool.h"},{"location":"flameshot/movetool_8h/#classes","text":"Type Name class MoveTool","title":"Classes"},{"location":"flameshot/movetool_8h_source/","text":"File movetool.h # File List > move > movetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class MoveTool : public AbstractActionTool { Q_OBJECT public: explicit MoveTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; CaptureTool::Type type() const override; QString description() const override; bool isSelectable() const override; CaptureTool* copy(QObject* parent = nullptr) override; public slots: void pressed(CaptureContext& context) override; };","title":"File movetool.h"},{"location":"flameshot/movetool_8h_source/#file-movetoolh","text":"File List > move > movetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class MoveTool : public AbstractActionTool { Q_OBJECT public: explicit MoveTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; CaptureTool::Type type() const override; QString description() const override; bool isSelectable() const override; CaptureTool* copy(QObject* parent = nullptr) override; public slots: void pressed(CaptureContext& context) override; };","title":"File movetool.h"},{"location":"flameshot/dir_ba37296f25af0f64ffd9ff73ad908ca7/","text":"Dir pencil # FileList > pencil Files # Type Name file penciltool.cpp file penciltool.h","title":"Dir pencil"},{"location":"flameshot/dir_ba37296f25af0f64ffd9ff73ad908ca7/#dir-pencil","text":"FileList > pencil","title":"Dir pencil"},{"location":"flameshot/dir_ba37296f25af0f64ffd9ff73ad908ca7/#files","text":"Type Name file penciltool.cpp file penciltool.h","title":"Files"},{"location":"flameshot/penciltool_8cpp/","text":"File penciltool.cpp # FileList > pencil > penciltool.cpp Go to the source code of this file. #include \"penciltool.h\" #include <QPainter>","title":"File penciltool.cpp"},{"location":"flameshot/penciltool_8cpp/#file-penciltoolcpp","text":"FileList > pencil > penciltool.cpp Go to the source code of this file. #include \"penciltool.h\" #include <QPainter>","title":"File penciltool.cpp"},{"location":"flameshot/penciltool_8cpp_source/","text":"File penciltool.cpp # File List > pencil > penciltool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"penciltool.h\" #include <QPainter> PencilTool::PencilTool(QObject* parent) : AbstractPathTool(parent) {} QIcon PencilTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pencil.svg\"); } QString PencilTool::name() const { return tr(\"Pencil\"); } CaptureTool::Type PencilTool::type() const { return CaptureTool::TYPE_PENCIL; } QString PencilTool::description() const { return tr(\"Set the Pencil as the paint tool\"); } CaptureTool* PencilTool::copy(QObject* parent) { auto* tool = new PencilTool(parent); copyParams(this, tool); return tool; } void PencilTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(m_color, size())); painter.drawPolyline(m_points.data(), m_points.size()); } void PencilTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { painter.setPen(QPen(context.color, context.toolSize + 2)); painter.drawLine(context.mousePos, context.mousePos); } void PencilTool::drawStart(const CaptureContext& context) { m_color = context.color; onSizeChanged(context.toolSize); m_points.append(context.mousePos); m_pathArea.setTopLeft(context.mousePos); m_pathArea.setBottomRight(context.mousePos); } void PencilTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File penciltool.cpp"},{"location":"flameshot/penciltool_8cpp_source/#file-penciltoolcpp","text":"File List > pencil > penciltool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"penciltool.h\" #include <QPainter> PencilTool::PencilTool(QObject* parent) : AbstractPathTool(parent) {} QIcon PencilTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pencil.svg\"); } QString PencilTool::name() const { return tr(\"Pencil\"); } CaptureTool::Type PencilTool::type() const { return CaptureTool::TYPE_PENCIL; } QString PencilTool::description() const { return tr(\"Set the Pencil as the paint tool\"); } CaptureTool* PencilTool::copy(QObject* parent) { auto* tool = new PencilTool(parent); copyParams(this, tool); return tool; } void PencilTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen(QPen(m_color, size())); painter.drawPolyline(m_points.data(), m_points.size()); } void PencilTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { painter.setPen(QPen(context.color, context.toolSize + 2)); painter.drawLine(context.mousePos, context.mousePos); } void PencilTool::drawStart(const CaptureContext& context) { m_color = context.color; onSizeChanged(context.toolSize); m_points.append(context.mousePos); m_pathArea.setTopLeft(context.mousePos); m_pathArea.setBottomRight(context.mousePos); } void PencilTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File penciltool.cpp"},{"location":"flameshot/penciltool_8h/","text":"File penciltool.h # FileList > pencil > penciltool.h Go to the source code of this file. #include \"src/tools/abstractpathtool.h\" Classes # Type Name class PencilTool","title":"File penciltool.h"},{"location":"flameshot/penciltool_8h/#file-penciltoolh","text":"FileList > pencil > penciltool.h Go to the source code of this file. #include \"src/tools/abstractpathtool.h\"","title":"File penciltool.h"},{"location":"flameshot/penciltool_8h/#classes","text":"Type Name class PencilTool","title":"Classes"},{"location":"flameshot/penciltool_8h_source/","text":"File penciltool.h # File List > pencil > penciltool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractpathtool.h\" class PencilTool : public AbstractPathTool { Q_OBJECT public: explicit PencilTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File penciltool.h"},{"location":"flameshot/penciltool_8h_source/#file-penciltoolh","text":"File List > pencil > penciltool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractpathtool.h\" class PencilTool : public AbstractPathTool { Q_OBJECT public: explicit PencilTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File penciltool.h"},{"location":"flameshot/dir_5a728c54be3df44fb5be2cd75280d106/","text":"Dir pin # FileList > pin Files # Type Name file pintool.cpp file pintool.h file pinwidget.cpp file pinwidget.h","title":"Dir pin"},{"location":"flameshot/dir_5a728c54be3df44fb5be2cd75280d106/#dir-pin","text":"FileList > pin","title":"Dir pin"},{"location":"flameshot/dir_5a728c54be3df44fb5be2cd75280d106/#files","text":"Type Name file pintool.cpp file pintool.h file pinwidget.cpp file pinwidget.h","title":"Files"},{"location":"flameshot/pintool_8cpp/","text":"File pintool.cpp # FileList > pin > pintool.cpp Go to the source code of this file. #include \"pintool.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/pin/pinwidget.h\" #include <QScreen>","title":"File pintool.cpp"},{"location":"flameshot/pintool_8cpp/#file-pintoolcpp","text":"FileList > pin > pintool.cpp Go to the source code of this file. #include \"pintool.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/pin/pinwidget.h\" #include <QScreen>","title":"File pintool.cpp"},{"location":"flameshot/pintool_8cpp_source/","text":"File pintool.cpp # File List > pin > pintool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pintool.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/pin/pinwidget.h\" #include <QScreen> PinTool::PinTool(QObject* parent) : AbstractActionTool(parent) {} bool PinTool::closeOnButtonPressed() const { return true; } QIcon PinTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pin.svg\"); } QString PinTool::name() const { return tr(\"Pin Tool\"); } CaptureTool::Type PinTool::type() const { return CaptureTool::TYPE_PIN; } QString PinTool::description() const { return tr(\"Pin image on the desktop\"); } CaptureTool* PinTool::copy(QObject* parent) { return new PinTool(parent); } void PinTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); emit requestAction(REQ_CAPTURE_DONE_OK); context.request.addTask(CaptureRequest::PIN); emit requestAction(REQ_CLOSE_GUI); }","title":"File pintool.cpp"},{"location":"flameshot/pintool_8cpp_source/#file-pintoolcpp","text":"File List > pin > pintool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pintool.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/pin/pinwidget.h\" #include <QScreen> PinTool::PinTool(QObject* parent) : AbstractActionTool(parent) {} bool PinTool::closeOnButtonPressed() const { return true; } QIcon PinTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pin.svg\"); } QString PinTool::name() const { return tr(\"Pin Tool\"); } CaptureTool::Type PinTool::type() const { return CaptureTool::TYPE_PIN; } QString PinTool::description() const { return tr(\"Pin image on the desktop\"); } CaptureTool* PinTool::copy(QObject* parent) { return new PinTool(parent); } void PinTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); emit requestAction(REQ_CAPTURE_DONE_OK); context.request.addTask(CaptureRequest::PIN); emit requestAction(REQ_CLOSE_GUI); }","title":"File pintool.cpp"},{"location":"flameshot/pintool_8h/","text":"File pintool.h # FileList > pin > pintool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class PinTool","title":"File pintool.h"},{"location":"flameshot/pintool_8h/#file-pintoolh","text":"FileList > pin > pintool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File pintool.h"},{"location":"flameshot/pintool_8h/#classes","text":"Type Name class PinTool","title":"Classes"},{"location":"flameshot/pintool_8h_source/","text":"File pintool.h # File List > pin > pintool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class PinTool : public AbstractActionTool { Q_OBJECT public: explicit PinTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QRect m_geometry; QPixmap m_pixmap; };","title":"File pintool.h"},{"location":"flameshot/pintool_8h_source/#file-pintoolh","text":"File List > pin > pintool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class PinTool : public AbstractActionTool { Q_OBJECT public: explicit PinTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; private: QRect m_geometry; QPixmap m_pixmap; };","title":"File pintool.h"},{"location":"flameshot/pinwidget_8cpp/","text":"File pinwidget.cpp # FileList > pin > pinwidget.cpp Go to the source code of this file. #include <QGraphicsDropShadowEffect> #include <QGraphicsOpacityEffect> #include <QPinchGesture> #include \"pinwidget.h\" #include \"qguiappcurrentscreen.h\" #include \"screenshotsaver.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QLabel> #include <QMenu> #include <QScreen> #include <QShortcut> #include <QVBoxLayout> #include <QWheelEvent>","title":"File pinwidget.cpp"},{"location":"flameshot/pinwidget_8cpp/#file-pinwidgetcpp","text":"FileList > pin > pinwidget.cpp Go to the source code of this file. #include <QGraphicsDropShadowEffect> #include <QGraphicsOpacityEffect> #include <QPinchGesture> #include \"pinwidget.h\" #include \"qguiappcurrentscreen.h\" #include \"screenshotsaver.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QLabel> #include <QMenu> #include <QScreen> #include <QShortcut> #include <QVBoxLayout> #include <QWheelEvent>","title":"File pinwidget.cpp"},{"location":"flameshot/pinwidget_8cpp_source/","text":"File pinwidget.cpp # File List > pin > pinwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include <QGraphicsDropShadowEffect> #include <QGraphicsOpacityEffect> #include <QPinchGesture> #include \"pinwidget.h\" #include \"qguiappcurrentscreen.h\" #include \"screenshotsaver.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QLabel> #include <QMenu> #include <QScreen> #include <QShortcut> #include <QVBoxLayout> #include <QWheelEvent> namespace { constexpr int MARGIN = 7; constexpr int BLUR_RADIUS = 2 * MARGIN; constexpr qreal STEP = 0.03; constexpr qreal MIN_SIZE = 100.0; } PinWidget::PinWidget(const QPixmap& pixmap, const QRect& geometry, QWidget* parent) : QWidget(parent) , m_pixmap(pixmap) , m_layout(new QVBoxLayout(this)) , m_label(new QLabel()) , m_shadowEffect(new QGraphicsDropShadowEffect(this)) { setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint); setFocusPolicy(Qt::StrongFocus); // set the bottom widget background transparent setAttribute(Qt::WA_TranslucentBackground); setAttribute(Qt::WA_DeleteOnClose); ConfigHandler conf; m_baseColor = conf.uiColor(); m_hoverColor = conf.contrastUiColor(); m_layout->setContentsMargins(MARGIN, MARGIN, MARGIN, MARGIN); m_shadowEffect->setColor(m_baseColor); m_shadowEffect->setBlurRadius(BLUR_RADIUS); m_shadowEffect->setOffset(0, 0); setGraphicsEffect(m_shadowEffect); setWindowOpacity(m_opacity); m_label->setPixmap(m_pixmap); m_layout->addWidget(m_label); new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close())); new QShortcut(Qt::Key_Escape, this, SLOT(close())); qreal devicePixelRatio = 1; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen != nullptr) { devicePixelRatio = currentScreen->devicePixelRatio(); } #endif const int margin = static_cast<int>(static_cast<double>(MARGIN) * devicePixelRatio); QRect adjusted_pos = geometry + QMargins(margin, margin, margin, margin); setGeometry(adjusted_pos); #if defined(Q_OS_LINUX) setWindowFlags(Qt::X11BypassWindowManagerHint); #endif #if defined(Q_OS_MACOS) if (currentScreen != nullptr) { QPoint topLeft = currentScreen->geometry().topLeft(); adjusted_pos.setX((adjusted_pos.x() - topLeft.x()) / devicePixelRatio + topLeft.x()); adjusted_pos.setY((adjusted_pos.y() - topLeft.y()) / devicePixelRatio + topLeft.y()); adjusted_pos.setWidth(adjusted_pos.size().width() / devicePixelRatio); adjusted_pos.setHeight(adjusted_pos.size().height() / devicePixelRatio); resize(0, 0); move(adjusted_pos.x(), adjusted_pos.y()); } #endif grabGesture(Qt::PinchGesture); this->setContextMenuPolicy(Qt::CustomContextMenu); connect(this, &QWidget::customContextMenuRequested, this, &PinWidget::showContextMenu); } void PinWidget::closePin() { update(); close(); } bool PinWidget::scrollEvent(QWheelEvent* event) { const auto phase = event->phase(); if (phase == Qt::ScrollPhase::ScrollUpdate #if defined(Q_OS_LINUX) || defined(Q_OS_WINDOWS) // Linux is getting only NoScrollPhase events. || phase == Qt::ScrollPhase::NoScrollPhase #endif ) { const auto angle = event->angleDelta(); if (angle.y() == 0) { return true; } m_currentStepScaleFactor = angle.y() > 0 ? m_currentStepScaleFactor + STEP : m_currentStepScaleFactor - STEP; m_expanding = m_currentStepScaleFactor >= 1.0; } #if defined(Q_OS_MACOS) // ScrollEnd is currently supported only on Mac OSX if (phase == Qt::ScrollPhase::ScrollEnd) { #else else { #endif m_scaleFactor *= m_currentStepScaleFactor; m_currentStepScaleFactor = 1.0; m_expanding = false; } m_sizeChanged = true; update(); return true; } void PinWidget::enterEvent(QEvent*) { m_shadowEffect->setColor(m_hoverColor); } void PinWidget::leaveEvent(QEvent*) { m_shadowEffect->setColor(m_baseColor); } void PinWidget::mouseDoubleClickEvent(QMouseEvent*) { closePin(); } void PinWidget::mousePressEvent(QMouseEvent* e) { m_dragStart = e->globalPos(); m_offsetX = e->localPos().x() / width(); m_offsetY = e->localPos().y() / height(); } void PinWidget::mouseMoveEvent(QMouseEvent* e) { const QPoint delta = e->globalPos() - m_dragStart; const int offsetW = width() * m_offsetX; const int offsetH = height() * m_offsetY; move(m_dragStart.x() + delta.x() - offsetW, m_dragStart.y() + delta.y() - offsetH); } void PinWidget::keyPressEvent(QKeyEvent* event) { if (event->key() == Qt::Key_0) { m_opacity = 1.0; } else if (event->key() == Qt::Key_9) { m_opacity = 0.9; } else if (event->key() == Qt::Key_8) { m_opacity = 0.8; } else if (event->key() == Qt::Key_7) { m_opacity = 0.7; } else if (event->key() == Qt::Key_6) { m_opacity = 0.6; } else if (event->key() == Qt::Key_5) { m_opacity = 0.5; } else if (event->key() == Qt::Key_4) { m_opacity = 0.4; } else if (event->key() == Qt::Key_3) { m_opacity = 0.3; } else if (event->key() == Qt::Key_2) { m_opacity = 0.2; } else if (event->key() == Qt::Key_1) { m_opacity = 0.1; } setWindowOpacity(m_opacity); } bool PinWidget::gestureEvent(QGestureEvent* event) { if (QGesture* pinch = event->gesture(Qt::PinchGesture)) { pinchTriggered(static_cast<QPinchGesture*>(pinch)); } return true; } void PinWidget::rotateLeft() { m_sizeChanged = true; auto rotateTransform = QTransform().rotate(270); m_pixmap = m_pixmap.transformed(rotateTransform); } void PinWidget::rotateRight() { m_sizeChanged = true; auto rotateTransform = QTransform().rotate(90); m_pixmap = m_pixmap.transformed(rotateTransform); } void PinWidget::increaseOpacity() { m_opacity += 0.1; if (m_opacity > 1.0) { m_opacity = 1.0; } setWindowOpacity(m_opacity); } void PinWidget::decreaseOpacity() { m_opacity -= 0.1; if (m_opacity < 0.0) { m_opacity = 0.0; } setWindowOpacity(m_opacity); } bool PinWidget::event(QEvent* event) { if (event->type() == QEvent::Gesture) { return gestureEvent(static_cast<QGestureEvent*>(event)); } else if (event->type() == QEvent::Wheel) { return scrollEvent(static_cast<QWheelEvent*>(event)); } return QWidget::event(event); } void PinWidget::paintEvent(QPaintEvent* event) { if (m_sizeChanged) { const auto aspectRatio = m_expanding ? Qt::KeepAspectRatioByExpanding : Qt::KeepAspectRatio; const auto transformType = ConfigHandler().antialiasingPinZoom() ? Qt::SmoothTransformation : Qt::FastTransformation; const qreal iw = m_pixmap.width(); const qreal ih = m_pixmap.height(); const qreal nw = qBound(MIN_SIZE, iw * m_currentStepScaleFactor * m_scaleFactor, static_cast<qreal>(maximumWidth())); const qreal nh = qBound(MIN_SIZE, ih * m_currentStepScaleFactor * m_scaleFactor, static_cast<qreal>(maximumHeight())); const QPixmap pix = m_pixmap.scaled(nw, nh, aspectRatio, transformType); m_label->setPixmap(pix); adjustSize(); m_sizeChanged = false; } } void PinWidget::pinchTriggered(QPinchGesture* gesture) { const QPinchGesture::ChangeFlags changeFlags = gesture->changeFlags(); if (changeFlags & QPinchGesture::ScaleFactorChanged) { m_currentStepScaleFactor = gesture->totalScaleFactor(); m_expanding = m_currentStepScaleFactor > gesture->lastScaleFactor(); } if (gesture->state() == Qt::GestureFinished) { m_scaleFactor *= m_currentStepScaleFactor; m_currentStepScaleFactor = 1; m_expanding = false; } m_sizeChanged = true; update(); } void PinWidget::showContextMenu(const QPoint& pos) { QMenu contextMenu(tr(\"Context menu\"), this); QAction copyToClipboardAction(tr(\"Copy to clipboard\"), this); connect(&copyToClipboardAction, &QAction::triggered, this, &PinWidget::copyToClipboard); contextMenu.addAction(&copyToClipboardAction); QAction saveToFileAction(tr(\"Save to file\"), this); connect( &saveToFileAction, &QAction::triggered, this, &PinWidget::saveToFile); contextMenu.addAction(&saveToFileAction); contextMenu.addSeparator(); QAction rotateRightAction(tr(\"Rotate Right\"), this); connect( &rotateRightAction, &QAction::triggered, this, &PinWidget::rotateRight); contextMenu.addAction(&rotateRightAction); QAction rotateLeftAction(tr(\"Rotate Left\"), this); connect( &rotateLeftAction, &QAction::triggered, this, &PinWidget::rotateLeft); contextMenu.addAction(&rotateLeftAction); QAction increaseOpacityAction(tr(\"Increase Opacity\"), this); connect(&increaseOpacityAction, &QAction::triggered, this, &PinWidget::increaseOpacity); contextMenu.addAction(&increaseOpacityAction); QAction decreaseOpacityAction(tr(\"Decrease Opacity\"), this); connect(&decreaseOpacityAction, &QAction::triggered, this, &PinWidget::decreaseOpacity); contextMenu.addAction(&decreaseOpacityAction); QAction closePinAction(tr(\"Close\"), this); connect(&closePinAction, &QAction::triggered, this, &PinWidget::closePin); contextMenu.addSeparator(); contextMenu.addAction(&closePinAction); contextMenu.exec(mapToGlobal(pos)); } void PinWidget::copyToClipboard() { saveToClipboard(m_pixmap); } void PinWidget::saveToFile() { hide(); saveToFilesystemGUI(m_pixmap); show(); }","title":"File pinwidget.cpp"},{"location":"flameshot/pinwidget_8cpp_source/#file-pinwidgetcpp","text":"File List > pin > pinwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include <QGraphicsDropShadowEffect> #include <QGraphicsOpacityEffect> #include <QPinchGesture> #include \"pinwidget.h\" #include \"qguiappcurrentscreen.h\" #include \"screenshotsaver.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QLabel> #include <QMenu> #include <QScreen> #include <QShortcut> #include <QVBoxLayout> #include <QWheelEvent> namespace { constexpr int MARGIN = 7; constexpr int BLUR_RADIUS = 2 * MARGIN; constexpr qreal STEP = 0.03; constexpr qreal MIN_SIZE = 100.0; } PinWidget::PinWidget(const QPixmap& pixmap, const QRect& geometry, QWidget* parent) : QWidget(parent) , m_pixmap(pixmap) , m_layout(new QVBoxLayout(this)) , m_label(new QLabel()) , m_shadowEffect(new QGraphicsDropShadowEffect(this)) { setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint); setFocusPolicy(Qt::StrongFocus); // set the bottom widget background transparent setAttribute(Qt::WA_TranslucentBackground); setAttribute(Qt::WA_DeleteOnClose); ConfigHandler conf; m_baseColor = conf.uiColor(); m_hoverColor = conf.contrastUiColor(); m_layout->setContentsMargins(MARGIN, MARGIN, MARGIN, MARGIN); m_shadowEffect->setColor(m_baseColor); m_shadowEffect->setBlurRadius(BLUR_RADIUS); m_shadowEffect->setOffset(0, 0); setGraphicsEffect(m_shadowEffect); setWindowOpacity(m_opacity); m_label->setPixmap(m_pixmap); m_layout->addWidget(m_label); new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close())); new QShortcut(Qt::Key_Escape, this, SLOT(close())); qreal devicePixelRatio = 1; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen != nullptr) { devicePixelRatio = currentScreen->devicePixelRatio(); } #endif const int margin = static_cast<int>(static_cast<double>(MARGIN) * devicePixelRatio); QRect adjusted_pos = geometry + QMargins(margin, margin, margin, margin); setGeometry(adjusted_pos); #if defined(Q_OS_LINUX) setWindowFlags(Qt::X11BypassWindowManagerHint); #endif #if defined(Q_OS_MACOS) if (currentScreen != nullptr) { QPoint topLeft = currentScreen->geometry().topLeft(); adjusted_pos.setX((adjusted_pos.x() - topLeft.x()) / devicePixelRatio + topLeft.x()); adjusted_pos.setY((adjusted_pos.y() - topLeft.y()) / devicePixelRatio + topLeft.y()); adjusted_pos.setWidth(adjusted_pos.size().width() / devicePixelRatio); adjusted_pos.setHeight(adjusted_pos.size().height() / devicePixelRatio); resize(0, 0); move(adjusted_pos.x(), adjusted_pos.y()); } #endif grabGesture(Qt::PinchGesture); this->setContextMenuPolicy(Qt::CustomContextMenu); connect(this, &QWidget::customContextMenuRequested, this, &PinWidget::showContextMenu); } void PinWidget::closePin() { update(); close(); } bool PinWidget::scrollEvent(QWheelEvent* event) { const auto phase = event->phase(); if (phase == Qt::ScrollPhase::ScrollUpdate #if defined(Q_OS_LINUX) || defined(Q_OS_WINDOWS) // Linux is getting only NoScrollPhase events. || phase == Qt::ScrollPhase::NoScrollPhase #endif ) { const auto angle = event->angleDelta(); if (angle.y() == 0) { return true; } m_currentStepScaleFactor = angle.y() > 0 ? m_currentStepScaleFactor + STEP : m_currentStepScaleFactor - STEP; m_expanding = m_currentStepScaleFactor >= 1.0; } #if defined(Q_OS_MACOS) // ScrollEnd is currently supported only on Mac OSX if (phase == Qt::ScrollPhase::ScrollEnd) { #else else { #endif m_scaleFactor *= m_currentStepScaleFactor; m_currentStepScaleFactor = 1.0; m_expanding = false; } m_sizeChanged = true; update(); return true; } void PinWidget::enterEvent(QEvent*) { m_shadowEffect->setColor(m_hoverColor); } void PinWidget::leaveEvent(QEvent*) { m_shadowEffect->setColor(m_baseColor); } void PinWidget::mouseDoubleClickEvent(QMouseEvent*) { closePin(); } void PinWidget::mousePressEvent(QMouseEvent* e) { m_dragStart = e->globalPos(); m_offsetX = e->localPos().x() / width(); m_offsetY = e->localPos().y() / height(); } void PinWidget::mouseMoveEvent(QMouseEvent* e) { const QPoint delta = e->globalPos() - m_dragStart; const int offsetW = width() * m_offsetX; const int offsetH = height() * m_offsetY; move(m_dragStart.x() + delta.x() - offsetW, m_dragStart.y() + delta.y() - offsetH); } void PinWidget::keyPressEvent(QKeyEvent* event) { if (event->key() == Qt::Key_0) { m_opacity = 1.0; } else if (event->key() == Qt::Key_9) { m_opacity = 0.9; } else if (event->key() == Qt::Key_8) { m_opacity = 0.8; } else if (event->key() == Qt::Key_7) { m_opacity = 0.7; } else if (event->key() == Qt::Key_6) { m_opacity = 0.6; } else if (event->key() == Qt::Key_5) { m_opacity = 0.5; } else if (event->key() == Qt::Key_4) { m_opacity = 0.4; } else if (event->key() == Qt::Key_3) { m_opacity = 0.3; } else if (event->key() == Qt::Key_2) { m_opacity = 0.2; } else if (event->key() == Qt::Key_1) { m_opacity = 0.1; } setWindowOpacity(m_opacity); } bool PinWidget::gestureEvent(QGestureEvent* event) { if (QGesture* pinch = event->gesture(Qt::PinchGesture)) { pinchTriggered(static_cast<QPinchGesture*>(pinch)); } return true; } void PinWidget::rotateLeft() { m_sizeChanged = true; auto rotateTransform = QTransform().rotate(270); m_pixmap = m_pixmap.transformed(rotateTransform); } void PinWidget::rotateRight() { m_sizeChanged = true; auto rotateTransform = QTransform().rotate(90); m_pixmap = m_pixmap.transformed(rotateTransform); } void PinWidget::increaseOpacity() { m_opacity += 0.1; if (m_opacity > 1.0) { m_opacity = 1.0; } setWindowOpacity(m_opacity); } void PinWidget::decreaseOpacity() { m_opacity -= 0.1; if (m_opacity < 0.0) { m_opacity = 0.0; } setWindowOpacity(m_opacity); } bool PinWidget::event(QEvent* event) { if (event->type() == QEvent::Gesture) { return gestureEvent(static_cast<QGestureEvent*>(event)); } else if (event->type() == QEvent::Wheel) { return scrollEvent(static_cast<QWheelEvent*>(event)); } return QWidget::event(event); } void PinWidget::paintEvent(QPaintEvent* event) { if (m_sizeChanged) { const auto aspectRatio = m_expanding ? Qt::KeepAspectRatioByExpanding : Qt::KeepAspectRatio; const auto transformType = ConfigHandler().antialiasingPinZoom() ? Qt::SmoothTransformation : Qt::FastTransformation; const qreal iw = m_pixmap.width(); const qreal ih = m_pixmap.height(); const qreal nw = qBound(MIN_SIZE, iw * m_currentStepScaleFactor * m_scaleFactor, static_cast<qreal>(maximumWidth())); const qreal nh = qBound(MIN_SIZE, ih * m_currentStepScaleFactor * m_scaleFactor, static_cast<qreal>(maximumHeight())); const QPixmap pix = m_pixmap.scaled(nw, nh, aspectRatio, transformType); m_label->setPixmap(pix); adjustSize(); m_sizeChanged = false; } } void PinWidget::pinchTriggered(QPinchGesture* gesture) { const QPinchGesture::ChangeFlags changeFlags = gesture->changeFlags(); if (changeFlags & QPinchGesture::ScaleFactorChanged) { m_currentStepScaleFactor = gesture->totalScaleFactor(); m_expanding = m_currentStepScaleFactor > gesture->lastScaleFactor(); } if (gesture->state() == Qt::GestureFinished) { m_scaleFactor *= m_currentStepScaleFactor; m_currentStepScaleFactor = 1; m_expanding = false; } m_sizeChanged = true; update(); } void PinWidget::showContextMenu(const QPoint& pos) { QMenu contextMenu(tr(\"Context menu\"), this); QAction copyToClipboardAction(tr(\"Copy to clipboard\"), this); connect(&copyToClipboardAction, &QAction::triggered, this, &PinWidget::copyToClipboard); contextMenu.addAction(&copyToClipboardAction); QAction saveToFileAction(tr(\"Save to file\"), this); connect( &saveToFileAction, &QAction::triggered, this, &PinWidget::saveToFile); contextMenu.addAction(&saveToFileAction); contextMenu.addSeparator(); QAction rotateRightAction(tr(\"Rotate Right\"), this); connect( &rotateRightAction, &QAction::triggered, this, &PinWidget::rotateRight); contextMenu.addAction(&rotateRightAction); QAction rotateLeftAction(tr(\"Rotate Left\"), this); connect( &rotateLeftAction, &QAction::triggered, this, &PinWidget::rotateLeft); contextMenu.addAction(&rotateLeftAction); QAction increaseOpacityAction(tr(\"Increase Opacity\"), this); connect(&increaseOpacityAction, &QAction::triggered, this, &PinWidget::increaseOpacity); contextMenu.addAction(&increaseOpacityAction); QAction decreaseOpacityAction(tr(\"Decrease Opacity\"), this); connect(&decreaseOpacityAction, &QAction::triggered, this, &PinWidget::decreaseOpacity); contextMenu.addAction(&decreaseOpacityAction); QAction closePinAction(tr(\"Close\"), this); connect(&closePinAction, &QAction::triggered, this, &PinWidget::closePin); contextMenu.addSeparator(); contextMenu.addAction(&closePinAction); contextMenu.exec(mapToGlobal(pos)); } void PinWidget::copyToClipboard() { saveToClipboard(m_pixmap); } void PinWidget::saveToFile() { hide(); saveToFilesystemGUI(m_pixmap); show(); }","title":"File pinwidget.cpp"},{"location":"flameshot/pinwidget_8h/","text":"File pinwidget.h # FileList > pin > pinwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class PinWidget","title":"File pinwidget.h"},{"location":"flameshot/pinwidget_8h/#file-pinwidgeth","text":"FileList > pin > pinwidget.h Go to the source code of this file. #include <QWidget>","title":"File pinwidget.h"},{"location":"flameshot/pinwidget_8h/#classes","text":"Type Name class PinWidget","title":"Classes"},{"location":"flameshot/pinwidget_8h_source/","text":"File pinwidget.h # File List > pin > pinwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QLabel; class QVBoxLayout; class QGestureEvent; class QPinchGesture; class QGraphicsDropShadowEffect; class PinWidget : public QWidget { Q_OBJECT public: explicit PinWidget(const QPixmap& pixmap, const QRect& geometry, QWidget* parent = nullptr); protected: void mouseDoubleClickEvent(QMouseEvent*) override; void mousePressEvent(QMouseEvent*) override; void mouseMoveEvent(QMouseEvent*) override; void keyPressEvent(QKeyEvent*) override; void enterEvent(QEvent*) override; void leaveEvent(QEvent*) override; bool event(QEvent* event) override; void paintEvent(QPaintEvent* event) override; private: bool gestureEvent(QGestureEvent* event); bool scrollEvent(QWheelEvent* e); void pinchTriggered(QPinchGesture*); void closePin(); void rotateLeft(); void rotateRight(); void increaseOpacity(); void decreaseOpacity(); QPixmap m_pixmap; QVBoxLayout* m_layout; QLabel* m_label; QPoint m_dragStart; qreal m_offsetX{}, m_offsetY{}; QGraphicsDropShadowEffect* m_shadowEffect; QColor m_baseColor, m_hoverColor; bool m_expanding{ false }; qreal m_scaleFactor{ 1 }; qreal m_opacity{ 1 }; unsigned int m_rotateFactor{ 0 }; qreal m_currentStepScaleFactor{ 1 }; bool m_sizeChanged{ false }; private slots: void showContextMenu(const QPoint& pos); void copyToClipboard(); void saveToFile(); };","title":"File pinwidget.h"},{"location":"flameshot/pinwidget_8h_source/#file-pinwidgeth","text":"File List > pin > pinwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QLabel; class QVBoxLayout; class QGestureEvent; class QPinchGesture; class QGraphicsDropShadowEffect; class PinWidget : public QWidget { Q_OBJECT public: explicit PinWidget(const QPixmap& pixmap, const QRect& geometry, QWidget* parent = nullptr); protected: void mouseDoubleClickEvent(QMouseEvent*) override; void mousePressEvent(QMouseEvent*) override; void mouseMoveEvent(QMouseEvent*) override; void keyPressEvent(QKeyEvent*) override; void enterEvent(QEvent*) override; void leaveEvent(QEvent*) override; bool event(QEvent* event) override; void paintEvent(QPaintEvent* event) override; private: bool gestureEvent(QGestureEvent* event); bool scrollEvent(QWheelEvent* e); void pinchTriggered(QPinchGesture*); void closePin(); void rotateLeft(); void rotateRight(); void increaseOpacity(); void decreaseOpacity(); QPixmap m_pixmap; QVBoxLayout* m_layout; QLabel* m_label; QPoint m_dragStart; qreal m_offsetX{}, m_offsetY{}; QGraphicsDropShadowEffect* m_shadowEffect; QColor m_baseColor, m_hoverColor; bool m_expanding{ false }; qreal m_scaleFactor{ 1 }; qreal m_opacity{ 1 }; unsigned int m_rotateFactor{ 0 }; qreal m_currentStepScaleFactor{ 1 }; bool m_sizeChanged{ false }; private slots: void showContextMenu(const QPoint& pos); void copyToClipboard(); void saveToFile(); };","title":"File pinwidget.h"},{"location":"flameshot/dir_1917b87740cdd44c073a6cb99e523447/","text":"Dir pixelate # FileList > pixelate Files # Type Name file pixelatetool.cpp file pixelatetool.h","title":"Dir pixelate"},{"location":"flameshot/dir_1917b87740cdd44c073a6cb99e523447/#dir-pixelate","text":"FileList > pixelate","title":"Dir pixelate"},{"location":"flameshot/dir_1917b87740cdd44c073a6cb99e523447/#files","text":"Type Name file pixelatetool.cpp file pixelatetool.h","title":"Files"},{"location":"flameshot/pixelatetool_8cpp/","text":"File pixelatetool.cpp # FileList > pixelate > pixelatetool.cpp Go to the source code of this file. #include \"pixelatetool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter>","title":"File pixelatetool.cpp"},{"location":"flameshot/pixelatetool_8cpp/#file-pixelatetoolcpp","text":"FileList > pixelate > pixelatetool.cpp Go to the source code of this file. #include \"pixelatetool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter>","title":"File pixelatetool.cpp"},{"location":"flameshot/pixelatetool_8cpp_source/","text":"File pixelatetool.cpp # File List > pixelate > pixelatetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pixelatetool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> PixelateTool::PixelateTool(QObject* parent) : AbstractTwoPointTool(parent) {} QIcon PixelateTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pixelate.svg\"); } QString PixelateTool::name() const { return tr(\"Pixelate\"); } CaptureTool::Type PixelateTool::type() const { return CaptureTool::TYPE_PIXELATE; } QString PixelateTool::description() const { return tr(\"Set Pixelate as the paint tool\"); } QRect PixelateTool::boundingRect() const { return QRect(points().first, points().second).normalized(); } CaptureTool* PixelateTool::copy(QObject* parent) { auto* tool = new PixelateTool(parent); copyParams(this, tool); return tool; } void PixelateTool::process(QPainter& painter, const QPixmap& pixmap) { QRect selection = boundingRect().intersected(pixmap.rect()); auto pixelRatio = pixmap.devicePixelRatio(); QRect selectionScaled = QRect(selection.topLeft() * pixelRatio, selection.bottomRight() * pixelRatio); // If thickness is less than 1, use old blur process if (size() <= 1) { auto* blur = new QGraphicsBlurEffect; blur->setBlurRadius(10); auto* item = new QGraphicsPixmapItem(pixmap.copy(selectionScaled)); item->setGraphicsEffect(blur); QGraphicsScene scene; scene.addItem(item); scene.render(&painter, selection, QRectF()); blur->setBlurRadius(12); // multiple repeat for make blur effect stronger scene.render(&painter, selection, QRectF()); } else { int width = static_cast<int>(selection.width() * (0.5 / qMax(1, size() + 1))); int height = static_cast<int>(selection.height() * (0.5 / qMax(1, size() + 1))); QSize size = QSize(qMax(width, 1), qMax(height, 1)); QPixmap t = pixmap.copy(selectionScaled); t = t.scaled(size, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); t = t.scaled(selection.width(), selection.height()); painter.drawImage(selection, t.toImage()); } } void PixelateTool::drawSearchArea(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.fillRect(boundingRect(), QBrush(Qt::black)); } void PixelateTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(context) Q_UNUSED(painter) } void PixelateTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File pixelatetool.cpp"},{"location":"flameshot/pixelatetool_8cpp_source/#file-pixelatetoolcpp","text":"File List > pixelate > pixelatetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pixelatetool.h\" #include <QApplication> #include <QGraphicsBlurEffect> #include <QGraphicsPixmapItem> #include <QGraphicsScene> #include <QImage> #include <QPainter> PixelateTool::PixelateTool(QObject* parent) : AbstractTwoPointTool(parent) {} QIcon PixelateTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"pixelate.svg\"); } QString PixelateTool::name() const { return tr(\"Pixelate\"); } CaptureTool::Type PixelateTool::type() const { return CaptureTool::TYPE_PIXELATE; } QString PixelateTool::description() const { return tr(\"Set Pixelate as the paint tool\"); } QRect PixelateTool::boundingRect() const { return QRect(points().first, points().second).normalized(); } CaptureTool* PixelateTool::copy(QObject* parent) { auto* tool = new PixelateTool(parent); copyParams(this, tool); return tool; } void PixelateTool::process(QPainter& painter, const QPixmap& pixmap) { QRect selection = boundingRect().intersected(pixmap.rect()); auto pixelRatio = pixmap.devicePixelRatio(); QRect selectionScaled = QRect(selection.topLeft() * pixelRatio, selection.bottomRight() * pixelRatio); // If thickness is less than 1, use old blur process if (size() <= 1) { auto* blur = new QGraphicsBlurEffect; blur->setBlurRadius(10); auto* item = new QGraphicsPixmapItem(pixmap.copy(selectionScaled)); item->setGraphicsEffect(blur); QGraphicsScene scene; scene.addItem(item); scene.render(&painter, selection, QRectF()); blur->setBlurRadius(12); // multiple repeat for make blur effect stronger scene.render(&painter, selection, QRectF()); } else { int width = static_cast<int>(selection.width() * (0.5 / qMax(1, size() + 1))); int height = static_cast<int>(selection.height() * (0.5 / qMax(1, size() + 1))); QSize size = QSize(qMax(width, 1), qMax(height, 1)); QPixmap t = pixmap.copy(selectionScaled); t = t.scaled(size, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); t = t.scaled(selection.width(), selection.height()); painter.drawImage(selection, t.toImage()); } } void PixelateTool::drawSearchArea(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.fillRect(boundingRect(), QBrush(Qt::black)); } void PixelateTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(context) Q_UNUSED(painter) } void PixelateTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File pixelatetool.cpp"},{"location":"flameshot/pixelatetool_8h/","text":"File pixelatetool.h # FileList > pixelate > pixelatetool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class PixelateTool","title":"File pixelatetool.h"},{"location":"flameshot/pixelatetool_8h/#file-pixelatetoolh","text":"FileList > pixelate > pixelatetool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File pixelatetool.h"},{"location":"flameshot/pixelatetool_8h/#classes","text":"Type Name class PixelateTool","title":"Classes"},{"location":"flameshot/pixelatetool_8h_source/","text":"File pixelatetool.h # File List > pixelate > pixelatetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class PixelateTool : public AbstractTwoPointTool { Q_OBJECT public: explicit PixelateTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void drawSearchArea(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File pixelatetool.h"},{"location":"flameshot/pixelatetool_8h_source/#file-pixelatetoolh","text":"File List > pixelate > pixelatetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class PixelateTool : public AbstractTwoPointTool { Q_OBJECT public: explicit PixelateTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; QRect boundingRect() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void drawSearchArea(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File pixelatetool.h"},{"location":"flameshot/dir_13d91df74e9cb3c514b017d500313e91/","text":"Dir rectangle # FileList > rectangle Files # Type Name file rectangletool.cpp file rectangletool.h","title":"Dir rectangle"},{"location":"flameshot/dir_13d91df74e9cb3c514b017d500313e91/#dir-rectangle","text":"FileList > rectangle","title":"Dir rectangle"},{"location":"flameshot/dir_13d91df74e9cb3c514b017d500313e91/#files","text":"Type Name file rectangletool.cpp file rectangletool.h","title":"Files"},{"location":"flameshot/rectangletool_8cpp/","text":"File rectangletool.cpp # FileList > rectangle > rectangletool.cpp Go to the source code of this file. #include \"rectangletool.h\" #include <QPainter> #include <QPainterPath> #include <cmath>","title":"File rectangletool.cpp"},{"location":"flameshot/rectangletool_8cpp/#file-rectangletoolcpp","text":"FileList > rectangle > rectangletool.cpp Go to the source code of this file. #include \"rectangletool.h\" #include <QPainter> #include <QPainterPath> #include <cmath>","title":"File rectangletool.cpp"},{"location":"flameshot/rectangletool_8cpp_source/","text":"File rectangletool.cpp # File List > rectangle > rectangletool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"rectangletool.h\" #include <QPainter> #include <QPainterPath> #include <cmath> RectangleTool::RectangleTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } QIcon RectangleTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"square.svg\"); } QString RectangleTool::name() const { return tr(\"Rectangle\"); } CaptureTool::Type RectangleTool::type() const { return CaptureTool::TYPE_RECTANGLE; } QString RectangleTool::description() const { return tr(\"Set the Rectangle as the paint tool\"); } CaptureTool* RectangleTool::copy(QObject* parent) { auto* tool = new RectangleTool(parent); copyParams(this, tool); return tool; } void RectangleTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) QPen orig_pen = painter.pen(); QBrush orig_brush = painter.brush(); painter.setPen( QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::RoundJoin)); painter.setBrush(QBrush(color())); if (size() == 0) { painter.drawRect(QRect(points().first, points().second)); } else { QPainterPath path; int offset = size() <= 1 ? 1 : static_cast<int>(round(size() / 2 + 0.5)); path.addRoundedRect( QRectF( std::min(points().first.x(), points().second.x()) - offset, std::min(points().first.y(), points().second.y()) - offset, std::abs(points().first.x() - points().second.x()) + offset * 2, std::abs(points().first.y() - points().second.y()) + offset * 2), size(), size()); painter.fillPath(path, color()); } painter.setPen(orig_pen); painter.setBrush(orig_brush); } void RectangleTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); onSizeChanged(context.toolSize); } void RectangleTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File rectangletool.cpp"},{"location":"flameshot/rectangletool_8cpp_source/#file-rectangletoolcpp","text":"File List > rectangle > rectangletool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"rectangletool.h\" #include <QPainter> #include <QPainterPath> #include <cmath> RectangleTool::RectangleTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } QIcon RectangleTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"square.svg\"); } QString RectangleTool::name() const { return tr(\"Rectangle\"); } CaptureTool::Type RectangleTool::type() const { return CaptureTool::TYPE_RECTANGLE; } QString RectangleTool::description() const { return tr(\"Set the Rectangle as the paint tool\"); } CaptureTool* RectangleTool::copy(QObject* parent) { auto* tool = new RectangleTool(parent); copyParams(this, tool); return tool; } void RectangleTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) QPen orig_pen = painter.pen(); QBrush orig_brush = painter.brush(); painter.setPen( QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::RoundJoin)); painter.setBrush(QBrush(color())); if (size() == 0) { painter.drawRect(QRect(points().first, points().second)); } else { QPainterPath path; int offset = size() <= 1 ? 1 : static_cast<int>(round(size() / 2 + 0.5)); path.addRoundedRect( QRectF( std::min(points().first.x(), points().second.x()) - offset, std::min(points().first.y(), points().second.y()) - offset, std::abs(points().first.x() - points().second.x()) + offset * 2, std::abs(points().first.y() - points().second.y()) + offset * 2), size(), size()); painter.fillPath(path, color()); } painter.setPen(orig_pen); painter.setBrush(orig_brush); } void RectangleTool::drawStart(const CaptureContext& context) { AbstractTwoPointTool::drawStart(context); onSizeChanged(context.toolSize); } void RectangleTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File rectangletool.cpp"},{"location":"flameshot/rectangletool_8h/","text":"File rectangletool.h # FileList > rectangle > rectangletool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class RectangleTool","title":"File rectangletool.h"},{"location":"flameshot/rectangletool_8h/#file-rectangletoolh","text":"FileList > rectangle > rectangletool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File rectangletool.h"},{"location":"flameshot/rectangletool_8h/#classes","text":"Type Name class RectangleTool","title":"Classes"},{"location":"flameshot/rectangletool_8h_source/","text":"File rectangletool.h # File List > rectangle > rectangletool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class RectangleTool : public AbstractTwoPointTool { Q_OBJECT public: explicit RectangleTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File rectangletool.h"},{"location":"flameshot/rectangletool_8h_source/#file-rectangletoolh","text":"File List > rectangle > rectangletool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class RectangleTool : public AbstractTwoPointTool { Q_OBJECT public: explicit RectangleTool(QObject* parent = nullptr); QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; };","title":"File rectangletool.h"},{"location":"flameshot/dir_1ff013da6731a496c5c20c595c3604d8/","text":"Dir redo # FileList > redo Files # Type Name file redotool.cpp file redotool.h","title":"Dir redo"},{"location":"flameshot/dir_1ff013da6731a496c5c20c595c3604d8/#dir-redo","text":"FileList > redo","title":"Dir redo"},{"location":"flameshot/dir_1ff013da6731a496c5c20c595c3604d8/#files","text":"Type Name file redotool.cpp file redotool.h","title":"Files"},{"location":"flameshot/redotool_8cpp/","text":"File redotool.cpp # FileList > redo > redotool.cpp Go to the source code of this file. #include \"redotool.h\" #include <QPainter>","title":"File redotool.cpp"},{"location":"flameshot/redotool_8cpp/#file-redotoolcpp","text":"FileList > redo > redotool.cpp Go to the source code of this file. #include \"redotool.h\" #include <QPainter>","title":"File redotool.cpp"},{"location":"flameshot/redotool_8cpp_source/","text":"File redotool.cpp # File List > redo > redotool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"redotool.h\" #include <QPainter> RedoTool::RedoTool(QObject* parent) : AbstractActionTool(parent) {} bool RedoTool::closeOnButtonPressed() const { return false; } QIcon RedoTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"redo-variant.svg\"); } QString RedoTool::name() const { return tr(\"Redo\"); } CaptureTool::Type RedoTool::type() const { return CaptureTool::TYPE_REDO; } QString RedoTool::description() const { return tr(\"Redo the next modification\"); } CaptureTool* RedoTool::copy(QObject* parent) { return new RedoTool(parent); } void RedoTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_REDO_MODIFICATION); }","title":"File redotool.cpp"},{"location":"flameshot/redotool_8cpp_source/#file-redotoolcpp","text":"File List > redo > redotool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"redotool.h\" #include <QPainter> RedoTool::RedoTool(QObject* parent) : AbstractActionTool(parent) {} bool RedoTool::closeOnButtonPressed() const { return false; } QIcon RedoTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"redo-variant.svg\"); } QString RedoTool::name() const { return tr(\"Redo\"); } CaptureTool::Type RedoTool::type() const { return CaptureTool::TYPE_REDO; } QString RedoTool::description() const { return tr(\"Redo the next modification\"); } CaptureTool* RedoTool::copy(QObject* parent) { return new RedoTool(parent); } void RedoTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_REDO_MODIFICATION); }","title":"File redotool.cpp"},{"location":"flameshot/redotool_8h/","text":"File redotool.h # FileList > redo > redotool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class RedoTool","title":"File redotool.h"},{"location":"flameshot/redotool_8h/#file-redotoolh","text":"FileList > redo > redotool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File redotool.h"},{"location":"flameshot/redotool_8h/#classes","text":"Type Name class RedoTool","title":"Classes"},{"location":"flameshot/redotool_8h_source/","text":"File redotool.h # File List > redo > redotool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class RedoTool : public AbstractActionTool { Q_OBJECT public: explicit RedoTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File redotool.h"},{"location":"flameshot/redotool_8h_source/#file-redotoolh","text":"File List > redo > redotool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class RedoTool : public AbstractActionTool { Q_OBJECT public: explicit RedoTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File redotool.h"},{"location":"flameshot/dir_3c4a7bc90ef282c246ef9e2efd31c803/","text":"Dir save # FileList > save Files # Type Name file savetool.cpp file savetool.h","title":"Dir save"},{"location":"flameshot/dir_3c4a7bc90ef282c246ef9e2efd31c803/#dir-save","text":"FileList > save","title":"Dir save"},{"location":"flameshot/dir_3c4a7bc90ef282c246ef9e2efd31c803/#files","text":"Type Name file savetool.cpp file savetool.h","title":"Files"},{"location":"flameshot/savetool_8cpp/","text":"File savetool.cpp # FileList > save > savetool.cpp Go to the source code of this file. #include \"savetool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter>","title":"File savetool.cpp"},{"location":"flameshot/savetool_8cpp/#file-savetoolcpp","text":"FileList > save > savetool.cpp Go to the source code of this file. #include \"savetool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter>","title":"File savetool.cpp"},{"location":"flameshot/savetool_8cpp_source/","text":"File savetool.cpp # File List > save > savetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"savetool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter> SaveTool::SaveTool(QObject* parent) : AbstractActionTool(parent) {} bool SaveTool::closeOnButtonPressed() const { return true; } QIcon SaveTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"content-save.svg\"); } QString SaveTool::name() const { return tr(\"Save\"); } CaptureTool::Type SaveTool::type() const { return CaptureTool::TYPE_SAVE; } QString SaveTool::description() const { return tr(\"Save screenshot to a file\"); } CaptureTool* SaveTool::copy(QObject* parent) { return new SaveTool(parent); } void SaveTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); context.request.addSaveTask(); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_CLOSE_GUI); }","title":"File savetool.cpp"},{"location":"flameshot/savetool_8cpp_source/#file-savetoolcpp","text":"File List > save > savetool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"savetool.h\" #include \"src/utils/screenshotsaver.h\" #include <QPainter> SaveTool::SaveTool(QObject* parent) : AbstractActionTool(parent) {} bool SaveTool::closeOnButtonPressed() const { return true; } QIcon SaveTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"content-save.svg\"); } QString SaveTool::name() const { return tr(\"Save\"); } CaptureTool::Type SaveTool::type() const { return CaptureTool::TYPE_SAVE; } QString SaveTool::description() const { return tr(\"Save screenshot to a file\"); } CaptureTool* SaveTool::copy(QObject* parent) { return new SaveTool(parent); } void SaveTool::pressed(CaptureContext& context) { emit requestAction(REQ_CLEAR_SELECTION); context.request.addSaveTask(); emit requestAction(REQ_CAPTURE_DONE_OK); emit requestAction(REQ_CLOSE_GUI); }","title":"File savetool.cpp"},{"location":"flameshot/savetool_8h/","text":"File savetool.h # FileList > save > savetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class SaveTool","title":"File savetool.h"},{"location":"flameshot/savetool_8h/#file-savetoolh","text":"FileList > save > savetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File savetool.h"},{"location":"flameshot/savetool_8h/#classes","text":"Type Name class SaveTool","title":"Classes"},{"location":"flameshot/savetool_8h_source/","text":"File savetool.h # File List > save > savetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class SaveTool : public AbstractActionTool { Q_OBJECT public: explicit SaveTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File savetool.h"},{"location":"flameshot/savetool_8h_source/#file-savetoolh","text":"File List > save > savetool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class SaveTool : public AbstractActionTool { Q_OBJECT public: explicit SaveTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File savetool.h"},{"location":"flameshot/dir_f9edf2c38a504f974175e7ed9752a343/","text":"Dir selection # FileList > selection Files # Type Name file selectiontool.cpp file selectiontool.h","title":"Dir selection"},{"location":"flameshot/dir_f9edf2c38a504f974175e7ed9752a343/#dir-selection","text":"FileList > selection","title":"Dir selection"},{"location":"flameshot/dir_f9edf2c38a504f974175e7ed9752a343/#files","text":"Type Name file selectiontool.cpp file selectiontool.h","title":"Files"},{"location":"flameshot/selectiontool_8cpp/","text":"File selectiontool.cpp # FileList > selection > selectiontool.cpp Go to the source code of this file. #include \"selectiontool.h\" #include <QPainter>","title":"File selectiontool.cpp"},{"location":"flameshot/selectiontool_8cpp/#file-selectiontoolcpp","text":"FileList > selection > selectiontool.cpp Go to the source code of this file. #include \"selectiontool.h\" #include <QPainter>","title":"File selectiontool.cpp"},{"location":"flameshot/selectiontool_8cpp_source/","text":"File selectiontool.cpp # File List > selection > selectiontool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"selectiontool.h\" #include <QPainter> SelectionTool::SelectionTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } bool SelectionTool::closeOnButtonPressed() const { return false; } QIcon SelectionTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"square-outline.svg\"); } QString SelectionTool::name() const { return tr(\"Rectangular Selection\"); } CaptureTool::Type SelectionTool::type() const { return CaptureTool::TYPE_SELECTION; } QString SelectionTool::description() const { return tr(\"Set Selection as the paint tool\"); } CaptureTool* SelectionTool::copy(QObject* parent) { auto* tool = new SelectionTool(parent); copyParams(this, tool); return tool; } void SelectionTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen( QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::MiterJoin)); painter.drawRect(QRect(points().first, points().second)); } void SelectionTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File selectiontool.cpp"},{"location":"flameshot/selectiontool_8cpp_source/#file-selectiontoolcpp","text":"File List > selection > selectiontool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"selectiontool.h\" #include <QPainter> SelectionTool::SelectionTool(QObject* parent) : AbstractTwoPointTool(parent) { m_supportsDiagonalAdj = true; } bool SelectionTool::closeOnButtonPressed() const { return false; } QIcon SelectionTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"square-outline.svg\"); } QString SelectionTool::name() const { return tr(\"Rectangular Selection\"); } CaptureTool::Type SelectionTool::type() const { return CaptureTool::TYPE_SELECTION; } QString SelectionTool::description() const { return tr(\"Set Selection as the paint tool\"); } CaptureTool* SelectionTool::copy(QObject* parent) { auto* tool = new SelectionTool(parent); copyParams(this, tool); return tool; } void SelectionTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) painter.setPen( QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::MiterJoin)); painter.drawRect(QRect(points().first, points().second)); } void SelectionTool::pressed(CaptureContext& context) { Q_UNUSED(context) }","title":"File selectiontool.cpp"},{"location":"flameshot/selectiontool_8h/","text":"File selectiontool.h # FileList > selection > selectiontool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\" Classes # Type Name class SelectionTool","title":"File selectiontool.h"},{"location":"flameshot/selectiontool_8h/#file-selectiontoolh","text":"FileList > selection > selectiontool.h Go to the source code of this file. #include \"src/tools/abstracttwopointtool.h\"","title":"File selectiontool.h"},{"location":"flameshot/selectiontool_8h/#classes","text":"Type Name class SelectionTool","title":"Classes"},{"location":"flameshot/selectiontool_8h_source/","text":"File selectiontool.h # File List > selection > selectiontool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class SelectionTool : public AbstractTwoPointTool { Q_OBJECT public: explicit SelectionTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File selectiontool.h"},{"location":"flameshot/selectiontool_8h_source/#file-selectiontoolh","text":"File List > selection > selectiontool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstracttwopointtool.h\" class SelectionTool : public AbstractTwoPointTool { Q_OBJECT public: explicit SelectionTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File selectiontool.h"},{"location":"flameshot/dir_b0ea79cfc017f31af5ad5063fc901952/","text":"Dir sizedecrease # FileList > sizedecrease Files # Type Name file sizedecreasetool.cpp file sizedecreasetool.h","title":"Dir sizedecrease"},{"location":"flameshot/dir_b0ea79cfc017f31af5ad5063fc901952/#dir-sizedecrease","text":"FileList > sizedecrease","title":"Dir sizedecrease"},{"location":"flameshot/dir_b0ea79cfc017f31af5ad5063fc901952/#files","text":"Type Name file sizedecreasetool.cpp file sizedecreasetool.h","title":"Files"},{"location":"flameshot/sizedecreasetool_8cpp/","text":"File sizedecreasetool.cpp # FileList > sizedecrease > sizedecreasetool.cpp Go to the source code of this file. #include \"sizedecreasetool.h\" #include <QPainter>","title":"File sizedecreasetool.cpp"},{"location":"flameshot/sizedecreasetool_8cpp/#file-sizedecreasetoolcpp","text":"FileList > sizedecrease > sizedecreasetool.cpp Go to the source code of this file. #include \"sizedecreasetool.h\" #include <QPainter>","title":"File sizedecreasetool.cpp"},{"location":"flameshot/sizedecreasetool_8cpp_source/","text":"File sizedecreasetool.cpp # File List > sizedecrease > sizedecreasetool.cpp Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #include \"sizedecreasetool.h\" #include <QPainter> SizeDecreaseTool::SizeDecreaseTool(QObject* parent) : AbstractActionTool(parent) {} bool SizeDecreaseTool::closeOnButtonPressed() const { return false; } QIcon SizeDecreaseTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"minus.svg\"); } QString SizeDecreaseTool::name() const { return tr(\"Decrease Tool Size\"); } CaptureTool::Type SizeDecreaseTool::type() const { return CaptureTool::TYPE_SIZEDECREASE; } QString SizeDecreaseTool::description() const { return tr(\"Decrease the size of the other tools\"); } CaptureTool* SizeDecreaseTool::copy(QObject* parent) { return new SizeDecreaseTool(parent); } void SizeDecreaseTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_DECREASE_TOOL_SIZE); }","title":"File sizedecreasetool.cpp"},{"location":"flameshot/sizedecreasetool_8cpp_source/#file-sizedecreasetoolcpp","text":"File List > sizedecrease > sizedecreasetool.cpp Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #include \"sizedecreasetool.h\" #include <QPainter> SizeDecreaseTool::SizeDecreaseTool(QObject* parent) : AbstractActionTool(parent) {} bool SizeDecreaseTool::closeOnButtonPressed() const { return false; } QIcon SizeDecreaseTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"minus.svg\"); } QString SizeDecreaseTool::name() const { return tr(\"Decrease Tool Size\"); } CaptureTool::Type SizeDecreaseTool::type() const { return CaptureTool::TYPE_SIZEDECREASE; } QString SizeDecreaseTool::description() const { return tr(\"Decrease the size of the other tools\"); } CaptureTool* SizeDecreaseTool::copy(QObject* parent) { return new SizeDecreaseTool(parent); } void SizeDecreaseTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_DECREASE_TOOL_SIZE); }","title":"File sizedecreasetool.cpp"},{"location":"flameshot/sizedecreasetool_8h/","text":"File sizedecreasetool.h # FileList > sizedecrease > sizedecreasetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class SizeDecreaseTool","title":"File sizedecreasetool.h"},{"location":"flameshot/sizedecreasetool_8h/#file-sizedecreasetoolh","text":"FileList > sizedecrease > sizedecreasetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File sizedecreasetool.h"},{"location":"flameshot/sizedecreasetool_8h/#classes","text":"Type Name class SizeDecreaseTool","title":"Classes"},{"location":"flameshot/sizedecreasetool_8h_source/","text":"File sizedecreasetool.h # File List > sizedecrease > sizedecreasetool.h Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #pragma once #include \"src/tools/abstractactiontool.h\" class SizeDecreaseTool : public AbstractActionTool { Q_OBJECT public: explicit SizeDecreaseTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File sizedecreasetool.h"},{"location":"flameshot/sizedecreasetool_8h_source/#file-sizedecreasetoolh","text":"File List > sizedecrease > sizedecreasetool.h Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #pragma once #include \"src/tools/abstractactiontool.h\" class SizeDecreaseTool : public AbstractActionTool { Q_OBJECT public: explicit SizeDecreaseTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File sizedecreasetool.h"},{"location":"flameshot/dir_777de1af8ff1563507ac02c87d0e93ef/","text":"Dir sizeincrease # FileList > sizeincrease Files # Type Name file sizeincreasetool.cpp file sizeincreasetool.h","title":"Dir sizeincrease"},{"location":"flameshot/dir_777de1af8ff1563507ac02c87d0e93ef/#dir-sizeincrease","text":"FileList > sizeincrease","title":"Dir sizeincrease"},{"location":"flameshot/dir_777de1af8ff1563507ac02c87d0e93ef/#files","text":"Type Name file sizeincreasetool.cpp file sizeincreasetool.h","title":"Files"},{"location":"flameshot/sizeincreasetool_8cpp/","text":"File sizeincreasetool.cpp # FileList > sizeincrease > sizeincreasetool.cpp Go to the source code of this file. #include \"sizeincreasetool.h\" #include <QPainter>","title":"File sizeincreasetool.cpp"},{"location":"flameshot/sizeincreasetool_8cpp/#file-sizeincreasetoolcpp","text":"FileList > sizeincrease > sizeincreasetool.cpp Go to the source code of this file. #include \"sizeincreasetool.h\" #include <QPainter>","title":"File sizeincreasetool.cpp"},{"location":"flameshot/sizeincreasetool_8cpp_source/","text":"File sizeincreasetool.cpp # File List > sizeincrease > sizeincreasetool.cpp Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #include \"sizeincreasetool.h\" #include <QPainter> SizeIncreaseTool::SizeIncreaseTool(QObject* parent) : AbstractActionTool(parent) {} bool SizeIncreaseTool::closeOnButtonPressed() const { return false; } QIcon SizeIncreaseTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"plus.svg\"); } QString SizeIncreaseTool::name() const { return tr(\"Increase Tool Size\"); } CaptureTool::Type SizeIncreaseTool::type() const { return CaptureTool::TYPE_SIZEINCREASE; } QString SizeIncreaseTool::description() const { return tr(\"Increase the size of the other tools\"); } CaptureTool* SizeIncreaseTool::copy(QObject* parent) { return new SizeIncreaseTool(parent); } void SizeIncreaseTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_INCREASE_TOOL_SIZE); }","title":"File sizeincreasetool.cpp"},{"location":"flameshot/sizeincreasetool_8cpp_source/#file-sizeincreasetoolcpp","text":"File List > sizeincrease > sizeincreasetool.cpp Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #include \"sizeincreasetool.h\" #include <QPainter> SizeIncreaseTool::SizeIncreaseTool(QObject* parent) : AbstractActionTool(parent) {} bool SizeIncreaseTool::closeOnButtonPressed() const { return false; } QIcon SizeIncreaseTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"plus.svg\"); } QString SizeIncreaseTool::name() const { return tr(\"Increase Tool Size\"); } CaptureTool::Type SizeIncreaseTool::type() const { return CaptureTool::TYPE_SIZEINCREASE; } QString SizeIncreaseTool::description() const { return tr(\"Increase the size of the other tools\"); } CaptureTool* SizeIncreaseTool::copy(QObject* parent) { return new SizeIncreaseTool(parent); } void SizeIncreaseTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_INCREASE_TOOL_SIZE); }","title":"File sizeincreasetool.cpp"},{"location":"flameshot/sizeincreasetool_8h/","text":"File sizeincreasetool.h # FileList > sizeincrease > sizeincreasetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class SizeIncreaseTool","title":"File sizeincreasetool.h"},{"location":"flameshot/sizeincreasetool_8h/#file-sizeincreasetoolh","text":"FileList > sizeincrease > sizeincreasetool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File sizeincreasetool.h"},{"location":"flameshot/sizeincreasetool_8h/#classes","text":"Type Name class SizeIncreaseTool","title":"Classes"},{"location":"flameshot/sizeincreasetool_8h_source/","text":"File sizeincreasetool.h # File List > sizeincrease > sizeincreasetool.h Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #pragma once #include \"src/tools/abstractactiontool.h\" class SizeIncreaseTool : public AbstractActionTool { Q_OBJECT public: explicit SizeIncreaseTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File sizeincreasetool.h"},{"location":"flameshot/sizeincreasetool_8h_source/#file-sizeincreasetoolh","text":"File List > sizeincrease > sizeincreasetool.h Go to the documentation of this file. // Copyright(c) 2017-2019 Alejandro Sirgo Rica & Contributors // // This file is part of Flameshot. // // Flameshot is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // Flameshot is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with Flameshot. If not, see <http://www.gnu.org/licenses/>. #pragma once #include \"src/tools/abstractactiontool.h\" class SizeIncreaseTool : public AbstractActionTool { Q_OBJECT public: explicit SizeIncreaseTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File sizeincreasetool.h"},{"location":"flameshot/dir_f5021cd629193c5e75833314925eef7a/","text":"Dir text # FileList > src > tools > text Files # Type Name file textconfig.cpp file textconfig.h file texttool.cpp file texttool.h file textwidget.cpp file textwidget.h","title":"Dir text"},{"location":"flameshot/dir_f5021cd629193c5e75833314925eef7a/#dir-text","text":"FileList > src > tools > text","title":"Dir text"},{"location":"flameshot/dir_f5021cd629193c5e75833314925eef7a/#files","text":"Type Name file textconfig.cpp file textconfig.h file texttool.cpp file texttool.h file textwidget.cpp file textwidget.h","title":"Files"},{"location":"flameshot/textconfig_8cpp/","text":"File textconfig.cpp # FileList > src > tools > text > textconfig.cpp Go to the source code of this file. #include \"textconfig.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/pathinfo.h\" #include <QComboBox> #include <QFontDatabase> #include <QHBoxLayout> #include <QPushButton>","title":"File textconfig.cpp"},{"location":"flameshot/textconfig_8cpp/#file-textconfigcpp","text":"FileList > src > tools > text > textconfig.cpp Go to the source code of this file. #include \"textconfig.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/pathinfo.h\" #include <QComboBox> #include <QFontDatabase> #include <QHBoxLayout> #include <QPushButton>","title":"File textconfig.cpp"},{"location":"flameshot/textconfig_8cpp_source/","text":"File textconfig.cpp # File List > src > tools > text > textconfig.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"textconfig.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/pathinfo.h\" #include <QComboBox> #include <QFontDatabase> #include <QHBoxLayout> #include <QPushButton> TextConfig::TextConfig(QWidget* parent) : QWidget(parent) , m_layout(new QVBoxLayout(this)) , m_fontsCB(new QComboBox()) , m_strikeOutButton(nullptr) , m_underlineButton(nullptr) , m_weightButton(nullptr) , m_italicButton(nullptr) , m_leftAlignButton(nullptr) , m_centerAlignButton(nullptr) , m_rightAlignButton(nullptr) { QFontDatabase fontDB; connect(m_fontsCB, &QComboBox::currentTextChanged, this, &TextConfig::fontFamilyChanged); m_fontsCB->addItems(fontDB.families()); setFontFamily(ConfigHandler().fontFamily()); QString iconPrefix = ColorUtils::colorIsDark(palette().windowText().color()) ? PathInfo::blackIconPath() : PathInfo::whiteIconPath(); m_strikeOutButton = new QPushButton( QIcon(iconPrefix + \"format_strikethrough.svg\"), QLatin1String(\"\")); m_strikeOutButton->setCheckable(true); connect(m_strikeOutButton, &QPushButton::clicked, this, &TextConfig::fontStrikeOutChanged); m_strikeOutButton->setToolTip(tr(\"StrikeOut\")); m_underlineButton = new QPushButton( QIcon(iconPrefix + \"format_underlined.svg\"), QLatin1String(\"\")); m_underlineButton->setCheckable(true); connect(m_underlineButton, &QPushButton::clicked, this, &TextConfig::fontUnderlineChanged); m_underlineButton->setToolTip(tr(\"Underline\")); m_weightButton = new QPushButton(QIcon(iconPrefix + \"format_bold.svg\"), QLatin1String(\"\")); m_weightButton->setCheckable(true); connect(m_weightButton, &QPushButton::clicked, this, &TextConfig::weightButtonPressed); m_weightButton->setToolTip(tr(\"Bold\")); m_italicButton = new QPushButton(QIcon(iconPrefix + \"format_italic.svg\"), QLatin1String(\"\")); m_italicButton->setCheckable(true); connect(m_italicButton, &QPushButton::clicked, this, &TextConfig::fontItalicChanged); m_italicButton->setToolTip(tr(\"Italic\")); auto* modifiersLayout = new QHBoxLayout(); m_leftAlignButton = new QPushButton(QIcon(iconPrefix + \"leftalign.svg\"), QLatin1String(\"\")); m_leftAlignButton->setCheckable(true); m_leftAlignButton->setAutoExclusive(true); connect(m_leftAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignLeft); }); m_leftAlignButton->setToolTip(tr(\"Left Align\")); m_centerAlignButton = new QPushButton(QIcon(iconPrefix + \"centeralign.svg\"), QLatin1String(\"\")); m_centerAlignButton->setCheckable(true); m_centerAlignButton->setAutoExclusive(true); connect(m_centerAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignCenter); }); m_centerAlignButton->setToolTip(tr(\"Center Align\")); m_rightAlignButton = new QPushButton(QIcon(iconPrefix + \"rightalign.svg\"), QLatin1String(\"\")); m_rightAlignButton->setCheckable(true); m_rightAlignButton->setAutoExclusive(true); connect(m_rightAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignRight); }); m_rightAlignButton->setToolTip(tr(\"Right Align\")); auto* alignmentLayout = new QHBoxLayout(); alignmentLayout->addWidget(m_leftAlignButton); alignmentLayout->addWidget(m_centerAlignButton); alignmentLayout->addWidget(m_rightAlignButton); m_layout->addWidget(m_fontsCB); modifiersLayout->addWidget(m_strikeOutButton); modifiersLayout->addWidget(m_underlineButton); modifiersLayout->addWidget(m_weightButton); modifiersLayout->addWidget(m_italicButton); m_layout->addLayout(modifiersLayout); m_layout->addLayout(alignmentLayout); } void TextConfig::setFontFamily(const QString& fontFamily) { m_fontsCB->setCurrentIndex( m_fontsCB->findText(fontFamily.isEmpty() ? font().family() : fontFamily)); } void TextConfig::setUnderline(const bool underline) { m_underlineButton->setChecked(underline); } void TextConfig::setStrikeOut(const bool strikeout) { m_strikeOutButton->setChecked(strikeout); } void TextConfig::setWeight(const int weight) { m_weightButton->setChecked(static_cast<QFont::Weight>(weight) == QFont::Bold); } void TextConfig::setItalic(const bool italic) { m_italicButton->setChecked(italic); } void TextConfig::weightButtonPressed(const bool weight) { if (weight) { emit fontWeightChanged(QFont::Bold); } else { emit fontWeightChanged(QFont::Normal); } } void TextConfig::setTextAlignment(Qt::AlignmentFlag alignment) { switch (alignment) { case (Qt::AlignCenter): m_leftAlignButton->setChecked(false); m_centerAlignButton->setChecked(true); m_rightAlignButton->setChecked(false); break; case (Qt::AlignRight): m_leftAlignButton->setChecked(false); m_centerAlignButton->setChecked(false); m_rightAlignButton->setChecked(true); break; case (Qt::AlignLeft): default: m_leftAlignButton->setChecked(true); m_centerAlignButton->setChecked(false); m_rightAlignButton->setChecked(false); break; } emit alignmentChanged(alignment); }","title":"File textconfig.cpp"},{"location":"flameshot/textconfig_8cpp_source/#file-textconfigcpp","text":"File List > src > tools > text > textconfig.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"textconfig.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/pathinfo.h\" #include <QComboBox> #include <QFontDatabase> #include <QHBoxLayout> #include <QPushButton> TextConfig::TextConfig(QWidget* parent) : QWidget(parent) , m_layout(new QVBoxLayout(this)) , m_fontsCB(new QComboBox()) , m_strikeOutButton(nullptr) , m_underlineButton(nullptr) , m_weightButton(nullptr) , m_italicButton(nullptr) , m_leftAlignButton(nullptr) , m_centerAlignButton(nullptr) , m_rightAlignButton(nullptr) { QFontDatabase fontDB; connect(m_fontsCB, &QComboBox::currentTextChanged, this, &TextConfig::fontFamilyChanged); m_fontsCB->addItems(fontDB.families()); setFontFamily(ConfigHandler().fontFamily()); QString iconPrefix = ColorUtils::colorIsDark(palette().windowText().color()) ? PathInfo::blackIconPath() : PathInfo::whiteIconPath(); m_strikeOutButton = new QPushButton( QIcon(iconPrefix + \"format_strikethrough.svg\"), QLatin1String(\"\")); m_strikeOutButton->setCheckable(true); connect(m_strikeOutButton, &QPushButton::clicked, this, &TextConfig::fontStrikeOutChanged); m_strikeOutButton->setToolTip(tr(\"StrikeOut\")); m_underlineButton = new QPushButton( QIcon(iconPrefix + \"format_underlined.svg\"), QLatin1String(\"\")); m_underlineButton->setCheckable(true); connect(m_underlineButton, &QPushButton::clicked, this, &TextConfig::fontUnderlineChanged); m_underlineButton->setToolTip(tr(\"Underline\")); m_weightButton = new QPushButton(QIcon(iconPrefix + \"format_bold.svg\"), QLatin1String(\"\")); m_weightButton->setCheckable(true); connect(m_weightButton, &QPushButton::clicked, this, &TextConfig::weightButtonPressed); m_weightButton->setToolTip(tr(\"Bold\")); m_italicButton = new QPushButton(QIcon(iconPrefix + \"format_italic.svg\"), QLatin1String(\"\")); m_italicButton->setCheckable(true); connect(m_italicButton, &QPushButton::clicked, this, &TextConfig::fontItalicChanged); m_italicButton->setToolTip(tr(\"Italic\")); auto* modifiersLayout = new QHBoxLayout(); m_leftAlignButton = new QPushButton(QIcon(iconPrefix + \"leftalign.svg\"), QLatin1String(\"\")); m_leftAlignButton->setCheckable(true); m_leftAlignButton->setAutoExclusive(true); connect(m_leftAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignLeft); }); m_leftAlignButton->setToolTip(tr(\"Left Align\")); m_centerAlignButton = new QPushButton(QIcon(iconPrefix + \"centeralign.svg\"), QLatin1String(\"\")); m_centerAlignButton->setCheckable(true); m_centerAlignButton->setAutoExclusive(true); connect(m_centerAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignCenter); }); m_centerAlignButton->setToolTip(tr(\"Center Align\")); m_rightAlignButton = new QPushButton(QIcon(iconPrefix + \"rightalign.svg\"), QLatin1String(\"\")); m_rightAlignButton->setCheckable(true); m_rightAlignButton->setAutoExclusive(true); connect(m_rightAlignButton, &QPushButton::clicked, this, [this] { alignmentChanged(Qt::AlignRight); }); m_rightAlignButton->setToolTip(tr(\"Right Align\")); auto* alignmentLayout = new QHBoxLayout(); alignmentLayout->addWidget(m_leftAlignButton); alignmentLayout->addWidget(m_centerAlignButton); alignmentLayout->addWidget(m_rightAlignButton); m_layout->addWidget(m_fontsCB); modifiersLayout->addWidget(m_strikeOutButton); modifiersLayout->addWidget(m_underlineButton); modifiersLayout->addWidget(m_weightButton); modifiersLayout->addWidget(m_italicButton); m_layout->addLayout(modifiersLayout); m_layout->addLayout(alignmentLayout); } void TextConfig::setFontFamily(const QString& fontFamily) { m_fontsCB->setCurrentIndex( m_fontsCB->findText(fontFamily.isEmpty() ? font().family() : fontFamily)); } void TextConfig::setUnderline(const bool underline) { m_underlineButton->setChecked(underline); } void TextConfig::setStrikeOut(const bool strikeout) { m_strikeOutButton->setChecked(strikeout); } void TextConfig::setWeight(const int weight) { m_weightButton->setChecked(static_cast<QFont::Weight>(weight) == QFont::Bold); } void TextConfig::setItalic(const bool italic) { m_italicButton->setChecked(italic); } void TextConfig::weightButtonPressed(const bool weight) { if (weight) { emit fontWeightChanged(QFont::Bold); } else { emit fontWeightChanged(QFont::Normal); } } void TextConfig::setTextAlignment(Qt::AlignmentFlag alignment) { switch (alignment) { case (Qt::AlignCenter): m_leftAlignButton->setChecked(false); m_centerAlignButton->setChecked(true); m_rightAlignButton->setChecked(false); break; case (Qt::AlignRight): m_leftAlignButton->setChecked(false); m_centerAlignButton->setChecked(false); m_rightAlignButton->setChecked(true); break; case (Qt::AlignLeft): default: m_leftAlignButton->setChecked(true); m_centerAlignButton->setChecked(false); m_rightAlignButton->setChecked(false); break; } emit alignmentChanged(alignment); }","title":"File textconfig.cpp"},{"location":"flameshot/textconfig_8h/","text":"File textconfig.h # FileList > src > tools > text > textconfig.h Go to the source code of this file. #include <QWidget> Classes # Type Name class TextConfig","title":"File textconfig.h"},{"location":"flameshot/textconfig_8h/#file-textconfigh","text":"FileList > src > tools > text > textconfig.h Go to the source code of this file. #include <QWidget>","title":"File textconfig.h"},{"location":"flameshot/textconfig_8h/#classes","text":"Type Name class TextConfig","title":"Classes"},{"location":"flameshot/textconfig_8h_source/","text":"File textconfig.h # File List > src > tools > text > textconfig.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QVBoxLayout; class QPushButton; class QComboBox; class TextConfig : public QWidget { Q_OBJECT public: explicit TextConfig(QWidget* parent = nullptr); void setFontFamily(const QString& fontFamily); void setUnderline(bool underline); void setStrikeOut(bool strikeout); void setWeight(int weight); void setItalic(bool italic); void setTextAlignment(Qt::AlignmentFlag alignment); signals: void fontFamilyChanged(const QString& f); void fontUnderlineChanged(const bool underlined); void fontStrikeOutChanged(const bool dashed); void fontWeightChanged(const QFont::Weight w); void fontItalicChanged(const bool italic); void alignmentChanged(Qt::AlignmentFlag alignment); public slots: private slots: void weightButtonPressed(bool weight); private: QVBoxLayout* m_layout; QComboBox* m_fontsCB; QPushButton* m_strikeOutButton; QPushButton* m_underlineButton; QPushButton* m_weightButton; QPushButton* m_italicButton; QPushButton* m_leftAlignButton; QPushButton* m_centerAlignButton; QPushButton* m_rightAlignButton; };","title":"File textconfig.h"},{"location":"flameshot/textconfig_8h_source/#file-textconfigh","text":"File List > src > tools > text > textconfig.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QVBoxLayout; class QPushButton; class QComboBox; class TextConfig : public QWidget { Q_OBJECT public: explicit TextConfig(QWidget* parent = nullptr); void setFontFamily(const QString& fontFamily); void setUnderline(bool underline); void setStrikeOut(bool strikeout); void setWeight(int weight); void setItalic(bool italic); void setTextAlignment(Qt::AlignmentFlag alignment); signals: void fontFamilyChanged(const QString& f); void fontUnderlineChanged(const bool underlined); void fontStrikeOutChanged(const bool dashed); void fontWeightChanged(const QFont::Weight w); void fontItalicChanged(const bool italic); void alignmentChanged(Qt::AlignmentFlag alignment); public slots: private slots: void weightButtonPressed(bool weight); private: QVBoxLayout* m_layout; QComboBox* m_fontsCB; QPushButton* m_strikeOutButton; QPushButton* m_underlineButton; QPushButton* m_weightButton; QPushButton* m_italicButton; QPushButton* m_leftAlignButton; QPushButton* m_centerAlignButton; QPushButton* m_rightAlignButton; };","title":"File textconfig.h"},{"location":"flameshot/texttool_8cpp/","text":"File texttool.cpp # FileList > src > tools > text > texttool.cpp Go to the source code of this file. #include \"texttool.h\" #include \"src/utils/confighandler.h\" #include \"textconfig.h\" #include \"textwidget.h\" Macros # Type Name define BASE_POINT_SIZE 8 define MAX_INFO_LENGTH 24 Macro Definition Documentation # define BASE_POINT_SIZE # #define BASE_POINT_SIZE 8 define MAX_INFO_LENGTH # #define MAX_INFO_LENGTH 24","title":"File texttool.cpp"},{"location":"flameshot/texttool_8cpp/#file-texttoolcpp","text":"FileList > src > tools > text > texttool.cpp Go to the source code of this file. #include \"texttool.h\" #include \"src/utils/confighandler.h\" #include \"textconfig.h\" #include \"textwidget.h\"","title":"File texttool.cpp"},{"location":"flameshot/texttool_8cpp/#macros","text":"Type Name define BASE_POINT_SIZE 8 define MAX_INFO_LENGTH 24","title":"Macros"},{"location":"flameshot/texttool_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/texttool_8cpp/#define-base_point_size","text":"#define BASE_POINT_SIZE 8","title":"define BASE_POINT_SIZE"},{"location":"flameshot/texttool_8cpp/#define-max_info_length","text":"#define MAX_INFO_LENGTH 24","title":"define MAX_INFO_LENGTH"},{"location":"flameshot/texttool_8cpp_source/","text":"File texttool.cpp # File List > src > tools > text > texttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"texttool.h\" #include \"src/utils/confighandler.h\" #include \"textconfig.h\" #include \"textwidget.h\" #define BASE_POINT_SIZE 8 #define MAX_INFO_LENGTH 24 TextTool::TextTool(QObject* parent) : CaptureTool(parent) , m_size(1) { QString fontFamily = ConfigHandler().fontFamily(); if (!fontFamily.isEmpty()) { m_font.setFamily(ConfigHandler().fontFamily()); } m_alignment = Qt::AlignLeft; } TextTool::~TextTool() { closeEditor(); } void TextTool::copyParams(const TextTool* from, TextTool* to) { CaptureTool::copyParams(from, to); to->m_font = from->m_font; to->m_alignment = from->m_alignment; to->m_text = from->m_text; to->m_size = from->m_size; to->m_color = from->m_color; to->m_textArea = from->m_textArea; to->m_currentPos = from->m_currentPos; } bool TextTool::isValid() const { return !m_text.isEmpty(); } bool TextTool::closeOnButtonPressed() const { return false; } bool TextTool::isSelectable() const { return true; } bool TextTool::showMousePreview() const { return false; } QRect TextTool::boundingRect() const { return m_textArea; } QIcon TextTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"text.svg\"); } QString TextTool::name() const { return tr(\"Text\"); } QString TextTool::info() { if (m_text.length() > 0) { m_tempString = QString(\"%1 - %2\").arg(name()).arg(m_text.trimmed()); m_tempString = m_tempString.split(\"\\n\").at(0); if (m_tempString.length() > MAX_INFO_LENGTH) { m_tempString.truncate(MAX_INFO_LENGTH); m_tempString += \"\u2026\"; } return m_tempString; } return name(); } CaptureTool::Type TextTool::type() const { return CaptureTool::TYPE_TEXT; } QString TextTool::description() const { return tr(\"Add text to your capture\"); } QWidget* TextTool::widget() { closeEditor(); m_widget = new TextWidget(); m_widget->setTextColor(m_color); m_font.setPointSize(m_size + BASE_POINT_SIZE); m_widget->setFont(m_font); m_widget->setAlignment(m_alignment); m_widget->setText(m_text); m_widget->selectAll(); connect(m_widget, &TextWidget::textUpdated, this, &TextTool::updateText); return m_widget; } void TextTool::closeEditor() { if (!m_widget.isNull()) { m_widget->hide(); delete m_widget; m_widget = nullptr; } if (!m_confW.isNull()) { m_confW->hide(); delete m_confW; m_confW = nullptr; } } QWidget* TextTool::configurationWidget() { m_confW = new TextConfig(); connect( m_confW, &TextConfig::fontFamilyChanged, this, &TextTool::updateFamily); connect(m_confW, &TextConfig::fontItalicChanged, this, &TextTool::updateFontItalic); connect(m_confW, &TextConfig::fontStrikeOutChanged, this, &TextTool::updateFontStrikeOut); connect(m_confW, &TextConfig::fontUnderlineChanged, this, &TextTool::updateFontUnderline); connect(m_confW, &TextConfig::fontWeightChanged, this, &TextTool::updateFontWeight); connect( m_confW, &TextConfig::alignmentChanged, this, &TextTool::updateAlignment); m_confW->setFontFamily(m_font.family()); m_confW->setItalic(m_font.italic()); m_confW->setUnderline(m_font.underline()); m_confW->setStrikeOut(m_font.strikeOut()); m_confW->setWeight(m_font.weight()); m_confW->setTextAlignment(m_alignment); return m_confW; } CaptureTool* TextTool::copy(QObject* parent) { auto* textTool = new TextTool(parent); if (m_confW != nullptr) { connect(m_confW, &TextConfig::fontFamilyChanged, textTool, &TextTool::updateFamily); connect(m_confW, &TextConfig::fontItalicChanged, textTool, &TextTool::updateFontItalic); connect(m_confW, &TextConfig::fontStrikeOutChanged, textTool, &TextTool::updateFontStrikeOut); connect(m_confW, &TextConfig::fontUnderlineChanged, textTool, &TextTool::updateFontUnderline); connect(m_confW, &TextConfig::fontWeightChanged, textTool, &TextTool::updateFontWeight); connect(m_confW, &TextConfig::alignmentChanged, textTool, &TextTool::updateAlignment); } copyParams(this, textTool); return textTool; } void TextTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) if (m_text.isEmpty()) { return; } const int val = 5; QFont orig_font = painter.font(); QPen orig_pen = painter.pen(); QFontMetrics fm(m_font); QSize size(fm.boundingRect(QRect(), 0, m_text).size()); size.setWidth(size.width() + val * 2); size.setHeight(size.height() + val * 2); m_textArea.setSize(size); // draw text painter.setFont(m_font); painter.setPen(m_color); if (!editMode()) { painter.drawText( m_textArea + QMargins(-val, -val, val, val), m_alignment, m_text); } painter.setFont(orig_font); painter.setPen(orig_pen); if (m_widget != nullptr) { m_widget->setAlignment(m_alignment); } } void TextTool::drawObjectSelection(QPainter& painter) { if (m_text.isEmpty()) { return; } drawObjectSelectionRect(painter, boundingRect()); } void TextTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(painter) Q_UNUSED(context) } void TextTool::drawEnd(const QPoint& point) { m_textArea.moveTo(point); } void TextTool::drawMove(const QPoint& point) { m_widget->move(point); } void TextTool::drawStart(const CaptureContext& context) { m_color = context.color; m_size = context.toolSize; emit requestAction(REQ_ADD_CHILD_WIDGET); } void TextTool::pressed(CaptureContext& context) { Q_UNUSED(context) } void TextTool::onColorChanged(const QColor& color) { m_color = color; if (m_widget != nullptr) { m_widget->setTextColor(color); } } void TextTool::onSizeChanged(int size) { m_size = size; m_font.setPointSize(m_size + BASE_POINT_SIZE); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateText(const QString& newText) { m_text = newText; } void TextTool::updateFamily(const QString& text) { m_font.setFamily(text); if (m_textOld.isEmpty()) { ConfigHandler().setFontFamily(m_font.family()); } if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontUnderline(const bool underlined) { m_font.setUnderline(underlined); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontStrikeOut(const bool strikeout) { m_font.setStrikeOut(strikeout); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontWeight(const QFont::Weight weight) { m_font.setWeight(weight); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontItalic(const bool italic) { m_font.setItalic(italic); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::move(const QPoint& pos) { m_textArea.moveTo(pos); } void TextTool::updateAlignment(Qt::AlignmentFlag alignment) { m_alignment = alignment; if (m_widget != nullptr) { m_widget->setAlignment(m_alignment); } } const QPoint* TextTool::pos() { m_currentPos = m_textArea.topLeft(); return &m_currentPos; } void TextTool::setEditMode(bool editMode) { if (editMode) { m_textOld = m_text; } CaptureTool::setEditMode(editMode); } bool TextTool::isChanged() { return QString::compare(m_text, m_textOld, Qt::CaseInsensitive) != 0; }","title":"File texttool.cpp"},{"location":"flameshot/texttool_8cpp_source/#file-texttoolcpp","text":"File List > src > tools > text > texttool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"texttool.h\" #include \"src/utils/confighandler.h\" #include \"textconfig.h\" #include \"textwidget.h\" #define BASE_POINT_SIZE 8 #define MAX_INFO_LENGTH 24 TextTool::TextTool(QObject* parent) : CaptureTool(parent) , m_size(1) { QString fontFamily = ConfigHandler().fontFamily(); if (!fontFamily.isEmpty()) { m_font.setFamily(ConfigHandler().fontFamily()); } m_alignment = Qt::AlignLeft; } TextTool::~TextTool() { closeEditor(); } void TextTool::copyParams(const TextTool* from, TextTool* to) { CaptureTool::copyParams(from, to); to->m_font = from->m_font; to->m_alignment = from->m_alignment; to->m_text = from->m_text; to->m_size = from->m_size; to->m_color = from->m_color; to->m_textArea = from->m_textArea; to->m_currentPos = from->m_currentPos; } bool TextTool::isValid() const { return !m_text.isEmpty(); } bool TextTool::closeOnButtonPressed() const { return false; } bool TextTool::isSelectable() const { return true; } bool TextTool::showMousePreview() const { return false; } QRect TextTool::boundingRect() const { return m_textArea; } QIcon TextTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"text.svg\"); } QString TextTool::name() const { return tr(\"Text\"); } QString TextTool::info() { if (m_text.length() > 0) { m_tempString = QString(\"%1 - %2\").arg(name()).arg(m_text.trimmed()); m_tempString = m_tempString.split(\"\\n\").at(0); if (m_tempString.length() > MAX_INFO_LENGTH) { m_tempString.truncate(MAX_INFO_LENGTH); m_tempString += \"\u2026\"; } return m_tempString; } return name(); } CaptureTool::Type TextTool::type() const { return CaptureTool::TYPE_TEXT; } QString TextTool::description() const { return tr(\"Add text to your capture\"); } QWidget* TextTool::widget() { closeEditor(); m_widget = new TextWidget(); m_widget->setTextColor(m_color); m_font.setPointSize(m_size + BASE_POINT_SIZE); m_widget->setFont(m_font); m_widget->setAlignment(m_alignment); m_widget->setText(m_text); m_widget->selectAll(); connect(m_widget, &TextWidget::textUpdated, this, &TextTool::updateText); return m_widget; } void TextTool::closeEditor() { if (!m_widget.isNull()) { m_widget->hide(); delete m_widget; m_widget = nullptr; } if (!m_confW.isNull()) { m_confW->hide(); delete m_confW; m_confW = nullptr; } } QWidget* TextTool::configurationWidget() { m_confW = new TextConfig(); connect( m_confW, &TextConfig::fontFamilyChanged, this, &TextTool::updateFamily); connect(m_confW, &TextConfig::fontItalicChanged, this, &TextTool::updateFontItalic); connect(m_confW, &TextConfig::fontStrikeOutChanged, this, &TextTool::updateFontStrikeOut); connect(m_confW, &TextConfig::fontUnderlineChanged, this, &TextTool::updateFontUnderline); connect(m_confW, &TextConfig::fontWeightChanged, this, &TextTool::updateFontWeight); connect( m_confW, &TextConfig::alignmentChanged, this, &TextTool::updateAlignment); m_confW->setFontFamily(m_font.family()); m_confW->setItalic(m_font.italic()); m_confW->setUnderline(m_font.underline()); m_confW->setStrikeOut(m_font.strikeOut()); m_confW->setWeight(m_font.weight()); m_confW->setTextAlignment(m_alignment); return m_confW; } CaptureTool* TextTool::copy(QObject* parent) { auto* textTool = new TextTool(parent); if (m_confW != nullptr) { connect(m_confW, &TextConfig::fontFamilyChanged, textTool, &TextTool::updateFamily); connect(m_confW, &TextConfig::fontItalicChanged, textTool, &TextTool::updateFontItalic); connect(m_confW, &TextConfig::fontStrikeOutChanged, textTool, &TextTool::updateFontStrikeOut); connect(m_confW, &TextConfig::fontUnderlineChanged, textTool, &TextTool::updateFontUnderline); connect(m_confW, &TextConfig::fontWeightChanged, textTool, &TextTool::updateFontWeight); connect(m_confW, &TextConfig::alignmentChanged, textTool, &TextTool::updateAlignment); } copyParams(this, textTool); return textTool; } void TextTool::process(QPainter& painter, const QPixmap& pixmap) { Q_UNUSED(pixmap) if (m_text.isEmpty()) { return; } const int val = 5; QFont orig_font = painter.font(); QPen orig_pen = painter.pen(); QFontMetrics fm(m_font); QSize size(fm.boundingRect(QRect(), 0, m_text).size()); size.setWidth(size.width() + val * 2); size.setHeight(size.height() + val * 2); m_textArea.setSize(size); // draw text painter.setFont(m_font); painter.setPen(m_color); if (!editMode()) { painter.drawText( m_textArea + QMargins(-val, -val, val, val), m_alignment, m_text); } painter.setFont(orig_font); painter.setPen(orig_pen); if (m_widget != nullptr) { m_widget->setAlignment(m_alignment); } } void TextTool::drawObjectSelection(QPainter& painter) { if (m_text.isEmpty()) { return; } drawObjectSelectionRect(painter, boundingRect()); } void TextTool::paintMousePreview(QPainter& painter, const CaptureContext& context) { Q_UNUSED(painter) Q_UNUSED(context) } void TextTool::drawEnd(const QPoint& point) { m_textArea.moveTo(point); } void TextTool::drawMove(const QPoint& point) { m_widget->move(point); } void TextTool::drawStart(const CaptureContext& context) { m_color = context.color; m_size = context.toolSize; emit requestAction(REQ_ADD_CHILD_WIDGET); } void TextTool::pressed(CaptureContext& context) { Q_UNUSED(context) } void TextTool::onColorChanged(const QColor& color) { m_color = color; if (m_widget != nullptr) { m_widget->setTextColor(color); } } void TextTool::onSizeChanged(int size) { m_size = size; m_font.setPointSize(m_size + BASE_POINT_SIZE); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateText(const QString& newText) { m_text = newText; } void TextTool::updateFamily(const QString& text) { m_font.setFamily(text); if (m_textOld.isEmpty()) { ConfigHandler().setFontFamily(m_font.family()); } if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontUnderline(const bool underlined) { m_font.setUnderline(underlined); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontStrikeOut(const bool strikeout) { m_font.setStrikeOut(strikeout); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontWeight(const QFont::Weight weight) { m_font.setWeight(weight); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::updateFontItalic(const bool italic) { m_font.setItalic(italic); if (m_widget != nullptr) { m_widget->setFont(m_font); } } void TextTool::move(const QPoint& pos) { m_textArea.moveTo(pos); } void TextTool::updateAlignment(Qt::AlignmentFlag alignment) { m_alignment = alignment; if (m_widget != nullptr) { m_widget->setAlignment(m_alignment); } } const QPoint* TextTool::pos() { m_currentPos = m_textArea.topLeft(); return &m_currentPos; } void TextTool::setEditMode(bool editMode) { if (editMode) { m_textOld = m_text; } CaptureTool::setEditMode(editMode); } bool TextTool::isChanged() { return QString::compare(m_text, m_textOld, Qt::CaseInsensitive) != 0; }","title":"File texttool.cpp"},{"location":"flameshot/texttool_8h/","text":"File texttool.h # FileList > src > tools > text > texttool.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include \"textconfig.h\" #include <QPoint> #include <QPointer> Classes # Type Name class TextTool","title":"File texttool.h"},{"location":"flameshot/texttool_8h/#file-texttoolh","text":"FileList > src > tools > text > texttool.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include \"textconfig.h\" #include <QPoint> #include <QPointer>","title":"File texttool.h"},{"location":"flameshot/texttool_8h/#classes","text":"Type Name class TextTool","title":"Classes"},{"location":"flameshot/texttool_8h_source/","text":"File texttool.h # File List > src > tools > text > texttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include \"textconfig.h\" #include <QPoint> #include <QPointer> class TextWidget; class TextConfig; class TextTool : public CaptureTool { Q_OBJECT public: explicit TextTool(QObject* parent = nullptr); ~TextTool() override; [[nodiscard]] bool isValid() const override; [[nodiscard]] bool closeOnButtonPressed() const override; [[nodiscard]] bool isSelectable() const override; [[nodiscard]] bool showMousePreview() const override; [[nodiscard]] QRect boundingRect() const override; [[nodiscard]] QIcon icon(const QColor& background, bool inEditor) const override; [[nodiscard]] QString name() const override; [[nodiscard]] QString description() const override; QString info() override; QWidget* widget() override; QWidget* configurationWidget() override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; void move(const QPoint& pos) override; const QPoint* pos() override; void drawObjectSelection(QPainter& painter) override; void setEditMode(bool editMode) override; bool isChanged() override; protected: void copyParams(const TextTool* from, TextTool* to); [[nodiscard]] CaptureTool::Type type() const override; public slots: void drawEnd(const QPoint& point) override; void drawMove(const QPoint& point) override; void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; void onColorChanged(const QColor& color) override; void onSizeChanged(int size) override; int size() const override { return m_size; }; private slots: void updateText(const QString& string); void updateFamily(const QString& string); void updateFontUnderline(bool underlined); void updateFontStrikeOut(bool strikeout); void updateFontWeight(QFont::Weight weight); void updateFontItalic(bool italic); void updateAlignment(Qt::AlignmentFlag alignment); private: void closeEditor(); QFont m_font; Qt::AlignmentFlag m_alignment; QString m_text; QString m_textOld; int m_size; QColor m_color; QRect m_textArea; QPointer<TextWidget> m_widget; QPointer<TextConfig> m_confW; QPoint m_currentPos; QString m_tempString; };","title":"File texttool.h"},{"location":"flameshot/texttool_8h_source/#file-texttoolh","text":"File List > src > tools > text > texttool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include \"textconfig.h\" #include <QPoint> #include <QPointer> class TextWidget; class TextConfig; class TextTool : public CaptureTool { Q_OBJECT public: explicit TextTool(QObject* parent = nullptr); ~TextTool() override; [[nodiscard]] bool isValid() const override; [[nodiscard]] bool closeOnButtonPressed() const override; [[nodiscard]] bool isSelectable() const override; [[nodiscard]] bool showMousePreview() const override; [[nodiscard]] QRect boundingRect() const override; [[nodiscard]] QIcon icon(const QColor& background, bool inEditor) const override; [[nodiscard]] QString name() const override; [[nodiscard]] QString description() const override; QString info() override; QWidget* widget() override; QWidget* configurationWidget() override; CaptureTool* copy(QObject* parent = nullptr) override; void process(QPainter& painter, const QPixmap& pixmap) override; void paintMousePreview(QPainter& painter, const CaptureContext& context) override; void move(const QPoint& pos) override; const QPoint* pos() override; void drawObjectSelection(QPainter& painter) override; void setEditMode(bool editMode) override; bool isChanged() override; protected: void copyParams(const TextTool* from, TextTool* to); [[nodiscard]] CaptureTool::Type type() const override; public slots: void drawEnd(const QPoint& point) override; void drawMove(const QPoint& point) override; void drawStart(const CaptureContext& context) override; void pressed(CaptureContext& context) override; void onColorChanged(const QColor& color) override; void onSizeChanged(int size) override; int size() const override { return m_size; }; private slots: void updateText(const QString& string); void updateFamily(const QString& string); void updateFontUnderline(bool underlined); void updateFontStrikeOut(bool strikeout); void updateFontWeight(QFont::Weight weight); void updateFontItalic(bool italic); void updateAlignment(Qt::AlignmentFlag alignment); private: void closeEditor(); QFont m_font; Qt::AlignmentFlag m_alignment; QString m_text; QString m_textOld; int m_size; QColor m_color; QRect m_textArea; QPointer<TextWidget> m_widget; QPointer<TextConfig> m_confW; QPoint m_currentPos; QString m_tempString; };","title":"File texttool.h"},{"location":"flameshot/textwidget_8cpp/","text":"File textwidget.cpp # FileList > src > tools > text > textwidget.cpp Go to the source code of this file. #include \"textwidget.h\"","title":"File textwidget.cpp"},{"location":"flameshot/textwidget_8cpp/#file-textwidgetcpp","text":"FileList > src > tools > text > textwidget.cpp Go to the source code of this file. #include \"textwidget.h\"","title":"File textwidget.cpp"},{"location":"flameshot/textwidget_8cpp_source/","text":"File textwidget.cpp # File List > src > tools > text > textwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"textwidget.h\" TextWidget::TextWidget(QWidget* parent) : QTextEdit(parent) { setStyleSheet(QStringLiteral(\"TextWidget { background: transparent; }\")); connect(this, &TextWidget::textChanged, this, &TextWidget::adjustSize); connect(this, &TextWidget::textChanged, this, &TextWidget::emitTextUpdated); setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); setContextMenuPolicy(Qt::NoContextMenu); } void TextWidget::showEvent(QShowEvent* e) { QFont font; QFontMetrics fm(font); setFixedWidth(fm.lineSpacing() * 6); setFixedHeight(fm.lineSpacing() * 2.5); m_baseSize = size(); m_minSize = m_baseSize; QTextEdit::showEvent(e); adjustSize(); } void TextWidget::resizeEvent(QResizeEvent* e) { m_minSize.setHeight(qMin(m_baseSize.height(), height())); m_minSize.setWidth(qMin(m_baseSize.width(), width())); QTextEdit::resizeEvent(e); } void TextWidget::setFont(const QFont& f) { QTextEdit::setFont(f); adjustSize(); } void TextWidget::setAlignment(Qt::AlignmentFlag alignment) { QTextEdit::setAlignment(alignment); adjustSize(); } void TextWidget::setTextColor(const QColor& c) { QString s( QStringLiteral(\"TextWidget { background: transparent; color: %1; }\")); setStyleSheet(s.arg(c.name())); } void TextWidget::adjustSize() { QString&& text = this->toPlainText(); QFontMetrics fm(font()); QRect bounds = fm.boundingRect(QRect(), 0, text); int pixelsWide = bounds.width() + fm.lineSpacing(); int pixelsHigh = bounds.height() * 1.15 + fm.lineSpacing(); if (pixelsWide < m_minSize.width()) { pixelsWide = m_minSize.width(); } if (pixelsHigh < m_minSize.height()) { pixelsHigh = m_minSize.height(); } this->setFixedSize(pixelsWide, pixelsHigh); } void TextWidget::emitTextUpdated() { emit textUpdated(this->toPlainText()); }","title":"File textwidget.cpp"},{"location":"flameshot/textwidget_8cpp_source/#file-textwidgetcpp","text":"File List > src > tools > text > textwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"textwidget.h\" TextWidget::TextWidget(QWidget* parent) : QTextEdit(parent) { setStyleSheet(QStringLiteral(\"TextWidget { background: transparent; }\")); connect(this, &TextWidget::textChanged, this, &TextWidget::adjustSize); connect(this, &TextWidget::textChanged, this, &TextWidget::emitTextUpdated); setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); setContextMenuPolicy(Qt::NoContextMenu); } void TextWidget::showEvent(QShowEvent* e) { QFont font; QFontMetrics fm(font); setFixedWidth(fm.lineSpacing() * 6); setFixedHeight(fm.lineSpacing() * 2.5); m_baseSize = size(); m_minSize = m_baseSize; QTextEdit::showEvent(e); adjustSize(); } void TextWidget::resizeEvent(QResizeEvent* e) { m_minSize.setHeight(qMin(m_baseSize.height(), height())); m_minSize.setWidth(qMin(m_baseSize.width(), width())); QTextEdit::resizeEvent(e); } void TextWidget::setFont(const QFont& f) { QTextEdit::setFont(f); adjustSize(); } void TextWidget::setAlignment(Qt::AlignmentFlag alignment) { QTextEdit::setAlignment(alignment); adjustSize(); } void TextWidget::setTextColor(const QColor& c) { QString s( QStringLiteral(\"TextWidget { background: transparent; color: %1; }\")); setStyleSheet(s.arg(c.name())); } void TextWidget::adjustSize() { QString&& text = this->toPlainText(); QFontMetrics fm(font()); QRect bounds = fm.boundingRect(QRect(), 0, text); int pixelsWide = bounds.width() + fm.lineSpacing(); int pixelsHigh = bounds.height() * 1.15 + fm.lineSpacing(); if (pixelsWide < m_minSize.width()) { pixelsWide = m_minSize.width(); } if (pixelsHigh < m_minSize.height()) { pixelsHigh = m_minSize.height(); } this->setFixedSize(pixelsWide, pixelsHigh); } void TextWidget::emitTextUpdated() { emit textUpdated(this->toPlainText()); }","title":"File textwidget.cpp"},{"location":"flameshot/textwidget_8h/","text":"File textwidget.h # FileList > src > tools > text > textwidget.h Go to the source code of this file. #include <QTextEdit> Classes # Type Name class TextWidget","title":"File textwidget.h"},{"location":"flameshot/textwidget_8h/#file-textwidgeth","text":"FileList > src > tools > text > textwidget.h Go to the source code of this file. #include <QTextEdit>","title":"File textwidget.h"},{"location":"flameshot/textwidget_8h/#classes","text":"Type Name class TextWidget","title":"Classes"},{"location":"flameshot/textwidget_8h_source/","text":"File textwidget.h # File List > src > tools > text > textwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTextEdit> class TextWidget : public QTextEdit { Q_OBJECT public: explicit TextWidget(QWidget* parent = nullptr); void adjustSize(); void setFont(const QFont& f); protected: void showEvent(QShowEvent* e); void resizeEvent(QResizeEvent* e); signals: void textUpdated(const QString& s); public slots: void setTextColor(const QColor& c); void setAlignment(Qt::AlignmentFlag alignment); private slots: void emitTextUpdated(); private: QSize m_baseSize; QSize m_minSize; };","title":"File textwidget.h"},{"location":"flameshot/textwidget_8h_source/#file-textwidgeth","text":"File List > src > tools > text > textwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QTextEdit> class TextWidget : public QTextEdit { Q_OBJECT public: explicit TextWidget(QWidget* parent = nullptr); void adjustSize(); void setFont(const QFont& f); protected: void showEvent(QShowEvent* e); void resizeEvent(QResizeEvent* e); signals: void textUpdated(const QString& s); public slots: void setTextColor(const QColor& c); void setAlignment(Qt::AlignmentFlag alignment); private slots: void emitTextUpdated(); private: QSize m_baseSize; QSize m_minSize; };","title":"File textwidget.h"},{"location":"flameshot/toolfactory_8cpp/","text":"File toolfactory.cpp # FileList > src > tools > toolfactory.cpp Go to the source code of this file. #include \"toolfactory.h\" #include \"accept/accepttool.h\" #include \"arrow/arrowtool.h\" #include \"circle/circletool.h\" #include \"circlecount/circlecounttool.h\" #include \"copy/copytool.h\" #include \"exit/exittool.h\" #include \"imgupload/imguploadertool.h\" #include \"invert/inverttool.h\" #include \"launcher/applaunchertool.h\" #include \"line/linetool.h\" #include \"marker/markertool.h\" #include \"move/movetool.h\" #include \"pencil/penciltool.h\" #include \"pin/pintool.h\" #include \"pixelate/pixelatetool.h\" #include \"rectangle/rectangletool.h\" #include \"redo/redotool.h\" #include \"save/savetool.h\" #include \"selection/selectiontool.h\" #include \"sizedecrease/sizedecreasetool.h\" #include \"sizeincrease/sizeincreasetool.h\" #include \"text/texttool.h\" #include \"undo/undotool.h\" Macros # Type Name define if_TYPE_return_TOOL (TYPE, TOOL) Macro Definition Documentation # define if_TYPE_return_TOOL # #define if_TYPE_return_TOOL ( TYPE, TOOL ) case CaptureTool::TYPE: \\ return new TOOL(parent)","title":"File toolfactory.cpp"},{"location":"flameshot/toolfactory_8cpp/#file-toolfactorycpp","text":"FileList > src > tools > toolfactory.cpp Go to the source code of this file. #include \"toolfactory.h\" #include \"accept/accepttool.h\" #include \"arrow/arrowtool.h\" #include \"circle/circletool.h\" #include \"circlecount/circlecounttool.h\" #include \"copy/copytool.h\" #include \"exit/exittool.h\" #include \"imgupload/imguploadertool.h\" #include \"invert/inverttool.h\" #include \"launcher/applaunchertool.h\" #include \"line/linetool.h\" #include \"marker/markertool.h\" #include \"move/movetool.h\" #include \"pencil/penciltool.h\" #include \"pin/pintool.h\" #include \"pixelate/pixelatetool.h\" #include \"rectangle/rectangletool.h\" #include \"redo/redotool.h\" #include \"save/savetool.h\" #include \"selection/selectiontool.h\" #include \"sizedecrease/sizedecreasetool.h\" #include \"sizeincrease/sizeincreasetool.h\" #include \"text/texttool.h\" #include \"undo/undotool.h\"","title":"File toolfactory.cpp"},{"location":"flameshot/toolfactory_8cpp/#macros","text":"Type Name define if_TYPE_return_TOOL (TYPE, TOOL)","title":"Macros"},{"location":"flameshot/toolfactory_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/toolfactory_8cpp/#define-if_type_return_tool","text":"#define if_TYPE_return_TOOL ( TYPE, TOOL ) case CaptureTool::TYPE: \\ return new TOOL(parent)","title":"define if_TYPE_return_TOOL"},{"location":"flameshot/toolfactory_8cpp_source/","text":"File toolfactory.cpp # File List > src > tools > toolfactory.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"toolfactory.h\" #include \"accept/accepttool.h\" #include \"arrow/arrowtool.h\" #include \"circle/circletool.h\" #include \"circlecount/circlecounttool.h\" #include \"copy/copytool.h\" #include \"exit/exittool.h\" #include \"imgupload/imguploadertool.h\" #include \"invert/inverttool.h\" #include \"launcher/applaunchertool.h\" #include \"line/linetool.h\" #include \"marker/markertool.h\" #include \"move/movetool.h\" #include \"pencil/penciltool.h\" #include \"pin/pintool.h\" #include \"pixelate/pixelatetool.h\" #include \"rectangle/rectangletool.h\" #include \"redo/redotool.h\" #include \"save/savetool.h\" #include \"selection/selectiontool.h\" #include \"sizedecrease/sizedecreasetool.h\" #include \"sizeincrease/sizeincreasetool.h\" #include \"text/texttool.h\" #include \"undo/undotool.h\" ToolFactory::ToolFactory(QObject* parent) : QObject(parent) {} CaptureTool* ToolFactory::CreateTool(CaptureTool::Type t, QObject* parent) { #define if_TYPE_return_TOOL(TYPE, TOOL) \\ case CaptureTool::TYPE: \\ return new TOOL(parent) switch (t) { if_TYPE_return_TOOL(TYPE_PENCIL, PencilTool); if_TYPE_return_TOOL(TYPE_DRAWER, LineTool); if_TYPE_return_TOOL(TYPE_ARROW, ArrowTool); if_TYPE_return_TOOL(TYPE_SELECTION, SelectionTool); if_TYPE_return_TOOL(TYPE_RECTANGLE, RectangleTool); if_TYPE_return_TOOL(TYPE_CIRCLE, CircleTool); if_TYPE_return_TOOL(TYPE_MARKER, MarkerTool); if_TYPE_return_TOOL(TYPE_MOVESELECTION, MoveTool); if_TYPE_return_TOOL(TYPE_UNDO, UndoTool); if_TYPE_return_TOOL(TYPE_COPY, CopyTool); if_TYPE_return_TOOL(TYPE_SAVE, SaveTool); if_TYPE_return_TOOL(TYPE_EXIT, ExitTool); if_TYPE_return_TOOL(TYPE_IMAGEUPLOADER, ImgUploaderTool); #if !defined(Q_OS_MACOS) if_TYPE_return_TOOL(TYPE_OPEN_APP, AppLauncher); #endif if_TYPE_return_TOOL(TYPE_PIXELATE, PixelateTool); if_TYPE_return_TOOL(TYPE_REDO, RedoTool); if_TYPE_return_TOOL(TYPE_PIN, PinTool); if_TYPE_return_TOOL(TYPE_TEXT, TextTool); if_TYPE_return_TOOL(TYPE_CIRCLECOUNT, CircleCountTool); if_TYPE_return_TOOL(TYPE_SIZEINCREASE, SizeIncreaseTool); if_TYPE_return_TOOL(TYPE_SIZEDECREASE, SizeDecreaseTool); if_TYPE_return_TOOL(TYPE_INVERT, InvertTool); if_TYPE_return_TOOL(TYPE_ACCEPT, AcceptTool); default: return nullptr; } }","title":"File toolfactory.cpp"},{"location":"flameshot/toolfactory_8cpp_source/#file-toolfactorycpp","text":"File List > src > tools > toolfactory.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"toolfactory.h\" #include \"accept/accepttool.h\" #include \"arrow/arrowtool.h\" #include \"circle/circletool.h\" #include \"circlecount/circlecounttool.h\" #include \"copy/copytool.h\" #include \"exit/exittool.h\" #include \"imgupload/imguploadertool.h\" #include \"invert/inverttool.h\" #include \"launcher/applaunchertool.h\" #include \"line/linetool.h\" #include \"marker/markertool.h\" #include \"move/movetool.h\" #include \"pencil/penciltool.h\" #include \"pin/pintool.h\" #include \"pixelate/pixelatetool.h\" #include \"rectangle/rectangletool.h\" #include \"redo/redotool.h\" #include \"save/savetool.h\" #include \"selection/selectiontool.h\" #include \"sizedecrease/sizedecreasetool.h\" #include \"sizeincrease/sizeincreasetool.h\" #include \"text/texttool.h\" #include \"undo/undotool.h\" ToolFactory::ToolFactory(QObject* parent) : QObject(parent) {} CaptureTool* ToolFactory::CreateTool(CaptureTool::Type t, QObject* parent) { #define if_TYPE_return_TOOL(TYPE, TOOL) \\ case CaptureTool::TYPE: \\ return new TOOL(parent) switch (t) { if_TYPE_return_TOOL(TYPE_PENCIL, PencilTool); if_TYPE_return_TOOL(TYPE_DRAWER, LineTool); if_TYPE_return_TOOL(TYPE_ARROW, ArrowTool); if_TYPE_return_TOOL(TYPE_SELECTION, SelectionTool); if_TYPE_return_TOOL(TYPE_RECTANGLE, RectangleTool); if_TYPE_return_TOOL(TYPE_CIRCLE, CircleTool); if_TYPE_return_TOOL(TYPE_MARKER, MarkerTool); if_TYPE_return_TOOL(TYPE_MOVESELECTION, MoveTool); if_TYPE_return_TOOL(TYPE_UNDO, UndoTool); if_TYPE_return_TOOL(TYPE_COPY, CopyTool); if_TYPE_return_TOOL(TYPE_SAVE, SaveTool); if_TYPE_return_TOOL(TYPE_EXIT, ExitTool); if_TYPE_return_TOOL(TYPE_IMAGEUPLOADER, ImgUploaderTool); #if !defined(Q_OS_MACOS) if_TYPE_return_TOOL(TYPE_OPEN_APP, AppLauncher); #endif if_TYPE_return_TOOL(TYPE_PIXELATE, PixelateTool); if_TYPE_return_TOOL(TYPE_REDO, RedoTool); if_TYPE_return_TOOL(TYPE_PIN, PinTool); if_TYPE_return_TOOL(TYPE_TEXT, TextTool); if_TYPE_return_TOOL(TYPE_CIRCLECOUNT, CircleCountTool); if_TYPE_return_TOOL(TYPE_SIZEINCREASE, SizeIncreaseTool); if_TYPE_return_TOOL(TYPE_SIZEDECREASE, SizeDecreaseTool); if_TYPE_return_TOOL(TYPE_INVERT, InvertTool); if_TYPE_return_TOOL(TYPE_ACCEPT, AcceptTool); default: return nullptr; } }","title":"File toolfactory.cpp"},{"location":"flameshot/toolfactory_8h/","text":"File toolfactory.h # FileList > src > tools > toolfactory.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QObject> Classes # Type Name class ToolFactory","title":"File toolfactory.h"},{"location":"flameshot/toolfactory_8h/#file-toolfactoryh","text":"FileList > src > tools > toolfactory.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QObject>","title":"File toolfactory.h"},{"location":"flameshot/toolfactory_8h/#classes","text":"Type Name class ToolFactory","title":"Classes"},{"location":"flameshot/toolfactory_8h_source/","text":"File toolfactory.h # File List > src > tools > toolfactory.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QObject> class CaptureTool; class ToolFactory : public QObject { Q_OBJECT public: explicit ToolFactory(QObject* parent = nullptr); ToolFactory(const ToolFactory&) = delete; ToolFactory& operator=(const ToolFactory&) = delete; CaptureTool* CreateTool(CaptureTool::Type t, QObject* parent = nullptr); };","title":"File toolfactory.h"},{"location":"flameshot/toolfactory_8h_source/#file-toolfactoryh","text":"File List > src > tools > toolfactory.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include \"src/widgets/capture/capturetoolbutton.h\" #include <QObject> class CaptureTool; class ToolFactory : public QObject { Q_OBJECT public: explicit ToolFactory(QObject* parent = nullptr); ToolFactory(const ToolFactory&) = delete; ToolFactory& operator=(const ToolFactory&) = delete; CaptureTool* CreateTool(CaptureTool::Type t, QObject* parent = nullptr); };","title":"File toolfactory.h"},{"location":"flameshot/dir_881e36e860689fc2ab48122781e8b3fb/","text":"Dir undo # FileList > src > tools > undo Files # Type Name file undotool.cpp file undotool.h","title":"Dir undo"},{"location":"flameshot/dir_881e36e860689fc2ab48122781e8b3fb/#dir-undo","text":"FileList > src > tools > undo","title":"Dir undo"},{"location":"flameshot/dir_881e36e860689fc2ab48122781e8b3fb/#files","text":"Type Name file undotool.cpp file undotool.h","title":"Files"},{"location":"flameshot/undotool_8cpp/","text":"File undotool.cpp # FileList > src > tools > undo > undotool.cpp Go to the source code of this file. #include \"undotool.h\" #include <QPainter>","title":"File undotool.cpp"},{"location":"flameshot/undotool_8cpp/#file-undotoolcpp","text":"FileList > src > tools > undo > undotool.cpp Go to the source code of this file. #include \"undotool.h\" #include <QPainter>","title":"File undotool.cpp"},{"location":"flameshot/undotool_8cpp_source/","text":"File undotool.cpp # File List > src > tools > undo > undotool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"undotool.h\" #include <QPainter> UndoTool::UndoTool(QObject* parent) : AbstractActionTool(parent) {} bool UndoTool::closeOnButtonPressed() const { return false; } QIcon UndoTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"undo-variant.svg\"); } QString UndoTool::name() const { return tr(\"Undo\"); } CaptureTool::Type UndoTool::type() const { return CaptureTool::TYPE_UNDO; } QString UndoTool::description() const { return tr(\"Undo the last modification\"); } CaptureTool* UndoTool::copy(QObject* parent) { return new UndoTool(parent); } void UndoTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_UNDO_MODIFICATION); }","title":"File undotool.cpp"},{"location":"flameshot/undotool_8cpp_source/#file-undotoolcpp","text":"File List > src > tools > undo > undotool.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"undotool.h\" #include <QPainter> UndoTool::UndoTool(QObject* parent) : AbstractActionTool(parent) {} bool UndoTool::closeOnButtonPressed() const { return false; } QIcon UndoTool::icon(const QColor& background, bool inEditor) const { Q_UNUSED(inEditor) return QIcon(iconPath(background) + \"undo-variant.svg\"); } QString UndoTool::name() const { return tr(\"Undo\"); } CaptureTool::Type UndoTool::type() const { return CaptureTool::TYPE_UNDO; } QString UndoTool::description() const { return tr(\"Undo the last modification\"); } CaptureTool* UndoTool::copy(QObject* parent) { return new UndoTool(parent); } void UndoTool::pressed(CaptureContext& context) { Q_UNUSED(context) emit requestAction(REQ_UNDO_MODIFICATION); }","title":"File undotool.cpp"},{"location":"flameshot/undotool_8h/","text":"File undotool.h # FileList > src > tools > undo > undotool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\" Classes # Type Name class UndoTool","title":"File undotool.h"},{"location":"flameshot/undotool_8h/#file-undotoolh","text":"FileList > src > tools > undo > undotool.h Go to the source code of this file. #include \"src/tools/abstractactiontool.h\"","title":"File undotool.h"},{"location":"flameshot/undotool_8h/#classes","text":"Type Name class UndoTool","title":"Classes"},{"location":"flameshot/undotool_8h_source/","text":"File undotool.h # File List > src > tools > undo > undotool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class UndoTool : public AbstractActionTool { Q_OBJECT public: explicit UndoTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File undotool.h"},{"location":"flameshot/undotool_8h_source/#file-undotoolh","text":"File List > src > tools > undo > undotool.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/abstractactiontool.h\" class UndoTool : public AbstractActionTool { Q_OBJECT public: explicit UndoTool(QObject* parent = nullptr); bool closeOnButtonPressed() const override; QIcon icon(const QColor& background, bool inEditor) const override; QString name() const override; QString description() const override; CaptureTool* copy(QObject* parent = nullptr) override; protected: CaptureTool::Type type() const override; public slots: void pressed(CaptureContext& context) override; };","title":"File undotool.h"},{"location":"flameshot/dir_313caf1132e152dd9b58bea13a4052ca/","text":"Dir utils # FileList > src > utils Files # Type Name file abstractlogger.cpp file abstractlogger.h file colorutils.cpp file colorutils.h file confighandler.cpp file confighandler.h file desktopfileparse.cpp file desktopfileparse.h file desktopinfo.cpp file desktopinfo.h file filenamehandler.cpp file filenamehandler.h file globalvalues.cpp file globalvalues.h file history.cpp file history.h file pathinfo.cpp file pathinfo.h file request.cpp file request.h file screengrabber.cpp file screengrabber.h file screenshotsaver.cpp file screenshotsaver.h file strfparse.cpp file strfparse.h file systemnotification.cpp file systemnotification.h file valuehandler.cpp file valuehandler.h file waylandutils.cpp file waylandutils.h file winlnkfileparse.cpp file winlnkfileparse.h","title":"Dir utils"},{"location":"flameshot/dir_313caf1132e152dd9b58bea13a4052ca/#dir-utils","text":"FileList > src > utils","title":"Dir utils"},{"location":"flameshot/dir_313caf1132e152dd9b58bea13a4052ca/#files","text":"Type Name file abstractlogger.cpp file abstractlogger.h file colorutils.cpp file colorutils.h file confighandler.cpp file confighandler.h file desktopfileparse.cpp file desktopfileparse.h file desktopinfo.cpp file desktopinfo.h file filenamehandler.cpp file filenamehandler.h file globalvalues.cpp file globalvalues.h file history.cpp file history.h file pathinfo.cpp file pathinfo.h file request.cpp file request.h file screengrabber.cpp file screengrabber.h file screenshotsaver.cpp file screenshotsaver.h file strfparse.cpp file strfparse.h file systemnotification.cpp file systemnotification.h file valuehandler.cpp file valuehandler.h file waylandutils.cpp file waylandutils.h file winlnkfileparse.cpp file winlnkfileparse.h","title":"Files"},{"location":"flameshot/abstractlogger_8cpp/","text":"File abstractlogger.cpp # FileList > src > utils > abstractlogger.cpp Go to the source code of this file. #include \"abstractlogger.h\" #include \"systemnotification.h\" #include <cassert> #include <QFileInfo>","title":"File abstractlogger.cpp"},{"location":"flameshot/abstractlogger_8cpp/#file-abstractloggercpp","text":"FileList > src > utils > abstractlogger.cpp Go to the source code of this file. #include \"abstractlogger.h\" #include \"systemnotification.h\" #include <cassert> #include <QFileInfo>","title":"File abstractlogger.cpp"},{"location":"flameshot/abstractlogger_8cpp_source/","text":"File abstractlogger.cpp # File List > src > utils > abstractlogger.cpp Go to the documentation of this file. #include \"abstractlogger.h\" #include \"systemnotification.h\" #include <cassert> #include <QFileInfo> AbstractLogger::AbstractLogger(Channel channel, int targets) : m_defaultChannel(channel) , m_targets(targets) { if (targets & LogFile) { // TODO } } AbstractLogger::AbstractLogger(QString& str, Channel channel, int additionalChannels) : AbstractLogger(channel, additionalChannels) { m_textStreams << new QTextStream(&str); } AbstractLogger::~AbstractLogger() { qDeleteAll(m_textStreams); } AbstractLogger AbstractLogger::info(int targets) { return { Info, targets }; } AbstractLogger AbstractLogger::warning(int targets) { return { Warning, targets }; } AbstractLogger AbstractLogger::error(int targets) { return { Error, targets }; } AbstractLogger& AbstractLogger::sendMessage(QString msg, Channel channel) { if (m_targets & Notification) { SystemNotification().sendMessage( msg, messageHeader(channel, Notification), m_notificationPath); } if (!m_textStreams.isEmpty()) { foreach (auto* stream, m_textStreams) { *stream << messageHeader(channel, String) << msg << \"\\n\"; } } if (m_targets & LogFile) { // TODO } if (m_targets & Stderr) { QTextStream stream(stderr); stream << messageHeader(channel, Stderr) << msg << \"\\n\"; } if (m_targets & Stdout) { QTextStream stream(stdout); stream << messageHeader(channel, Stdout) << msg << \"\\n\"; } return *this; } AbstractLogger& AbstractLogger::operator<<(QString msg) { sendMessage(msg, m_defaultChannel); return *this; } AbstractLogger& AbstractLogger::addOutputString(QString& str) { m_textStreams << new QTextStream(&str); return *this; } AbstractLogger& AbstractLogger::attachNotificationPath(QString path) { if (m_targets & Notification) { m_notificationPath = path; } else { assert(\"Cannot attach notification path to a logger without a \" \"notification channel.\"); } return *this; } AbstractLogger& AbstractLogger::enableMessageHeader(bool enable) { m_enableMessageHeader = enable; return *this; } QString AbstractLogger::messageHeader(Channel channel, Target target) { if (!m_enableMessageHeader) { return \"\"; } QString messageChannel; if (channel == Info) { messageChannel = \"info\"; } else if (channel == Warning) { messageChannel = \"warning\"; } else if (channel == Error) { messageChannel = \"error\"; } if (target == Notification) { messageChannel[0] = messageChannel[0].toUpper(); return \"Flameshot \" + messageChannel; } else { return \"flameshot: \" + messageChannel + \": \"; } }","title":"File abstractlogger.cpp"},{"location":"flameshot/abstractlogger_8cpp_source/#file-abstractloggercpp","text":"File List > src > utils > abstractlogger.cpp Go to the documentation of this file. #include \"abstractlogger.h\" #include \"systemnotification.h\" #include <cassert> #include <QFileInfo> AbstractLogger::AbstractLogger(Channel channel, int targets) : m_defaultChannel(channel) , m_targets(targets) { if (targets & LogFile) { // TODO } } AbstractLogger::AbstractLogger(QString& str, Channel channel, int additionalChannels) : AbstractLogger(channel, additionalChannels) { m_textStreams << new QTextStream(&str); } AbstractLogger::~AbstractLogger() { qDeleteAll(m_textStreams); } AbstractLogger AbstractLogger::info(int targets) { return { Info, targets }; } AbstractLogger AbstractLogger::warning(int targets) { return { Warning, targets }; } AbstractLogger AbstractLogger::error(int targets) { return { Error, targets }; } AbstractLogger& AbstractLogger::sendMessage(QString msg, Channel channel) { if (m_targets & Notification) { SystemNotification().sendMessage( msg, messageHeader(channel, Notification), m_notificationPath); } if (!m_textStreams.isEmpty()) { foreach (auto* stream, m_textStreams) { *stream << messageHeader(channel, String) << msg << \"\\n\"; } } if (m_targets & LogFile) { // TODO } if (m_targets & Stderr) { QTextStream stream(stderr); stream << messageHeader(channel, Stderr) << msg << \"\\n\"; } if (m_targets & Stdout) { QTextStream stream(stdout); stream << messageHeader(channel, Stdout) << msg << \"\\n\"; } return *this; } AbstractLogger& AbstractLogger::operator<<(QString msg) { sendMessage(msg, m_defaultChannel); return *this; } AbstractLogger& AbstractLogger::addOutputString(QString& str) { m_textStreams << new QTextStream(&str); return *this; } AbstractLogger& AbstractLogger::attachNotificationPath(QString path) { if (m_targets & Notification) { m_notificationPath = path; } else { assert(\"Cannot attach notification path to a logger without a \" \"notification channel.\"); } return *this; } AbstractLogger& AbstractLogger::enableMessageHeader(bool enable) { m_enableMessageHeader = enable; return *this; } QString AbstractLogger::messageHeader(Channel channel, Target target) { if (!m_enableMessageHeader) { return \"\"; } QString messageChannel; if (channel == Info) { messageChannel = \"info\"; } else if (channel == Warning) { messageChannel = \"warning\"; } else if (channel == Error) { messageChannel = \"error\"; } if (target == Notification) { messageChannel[0] = messageChannel[0].toUpper(); return \"Flameshot \" + messageChannel; } else { return \"flameshot: \" + messageChannel + \": \"; } }","title":"File abstractlogger.cpp"},{"location":"flameshot/abstractlogger_8h/","text":"File abstractlogger.h # FileList > src > utils > abstractlogger.h Go to the source code of this file. #include <QString> #include <QTextStream> Classes # Type Name class AbstractLogger A class that allows you to log events to where they need to go.","title":"File abstractlogger.h"},{"location":"flameshot/abstractlogger_8h/#file-abstractloggerh","text":"FileList > src > utils > abstractlogger.h Go to the source code of this file. #include <QString> #include <QTextStream>","title":"File abstractlogger.h"},{"location":"flameshot/abstractlogger_8h/#classes","text":"Type Name class AbstractLogger A class that allows you to log events to where they need to go.","title":"Classes"},{"location":"flameshot/abstractlogger_8h_source/","text":"File abstractlogger.h # File List > src > utils > abstractlogger.h Go to the documentation of this file. #pragma once #include <QString> #include <QTextStream> class AbstractLogger { public: enum Target { Notification = 0x01, Stderr = 0x02, LogFile = 0x08, String = 0x10, Stdout = 0x20, Default = Notification | LogFile | Stderr, }; enum Channel { Info, Warning, Error }; AbstractLogger(Channel channel = Info, int targets = Default); AbstractLogger(QString& str, Channel channel, int additionalTargets = String); ~AbstractLogger(); // Convenience functions static AbstractLogger info(int targets = Default); static AbstractLogger warning(int targets = Default); static AbstractLogger error(int targets = Default); AbstractLogger& sendMessage(QString msg, Channel channel); AbstractLogger& operator<<(QString msg); AbstractLogger& addOutputString(QString& str); AbstractLogger& attachNotificationPath(QString path); AbstractLogger& enableMessageHeader(bool enable); private: QString messageHeader(Channel channel, Target target); int m_targets; Channel m_defaultChannel; QList<QTextStream*> m_textStreams; QString m_notificationPath; bool m_enableMessageHeader = true; };","title":"File abstractlogger.h"},{"location":"flameshot/abstractlogger_8h_source/#file-abstractloggerh","text":"File List > src > utils > abstractlogger.h Go to the documentation of this file. #pragma once #include <QString> #include <QTextStream> class AbstractLogger { public: enum Target { Notification = 0x01, Stderr = 0x02, LogFile = 0x08, String = 0x10, Stdout = 0x20, Default = Notification | LogFile | Stderr, }; enum Channel { Info, Warning, Error }; AbstractLogger(Channel channel = Info, int targets = Default); AbstractLogger(QString& str, Channel channel, int additionalTargets = String); ~AbstractLogger(); // Convenience functions static AbstractLogger info(int targets = Default); static AbstractLogger warning(int targets = Default); static AbstractLogger error(int targets = Default); AbstractLogger& sendMessage(QString msg, Channel channel); AbstractLogger& operator<<(QString msg); AbstractLogger& addOutputString(QString& str); AbstractLogger& attachNotificationPath(QString path); AbstractLogger& enableMessageHeader(bool enable); private: QString messageHeader(Channel channel, Target target); int m_targets; Channel m_defaultChannel; QList<QTextStream*> m_textStreams; QString m_notificationPath; bool m_enableMessageHeader = true; };","title":"File abstractlogger.h"},{"location":"flameshot/colorutils_8cpp/","text":"File colorutils.cpp # FileList > src > utils > colorutils.cpp Go to the source code of this file. #include \"colorutils.h\" Public Functions # Type Name qreal getColorLuma (const QColor & c) Public Functions Documentation # function getColorLuma # inline qreal getColorLuma ( const QColor & c )","title":"File colorutils.cpp"},{"location":"flameshot/colorutils_8cpp/#file-colorutilscpp","text":"FileList > src > utils > colorutils.cpp Go to the source code of this file. #include \"colorutils.h\"","title":"File colorutils.cpp"},{"location":"flameshot/colorutils_8cpp/#public-functions","text":"Type Name qreal getColorLuma (const QColor & c)","title":"Public Functions"},{"location":"flameshot/colorutils_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/colorutils_8cpp/#function-getcolorluma","text":"inline qreal getColorLuma ( const QColor & c )","title":"function getColorLuma"},{"location":"flameshot/colorutils_8cpp_source/","text":"File colorutils.cpp # File List > src > utils > colorutils.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"colorutils.h\" inline qreal getColorLuma(const QColor& c) { return 0.30 * c.redF() + 0.59 * c.greenF() + 0.11 * c.blueF(); } bool ColorUtils::colorIsDark(const QColor& c) { // when luma <= 0.5, we considor it as a dark color return getColorLuma(c) <= 0.5; } QColor ColorUtils::contrastColor(const QColor& c) { int change = colorIsDark(c) ? 30 : -45; return { qBound(0, c.red() + change, 255), qBound(0, c.green() + change, 255), qBound(0, c.blue() + change, 255) }; }","title":"File colorutils.cpp"},{"location":"flameshot/colorutils_8cpp_source/#file-colorutilscpp","text":"File List > src > utils > colorutils.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"colorutils.h\" inline qreal getColorLuma(const QColor& c) { return 0.30 * c.redF() + 0.59 * c.greenF() + 0.11 * c.blueF(); } bool ColorUtils::colorIsDark(const QColor& c) { // when luma <= 0.5, we considor it as a dark color return getColorLuma(c) <= 0.5; } QColor ColorUtils::contrastColor(const QColor& c) { int change = colorIsDark(c) ? 30 : -45; return { qBound(0, c.red() + change, 255), qBound(0, c.green() + change, 255), qBound(0, c.blue() + change, 255) }; }","title":"File colorutils.cpp"},{"location":"flameshot/colorutils_8h/","text":"File colorutils.h # FileList > src > utils > colorutils.h Go to the source code of this file. #include <QColor> Namespaces # Type Name namespace ColorUtils","title":"File colorutils.h"},{"location":"flameshot/colorutils_8h/#file-colorutilsh","text":"FileList > src > utils > colorutils.h Go to the source code of this file. #include <QColor>","title":"File colorutils.h"},{"location":"flameshot/colorutils_8h/#namespaces","text":"Type Name namespace ColorUtils","title":"Namespaces"},{"location":"flameshot/colorutils_8h_source/","text":"File colorutils.h # File List > src > utils > colorutils.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QColor> namespace ColorUtils { // namespace bool colorIsDark(const QColor& c); QColor contrastColor(const QColor& c); } // namespace","title":"File colorutils.h"},{"location":"flameshot/colorutils_8h_source/#file-colorutilsh","text":"File List > src > utils > colorutils.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QColor> namespace ColorUtils { // namespace bool colorIsDark(const QColor& c); QColor contrastColor(const QColor& c); } // namespace","title":"File colorutils.h"},{"location":"flameshot/confighandler_8cpp/","text":"File confighandler.cpp # FileList > src > utils > confighandler.cpp Go to the source code of this file. #include \"confighandler.h\" #include \"abstractlogger.h\" #include \"src/tools/capturetool.h\" #include \"valuehandler.h\" #include <QCoreApplication> #include <QDebug> #include <QDir> #include <QFile> #include <QFileSystemWatcher> #include <QKeySequence> #include <QMap> #include <QSharedPointer> #include <QStandardPaths> #include <QVector> #include <algorithm> #include <stdexcept> Public Static Attributes # Type Name QMap< class QString, QSharedPointer < ValueHandler > > recognizedGeneralOptions QMap< QString, QSharedPointer < KeySequence > > recognizedShortcuts Public Functions # Type Name bool verifyLaunchFile () Macros # Type Name define OPTION (KEY, TYPE) define SHORTCUT (NAME, DEFAULT_VALUE) Public Static Attributes Documentation # variable recognizedGeneralOptions # QMap<class QString, QSharedPointer<ValueHandler> > recognizedGeneralOptions; This map contains all the information that is needed to parse, verify and preprocess each configuration option in the General section. NOTE: Please keep it well structured variable recognizedShortcuts # QMap<QString, QSharedPointer<KeySequence> > recognizedShortcuts; Public Functions Documentation # function verifyLaunchFile # bool verifyLaunchFile () Macro Definition Documentation # define OPTION # #define OPTION ( KEY, TYPE ) { \\ QStringLiteral(KEY), QSharedPointer < ValueHandler >(new TYPE) \\ } Use this to declare a setting with a type that is either unrecognized by QVariant or if you need to place additional constraints on its value. Parameters: KEY Name of the setting as in the config file (a C-style string literal) TYPE An instance of a ValueHandler derivative. This must be specified in the form of a constructor, or the macro will misbehave. define SHORTCUT # #define SHORTCUT ( NAME, DEFAULT_VALUE ) { \\ QStringLiteral(NAME), QSharedPointer < KeySequence >(new KeySequence ( \\ QKeySequence(QLatin1String(DEFAULT_VALUE)))) \\ }","title":"File confighandler.cpp"},{"location":"flameshot/confighandler_8cpp/#file-confighandlercpp","text":"FileList > src > utils > confighandler.cpp Go to the source code of this file. #include \"confighandler.h\" #include \"abstractlogger.h\" #include \"src/tools/capturetool.h\" #include \"valuehandler.h\" #include <QCoreApplication> #include <QDebug> #include <QDir> #include <QFile> #include <QFileSystemWatcher> #include <QKeySequence> #include <QMap> #include <QSharedPointer> #include <QStandardPaths> #include <QVector> #include <algorithm> #include <stdexcept>","title":"File confighandler.cpp"},{"location":"flameshot/confighandler_8cpp/#public-static-attributes","text":"Type Name QMap< class QString, QSharedPointer < ValueHandler > > recognizedGeneralOptions QMap< QString, QSharedPointer < KeySequence > > recognizedShortcuts","title":"Public Static Attributes"},{"location":"flameshot/confighandler_8cpp/#public-functions","text":"Type Name bool verifyLaunchFile ()","title":"Public Functions"},{"location":"flameshot/confighandler_8cpp/#macros","text":"Type Name define OPTION (KEY, TYPE) define SHORTCUT (NAME, DEFAULT_VALUE)","title":"Macros"},{"location":"flameshot/confighandler_8cpp/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"flameshot/confighandler_8cpp/#variable-recognizedgeneraloptions","text":"QMap<class QString, QSharedPointer<ValueHandler> > recognizedGeneralOptions; This map contains all the information that is needed to parse, verify and preprocess each configuration option in the General section. NOTE: Please keep it well structured","title":"variable recognizedGeneralOptions"},{"location":"flameshot/confighandler_8cpp/#variable-recognizedshortcuts","text":"QMap<QString, QSharedPointer<KeySequence> > recognizedShortcuts;","title":"variable recognizedShortcuts"},{"location":"flameshot/confighandler_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/confighandler_8cpp/#function-verifylaunchfile","text":"bool verifyLaunchFile ()","title":"function verifyLaunchFile"},{"location":"flameshot/confighandler_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/confighandler_8cpp/#define-option","text":"#define OPTION ( KEY, TYPE ) { \\ QStringLiteral(KEY), QSharedPointer < ValueHandler >(new TYPE) \\ } Use this to declare a setting with a type that is either unrecognized by QVariant or if you need to place additional constraints on its value. Parameters: KEY Name of the setting as in the config file (a C-style string literal) TYPE An instance of a ValueHandler derivative. This must be specified in the form of a constructor, or the macro will misbehave.","title":"define OPTION"},{"location":"flameshot/confighandler_8cpp/#define-shortcut","text":"#define SHORTCUT ( NAME, DEFAULT_VALUE ) { \\ QStringLiteral(NAME), QSharedPointer < KeySequence >(new KeySequence ( \\ QKeySequence(QLatin1String(DEFAULT_VALUE)))) \\ }","title":"define SHORTCUT"},{"location":"flameshot/confighandler_8cpp_source/","text":"File confighandler.cpp # File List > src > utils > confighandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"confighandler.h\" #include \"abstractlogger.h\" #include \"src/tools/capturetool.h\" #include \"valuehandler.h\" #include <QCoreApplication> #include <QDebug> #include <QDir> #include <QFile> #include <QFileSystemWatcher> #include <QKeySequence> #include <QMap> #include <QSharedPointer> #include <QStandardPaths> #include <QVector> #include <algorithm> #include <stdexcept> #if defined(Q_OS_MACOS) #include <QProcess> #endif // HELPER FUNCTIONS bool verifyLaunchFile() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QString path = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, \"autostart/\", QStandardPaths::LocateDirectory) + \"Flameshot.desktop\"; bool res = QFile(path).exists(); #elif defined(Q_OS_WIN) QSettings bootUpSettings( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", QSettings::NativeFormat); bool res = bootUpSettings.value(\"Flameshot\").toString() == QDir::toNativeSeparators(QCoreApplication::applicationFilePath()); #endif return res; } // VALUE HANDLING #define OPTION(KEY, TYPE) \\ { \\ QStringLiteral(KEY), QSharedPointer<ValueHandler>(new TYPE) \\ } #define SHORTCUT(NAME, DEFAULT_VALUE) \\ { \\ QStringLiteral(NAME), QSharedPointer<KeySequence>(new KeySequence( \\ QKeySequence(QLatin1String(DEFAULT_VALUE)))) \\ } // clang-format off static QMap<class QString, QSharedPointer<ValueHandler>> recognizedGeneralOptions = { // KEY TYPE DEFAULT_VALUE OPTION(\"showHelp\" ,Bool ( true )), OPTION(\"showSidePanelButton\" ,Bool ( true )), OPTION(\"showDesktopNotification\" ,Bool ( true )), OPTION(\"disabledTrayIcon\" ,Bool ( false )), OPTION(\"historyConfirmationToDelete\" ,Bool ( true )), #if !defined(DISABLE_UPDATE_CHECKER) OPTION(\"checkForUpdates\" ,Bool ( true )), #endif OPTION(\"allowMultipleGuiInstances\" ,Bool ( false )), OPTION(\"showMagnifier\" ,Bool ( false )), OPTION(\"squareMagnifier\" ,Bool ( false )), #if !defined(Q_OS_WIN) OPTION(\"autoCloseIdleDaemon\" ,Bool ( false )), #endif OPTION(\"startupLaunch\" ,Bool ( false )), OPTION(\"showStartupLaunchMessage\" ,Bool ( true )), OPTION(\"copyURLAfterUpload\" ,Bool ( true )), OPTION(\"copyPathAfterSave\" ,Bool ( false )), OPTION(\"antialiasingPinZoom\" ,Bool ( true )), OPTION(\"useJpgForClipboard\" ,Bool ( false )), OPTION(\"uploadWithoutConfirmation\" ,Bool ( false )), OPTION(\"saveAfterCopy\" ,Bool ( false )), OPTION(\"savePath\" ,ExistingDir ( )), OPTION(\"savePathFixed\" ,Bool ( false )), OPTION(\"saveAsFileExtension\" ,SaveFileExtension ( )), OPTION(\"saveLastRegion\" ,Bool (false )), OPTION(\"uploadHistoryMax\" ,LowerBoundedInt (0, 25 )), OPTION(\"undoLimit\" ,BoundedInt (0, 999, 100 )), // Interface tab OPTION(\"uiColor\" ,Color ( {116, 0, 150} )), OPTION(\"contrastUiColor\" ,Color ( {39, 0, 50} )), OPTION(\"contrastOpacity\" ,BoundedInt ( 0, 255, 190 )), OPTION(\"buttons\" ,ButtonList ( {} )), // Filename Editor tab OPTION(\"filenamePattern\" ,FilenamePattern ( {} )), // Others OPTION(\"drawThickness\" ,LowerBoundedInt (1 , 3 )), OPTION(\"drawFontSize\" ,LowerBoundedInt (1 , 8 )), OPTION(\"drawColor\" ,Color ( Qt::red )), OPTION(\"userColors\" ,UserColors(3, 17 )), OPTION(\"ignoreUpdateToVersion\" ,String ( \"\" )), OPTION(\"keepOpenAppLauncher\" ,Bool ( false )), OPTION(\"fontFamily\" ,String ( \"\" )), // PREDEFINED_COLOR_PALETTE_LARGE is defined in src/CMakeList.txt file and can be overwritten in GitHub actions OPTION(\"predefinedColorPaletteLarge\", Bool ( PREDEFINED_COLOR_PALETTE_LARGE )), // NOTE: If another tool size is added besides drawThickness and // drawFontSize, remember to update ConfigHandler::toolSize OPTION(\"copyOnDoubleClick\" ,Bool ( false )), OPTION(\"uploadClientSecret\" ,String ( \"313baf0c7b4d3ff\" )), OPTION(\"showSelectionGeometry\" , BoundedInt (0,5,4)), OPTION(\"showSelectionGeometryHideTime\", LowerBoundedInt (0, 3000)) }; static QMap<QString, QSharedPointer<KeySequence>> recognizedShortcuts = { // NAME DEFAULT_SHORTCUT SHORTCUT(\"TYPE_PENCIL\" , \"P\" ), SHORTCUT(\"TYPE_DRAWER\" , \"D\" ), SHORTCUT(\"TYPE_ARROW\" , \"A\" ), SHORTCUT(\"TYPE_SELECTION\" , \"S\" ), SHORTCUT(\"TYPE_RECTANGLE\" , \"R\" ), SHORTCUT(\"TYPE_CIRCLE\" , \"C\" ), SHORTCUT(\"TYPE_MARKER\" , \"M\" ), SHORTCUT(\"TYPE_MOVESELECTION\" , \"Ctrl+M\" ), SHORTCUT(\"TYPE_UNDO\" , \"Ctrl+Z\" ), SHORTCUT(\"TYPE_COPY\" , \"Ctrl+C\" ), SHORTCUT(\"TYPE_SAVE\" , \"Ctrl+S\" ), SHORTCUT(\"TYPE_ACCEPT\" , \"Return\" ), SHORTCUT(\"TYPE_EXIT\" , \"Ctrl+Q\" ), SHORTCUT(\"TYPE_IMAGEUPLOADER\" , ), #if !defined(Q_OS_MACOS) SHORTCUT(\"TYPE_OPEN_APP\" , \"Ctrl+O\" ), #endif SHORTCUT(\"TYPE_PIXELATE\" , \"B\" ), SHORTCUT(\"TYPE_INVERT\" , \"I\" ), SHORTCUT(\"TYPE_REDO\" , \"Ctrl+Shift+Z\" ), SHORTCUT(\"TYPE_TEXT\" , \"T\" ), SHORTCUT(\"TYPE_TOGGLE_PANEL\" , \"Space\" ), SHORTCUT(\"TYPE_RESIZE_LEFT\" , \"Shift+Left\" ), SHORTCUT(\"TYPE_RESIZE_RIGHT\" , \"Shift+Right\" ), SHORTCUT(\"TYPE_RESIZE_UP\" , \"Shift+Up\" ), SHORTCUT(\"TYPE_RESIZE_DOWN\" , \"Shift+Down\" ), SHORTCUT(\"TYPE_SYM_RESIZE_LEFT\" , \"Ctrl+Shift+Left\" ), SHORTCUT(\"TYPE_SYM_RESIZE_RIGHT\" , \"Ctrl+Shift+Right\" ), SHORTCUT(\"TYPE_SYM_RESIZE_UP\" , \"Ctrl+Shift+Up\" ), SHORTCUT(\"TYPE_SYM_RESIZE_DOWN\" , \"Ctrl+Shift+Down\" ), SHORTCUT(\"TYPE_SELECT_ALL\" , \"Ctrl+A\" ), SHORTCUT(\"TYPE_MOVE_LEFT\" , \"Left\" ), SHORTCUT(\"TYPE_MOVE_RIGHT\" , \"Right\" ), SHORTCUT(\"TYPE_MOVE_UP\" , \"Up\" ), SHORTCUT(\"TYPE_MOVE_DOWN\" , \"Down\" ), SHORTCUT(\"TYPE_COMMIT_CURRENT_TOOL\" , \"Ctrl+Return\" ), #if defined(Q_OS_MACOS) SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" , \"Backspace\" ), SHORTCUT(\"TAKE_SCREENSHOT\" , \"Ctrl+Shift+X\" ), SHORTCUT(\"SCREENSHOT_HISTORY\" , \"Alt+Shift+X\" ), #else SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" , \"Delete\" ), #endif SHORTCUT(\"TYPE_PIN\" , ), SHORTCUT(\"TYPE_SELECTIONINDICATOR\" , ), SHORTCUT(\"TYPE_SIZEINCREASE\" , ), SHORTCUT(\"TYPE_SIZEDECREASE\" , ), SHORTCUT(\"TYPE_CIRCLECOUNT\" , ), }; // clang-format on // CLASS CONFIGHANDLER ConfigHandler::ConfigHandler() : m_settings(QSettings::IniFormat, QSettings::UserScope, qApp->organizationName(), qApp->applicationName()) { static bool firstInitialization = true; if (firstInitialization) { // check for error every time the file changes m_configWatcher.reset(new QFileSystemWatcher()); ensureFileWatched(); QObject::connect(m_configWatcher.data(), &QFileSystemWatcher::fileChanged, [](const QString& fileName) { emit getInstance()->fileChanged(); if (QFile(fileName).exists()) { m_configWatcher->addPath(fileName); } if (m_skipNextErrorCheck) { m_skipNextErrorCheck = false; return; } ConfigHandler().checkAndHandleError(); if (!QFile(fileName).exists()) { // File watcher stops watching a deleted file. // Next time the config is accessed, force it // to check for errors (and watch again). m_errorCheckPending = true; } }); } firstInitialization = false; } ConfigHandler* ConfigHandler::getInstance() { static ConfigHandler config; return &config; } // SPECIAL CASES bool ConfigHandler::startupLaunch() { bool res = value(QStringLiteral(\"startupLaunch\")).toBool(); if (res != verifyLaunchFile()) { setStartupLaunch(res); } return res; } void ConfigHandler::setStartupLaunch(const bool start) { if (start == value(QStringLiteral(\"startupLaunch\")).toBool()) { return; } setValue(QStringLiteral(\"startupLaunch\"), start); #if defined(Q_OS_MACOS) /* TODO - there should be more correct way via API, but didn't find it without extra dependencies, there should be something like that: https://stackoverflow.com/questions/3358410/programmatically-run-at-startup-on-mac-os-x But files with this features differs on different MacOS versions and it doesn't work not on a BigSur at lease. */ QProcess process; if (start) { process.start(\"osascript\", QStringList() << \"-e\" << \"tell application \\\"System Events\\\" to make login \" \"item at end with properties {name: \" \"\\\"Flameshot\\\",path:\\\"/Applications/\" \"flameshot.app\\\", hidden:false}\"); } else { process.start(\"osascript\", QStringList() << \"-e\" << \"tell application \\\"System Events\\\" to \" \"delete login item \\\"Flameshot\\\"\"); } if (!process.waitForFinished()) { qWarning() << \"Login items is changed. \" << process.errorString(); } else { qWarning() << \"Unable to change login items, error:\" << process.readAll(); } #elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QString path = QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation) + \"/autostart/\"; QDir autostartDir(path); if (!autostartDir.exists()) { autostartDir.mkpath(\".\"); } QFile file(path + \"Flameshot.desktop\"); if (start) { if (file.open(QIODevice::WriteOnly)) { QByteArray data(\"[Desktop Entry]\\nName=flameshot\\nIcon=flameshot\" \"\\nExec=flameshot\\nTerminal=false\\nType=Application\" \"\\nX-GNOME-Autostart-enabled=true\\n\"); file.write(data); } } else { file.remove(); } #elif defined(Q_OS_WIN) QSettings bootUpSettings( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", QSettings::NativeFormat); // set workdir for flameshot on startup QSettings bootUpPath( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App \" \"Paths\", QSettings::NativeFormat); if (start) { QString app_path = QDir::toNativeSeparators(QCoreApplication::applicationFilePath()); bootUpSettings.setValue(\"Flameshot\", app_path); // set application workdir bootUpPath.beginGroup(\"flameshot.exe\"); bootUpPath.setValue(\"Path\", QCoreApplication::applicationDirPath()); bootUpPath.endGroup(); } else { bootUpSettings.remove(\"Flameshot\"); // remove application workdir bootUpPath.beginGroup(\"flameshot.exe\"); bootUpPath.remove(\"\"); bootUpPath.endGroup(); } #endif } void ConfigHandler::setAllTheButtons() { QList<CaptureTool::Type> buttons = CaptureToolButton::getIterableButtonTypes(); setValue(QStringLiteral(\"buttons\"), QVariant::fromValue(buttons)); } void ConfigHandler::setToolSize(CaptureTool::Type toolType, int size) { if (toolType == CaptureTool::TYPE_TEXT) { setDrawFontSize(size); } else if (toolType != CaptureTool::NONE) { setDrawThickness(size); } } int ConfigHandler::toolSize(CaptureTool::Type toolType) { if (toolType == CaptureTool::TYPE_TEXT) { return drawFontSize(); } else { return drawThickness(); } } // DEFAULTS QString ConfigHandler::filenamePatternDefault() { return QStringLiteral(\"%F_%H-%M\"); } void ConfigHandler::setDefaultSettings() { foreach (const QString& key, m_settings.allKeys()) { if (isShortcut(key)) { // Do not reset Shortcuts continue; } m_settings.remove(key); } m_settings.sync(); } QString ConfigHandler::configFilePath() const { return m_settings.fileName(); } // GENERIC GETTERS AND SETTERS bool ConfigHandler::setShortcut(const QString& actionName, const QString& shortcut) { qDebug() << actionName; static QVector<QKeySequence> reservedShortcuts = { #if defined(Q_OS_MACOS) Qt::CTRL + Qt::Key_Backspace, Qt::Key_Escape, #else Qt::Key_Backspace, Qt::Key_Escape, #endif }; if (hasError()) { return false; } bool error = false; m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); if (shortcut.isEmpty()) { setValue(actionName, \"\"); } else if (reservedShortcuts.contains(QKeySequence(shortcut))) { // do not allow to set reserved shortcuts error = true; } else { error = false; // Make no difference for Return and Enter keys QString newShortcut = KeySequence().value(shortcut).toString(); for (auto& otherAction : m_settings.allKeys()) { if (actionName == otherAction) { continue; } QString existingShortcut = KeySequence().value(m_settings.value(otherAction)).toString(); if (newShortcut == existingShortcut) { error = true; goto done; } } m_settings.setValue(actionName, KeySequence().value(shortcut)); } done: m_settings.endGroup(); return !error; } QString ConfigHandler::shortcut(const QString& actionName) { QString setting = CONFIG_GROUP_SHORTCUTS \"/\" + actionName; QString shortcut = value(setting).toString(); if (!m_settings.contains(setting)) { // The action uses a shortcut that is a flameshot default // (not set explicitly by user) m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); for (auto& otherAction : m_settings.allKeys()) { if (m_settings.value(otherAction) == shortcut) { // We found an explicit shortcut - it will take precedence m_settings.endGroup(); return {}; } } m_settings.endGroup(); } return shortcut; } void ConfigHandler::setValue(const QString& key, const QVariant& value) { assertKeyRecognized(key); if (!hasError()) { // don't let the file watcher initiate another error check m_skipNextErrorCheck = true; auto val = valueHandler(key)->representation(value); m_settings.setValue(key, val); } } QVariant ConfigHandler::value(const QString& key) const { assertKeyRecognized(key); auto val = m_settings.value(key); auto handler = valueHandler(key); // Check the value for semantic errors if (val.isValid() && !handler->check(val)) { setErrorState(true); } if (m_hasError) { return handler->fallback(); } return handler->value(val); } void ConfigHandler::remove(const QString& key) { m_settings.remove(key); } void ConfigHandler::resetValue(const QString& key) { m_settings.setValue(key, valueHandler(key)->fallback()); } QSet<QString>& ConfigHandler::recognizedGeneralOptions() { #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0) auto keys = ::recognizedGeneralOptions.keys(); static QSet<QString> options = QSet<QString>(keys.begin(), keys.end()); #else static QSet<QString> options = QSet<QString>::fromList(::recognizedGeneralOptions.keys()); #endif return options; } QSet<QString>& ConfigHandler::recognizedShortcutNames() { #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0) auto keys = recognizedShortcuts.keys(); static QSet<QString> names = QSet<QString>(keys.begin(), keys.end()); #else static QSet<QString> names = QSet<QString>::fromList(recognizedShortcuts.keys()); #endif return names; } QSet<QString> ConfigHandler::keysFromGroup(const QString& group) const { QSet<QString> keys; for (const QString& key : m_settings.allKeys()) { if (group == CONFIG_GROUP_GENERAL && !key.contains('/')) { keys.insert(key); } else if (key.startsWith(group + \"/\")) { keys.insert(baseName(key)); } } return keys; } // ERROR HANDLING bool ConfigHandler::checkForErrors(AbstractLogger* log) const { return checkUnrecognizedSettings(log) && checkShortcutConflicts(log) && checkSemantics(log); } bool ConfigHandler::checkUnrecognizedSettings(AbstractLogger* log, QList<QString>* offenders) const { // sort the config keys by group QSet<QString> generalKeys = keysFromGroup(CONFIG_GROUP_GENERAL), shortcutKeys = keysFromGroup(CONFIG_GROUP_SHORTCUTS), recognizedGeneralKeys = recognizedGeneralOptions(), recognizedShortcutKeys = recognizedShortcutNames(); // subtract recognized keys generalKeys.subtract(recognizedGeneralKeys); shortcutKeys.subtract(recognizedShortcutKeys); // what is left are the unrecognized keys - hopefully empty bool ok = generalKeys.isEmpty() && shortcutKeys.isEmpty(); if (log != nullptr || offenders != nullptr) { for (const QString& key : generalKeys) { if (log) { *log << tr(\"Unrecognized setting: '%1'\\n\").arg(key); } if (offenders) { offenders->append(key); } } for (const QString& key : shortcutKeys) { if (log) { *log << tr(\"Unrecognized shortcut name: '%1'.\\n\").arg(key); } if (offenders) { offenders->append(CONFIG_GROUP_SHORTCUTS \"/\" + key); } } } return ok; } bool ConfigHandler::checkShortcutConflicts(AbstractLogger* log) const { bool ok = true; m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); QStringList shortcuts = m_settings.allKeys(); QStringList reportedInLog; for (auto key1 = shortcuts.begin(); key1 != shortcuts.end(); ++key1) { for (auto key2 = key1 + 1; key2 != shortcuts.end(); ++key2) { // values stored in variables are useful when running debugger QString value1 = m_settings.value(*key1).toString(), value2 = m_settings.value(*key2).toString(); // The check will pass if: // - one shortcut is empty (the action doesn't use a shortcut) // - or one of the settings is not found in m_settings, i.e. // user wants to use flameshot's default shortcut for the action // - or the shortcuts for both actions are different if (!(value1.isEmpty() || !m_settings.contains(*key1) || !m_settings.contains(*key2) || value1 != value2)) { ok = false; if (log == nullptr) { break; } else if (!reportedInLog.contains(*key1) && // No duplicate !reportedInLog.contains(*key2)) { // log entries reportedInLog.append(*key1); reportedInLog.append(*key2); *log << tr(\"Shortcut conflict: '%1' and '%2' \" \"have the same shortcut: %3\\n\") .arg(*key1) .arg(*key2) .arg(value1); } } } } m_settings.endGroup(); return ok; } bool ConfigHandler::checkSemantics(AbstractLogger* log, QList<QString>* offenders) const { QStringList allKeys = m_settings.allKeys(); bool ok = true; for (const QString& key : allKeys) { // Test if the key is recognized if (!recognizedGeneralOptions().contains(key) && (!isShortcut(key) || !recognizedShortcutNames().contains(baseName(key)))) { continue; } QVariant val = m_settings.value(key); auto valueHandler = this->valueHandler(key); if (val.isValid() && !valueHandler->check(val)) { // Key does not pass the check ok = false; if (log == nullptr && offenders == nullptr) { break; } if (log != nullptr) { *log << tr(\"Bad value in '%1'. Expected: %2\\n\") .arg(key) .arg(valueHandler->expected()); } if (offenders != nullptr) { offenders->append(key); } } } return ok; } void ConfigHandler::checkAndHandleError() const { if (!QFile(m_settings.fileName()).exists()) { setErrorState(false); } else { setErrorState(!checkForErrors()); } ensureFileWatched(); } void ConfigHandler::setErrorState(bool error) const { bool hadError = m_hasError; m_hasError = error; // Notify user every time m_hasError changes if (!hadError && m_hasError) { QString msg = errorMessage(); AbstractLogger::error() << msg; emit getInstance()->error(); } else if (hadError && !m_hasError) { auto msg = tr(\"You have successfully resolved the configuration error.\"); AbstractLogger::info() << msg; emit getInstance()->errorResolved(); } } bool ConfigHandler::hasError() const { if (m_errorCheckPending) { checkAndHandleError(); m_errorCheckPending = false; } return m_hasError; } QString ConfigHandler::errorMessage() const { return tr( \"The configuration contains an error. Open configuration to resolve.\"); } void ConfigHandler::ensureFileWatched() const { QFile file(m_settings.fileName()); if (!file.exists()) { file.open(QFileDevice::WriteOnly); file.close(); } if (m_configWatcher != nullptr && m_configWatcher->files().isEmpty() && qApp != nullptr // ensures that the organization name can be accessed ) { m_configWatcher->addPath(m_settings.fileName()); } } QSharedPointer<ValueHandler> ConfigHandler::valueHandler( const QString& key) const { QSharedPointer<ValueHandler> handler; if (isShortcut(key)) { handler = recognizedShortcuts.value( baseName(key), QSharedPointer<KeySequence>(new KeySequence())); } else { // General group handler = ::recognizedGeneralOptions.value(key); } return handler; } void ConfigHandler::assertKeyRecognized(const QString& key) const { bool recognized = isShortcut(key) ? recognizedShortcutNames().contains(baseName(key)) : ::recognizedGeneralOptions.contains(key); if (!recognized) { #if defined(QT_DEBUG) // This should never happen, but just in case throw std::logic_error( tr(\"Bad config key '%1' in ConfigHandler. Please report \" \"this as a bug.\") .arg(key) .toStdString()); #else setErrorState(true); #endif } } bool ConfigHandler::isShortcut(const QString& key) const { return m_settings.group() == QStringLiteral(CONFIG_GROUP_SHORTCUTS) || key.startsWith(QStringLiteral(CONFIG_GROUP_SHORTCUTS \"/\")); } QString ConfigHandler::baseName(QString key) const { return QFileInfo(key).baseName(); } // STATIC MEMBER DEFINITIONS bool ConfigHandler::m_hasError = false; bool ConfigHandler::m_errorCheckPending = true; bool ConfigHandler::m_skipNextErrorCheck = false; QSharedPointer<QFileSystemWatcher> ConfigHandler::m_configWatcher;","title":"File confighandler.cpp"},{"location":"flameshot/confighandler_8cpp_source/#file-confighandlercpp","text":"File List > src > utils > confighandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"confighandler.h\" #include \"abstractlogger.h\" #include \"src/tools/capturetool.h\" #include \"valuehandler.h\" #include <QCoreApplication> #include <QDebug> #include <QDir> #include <QFile> #include <QFileSystemWatcher> #include <QKeySequence> #include <QMap> #include <QSharedPointer> #include <QStandardPaths> #include <QVector> #include <algorithm> #include <stdexcept> #if defined(Q_OS_MACOS) #include <QProcess> #endif // HELPER FUNCTIONS bool verifyLaunchFile() { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QString path = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, \"autostart/\", QStandardPaths::LocateDirectory) + \"Flameshot.desktop\"; bool res = QFile(path).exists(); #elif defined(Q_OS_WIN) QSettings bootUpSettings( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", QSettings::NativeFormat); bool res = bootUpSettings.value(\"Flameshot\").toString() == QDir::toNativeSeparators(QCoreApplication::applicationFilePath()); #endif return res; } // VALUE HANDLING #define OPTION(KEY, TYPE) \\ { \\ QStringLiteral(KEY), QSharedPointer<ValueHandler>(new TYPE) \\ } #define SHORTCUT(NAME, DEFAULT_VALUE) \\ { \\ QStringLiteral(NAME), QSharedPointer<KeySequence>(new KeySequence( \\ QKeySequence(QLatin1String(DEFAULT_VALUE)))) \\ } // clang-format off static QMap<class QString, QSharedPointer<ValueHandler>> recognizedGeneralOptions = { // KEY TYPE DEFAULT_VALUE OPTION(\"showHelp\" ,Bool ( true )), OPTION(\"showSidePanelButton\" ,Bool ( true )), OPTION(\"showDesktopNotification\" ,Bool ( true )), OPTION(\"disabledTrayIcon\" ,Bool ( false )), OPTION(\"historyConfirmationToDelete\" ,Bool ( true )), #if !defined(DISABLE_UPDATE_CHECKER) OPTION(\"checkForUpdates\" ,Bool ( true )), #endif OPTION(\"allowMultipleGuiInstances\" ,Bool ( false )), OPTION(\"showMagnifier\" ,Bool ( false )), OPTION(\"squareMagnifier\" ,Bool ( false )), #if !defined(Q_OS_WIN) OPTION(\"autoCloseIdleDaemon\" ,Bool ( false )), #endif OPTION(\"startupLaunch\" ,Bool ( false )), OPTION(\"showStartupLaunchMessage\" ,Bool ( true )), OPTION(\"copyURLAfterUpload\" ,Bool ( true )), OPTION(\"copyPathAfterSave\" ,Bool ( false )), OPTION(\"antialiasingPinZoom\" ,Bool ( true )), OPTION(\"useJpgForClipboard\" ,Bool ( false )), OPTION(\"uploadWithoutConfirmation\" ,Bool ( false )), OPTION(\"saveAfterCopy\" ,Bool ( false )), OPTION(\"savePath\" ,ExistingDir ( )), OPTION(\"savePathFixed\" ,Bool ( false )), OPTION(\"saveAsFileExtension\" ,SaveFileExtension ( )), OPTION(\"saveLastRegion\" ,Bool (false )), OPTION(\"uploadHistoryMax\" ,LowerBoundedInt (0, 25 )), OPTION(\"undoLimit\" ,BoundedInt (0, 999, 100 )), // Interface tab OPTION(\"uiColor\" ,Color ( {116, 0, 150} )), OPTION(\"contrastUiColor\" ,Color ( {39, 0, 50} )), OPTION(\"contrastOpacity\" ,BoundedInt ( 0, 255, 190 )), OPTION(\"buttons\" ,ButtonList ( {} )), // Filename Editor tab OPTION(\"filenamePattern\" ,FilenamePattern ( {} )), // Others OPTION(\"drawThickness\" ,LowerBoundedInt (1 , 3 )), OPTION(\"drawFontSize\" ,LowerBoundedInt (1 , 8 )), OPTION(\"drawColor\" ,Color ( Qt::red )), OPTION(\"userColors\" ,UserColors(3, 17 )), OPTION(\"ignoreUpdateToVersion\" ,String ( \"\" )), OPTION(\"keepOpenAppLauncher\" ,Bool ( false )), OPTION(\"fontFamily\" ,String ( \"\" )), // PREDEFINED_COLOR_PALETTE_LARGE is defined in src/CMakeList.txt file and can be overwritten in GitHub actions OPTION(\"predefinedColorPaletteLarge\", Bool ( PREDEFINED_COLOR_PALETTE_LARGE )), // NOTE: If another tool size is added besides drawThickness and // drawFontSize, remember to update ConfigHandler::toolSize OPTION(\"copyOnDoubleClick\" ,Bool ( false )), OPTION(\"uploadClientSecret\" ,String ( \"313baf0c7b4d3ff\" )), OPTION(\"showSelectionGeometry\" , BoundedInt (0,5,4)), OPTION(\"showSelectionGeometryHideTime\", LowerBoundedInt (0, 3000)) }; static QMap<QString, QSharedPointer<KeySequence>> recognizedShortcuts = { // NAME DEFAULT_SHORTCUT SHORTCUT(\"TYPE_PENCIL\" , \"P\" ), SHORTCUT(\"TYPE_DRAWER\" , \"D\" ), SHORTCUT(\"TYPE_ARROW\" , \"A\" ), SHORTCUT(\"TYPE_SELECTION\" , \"S\" ), SHORTCUT(\"TYPE_RECTANGLE\" , \"R\" ), SHORTCUT(\"TYPE_CIRCLE\" , \"C\" ), SHORTCUT(\"TYPE_MARKER\" , \"M\" ), SHORTCUT(\"TYPE_MOVESELECTION\" , \"Ctrl+M\" ), SHORTCUT(\"TYPE_UNDO\" , \"Ctrl+Z\" ), SHORTCUT(\"TYPE_COPY\" , \"Ctrl+C\" ), SHORTCUT(\"TYPE_SAVE\" , \"Ctrl+S\" ), SHORTCUT(\"TYPE_ACCEPT\" , \"Return\" ), SHORTCUT(\"TYPE_EXIT\" , \"Ctrl+Q\" ), SHORTCUT(\"TYPE_IMAGEUPLOADER\" , ), #if !defined(Q_OS_MACOS) SHORTCUT(\"TYPE_OPEN_APP\" , \"Ctrl+O\" ), #endif SHORTCUT(\"TYPE_PIXELATE\" , \"B\" ), SHORTCUT(\"TYPE_INVERT\" , \"I\" ), SHORTCUT(\"TYPE_REDO\" , \"Ctrl+Shift+Z\" ), SHORTCUT(\"TYPE_TEXT\" , \"T\" ), SHORTCUT(\"TYPE_TOGGLE_PANEL\" , \"Space\" ), SHORTCUT(\"TYPE_RESIZE_LEFT\" , \"Shift+Left\" ), SHORTCUT(\"TYPE_RESIZE_RIGHT\" , \"Shift+Right\" ), SHORTCUT(\"TYPE_RESIZE_UP\" , \"Shift+Up\" ), SHORTCUT(\"TYPE_RESIZE_DOWN\" , \"Shift+Down\" ), SHORTCUT(\"TYPE_SYM_RESIZE_LEFT\" , \"Ctrl+Shift+Left\" ), SHORTCUT(\"TYPE_SYM_RESIZE_RIGHT\" , \"Ctrl+Shift+Right\" ), SHORTCUT(\"TYPE_SYM_RESIZE_UP\" , \"Ctrl+Shift+Up\" ), SHORTCUT(\"TYPE_SYM_RESIZE_DOWN\" , \"Ctrl+Shift+Down\" ), SHORTCUT(\"TYPE_SELECT_ALL\" , \"Ctrl+A\" ), SHORTCUT(\"TYPE_MOVE_LEFT\" , \"Left\" ), SHORTCUT(\"TYPE_MOVE_RIGHT\" , \"Right\" ), SHORTCUT(\"TYPE_MOVE_UP\" , \"Up\" ), SHORTCUT(\"TYPE_MOVE_DOWN\" , \"Down\" ), SHORTCUT(\"TYPE_COMMIT_CURRENT_TOOL\" , \"Ctrl+Return\" ), #if defined(Q_OS_MACOS) SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" , \"Backspace\" ), SHORTCUT(\"TAKE_SCREENSHOT\" , \"Ctrl+Shift+X\" ), SHORTCUT(\"SCREENSHOT_HISTORY\" , \"Alt+Shift+X\" ), #else SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" , \"Delete\" ), #endif SHORTCUT(\"TYPE_PIN\" , ), SHORTCUT(\"TYPE_SELECTIONINDICATOR\" , ), SHORTCUT(\"TYPE_SIZEINCREASE\" , ), SHORTCUT(\"TYPE_SIZEDECREASE\" , ), SHORTCUT(\"TYPE_CIRCLECOUNT\" , ), }; // clang-format on // CLASS CONFIGHANDLER ConfigHandler::ConfigHandler() : m_settings(QSettings::IniFormat, QSettings::UserScope, qApp->organizationName(), qApp->applicationName()) { static bool firstInitialization = true; if (firstInitialization) { // check for error every time the file changes m_configWatcher.reset(new QFileSystemWatcher()); ensureFileWatched(); QObject::connect(m_configWatcher.data(), &QFileSystemWatcher::fileChanged, [](const QString& fileName) { emit getInstance()->fileChanged(); if (QFile(fileName).exists()) { m_configWatcher->addPath(fileName); } if (m_skipNextErrorCheck) { m_skipNextErrorCheck = false; return; } ConfigHandler().checkAndHandleError(); if (!QFile(fileName).exists()) { // File watcher stops watching a deleted file. // Next time the config is accessed, force it // to check for errors (and watch again). m_errorCheckPending = true; } }); } firstInitialization = false; } ConfigHandler* ConfigHandler::getInstance() { static ConfigHandler config; return &config; } // SPECIAL CASES bool ConfigHandler::startupLaunch() { bool res = value(QStringLiteral(\"startupLaunch\")).toBool(); if (res != verifyLaunchFile()) { setStartupLaunch(res); } return res; } void ConfigHandler::setStartupLaunch(const bool start) { if (start == value(QStringLiteral(\"startupLaunch\")).toBool()) { return; } setValue(QStringLiteral(\"startupLaunch\"), start); #if defined(Q_OS_MACOS) /* TODO - there should be more correct way via API, but didn't find it without extra dependencies, there should be something like that: https://stackoverflow.com/questions/3358410/programmatically-run-at-startup-on-mac-os-x But files with this features differs on different MacOS versions and it doesn't work not on a BigSur at lease. */ QProcess process; if (start) { process.start(\"osascript\", QStringList() << \"-e\" << \"tell application \\\"System Events\\\" to make login \" \"item at end with properties {name: \" \"\\\"Flameshot\\\",path:\\\"/Applications/\" \"flameshot.app\\\", hidden:false}\"); } else { process.start(\"osascript\", QStringList() << \"-e\" << \"tell application \\\"System Events\\\" to \" \"delete login item \\\"Flameshot\\\"\"); } if (!process.waitForFinished()) { qWarning() << \"Login items is changed. \" << process.errorString(); } else { qWarning() << \"Unable to change login items, error:\" << process.readAll(); } #elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QString path = QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation) + \"/autostart/\"; QDir autostartDir(path); if (!autostartDir.exists()) { autostartDir.mkpath(\".\"); } QFile file(path + \"Flameshot.desktop\"); if (start) { if (file.open(QIODevice::WriteOnly)) { QByteArray data(\"[Desktop Entry]\\nName=flameshot\\nIcon=flameshot\" \"\\nExec=flameshot\\nTerminal=false\\nType=Application\" \"\\nX-GNOME-Autostart-enabled=true\\n\"); file.write(data); } } else { file.remove(); } #elif defined(Q_OS_WIN) QSettings bootUpSettings( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", QSettings::NativeFormat); // set workdir for flameshot on startup QSettings bootUpPath( \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App \" \"Paths\", QSettings::NativeFormat); if (start) { QString app_path = QDir::toNativeSeparators(QCoreApplication::applicationFilePath()); bootUpSettings.setValue(\"Flameshot\", app_path); // set application workdir bootUpPath.beginGroup(\"flameshot.exe\"); bootUpPath.setValue(\"Path\", QCoreApplication::applicationDirPath()); bootUpPath.endGroup(); } else { bootUpSettings.remove(\"Flameshot\"); // remove application workdir bootUpPath.beginGroup(\"flameshot.exe\"); bootUpPath.remove(\"\"); bootUpPath.endGroup(); } #endif } void ConfigHandler::setAllTheButtons() { QList<CaptureTool::Type> buttons = CaptureToolButton::getIterableButtonTypes(); setValue(QStringLiteral(\"buttons\"), QVariant::fromValue(buttons)); } void ConfigHandler::setToolSize(CaptureTool::Type toolType, int size) { if (toolType == CaptureTool::TYPE_TEXT) { setDrawFontSize(size); } else if (toolType != CaptureTool::NONE) { setDrawThickness(size); } } int ConfigHandler::toolSize(CaptureTool::Type toolType) { if (toolType == CaptureTool::TYPE_TEXT) { return drawFontSize(); } else { return drawThickness(); } } // DEFAULTS QString ConfigHandler::filenamePatternDefault() { return QStringLiteral(\"%F_%H-%M\"); } void ConfigHandler::setDefaultSettings() { foreach (const QString& key, m_settings.allKeys()) { if (isShortcut(key)) { // Do not reset Shortcuts continue; } m_settings.remove(key); } m_settings.sync(); } QString ConfigHandler::configFilePath() const { return m_settings.fileName(); } // GENERIC GETTERS AND SETTERS bool ConfigHandler::setShortcut(const QString& actionName, const QString& shortcut) { qDebug() << actionName; static QVector<QKeySequence> reservedShortcuts = { #if defined(Q_OS_MACOS) Qt::CTRL + Qt::Key_Backspace, Qt::Key_Escape, #else Qt::Key_Backspace, Qt::Key_Escape, #endif }; if (hasError()) { return false; } bool error = false; m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); if (shortcut.isEmpty()) { setValue(actionName, \"\"); } else if (reservedShortcuts.contains(QKeySequence(shortcut))) { // do not allow to set reserved shortcuts error = true; } else { error = false; // Make no difference for Return and Enter keys QString newShortcut = KeySequence().value(shortcut).toString(); for (auto& otherAction : m_settings.allKeys()) { if (actionName == otherAction) { continue; } QString existingShortcut = KeySequence().value(m_settings.value(otherAction)).toString(); if (newShortcut == existingShortcut) { error = true; goto done; } } m_settings.setValue(actionName, KeySequence().value(shortcut)); } done: m_settings.endGroup(); return !error; } QString ConfigHandler::shortcut(const QString& actionName) { QString setting = CONFIG_GROUP_SHORTCUTS \"/\" + actionName; QString shortcut = value(setting).toString(); if (!m_settings.contains(setting)) { // The action uses a shortcut that is a flameshot default // (not set explicitly by user) m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); for (auto& otherAction : m_settings.allKeys()) { if (m_settings.value(otherAction) == shortcut) { // We found an explicit shortcut - it will take precedence m_settings.endGroup(); return {}; } } m_settings.endGroup(); } return shortcut; } void ConfigHandler::setValue(const QString& key, const QVariant& value) { assertKeyRecognized(key); if (!hasError()) { // don't let the file watcher initiate another error check m_skipNextErrorCheck = true; auto val = valueHandler(key)->representation(value); m_settings.setValue(key, val); } } QVariant ConfigHandler::value(const QString& key) const { assertKeyRecognized(key); auto val = m_settings.value(key); auto handler = valueHandler(key); // Check the value for semantic errors if (val.isValid() && !handler->check(val)) { setErrorState(true); } if (m_hasError) { return handler->fallback(); } return handler->value(val); } void ConfigHandler::remove(const QString& key) { m_settings.remove(key); } void ConfigHandler::resetValue(const QString& key) { m_settings.setValue(key, valueHandler(key)->fallback()); } QSet<QString>& ConfigHandler::recognizedGeneralOptions() { #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0) auto keys = ::recognizedGeneralOptions.keys(); static QSet<QString> options = QSet<QString>(keys.begin(), keys.end()); #else static QSet<QString> options = QSet<QString>::fromList(::recognizedGeneralOptions.keys()); #endif return options; } QSet<QString>& ConfigHandler::recognizedShortcutNames() { #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0) auto keys = recognizedShortcuts.keys(); static QSet<QString> names = QSet<QString>(keys.begin(), keys.end()); #else static QSet<QString> names = QSet<QString>::fromList(recognizedShortcuts.keys()); #endif return names; } QSet<QString> ConfigHandler::keysFromGroup(const QString& group) const { QSet<QString> keys; for (const QString& key : m_settings.allKeys()) { if (group == CONFIG_GROUP_GENERAL && !key.contains('/')) { keys.insert(key); } else if (key.startsWith(group + \"/\")) { keys.insert(baseName(key)); } } return keys; } // ERROR HANDLING bool ConfigHandler::checkForErrors(AbstractLogger* log) const { return checkUnrecognizedSettings(log) && checkShortcutConflicts(log) && checkSemantics(log); } bool ConfigHandler::checkUnrecognizedSettings(AbstractLogger* log, QList<QString>* offenders) const { // sort the config keys by group QSet<QString> generalKeys = keysFromGroup(CONFIG_GROUP_GENERAL), shortcutKeys = keysFromGroup(CONFIG_GROUP_SHORTCUTS), recognizedGeneralKeys = recognizedGeneralOptions(), recognizedShortcutKeys = recognizedShortcutNames(); // subtract recognized keys generalKeys.subtract(recognizedGeneralKeys); shortcutKeys.subtract(recognizedShortcutKeys); // what is left are the unrecognized keys - hopefully empty bool ok = generalKeys.isEmpty() && shortcutKeys.isEmpty(); if (log != nullptr || offenders != nullptr) { for (const QString& key : generalKeys) { if (log) { *log << tr(\"Unrecognized setting: '%1'\\n\").arg(key); } if (offenders) { offenders->append(key); } } for (const QString& key : shortcutKeys) { if (log) { *log << tr(\"Unrecognized shortcut name: '%1'.\\n\").arg(key); } if (offenders) { offenders->append(CONFIG_GROUP_SHORTCUTS \"/\" + key); } } } return ok; } bool ConfigHandler::checkShortcutConflicts(AbstractLogger* log) const { bool ok = true; m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS); QStringList shortcuts = m_settings.allKeys(); QStringList reportedInLog; for (auto key1 = shortcuts.begin(); key1 != shortcuts.end(); ++key1) { for (auto key2 = key1 + 1; key2 != shortcuts.end(); ++key2) { // values stored in variables are useful when running debugger QString value1 = m_settings.value(*key1).toString(), value2 = m_settings.value(*key2).toString(); // The check will pass if: // - one shortcut is empty (the action doesn't use a shortcut) // - or one of the settings is not found in m_settings, i.e. // user wants to use flameshot's default shortcut for the action // - or the shortcuts for both actions are different if (!(value1.isEmpty() || !m_settings.contains(*key1) || !m_settings.contains(*key2) || value1 != value2)) { ok = false; if (log == nullptr) { break; } else if (!reportedInLog.contains(*key1) && // No duplicate !reportedInLog.contains(*key2)) { // log entries reportedInLog.append(*key1); reportedInLog.append(*key2); *log << tr(\"Shortcut conflict: '%1' and '%2' \" \"have the same shortcut: %3\\n\") .arg(*key1) .arg(*key2) .arg(value1); } } } } m_settings.endGroup(); return ok; } bool ConfigHandler::checkSemantics(AbstractLogger* log, QList<QString>* offenders) const { QStringList allKeys = m_settings.allKeys(); bool ok = true; for (const QString& key : allKeys) { // Test if the key is recognized if (!recognizedGeneralOptions().contains(key) && (!isShortcut(key) || !recognizedShortcutNames().contains(baseName(key)))) { continue; } QVariant val = m_settings.value(key); auto valueHandler = this->valueHandler(key); if (val.isValid() && !valueHandler->check(val)) { // Key does not pass the check ok = false; if (log == nullptr && offenders == nullptr) { break; } if (log != nullptr) { *log << tr(\"Bad value in '%1'. Expected: %2\\n\") .arg(key) .arg(valueHandler->expected()); } if (offenders != nullptr) { offenders->append(key); } } } return ok; } void ConfigHandler::checkAndHandleError() const { if (!QFile(m_settings.fileName()).exists()) { setErrorState(false); } else { setErrorState(!checkForErrors()); } ensureFileWatched(); } void ConfigHandler::setErrorState(bool error) const { bool hadError = m_hasError; m_hasError = error; // Notify user every time m_hasError changes if (!hadError && m_hasError) { QString msg = errorMessage(); AbstractLogger::error() << msg; emit getInstance()->error(); } else if (hadError && !m_hasError) { auto msg = tr(\"You have successfully resolved the configuration error.\"); AbstractLogger::info() << msg; emit getInstance()->errorResolved(); } } bool ConfigHandler::hasError() const { if (m_errorCheckPending) { checkAndHandleError(); m_errorCheckPending = false; } return m_hasError; } QString ConfigHandler::errorMessage() const { return tr( \"The configuration contains an error. Open configuration to resolve.\"); } void ConfigHandler::ensureFileWatched() const { QFile file(m_settings.fileName()); if (!file.exists()) { file.open(QFileDevice::WriteOnly); file.close(); } if (m_configWatcher != nullptr && m_configWatcher->files().isEmpty() && qApp != nullptr // ensures that the organization name can be accessed ) { m_configWatcher->addPath(m_settings.fileName()); } } QSharedPointer<ValueHandler> ConfigHandler::valueHandler( const QString& key) const { QSharedPointer<ValueHandler> handler; if (isShortcut(key)) { handler = recognizedShortcuts.value( baseName(key), QSharedPointer<KeySequence>(new KeySequence())); } else { // General group handler = ::recognizedGeneralOptions.value(key); } return handler; } void ConfigHandler::assertKeyRecognized(const QString& key) const { bool recognized = isShortcut(key) ? recognizedShortcutNames().contains(baseName(key)) : ::recognizedGeneralOptions.contains(key); if (!recognized) { #if defined(QT_DEBUG) // This should never happen, but just in case throw std::logic_error( tr(\"Bad config key '%1' in ConfigHandler. Please report \" \"this as a bug.\") .arg(key) .toStdString()); #else setErrorState(true); #endif } } bool ConfigHandler::isShortcut(const QString& key) const { return m_settings.group() == QStringLiteral(CONFIG_GROUP_SHORTCUTS) || key.startsWith(QStringLiteral(CONFIG_GROUP_SHORTCUTS \"/\")); } QString ConfigHandler::baseName(QString key) const { return QFileInfo(key).baseName(); } // STATIC MEMBER DEFINITIONS bool ConfigHandler::m_hasError = false; bool ConfigHandler::m_errorCheckPending = true; bool ConfigHandler::m_skipNextErrorCheck = false; QSharedPointer<QFileSystemWatcher> ConfigHandler::m_configWatcher;","title":"File confighandler.cpp"},{"location":"flameshot/confighandler_8h/","text":"File confighandler.h # FileList > src > utils > confighandler.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include <QSettings> #include <QStringList> #include <QVariant> #include <QVector> Classes # Type Name class ConfigHandler Macros # Type Name define CONFIG_GETTER (KEY, TYPE) TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } define CONFIG_GETTER_SETTER (GETFUNC, SETFUNC, TYPE) define CONFIG_GROUP_GENERAL \"General\" define CONFIG_GROUP_SHORTCUTS \"Shortcuts\" define CONFIG_SETTER (FUNC, KEY, TYPE) Macro Definition Documentation # define CONFIG_GETTER # #define CONFIG_GETTER ( KEY, TYPE ) TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } Declare and implement a getter for a config option. KEY is the option key as it appears in the config file, TYPE is the C++ type. At the same time KEY is the name of the generated getter function. define CONFIG_GETTER_SETTER # #define CONFIG_GETTER_SETTER ( GETFUNC, SETFUNC, TYPE ) CONFIG_GETTER(GETFUNC, TYPE) \\ CONFIG_SETTER(SETFUNC, GETFUNC, TYPE) Combines the functionality of CONFIG_GETTER and CONFIG_SETTER . GETFUNC is simultaneously the name of the getter function and the option key as it appears in the config file. SETFUNC is the name of the setter function. TYPE is the C++ type of the value. define CONFIG_GROUP_GENERAL # #define CONFIG_GROUP_GENERAL \"General\" define CONFIG_GROUP_SHORTCUTS # #define CONFIG_GROUP_SHORTCUTS \"Shortcuts\" define CONFIG_SETTER # #define CONFIG_SETTER ( FUNC, KEY, TYPE ) void FUNC(const TYPE& val) \\ { \\ QString key = QStringLiteral(#KEY); \\ /* Without this check, multiple `flameshot gui` instances running */ \\ /* simultaneously would cause an endless loop of fileWatcher calls */ \\ if (QVariant::fromValue(val) != value(key)) { \\ setValue(key, QVariant::fromValue(val)); \\ } \\ } Declare and implement a setter for a config option. FUNC is the name of the generated function, KEY is the option key as it appears in the config file and TYPE is the C++ type.","title":"File confighandler.h"},{"location":"flameshot/confighandler_8h/#file-confighandlerh","text":"FileList > src > utils > confighandler.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include <QSettings> #include <QStringList> #include <QVariant> #include <QVector>","title":"File confighandler.h"},{"location":"flameshot/confighandler_8h/#classes","text":"Type Name class ConfigHandler","title":"Classes"},{"location":"flameshot/confighandler_8h/#macros","text":"Type Name define CONFIG_GETTER (KEY, TYPE) TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } define CONFIG_GETTER_SETTER (GETFUNC, SETFUNC, TYPE) define CONFIG_GROUP_GENERAL \"General\" define CONFIG_GROUP_SHORTCUTS \"Shortcuts\" define CONFIG_SETTER (FUNC, KEY, TYPE)","title":"Macros"},{"location":"flameshot/confighandler_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/confighandler_8h/#define-config_getter","text":"#define CONFIG_GETTER ( KEY, TYPE ) TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } Declare and implement a getter for a config option. KEY is the option key as it appears in the config file, TYPE is the C++ type. At the same time KEY is the name of the generated getter function.","title":"define CONFIG_GETTER"},{"location":"flameshot/confighandler_8h/#define-config_getter_setter","text":"#define CONFIG_GETTER_SETTER ( GETFUNC, SETFUNC, TYPE ) CONFIG_GETTER(GETFUNC, TYPE) \\ CONFIG_SETTER(SETFUNC, GETFUNC, TYPE) Combines the functionality of CONFIG_GETTER and CONFIG_SETTER . GETFUNC is simultaneously the name of the getter function and the option key as it appears in the config file. SETFUNC is the name of the setter function. TYPE is the C++ type of the value.","title":"define CONFIG_GETTER_SETTER"},{"location":"flameshot/confighandler_8h/#define-config_group_general","text":"#define CONFIG_GROUP_GENERAL \"General\"","title":"define CONFIG_GROUP_GENERAL"},{"location":"flameshot/confighandler_8h/#define-config_group_shortcuts","text":"#define CONFIG_GROUP_SHORTCUTS \"Shortcuts\"","title":"define CONFIG_GROUP_SHORTCUTS"},{"location":"flameshot/confighandler_8h/#define-config_setter","text":"#define CONFIG_SETTER ( FUNC, KEY, TYPE ) void FUNC(const TYPE& val) \\ { \\ QString key = QStringLiteral(#KEY); \\ /* Without this check, multiple `flameshot gui` instances running */ \\ /* simultaneously would cause an endless loop of fileWatcher calls */ \\ if (QVariant::fromValue(val) != value(key)) { \\ setValue(key, QVariant::fromValue(val)); \\ } \\ } Declare and implement a setter for a config option. FUNC is the name of the generated function, KEY is the option key as it appears in the config file and TYPE is the C++ type.","title":"define CONFIG_SETTER"},{"location":"flameshot/confighandler_8h_source/","text":"File confighandler.h # File List > src > utils > confighandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include <QSettings> #include <QStringList> #include <QVariant> #include <QVector> #define CONFIG_GROUP_GENERAL \"General\" #define CONFIG_GROUP_SHORTCUTS \"Shortcuts\" class QFileSystemWatcher; class ValueHandler; template<class T> class QSharedPointer; class QTextStream; class AbstractLogger; #define CONFIG_GETTER(KEY, TYPE) \\ TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } #define CONFIG_SETTER(FUNC, KEY, TYPE) \\ void FUNC(const TYPE& val) \\ { \\ QString key = QStringLiteral(#KEY); \\ /* Without this check, multiple `flameshot gui` instances running */ \\ /* simultaneously would cause an endless loop of fileWatcher calls */ \\ if (QVariant::fromValue(val) != value(key)) { \\ setValue(key, QVariant::fromValue(val)); \\ } \\ } #define CONFIG_GETTER_SETTER(GETFUNC, SETFUNC, TYPE) \\ CONFIG_GETTER(GETFUNC, TYPE) \\ CONFIG_SETTER(SETFUNC, GETFUNC, TYPE) class ConfigHandler : public QObject { Q_OBJECT public: explicit ConfigHandler(); static ConfigHandler* getInstance(); // Definitions of getters and setters for config options // Some special cases are implemented regularly, without the macro // NOTE: When adding new options, make sure to add an entry in // recognizedGeneralOptions in the cpp file. CONFIG_GETTER_SETTER(userColors, setUserColors, QVector<QColor>); CONFIG_GETTER_SETTER(savePath, setSavePath, QString) CONFIG_GETTER_SETTER(savePathFixed, setSavePathFixed, bool) CONFIG_GETTER_SETTER(uiColor, setUiColor, QColor) CONFIG_GETTER_SETTER(contrastUiColor, setContrastUiColor, QColor) CONFIG_GETTER_SETTER(drawColor, setDrawColor, QColor) CONFIG_GETTER_SETTER(predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool) CONFIG_GETTER_SETTER(fontFamily, setFontFamily, QString) CONFIG_GETTER_SETTER(showHelp, setShowHelp, bool) CONFIG_GETTER_SETTER(showSidePanelButton, setShowSidePanelButton, bool) CONFIG_GETTER_SETTER(showDesktopNotification, setShowDesktopNotification, bool) CONFIG_GETTER_SETTER(filenamePattern, setFilenamePattern, QString) CONFIG_GETTER_SETTER(disabledTrayIcon, setDisabledTrayIcon, bool) CONFIG_GETTER_SETTER(drawThickness, setDrawThickness, int) CONFIG_GETTER_SETTER(drawFontSize, setDrawFontSize, int) CONFIG_GETTER_SETTER(keepOpenAppLauncher, setKeepOpenAppLauncher, bool) #if !defined(DISABLE_UPDATE_CHECKER) CONFIG_GETTER_SETTER(checkForUpdates, setCheckForUpdates, bool) #endif CONFIG_GETTER_SETTER(allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool) CONFIG_GETTER_SETTER(autoCloseIdleDaemon, setAutoCloseIdleDaemon, bool) CONFIG_GETTER_SETTER(showStartupLaunchMessage, setShowStartupLaunchMessage, bool) CONFIG_GETTER_SETTER(contrastOpacity, setContrastOpacity, int) CONFIG_GETTER_SETTER(copyURLAfterUpload, setCopyURLAfterUpload, bool) CONFIG_GETTER_SETTER(historyConfirmationToDelete, setHistoryConfirmationToDelete, bool) CONFIG_GETTER_SETTER(uploadHistoryMax, setUploadHistoryMax, int) CONFIG_GETTER_SETTER(saveAfterCopy, setSaveAfterCopy, bool) CONFIG_GETTER_SETTER(copyPathAfterSave, setCopyPathAfterSave, bool) CONFIG_GETTER_SETTER(saveAsFileExtension, setSaveAsFileExtension, QString) CONFIG_GETTER_SETTER(antialiasingPinZoom, setAntialiasingPinZoom, bool) CONFIG_GETTER_SETTER(useJpgForClipboard, setUseJpgForClipboard, bool) CONFIG_GETTER_SETTER(uploadWithoutConfirmation, setUploadWithoutConfirmation, bool) CONFIG_GETTER_SETTER(ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString) CONFIG_GETTER_SETTER(undoLimit, setUndoLimit, int) CONFIG_GETTER_SETTER(buttons, setButtons, QList<CaptureTool::Type>) CONFIG_GETTER_SETTER(showMagnifier, setShowMagnifier, bool) CONFIG_GETTER_SETTER(squareMagnifier, setSquareMagnifier, bool) CONFIG_GETTER_SETTER(copyOnDoubleClick, setCopyOnDoubleClick, bool) CONFIG_GETTER_SETTER(uploadClientSecret, setUploadClientSecret, QString) CONFIG_GETTER_SETTER(saveLastRegion, setSaveLastRegion, bool) CONFIG_GETTER_SETTER(showSelectionGeometry, setShowSelectionGeometry, int) // SPECIAL CASES bool startupLaunch(); void setStartupLaunch(const bool); void setAllTheButtons(); void setToolSize(CaptureTool::Type toolType, int size); int toolSize(CaptureTool::Type toolType); // DEFAULTS QString filenamePatternDefault(); void setDefaultSettings(); QString configFilePath() const; // GENERIC GETTERS AND SETTERS bool setShortcut(const QString& actionName, const QString& shortcut); QString shortcut(const QString& actionName); void setValue(const QString& key, const QVariant& value); QVariant value(const QString& key) const; void remove(const QString& key); void resetValue(const QString& key); // INFO static QSet<QString>& recognizedGeneralOptions(); static QSet<QString>& recognizedShortcutNames(); QSet<QString> keysFromGroup(const QString& group) const; // ERROR HANDLING bool checkForErrors(AbstractLogger* log = nullptr) const; bool checkUnrecognizedSettings(AbstractLogger* log = nullptr, QList<QString>* offenders = nullptr) const; bool checkShortcutConflicts(AbstractLogger* log = nullptr) const; bool checkSemantics(AbstractLogger* log = nullptr, QList<QString>* offenders = nullptr) const; void checkAndHandleError() const; void setErrorState(bool error) const; bool hasError() const; QString errorMessage() const; signals: void error() const; void errorResolved() const; void fileChanged() const; private: mutable QSettings m_settings; static bool m_hasError, m_errorCheckPending, m_skipNextErrorCheck; static QSharedPointer<QFileSystemWatcher> m_configWatcher; void ensureFileWatched() const; QSharedPointer<ValueHandler> valueHandler(const QString& key) const; void assertKeyRecognized(const QString& key) const; bool isShortcut(const QString& key) const; QString baseName(QString key) const; void cleanUnusedKeys(const QString& group, const QSet<QString>& keys) const; };","title":"File confighandler.h"},{"location":"flameshot/confighandler_8h_source/#file-confighandlerh","text":"File List > src > utils > confighandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include <QSettings> #include <QStringList> #include <QVariant> #include <QVector> #define CONFIG_GROUP_GENERAL \"General\" #define CONFIG_GROUP_SHORTCUTS \"Shortcuts\" class QFileSystemWatcher; class ValueHandler; template<class T> class QSharedPointer; class QTextStream; class AbstractLogger; #define CONFIG_GETTER(KEY, TYPE) \\ TYPE KEY() { return value(QStringLiteral(#KEY)).value<TYPE>(); } #define CONFIG_SETTER(FUNC, KEY, TYPE) \\ void FUNC(const TYPE& val) \\ { \\ QString key = QStringLiteral(#KEY); \\ /* Without this check, multiple `flameshot gui` instances running */ \\ /* simultaneously would cause an endless loop of fileWatcher calls */ \\ if (QVariant::fromValue(val) != value(key)) { \\ setValue(key, QVariant::fromValue(val)); \\ } \\ } #define CONFIG_GETTER_SETTER(GETFUNC, SETFUNC, TYPE) \\ CONFIG_GETTER(GETFUNC, TYPE) \\ CONFIG_SETTER(SETFUNC, GETFUNC, TYPE) class ConfigHandler : public QObject { Q_OBJECT public: explicit ConfigHandler(); static ConfigHandler* getInstance(); // Definitions of getters and setters for config options // Some special cases are implemented regularly, without the macro // NOTE: When adding new options, make sure to add an entry in // recognizedGeneralOptions in the cpp file. CONFIG_GETTER_SETTER(userColors, setUserColors, QVector<QColor>); CONFIG_GETTER_SETTER(savePath, setSavePath, QString) CONFIG_GETTER_SETTER(savePathFixed, setSavePathFixed, bool) CONFIG_GETTER_SETTER(uiColor, setUiColor, QColor) CONFIG_GETTER_SETTER(contrastUiColor, setContrastUiColor, QColor) CONFIG_GETTER_SETTER(drawColor, setDrawColor, QColor) CONFIG_GETTER_SETTER(predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool) CONFIG_GETTER_SETTER(fontFamily, setFontFamily, QString) CONFIG_GETTER_SETTER(showHelp, setShowHelp, bool) CONFIG_GETTER_SETTER(showSidePanelButton, setShowSidePanelButton, bool) CONFIG_GETTER_SETTER(showDesktopNotification, setShowDesktopNotification, bool) CONFIG_GETTER_SETTER(filenamePattern, setFilenamePattern, QString) CONFIG_GETTER_SETTER(disabledTrayIcon, setDisabledTrayIcon, bool) CONFIG_GETTER_SETTER(drawThickness, setDrawThickness, int) CONFIG_GETTER_SETTER(drawFontSize, setDrawFontSize, int) CONFIG_GETTER_SETTER(keepOpenAppLauncher, setKeepOpenAppLauncher, bool) #if !defined(DISABLE_UPDATE_CHECKER) CONFIG_GETTER_SETTER(checkForUpdates, setCheckForUpdates, bool) #endif CONFIG_GETTER_SETTER(allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool) CONFIG_GETTER_SETTER(autoCloseIdleDaemon, setAutoCloseIdleDaemon, bool) CONFIG_GETTER_SETTER(showStartupLaunchMessage, setShowStartupLaunchMessage, bool) CONFIG_GETTER_SETTER(contrastOpacity, setContrastOpacity, int) CONFIG_GETTER_SETTER(copyURLAfterUpload, setCopyURLAfterUpload, bool) CONFIG_GETTER_SETTER(historyConfirmationToDelete, setHistoryConfirmationToDelete, bool) CONFIG_GETTER_SETTER(uploadHistoryMax, setUploadHistoryMax, int) CONFIG_GETTER_SETTER(saveAfterCopy, setSaveAfterCopy, bool) CONFIG_GETTER_SETTER(copyPathAfterSave, setCopyPathAfterSave, bool) CONFIG_GETTER_SETTER(saveAsFileExtension, setSaveAsFileExtension, QString) CONFIG_GETTER_SETTER(antialiasingPinZoom, setAntialiasingPinZoom, bool) CONFIG_GETTER_SETTER(useJpgForClipboard, setUseJpgForClipboard, bool) CONFIG_GETTER_SETTER(uploadWithoutConfirmation, setUploadWithoutConfirmation, bool) CONFIG_GETTER_SETTER(ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString) CONFIG_GETTER_SETTER(undoLimit, setUndoLimit, int) CONFIG_GETTER_SETTER(buttons, setButtons, QList<CaptureTool::Type>) CONFIG_GETTER_SETTER(showMagnifier, setShowMagnifier, bool) CONFIG_GETTER_SETTER(squareMagnifier, setSquareMagnifier, bool) CONFIG_GETTER_SETTER(copyOnDoubleClick, setCopyOnDoubleClick, bool) CONFIG_GETTER_SETTER(uploadClientSecret, setUploadClientSecret, QString) CONFIG_GETTER_SETTER(saveLastRegion, setSaveLastRegion, bool) CONFIG_GETTER_SETTER(showSelectionGeometry, setShowSelectionGeometry, int) // SPECIAL CASES bool startupLaunch(); void setStartupLaunch(const bool); void setAllTheButtons(); void setToolSize(CaptureTool::Type toolType, int size); int toolSize(CaptureTool::Type toolType); // DEFAULTS QString filenamePatternDefault(); void setDefaultSettings(); QString configFilePath() const; // GENERIC GETTERS AND SETTERS bool setShortcut(const QString& actionName, const QString& shortcut); QString shortcut(const QString& actionName); void setValue(const QString& key, const QVariant& value); QVariant value(const QString& key) const; void remove(const QString& key); void resetValue(const QString& key); // INFO static QSet<QString>& recognizedGeneralOptions(); static QSet<QString>& recognizedShortcutNames(); QSet<QString> keysFromGroup(const QString& group) const; // ERROR HANDLING bool checkForErrors(AbstractLogger* log = nullptr) const; bool checkUnrecognizedSettings(AbstractLogger* log = nullptr, QList<QString>* offenders = nullptr) const; bool checkShortcutConflicts(AbstractLogger* log = nullptr) const; bool checkSemantics(AbstractLogger* log = nullptr, QList<QString>* offenders = nullptr) const; void checkAndHandleError() const; void setErrorState(bool error) const; bool hasError() const; QString errorMessage() const; signals: void error() const; void errorResolved() const; void fileChanged() const; private: mutable QSettings m_settings; static bool m_hasError, m_errorCheckPending, m_skipNextErrorCheck; static QSharedPointer<QFileSystemWatcher> m_configWatcher; void ensureFileWatched() const; QSharedPointer<ValueHandler> valueHandler(const QString& key) const; void assertKeyRecognized(const QString& key) const; bool isShortcut(const QString& key) const; QString baseName(QString key) const; void cleanUnusedKeys(const QString& group, const QSet<QString>& keys) const; };","title":"File confighandler.h"},{"location":"flameshot/desktopfileparse_8cpp/","text":"File desktopfileparse.cpp # FileList > src > utils > desktopfileparse.cpp Go to the source code of this file. #include \"desktopfileparse.h\" #include <QDir> #include <QFile> #include <QLocale> #include <QString> #include <QTextStream>","title":"File desktopfileparse.cpp"},{"location":"flameshot/desktopfileparse_8cpp/#file-desktopfileparsecpp","text":"FileList > src > utils > desktopfileparse.cpp Go to the source code of this file. #include \"desktopfileparse.h\" #include <QDir> #include <QFile> #include <QLocale> #include <QString> #include <QTextStream>","title":"File desktopfileparse.cpp"},{"location":"flameshot/desktopfileparse_8cpp_source/","text":"File desktopfileparse.cpp # File List > src > utils > desktopfileparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"desktopfileparse.h\" #include <QDir> #include <QFile> #include <QLocale> #include <QString> #include <QTextStream> DesktopFileParser::DesktopFileParser() { QString locale = QLocale().name(); QString localeShort = QLocale().name().left(2); m_localeName = QStringLiteral(\"Name[%1]\").arg(locale); m_localeDescription = QStringLiteral(\"Comment[%1]\").arg(locale); m_localeNameShort = QStringLiteral(\"Name[%1]\").arg(localeShort); m_localeDescriptionShort = QStringLiteral(\"Comment[%1]\").arg(localeShort); m_defaultIcon = QIcon::fromTheme(QStringLiteral(\"application-x-executable\")); } DesktopAppData DesktopFileParser::parseDesktopFile(const QString& fileName, bool& ok) const { DesktopAppData res; ok = true; QFile file(fileName); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { ok = false; return res; } bool nameLocaleSet = false; bool descriptionLocaleSet = false; bool isApplication = false; bool isService = false; QTextStream in(&file); // enter the desktop entry definition while (!in.atEnd() && in.readLine() != QLatin1String(\"[Desktop Entry]\")) { } // start parsing while (!in.atEnd()) { QString line = in.readLine(); if (line.startsWith(QLatin1String(\"Icon\"))) { res.icon = QIcon::fromTheme( line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(), m_defaultIcon); } else if (!nameLocaleSet && line.startsWith(QLatin1String(\"Name\"))) { if (line.startsWith(m_localeName) || line.startsWith(m_localeNameShort)) { res.name = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); nameLocaleSet = true; } else if (line.startsWith(QLatin1String(\"Name=\"))) { res.name = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } } else if (!descriptionLocaleSet && line.startsWith(QLatin1String(\"Comment\"))) { if (line.startsWith(m_localeDescription) || line.startsWith(m_localeDescriptionShort)) { res.description = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); descriptionLocaleSet = true; } else if (line.startsWith(QLatin1String(\"Comment=\"))) { res.description = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } } else if (line.startsWith(QLatin1String(\"Exec\"))) { if (line.contains(QLatin1String(\"%\"))) { res.exec = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } else { ok = false; break; } } else if (line.startsWith(QLatin1String(\"Type\"))) { if (line.contains(QLatin1String(\"Application\"))) { isApplication = true; } if (line.contains(QLatin1String(\"Service\"))) { isService = true; } } else if (line.startsWith(QLatin1String(\"Categories\"))) { res.categories = line.mid(line.indexOf(QLatin1String(\"=\")) + 1) .split(QStringLiteral(\";\")); } else if (line == QLatin1String(\"NoDisplay=true\")) { ok = false; break; } else if (line == QLatin1String(\"Terminal=true\")) { res.showInTerminal = true; } // ignore the other entries else if (line.startsWith(QLatin1String(\"[\"))) { break; } } file.close(); if (res.exec.isEmpty() || res.name.isEmpty() || (!isApplication && !isService)) { ok = false; } return res; } int DesktopFileParser::processDirectory(const QDir& dir) { // Note that // https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html // says files must end in .desktop or .directory // So filtering by .desktop stops us reading things like editor backups // .kdelnk is long deprecated QStringList entries = dir.entryList({ \"*.desktop\" }, QDir::NoDotAndDotDot | QDir::Files); bool ok; int length = m_appList.length(); for (const QString& file : entries) { DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok); if (ok) { m_appList.append(app); } } return m_appList.length() - length; } QVector<DesktopAppData> DesktopFileParser::getAppsByCategory( const QString& category) { QVector<DesktopAppData> res; for (const DesktopAppData& app : qAsConst(m_appList)) { if (app.categories.contains(category)) { res.append(app); } } return res; } QMap<QString, QVector<DesktopAppData>> DesktopFileParser::getAppsByCategory( const QStringList& categories) { QMap<QString, QVector<DesktopAppData>> res; for (const DesktopAppData& app : qAsConst(m_appList)) { for (const QString& category : categories) { if (app.categories.contains(category)) { res[category].append(app); } } } return res; }","title":"File desktopfileparse.cpp"},{"location":"flameshot/desktopfileparse_8cpp_source/#file-desktopfileparsecpp","text":"File List > src > utils > desktopfileparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"desktopfileparse.h\" #include <QDir> #include <QFile> #include <QLocale> #include <QString> #include <QTextStream> DesktopFileParser::DesktopFileParser() { QString locale = QLocale().name(); QString localeShort = QLocale().name().left(2); m_localeName = QStringLiteral(\"Name[%1]\").arg(locale); m_localeDescription = QStringLiteral(\"Comment[%1]\").arg(locale); m_localeNameShort = QStringLiteral(\"Name[%1]\").arg(localeShort); m_localeDescriptionShort = QStringLiteral(\"Comment[%1]\").arg(localeShort); m_defaultIcon = QIcon::fromTheme(QStringLiteral(\"application-x-executable\")); } DesktopAppData DesktopFileParser::parseDesktopFile(const QString& fileName, bool& ok) const { DesktopAppData res; ok = true; QFile file(fileName); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { ok = false; return res; } bool nameLocaleSet = false; bool descriptionLocaleSet = false; bool isApplication = false; bool isService = false; QTextStream in(&file); // enter the desktop entry definition while (!in.atEnd() && in.readLine() != QLatin1String(\"[Desktop Entry]\")) { } // start parsing while (!in.atEnd()) { QString line = in.readLine(); if (line.startsWith(QLatin1String(\"Icon\"))) { res.icon = QIcon::fromTheme( line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(), m_defaultIcon); } else if (!nameLocaleSet && line.startsWith(QLatin1String(\"Name\"))) { if (line.startsWith(m_localeName) || line.startsWith(m_localeNameShort)) { res.name = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); nameLocaleSet = true; } else if (line.startsWith(QLatin1String(\"Name=\"))) { res.name = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } } else if (!descriptionLocaleSet && line.startsWith(QLatin1String(\"Comment\"))) { if (line.startsWith(m_localeDescription) || line.startsWith(m_localeDescriptionShort)) { res.description = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); descriptionLocaleSet = true; } else if (line.startsWith(QLatin1String(\"Comment=\"))) { res.description = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } } else if (line.startsWith(QLatin1String(\"Exec\"))) { if (line.contains(QLatin1String(\"%\"))) { res.exec = line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(); } else { ok = false; break; } } else if (line.startsWith(QLatin1String(\"Type\"))) { if (line.contains(QLatin1String(\"Application\"))) { isApplication = true; } if (line.contains(QLatin1String(\"Service\"))) { isService = true; } } else if (line.startsWith(QLatin1String(\"Categories\"))) { res.categories = line.mid(line.indexOf(QLatin1String(\"=\")) + 1) .split(QStringLiteral(\";\")); } else if (line == QLatin1String(\"NoDisplay=true\")) { ok = false; break; } else if (line == QLatin1String(\"Terminal=true\")) { res.showInTerminal = true; } // ignore the other entries else if (line.startsWith(QLatin1String(\"[\"))) { break; } } file.close(); if (res.exec.isEmpty() || res.name.isEmpty() || (!isApplication && !isService)) { ok = false; } return res; } int DesktopFileParser::processDirectory(const QDir& dir) { // Note that // https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html // says files must end in .desktop or .directory // So filtering by .desktop stops us reading things like editor backups // .kdelnk is long deprecated QStringList entries = dir.entryList({ \"*.desktop\" }, QDir::NoDotAndDotDot | QDir::Files); bool ok; int length = m_appList.length(); for (const QString& file : entries) { DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok); if (ok) { m_appList.append(app); } } return m_appList.length() - length; } QVector<DesktopAppData> DesktopFileParser::getAppsByCategory( const QString& category) { QVector<DesktopAppData> res; for (const DesktopAppData& app : qAsConst(m_appList)) { if (app.categories.contains(category)) { res.append(app); } } return res; } QMap<QString, QVector<DesktopAppData>> DesktopFileParser::getAppsByCategory( const QStringList& categories) { QMap<QString, QVector<DesktopAppData>> res; for (const DesktopAppData& app : qAsConst(m_appList)) { for (const QString& category : categories) { if (app.categories.contains(category)) { res[category].append(app); } } } return res; }","title":"File desktopfileparse.cpp"},{"location":"flameshot/desktopfileparse_8h/","text":"File desktopfileparse.h # FileList > src > utils > desktopfileparse.h Go to the source code of this file. #include <QIcon> #include <QMap> #include <QStringList> Classes # Type Name struct DesktopAppData struct DesktopFileParser","title":"File desktopfileparse.h"},{"location":"flameshot/desktopfileparse_8h/#file-desktopfileparseh","text":"FileList > src > utils > desktopfileparse.h Go to the source code of this file. #include <QIcon> #include <QMap> #include <QStringList>","title":"File desktopfileparse.h"},{"location":"flameshot/desktopfileparse_8h/#classes","text":"Type Name struct DesktopAppData struct DesktopFileParser","title":"Classes"},{"location":"flameshot/desktopfileparse_8h_source/","text":"File desktopfileparse.h # File List > src > utils > desktopfileparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QIcon> #include <QMap> #include <QStringList> class QDir; class QString; class QTextStream; struct DesktopAppData { DesktopAppData() : showInTerminal() {} DesktopAppData(const QString& name, const QString& description, const QString& exec, QIcon icon) : name(name) , description(description) , exec(exec) , icon(icon) , showInTerminal(false) {} bool operator==(const DesktopAppData& other) const { return name == other.name; } QString name; QString description; QString exec; QStringList categories; QIcon icon; bool showInTerminal; }; struct DesktopFileParser { DesktopFileParser(); DesktopAppData parseDesktopFile(const QString& fileName, bool& ok) const; int processDirectory(const QDir& dir); QVector<DesktopAppData> getAppsByCategory(const QString& category); QMap<QString, QVector<DesktopAppData>> getAppsByCategory( const QStringList& categories); private: QString m_localeName; QString m_localeDescription; QString m_localeNameShort; QString m_localeDescriptionShort; QIcon m_defaultIcon; QVector<DesktopAppData> m_appList; };","title":"File desktopfileparse.h"},{"location":"flameshot/desktopfileparse_8h_source/#file-desktopfileparseh","text":"File List > src > utils > desktopfileparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QIcon> #include <QMap> #include <QStringList> class QDir; class QString; class QTextStream; struct DesktopAppData { DesktopAppData() : showInTerminal() {} DesktopAppData(const QString& name, const QString& description, const QString& exec, QIcon icon) : name(name) , description(description) , exec(exec) , icon(icon) , showInTerminal(false) {} bool operator==(const DesktopAppData& other) const { return name == other.name; } QString name; QString description; QString exec; QStringList categories; QIcon icon; bool showInTerminal; }; struct DesktopFileParser { DesktopFileParser(); DesktopAppData parseDesktopFile(const QString& fileName, bool& ok) const; int processDirectory(const QDir& dir); QVector<DesktopAppData> getAppsByCategory(const QString& category); QMap<QString, QVector<DesktopAppData>> getAppsByCategory( const QStringList& categories); private: QString m_localeName; QString m_localeDescription; QString m_localeNameShort; QString m_localeDescriptionShort; QIcon m_defaultIcon; QVector<DesktopAppData> m_appList; };","title":"File desktopfileparse.h"},{"location":"flameshot/desktopinfo_8cpp/","text":"File desktopinfo.cpp # FileList > src > utils > desktopinfo.cpp Go to the source code of this file. #include \"desktopinfo.h\" #include <QProcessEnvironment>","title":"File desktopinfo.cpp"},{"location":"flameshot/desktopinfo_8cpp/#file-desktopinfocpp","text":"FileList > src > utils > desktopinfo.cpp Go to the source code of this file. #include \"desktopinfo.h\" #include <QProcessEnvironment>","title":"File desktopinfo.cpp"},{"location":"flameshot/desktopinfo_8cpp_source/","text":"File desktopinfo.cpp # File List > src > utils > desktopinfo.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"desktopinfo.h\" #include <QProcessEnvironment> DesktopInfo::DesktopInfo() { auto e = QProcessEnvironment::systemEnvironment(); XDG_CURRENT_DESKTOP = e.value(QStringLiteral(\"XDG_CURRENT_DESKTOP\")); XDG_SESSION_TYPE = e.value(QStringLiteral(\"XDG_SESSION_TYPE\")); WAYLAND_DISPLAY = e.value(QStringLiteral(\"WAYLAND_DISPLAY\")); KDE_FULL_SESSION = e.value(QStringLiteral(\"KDE_FULL_SESSION\")); GNOME_DESKTOP_SESSION_ID = e.value(QStringLiteral(\"GNOME_DESKTOP_SESSION_ID\")); DESKTOP_SESSION = e.value(QStringLiteral(\"DESKTOP_SESSION\")); } bool DesktopInfo::waylandDetected() { return XDG_SESSION_TYPE == QLatin1String(\"wayland\") || WAYLAND_DISPLAY.contains(QLatin1String(\"wayland\"), Qt::CaseInsensitive); } DesktopInfo::WM DesktopInfo::windowManager() { DesktopInfo::WM res = DesktopInfo::OTHER; QStringList desktops = XDG_CURRENT_DESKTOP.split(QChar(':')); for (auto& desktop : desktops) { if (desktop.contains(QLatin1String(\"GNOME\"), Qt::CaseInsensitive)) { return DesktopInfo::GNOME; } if (desktop.contains(QLatin1String(\"qtile\"), Qt::CaseInsensitive)) { return DesktopInfo::QTILE; } if (desktop.contains(QLatin1String(\"sway\"), Qt::CaseInsensitive)) { return DesktopInfo::SWAY; } if (desktop.contains(QLatin1String(\"kde-plasma\"))) { return DesktopInfo::KDE; } } if (!GNOME_DESKTOP_SESSION_ID.isEmpty()) { return DesktopInfo::GNOME; } if (!KDE_FULL_SESSION.isEmpty()) { return DesktopInfo::KDE; } return res; }","title":"File desktopinfo.cpp"},{"location":"flameshot/desktopinfo_8cpp_source/#file-desktopinfocpp","text":"File List > src > utils > desktopinfo.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"desktopinfo.h\" #include <QProcessEnvironment> DesktopInfo::DesktopInfo() { auto e = QProcessEnvironment::systemEnvironment(); XDG_CURRENT_DESKTOP = e.value(QStringLiteral(\"XDG_CURRENT_DESKTOP\")); XDG_SESSION_TYPE = e.value(QStringLiteral(\"XDG_SESSION_TYPE\")); WAYLAND_DISPLAY = e.value(QStringLiteral(\"WAYLAND_DISPLAY\")); KDE_FULL_SESSION = e.value(QStringLiteral(\"KDE_FULL_SESSION\")); GNOME_DESKTOP_SESSION_ID = e.value(QStringLiteral(\"GNOME_DESKTOP_SESSION_ID\")); DESKTOP_SESSION = e.value(QStringLiteral(\"DESKTOP_SESSION\")); } bool DesktopInfo::waylandDetected() { return XDG_SESSION_TYPE == QLatin1String(\"wayland\") || WAYLAND_DISPLAY.contains(QLatin1String(\"wayland\"), Qt::CaseInsensitive); } DesktopInfo::WM DesktopInfo::windowManager() { DesktopInfo::WM res = DesktopInfo::OTHER; QStringList desktops = XDG_CURRENT_DESKTOP.split(QChar(':')); for (auto& desktop : desktops) { if (desktop.contains(QLatin1String(\"GNOME\"), Qt::CaseInsensitive)) { return DesktopInfo::GNOME; } if (desktop.contains(QLatin1String(\"qtile\"), Qt::CaseInsensitive)) { return DesktopInfo::QTILE; } if (desktop.contains(QLatin1String(\"sway\"), Qt::CaseInsensitive)) { return DesktopInfo::SWAY; } if (desktop.contains(QLatin1String(\"kde-plasma\"))) { return DesktopInfo::KDE; } } if (!GNOME_DESKTOP_SESSION_ID.isEmpty()) { return DesktopInfo::GNOME; } if (!KDE_FULL_SESSION.isEmpty()) { return DesktopInfo::KDE; } return res; }","title":"File desktopinfo.cpp"},{"location":"flameshot/desktopinfo_8h/","text":"File desktopinfo.h # FileList > src > utils > desktopinfo.h Go to the source code of this file. #include <QString> Classes # Type Name class DesktopInfo","title":"File desktopinfo.h"},{"location":"flameshot/desktopinfo_8h/#file-desktopinfoh","text":"FileList > src > utils > desktopinfo.h Go to the source code of this file. #include <QString>","title":"File desktopinfo.h"},{"location":"flameshot/desktopinfo_8h/#classes","text":"Type Name class DesktopInfo","title":"Classes"},{"location":"flameshot/desktopinfo_8h_source/","text":"File desktopinfo.h # File List > src > utils > desktopinfo.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class DesktopInfo { public: DesktopInfo(); enum WM { GNOME, KDE, OTHER, QTILE, SWAY }; bool waylandDetected(); WM windowManager(); private: QString XDG_CURRENT_DESKTOP; QString XDG_SESSION_TYPE; QString WAYLAND_DISPLAY; QString KDE_FULL_SESSION; QString GNOME_DESKTOP_SESSION_ID; QString GDMSESSION; QString DESKTOP_SESSION; };","title":"File desktopinfo.h"},{"location":"flameshot/desktopinfo_8h_source/#file-desktopinfoh","text":"File List > src > utils > desktopinfo.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class DesktopInfo { public: DesktopInfo(); enum WM { GNOME, KDE, OTHER, QTILE, SWAY }; bool waylandDetected(); WM windowManager(); private: QString XDG_CURRENT_DESKTOP; QString XDG_SESSION_TYPE; QString WAYLAND_DISPLAY; QString KDE_FULL_SESSION; QString GNOME_DESKTOP_SESSION_ID; QString GDMSESSION; QString DESKTOP_SESSION; };","title":"File desktopinfo.h"},{"location":"flameshot/filenamehandler_8cpp/","text":"File filenamehandler.cpp # FileList > src > utils > filenamehandler.cpp Go to the source code of this file. #include \"filenamehandler.h\" #include \"abstractlogger.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/strfparse.h\" #include <QDir> #include <ctime> #include <exception> #include <locale>","title":"File filenamehandler.cpp"},{"location":"flameshot/filenamehandler_8cpp/#file-filenamehandlercpp","text":"FileList > src > utils > filenamehandler.cpp Go to the source code of this file. #include \"filenamehandler.h\" #include \"abstractlogger.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/strfparse.h\" #include <QDir> #include <ctime> #include <exception> #include <locale>","title":"File filenamehandler.cpp"},{"location":"flameshot/filenamehandler_8cpp_source/","text":"File filenamehandler.cpp # File List > src > utils > filenamehandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"filenamehandler.h\" #include \"abstractlogger.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/strfparse.h\" #include <QDir> #include <ctime> #include <exception> #include <locale> FileNameHandler::FileNameHandler(QObject* parent) : QObject(parent) { auto err = AbstractLogger::error(AbstractLogger::Stderr); try { std::locale::global(std::locale()); } catch (std::exception& e) { err << \"Locales on your system are not properly configured. Falling \" \"back to defaults\"; std::locale::global(std::locale(\"en_US.UTF-8\")); } } QString FileNameHandler::parsedPattern() { return parseFilename(ConfigHandler().filenamePattern()); } QString FileNameHandler::parseFilename(const QString& name) { QString res = name; if (name.isEmpty()) { res = ConfigHandler().filenamePatternDefault(); } // remove trailing characters '%' in the pattern while (res.endsWith('%')) { res.chop(1); } res = QString::fromStdString(strfparse::format_time_string(name.toStdString())); // add the parsed pattern in a correct format for the filesystem res = res.replace(QLatin1String(\"/\"), QStringLiteral(\"\u2044\")) .replace(QLatin1String(\":\"), QLatin1String(\"-\")); return res; } QString FileNameHandler::properScreenshotPath(QString path, const QString& format) { QFileInfo info(path); QString suffix = info.suffix(); if (info.isDir()) { // path is a directory => generate filename from configured pattern path = QDir(QDir(path).absolutePath() + \"/\" + parsedPattern()).path(); } else { // path points to a file => strip it of its suffix for now path = QDir(info.dir().absolutePath() + \"/\" + info.completeBaseName()) .path(); } if (!format.isEmpty()) { // Override suffix to match format path += \".\" + format; } else if (!suffix.isEmpty()) { // Leave the suffix as it was path += \".\" + suffix; } else { path += \".png\"; } if (!QFileInfo::exists(path)) { return path; } else { return autoNumerateDuplicate(path); } } QString FileNameHandler::autoNumerateDuplicate(QString path) { // add numeration in case of repeated filename in the directory // find unused name adding _n where n is a number QFileInfo checkFile(path); QString directory = checkFile.dir().absolutePath(), filename = checkFile.completeBaseName(), suffix = checkFile.suffix(); if (!suffix.isEmpty()) { suffix = QStringLiteral(\".\") + suffix; } if (checkFile.exists()) { filename += QLatin1String(\"_\"); int i = 1; while (true) { checkFile.setFile(directory + \"/\" + filename + QString::number(i) + suffix); if (!checkFile.exists()) { filename += QString::number(i); break; } ++i; } } return checkFile.filePath(); }","title":"File filenamehandler.cpp"},{"location":"flameshot/filenamehandler_8cpp_source/#file-filenamehandlercpp","text":"File List > src > utils > filenamehandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"filenamehandler.h\" #include \"abstractlogger.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/strfparse.h\" #include <QDir> #include <ctime> #include <exception> #include <locale> FileNameHandler::FileNameHandler(QObject* parent) : QObject(parent) { auto err = AbstractLogger::error(AbstractLogger::Stderr); try { std::locale::global(std::locale()); } catch (std::exception& e) { err << \"Locales on your system are not properly configured. Falling \" \"back to defaults\"; std::locale::global(std::locale(\"en_US.UTF-8\")); } } QString FileNameHandler::parsedPattern() { return parseFilename(ConfigHandler().filenamePattern()); } QString FileNameHandler::parseFilename(const QString& name) { QString res = name; if (name.isEmpty()) { res = ConfigHandler().filenamePatternDefault(); } // remove trailing characters '%' in the pattern while (res.endsWith('%')) { res.chop(1); } res = QString::fromStdString(strfparse::format_time_string(name.toStdString())); // add the parsed pattern in a correct format for the filesystem res = res.replace(QLatin1String(\"/\"), QStringLiteral(\"\u2044\")) .replace(QLatin1String(\":\"), QLatin1String(\"-\")); return res; } QString FileNameHandler::properScreenshotPath(QString path, const QString& format) { QFileInfo info(path); QString suffix = info.suffix(); if (info.isDir()) { // path is a directory => generate filename from configured pattern path = QDir(QDir(path).absolutePath() + \"/\" + parsedPattern()).path(); } else { // path points to a file => strip it of its suffix for now path = QDir(info.dir().absolutePath() + \"/\" + info.completeBaseName()) .path(); } if (!format.isEmpty()) { // Override suffix to match format path += \".\" + format; } else if (!suffix.isEmpty()) { // Leave the suffix as it was path += \".\" + suffix; } else { path += \".png\"; } if (!QFileInfo::exists(path)) { return path; } else { return autoNumerateDuplicate(path); } } QString FileNameHandler::autoNumerateDuplicate(QString path) { // add numeration in case of repeated filename in the directory // find unused name adding _n where n is a number QFileInfo checkFile(path); QString directory = checkFile.dir().absolutePath(), filename = checkFile.completeBaseName(), suffix = checkFile.suffix(); if (!suffix.isEmpty()) { suffix = QStringLiteral(\".\") + suffix; } if (checkFile.exists()) { filename += QLatin1String(\"_\"); int i = 1; while (true) { checkFile.setFile(directory + \"/\" + filename + QString::number(i) + suffix); if (!checkFile.exists()) { filename += QString::number(i); break; } ++i; } } return checkFile.filePath(); }","title":"File filenamehandler.cpp"},{"location":"flameshot/filenamehandler_8h/","text":"File filenamehandler.h # FileList > src > utils > filenamehandler.h Go to the source code of this file. #include <QObject> Classes # Type Name class FileNameHandler","title":"File filenamehandler.h"},{"location":"flameshot/filenamehandler_8h/#file-filenamehandlerh","text":"FileList > src > utils > filenamehandler.h Go to the source code of this file. #include <QObject>","title":"File filenamehandler.h"},{"location":"flameshot/filenamehandler_8h/#classes","text":"Type Name class FileNameHandler","title":"Classes"},{"location":"flameshot/filenamehandler_8h_source/","text":"File filenamehandler.h # File List > src > utils > filenamehandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> class FileNameHandler : public QObject { Q_OBJECT public: explicit FileNameHandler(QObject* parent = nullptr); QString parsedPattern(); QString parseFilename(const QString& name); QString properScreenshotPath(QString filename, const QString& format = QString()); static const int MAX_CHARACTERS = 70; private: QString autoNumerateDuplicate(QString path); };","title":"File filenamehandler.h"},{"location":"flameshot/filenamehandler_8h_source/#file-filenamehandlerh","text":"File List > src > utils > filenamehandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> class FileNameHandler : public QObject { Q_OBJECT public: explicit FileNameHandler(QObject* parent = nullptr); QString parsedPattern(); QString parseFilename(const QString& name); QString properScreenshotPath(QString filename, const QString& format = QString()); static const int MAX_CHARACTERS = 70; private: QString autoNumerateDuplicate(QString path); };","title":"File filenamehandler.h"},{"location":"flameshot/globalvalues_8cpp/","text":"File globalvalues.cpp # FileList > src > utils > globalvalues.cpp Go to the source code of this file. #include \"globalvalues.h\" #include <QApplication> #include <QFontMetrics>","title":"File globalvalues.cpp"},{"location":"flameshot/globalvalues_8cpp/#file-globalvaluescpp","text":"FileList > src > utils > globalvalues.cpp Go to the source code of this file. #include \"globalvalues.h\" #include <QApplication> #include <QFontMetrics>","title":"File globalvalues.cpp"},{"location":"flameshot/globalvalues_8cpp_source/","text":"File globalvalues.cpp # File List > src > utils > globalvalues.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"globalvalues.h\" #include <QApplication> #include <QFontMetrics> int GlobalValues::buttonBaseSize() { return QApplication::fontMetrics().lineSpacing() * 2.2; } QString GlobalValues::versionInfo() { return QStringLiteral(\"Flameshot \" APP_VERSION \" (\" FLAMESHOT_GIT_HASH \")\" \"\\nCompiled with Qt \" QT_VERSION_STR); } QString GlobalValues::iconPath() { #if USE_MONOCHROME_ICON return QString(\":img/app/flameshot.monochrome.svg\"); #else return { \":img/app/flameshot.svg\" }; #endif } QString GlobalValues::iconPathPNG() { #if USE_MONOCHROME_ICON return QString(\":img/app/flameshot.monochrome.png\"); #else return { \":img/app/flameshot.png\" }; #endif }","title":"File globalvalues.cpp"},{"location":"flameshot/globalvalues_8cpp_source/#file-globalvaluescpp","text":"File List > src > utils > globalvalues.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"globalvalues.h\" #include <QApplication> #include <QFontMetrics> int GlobalValues::buttonBaseSize() { return QApplication::fontMetrics().lineSpacing() * 2.2; } QString GlobalValues::versionInfo() { return QStringLiteral(\"Flameshot \" APP_VERSION \" (\" FLAMESHOT_GIT_HASH \")\" \"\\nCompiled with Qt \" QT_VERSION_STR); } QString GlobalValues::iconPath() { #if USE_MONOCHROME_ICON return QString(\":img/app/flameshot.monochrome.svg\"); #else return { \":img/app/flameshot.svg\" }; #endif } QString GlobalValues::iconPathPNG() { #if USE_MONOCHROME_ICON return QString(\":img/app/flameshot.monochrome.png\"); #else return { \":img/app/flameshot.png\" }; #endif }","title":"File globalvalues.cpp"},{"location":"flameshot/globalvalues_8h/","text":"File globalvalues.h # FileList > src > utils > globalvalues.h Go to the source code of this file. Namespaces # Type Name namespace GlobalValues","title":"File globalvalues.h"},{"location":"flameshot/globalvalues_8h/#file-globalvaluesh","text":"FileList > src > utils > globalvalues.h Go to the source code of this file.","title":"File globalvalues.h"},{"location":"flameshot/globalvalues_8h/#namespaces","text":"Type Name namespace GlobalValues","title":"Namespaces"},{"location":"flameshot/globalvalues_8h_source/","text":"File globalvalues.h # File List > src > utils > globalvalues.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once class QString; namespace GlobalValues { int buttonBaseSize(); QString versionInfo(); QString iconPath(); QString iconPathPNG(); }","title":"File globalvalues.h"},{"location":"flameshot/globalvalues_8h_source/#file-globalvaluesh","text":"File List > src > utils > globalvalues.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once class QString; namespace GlobalValues { int buttonBaseSize(); QString versionInfo(); QString iconPath(); QString iconPathPNG(); }","title":"File globalvalues.h"},{"location":"flameshot/history_8cpp/","text":"File history.cpp # FileList > src > utils > history.cpp Go to the source code of this file. #include \"history.h\" #include \"src/utils/confighandler.h\" #include <QDir> #include <QFile> #include <QProcessEnvironment> #include <QStringList>","title":"File history.cpp"},{"location":"flameshot/history_8cpp/#file-historycpp","text":"FileList > src > utils > history.cpp Go to the source code of this file. #include \"history.h\" #include \"src/utils/confighandler.h\" #include <QDir> #include <QFile> #include <QProcessEnvironment> #include <QStringList>","title":"File history.cpp"},{"location":"flameshot/history_8cpp_source/","text":"File history.cpp # File List > src > utils > history.cpp Go to the documentation of this file. #include \"history.h\" #include \"src/utils/confighandler.h\" #include <QDir> #include <QFile> #include <QProcessEnvironment> #include <QStringList> History::History() { // Get cache history path ConfigHandler config; #ifdef Q_OS_WIN m_historyPath = QDir::homePath() + \"/AppData/Roaming/flameshot/history/\"; #else QString path = QProcessEnvironment::systemEnvironment().value( \"XDG_CACHE_HOME\", QDir::homePath() + \"/.cache\"); m_historyPath = path + \"/flameshot/history/\"; #endif // Check if directory for history exists and create if doesn't QDir dir = QDir(m_historyPath); if (!dir.exists()) { dir.mkpath(\".\"); } } const QString& History::path() { return m_historyPath; } void History::save(const QPixmap& pixmap, const QString& fileName) { // scale preview only in local disk QPixmap pixmapScaled = QPixmap(pixmap); if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT >= pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) { pixmapScaled = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT, Qt::SmoothTransformation); } else { pixmapScaled = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH, Qt::SmoothTransformation); } // save preview QFile file(path() + fileName); file.open(QIODevice::WriteOnly); pixmapScaled.save(&file, \"PNG\"); history(); } const QList<QString>& History::history() { QDir directory(path()); QStringList images = directory.entryList(QStringList() << \"*.png\" << \"*.PNG\", QDir::Files, QDir::Time); int cnt = 0; int max = ConfigHandler().uploadHistoryMax(); m_thumbs.clear(); foreach (QString fileName, images) { if (++cnt <= max) { m_thumbs.append(fileName); } else { QFile file(path() + fileName); file.remove(); } } return m_thumbs; } const HistoryFileName& History::unpackFileName(const QString& fileNamePacked) { int nPathIndex = fileNamePacked.lastIndexOf(\"/\"); QStringList unpackedFileName; if (nPathIndex == -1) { unpackedFileName = fileNamePacked.split(\"-\"); } else { unpackedFileName = fileNamePacked.mid(nPathIndex + 1).split(\"-\"); } switch (unpackedFileName.length()) { case 3: m_unpackedFileName.file = unpackedFileName[2]; m_unpackedFileName.token = unpackedFileName[1]; m_unpackedFileName.type = unpackedFileName[0]; break; case 2: m_unpackedFileName.file = unpackedFileName[1]; m_unpackedFileName.token = \"\"; m_unpackedFileName.type = unpackedFileName[0]; break; default: m_unpackedFileName.file = unpackedFileName[0]; m_unpackedFileName.token = \"\"; m_unpackedFileName.type = \"\"; break; } return m_unpackedFileName; } const QString& History::packFileName(const QString& storageType, const QString& deleteToken, const QString& fileName) { m_packedFileName = fileName; if (storageType.length() > 0) { if (deleteToken.length() > 0) { m_packedFileName = storageType + \"-\" + deleteToken + \"-\" + m_packedFileName; } else { m_packedFileName = storageType + \"-\" + m_packedFileName; } } return m_packedFileName; }","title":"File history.cpp"},{"location":"flameshot/history_8cpp_source/#file-historycpp","text":"File List > src > utils > history.cpp Go to the documentation of this file. #include \"history.h\" #include \"src/utils/confighandler.h\" #include <QDir> #include <QFile> #include <QProcessEnvironment> #include <QStringList> History::History() { // Get cache history path ConfigHandler config; #ifdef Q_OS_WIN m_historyPath = QDir::homePath() + \"/AppData/Roaming/flameshot/history/\"; #else QString path = QProcessEnvironment::systemEnvironment().value( \"XDG_CACHE_HOME\", QDir::homePath() + \"/.cache\"); m_historyPath = path + \"/flameshot/history/\"; #endif // Check if directory for history exists and create if doesn't QDir dir = QDir(m_historyPath); if (!dir.exists()) { dir.mkpath(\".\"); } } const QString& History::path() { return m_historyPath; } void History::save(const QPixmap& pixmap, const QString& fileName) { // scale preview only in local disk QPixmap pixmapScaled = QPixmap(pixmap); if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT >= pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) { pixmapScaled = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT, Qt::SmoothTransformation); } else { pixmapScaled = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH, Qt::SmoothTransformation); } // save preview QFile file(path() + fileName); file.open(QIODevice::WriteOnly); pixmapScaled.save(&file, \"PNG\"); history(); } const QList<QString>& History::history() { QDir directory(path()); QStringList images = directory.entryList(QStringList() << \"*.png\" << \"*.PNG\", QDir::Files, QDir::Time); int cnt = 0; int max = ConfigHandler().uploadHistoryMax(); m_thumbs.clear(); foreach (QString fileName, images) { if (++cnt <= max) { m_thumbs.append(fileName); } else { QFile file(path() + fileName); file.remove(); } } return m_thumbs; } const HistoryFileName& History::unpackFileName(const QString& fileNamePacked) { int nPathIndex = fileNamePacked.lastIndexOf(\"/\"); QStringList unpackedFileName; if (nPathIndex == -1) { unpackedFileName = fileNamePacked.split(\"-\"); } else { unpackedFileName = fileNamePacked.mid(nPathIndex + 1).split(\"-\"); } switch (unpackedFileName.length()) { case 3: m_unpackedFileName.file = unpackedFileName[2]; m_unpackedFileName.token = unpackedFileName[1]; m_unpackedFileName.type = unpackedFileName[0]; break; case 2: m_unpackedFileName.file = unpackedFileName[1]; m_unpackedFileName.token = \"\"; m_unpackedFileName.type = unpackedFileName[0]; break; default: m_unpackedFileName.file = unpackedFileName[0]; m_unpackedFileName.token = \"\"; m_unpackedFileName.type = \"\"; break; } return m_unpackedFileName; } const QString& History::packFileName(const QString& storageType, const QString& deleteToken, const QString& fileName) { m_packedFileName = fileName; if (storageType.length() > 0) { if (deleteToken.length() > 0) { m_packedFileName = storageType + \"-\" + deleteToken + \"-\" + m_packedFileName; } else { m_packedFileName = storageType + \"-\" + m_packedFileName; } } return m_packedFileName; }","title":"File history.cpp"},{"location":"flameshot/history_8h/","text":"File history.h # FileList > src > utils > history.h Go to the source code of this file. #include <QList> #include <QPixmap> #include <QString> Classes # Type Name class History struct HistoryFileName Macros # Type Name define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100 define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250 Macro Definition Documentation # define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT # #define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100 define HISTORYPIXMAP_MAX_PREVIEW_WIDTH # #define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250","title":"File history.h"},{"location":"flameshot/history_8h/#file-historyh","text":"FileList > src > utils > history.h Go to the source code of this file. #include <QList> #include <QPixmap> #include <QString>","title":"File history.h"},{"location":"flameshot/history_8h/#classes","text":"Type Name class History struct HistoryFileName","title":"Classes"},{"location":"flameshot/history_8h/#macros","text":"Type Name define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100 define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250","title":"Macros"},{"location":"flameshot/history_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/history_8h/#define-historypixmap_max_preview_height","text":"#define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100","title":"define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT"},{"location":"flameshot/history_8h/#define-historypixmap_max_preview_width","text":"#define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250","title":"define HISTORYPIXMAP_MAX_PREVIEW_WIDTH"},{"location":"flameshot/history_8h_source/","text":"File history.h # File List > src > utils > history.h Go to the documentation of this file. #ifndef HISTORY_H #define HISTORY_H #define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250 #define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100 #include <QList> #include <QPixmap> #include <QString> struct HistoryFileName { QString file; QString token; QString type; }; class History { public: History(); void save(const QPixmap&, const QString&); const QList<QString>& history(); const QString& path(); const HistoryFileName& unpackFileName(const QString&); const QString& packFileName(const QString&, const QString&, const QString&); private: QString m_historyPath; QList<QString> m_thumbs; // temporary variables QString m_packedFileName; HistoryFileName m_unpackedFileName; }; #endif // HISTORY_H","title":"File history.h"},{"location":"flameshot/history_8h_source/#file-historyh","text":"File List > src > utils > history.h Go to the documentation of this file. #ifndef HISTORY_H #define HISTORY_H #define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250 #define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100 #include <QList> #include <QPixmap> #include <QString> struct HistoryFileName { QString file; QString token; QString type; }; class History { public: History(); void save(const QPixmap&, const QString&); const QList<QString>& history(); const QString& path(); const HistoryFileName& unpackFileName(const QString&); const QString& packFileName(const QString&, const QString&, const QString&); private: QString m_historyPath; QList<QString> m_thumbs; // temporary variables QString m_packedFileName; HistoryFileName m_unpackedFileName; }; #endif // HISTORY_H","title":"File history.h"},{"location":"flameshot/pathinfo_8cpp/","text":"File pathinfo.cpp # FileList > src > utils > pathinfo.cpp Go to the source code of this file. #include \"pathinfo.h\" #include <QApplication> #include <QDir> #include <QFileInfo>","title":"File pathinfo.cpp"},{"location":"flameshot/pathinfo_8cpp/#file-pathinfocpp","text":"FileList > src > utils > pathinfo.cpp Go to the source code of this file. #include \"pathinfo.h\" #include <QApplication> #include <QDir> #include <QFileInfo>","title":"File pathinfo.cpp"},{"location":"flameshot/pathinfo_8cpp_source/","text":"File pathinfo.cpp # File List > src > utils > pathinfo.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pathinfo.h\" #include <QApplication> #include <QDir> #include <QFileInfo> const QString PathInfo::whiteIconPath() { return QStringLiteral(\":/img/material/white/\"); } const QString PathInfo::blackIconPath() { return QStringLiteral(\":/img/material/black/\"); } QStringList PathInfo::translationsPaths() { QString binaryPath = QFileInfo(qApp->applicationDirPath()).absoluteFilePath(); QString trPath = QDir::toNativeSeparators(binaryPath + \"/translations\"); #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) return QStringList() << QStringLiteral(APP_PREFIX) + \"/share/flameshot/translations\" << trPath << QStringLiteral(\"/usr/share/flameshot/translations\") << QStringLiteral(\"/usr/local/share/flameshot/translations\"); #elif defined(Q_OS_WIN) return QStringList() << trPath; #endif }","title":"File pathinfo.cpp"},{"location":"flameshot/pathinfo_8cpp_source/#file-pathinfocpp","text":"File List > src > utils > pathinfo.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"pathinfo.h\" #include <QApplication> #include <QDir> #include <QFileInfo> const QString PathInfo::whiteIconPath() { return QStringLiteral(\":/img/material/white/\"); } const QString PathInfo::blackIconPath() { return QStringLiteral(\":/img/material/black/\"); } QStringList PathInfo::translationsPaths() { QString binaryPath = QFileInfo(qApp->applicationDirPath()).absoluteFilePath(); QString trPath = QDir::toNativeSeparators(binaryPath + \"/translations\"); #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) return QStringList() << QStringLiteral(APP_PREFIX) + \"/share/flameshot/translations\" << trPath << QStringLiteral(\"/usr/share/flameshot/translations\") << QStringLiteral(\"/usr/local/share/flameshot/translations\"); #elif defined(Q_OS_WIN) return QStringList() << trPath; #endif }","title":"File pathinfo.cpp"},{"location":"flameshot/pathinfo_8h/","text":"File pathinfo.h # FileList > src > utils > pathinfo.h Go to the source code of this file. #include <QStringList> Namespaces # Type Name namespace PathInfo","title":"File pathinfo.h"},{"location":"flameshot/pathinfo_8h/#file-pathinfoh","text":"FileList > src > utils > pathinfo.h Go to the source code of this file. #include <QStringList>","title":"File pathinfo.h"},{"location":"flameshot/pathinfo_8h/#namespaces","text":"Type Name namespace PathInfo","title":"Namespaces"},{"location":"flameshot/pathinfo_8h_source/","text":"File pathinfo.h # File List > src > utils > pathinfo.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QStringList> namespace PathInfo { // namespace const QString whiteIconPath(); const QString blackIconPath(); QStringList translationsPaths(); } // namespace","title":"File pathinfo.h"},{"location":"flameshot/pathinfo_8h_source/#file-pathinfoh","text":"File List > src > utils > pathinfo.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QStringList> namespace PathInfo { // namespace const QString whiteIconPath(); const QString blackIconPath(); QStringList translationsPaths(); } // namespace","title":"File pathinfo.h"},{"location":"flameshot/request_8cpp/","text":"File request.cpp # FileList > src > utils > request.cpp Go to the source code of this file. #include \"request.h\"","title":"File request.cpp"},{"location":"flameshot/request_8cpp/#file-requestcpp","text":"FileList > src > utils > request.cpp Go to the source code of this file. #include \"request.h\"","title":"File request.cpp"},{"location":"flameshot/request_8cpp_source/","text":"File request.cpp # File List > src > utils > request.cpp Go to the documentation of this file. // // Created by nullobsi on 2021/02/01. // /* * Implementation of interface class OrgFreedesktopPortalRequestInterface */ #include \"request.h\" OrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface( const QString& service, const QString& path, const QDBusConnection& connection, QObject* parent) : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent) {} OrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface() = default;","title":"File request.cpp"},{"location":"flameshot/request_8cpp_source/#file-requestcpp","text":"File List > src > utils > request.cpp Go to the documentation of this file. // // Created by nullobsi on 2021/02/01. // /* * Implementation of interface class OrgFreedesktopPortalRequestInterface */ #include \"request.h\" OrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface( const QString& service, const QString& path, const QDBusConnection& connection, QObject* parent) : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent) {} OrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface() = default;","title":"File request.cpp"},{"location":"flameshot/request_8h/","text":"File request.h # FileList > src > utils > request.h Go to the source code of this file. #include <QtCore/QByteArray> #include <QtCore/QList> #include <QtCore/QMap> #include <QtCore/QObject> #include <QtCore/QString> #include <QtCore/QStringList> #include <QtCore/QVariant> #include <QtDBus/QtDBus> Namespaces # Type Name namespace org namespace freedesktop namespace portal Classes # Type Name class OrgFreedesktopPortalRequestInterface","title":"File request.h"},{"location":"flameshot/request_8h/#file-requesth","text":"FileList > src > utils > request.h Go to the source code of this file. #include <QtCore/QByteArray> #include <QtCore/QList> #include <QtCore/QMap> #include <QtCore/QObject> #include <QtCore/QString> #include <QtCore/QStringList> #include <QtCore/QVariant> #include <QtDBus/QtDBus>","title":"File request.h"},{"location":"flameshot/request_8h/#namespaces","text":"Type Name namespace org namespace freedesktop namespace portal","title":"Namespaces"},{"location":"flameshot/request_8h/#classes","text":"Type Name class OrgFreedesktopPortalRequestInterface","title":"Classes"},{"location":"flameshot/request_8h_source/","text":"File request.h # File List > src > utils > request.h Go to the documentation of this file. /* * This file was generated by qdbusxml2cpp version 0.8 * Command line was: qdbusxml2cpp -p response.cpp resp.xml * * qdbusxml2cpp is Copyright (C) 2020 The Qt Company Ltd. * * This is an auto-generated file. * Do not edit! All changes made to it will be lost. */ #ifndef RESPONSE_CPP #define RESPONSE_CPP #include <QtCore/QByteArray> #include <QtCore/QList> #include <QtCore/QMap> #include <QtCore/QObject> #include <QtCore/QString> #include <QtCore/QStringList> #include <QtCore/QVariant> #include <QtDBus/QtDBus> /* * Proxy class for interface org.freedesktop.portal.Request */ class OrgFreedesktopPortalRequestInterface : public QDBusAbstractInterface { Q_OBJECT public: static inline const char* staticInterfaceName() { return \"org.freedesktop.portal.Request\"; } public: OrgFreedesktopPortalRequestInterface(const QString& service, const QString& path, const QDBusConnection& connection, QObject* parent = nullptr); ~OrgFreedesktopPortalRequestInterface(); public Q_SLOTS: // METHODS inline QDBusPendingReply<> Close() { QList<QVariant> argumentList; return asyncCallWithArgumentList(QStringLiteral(\"Close\"), argumentList); } Q_SIGNALS: // SIGNALS void Response(uint response, QVariantMap results); }; namespace org { namespace freedesktop { namespace portal { typedef ::OrgFreedesktopPortalRequestInterface Request; } } } #endif","title":"File request.h"},{"location":"flameshot/request_8h_source/#file-requesth","text":"File List > src > utils > request.h Go to the documentation of this file. /* * This file was generated by qdbusxml2cpp version 0.8 * Command line was: qdbusxml2cpp -p response.cpp resp.xml * * qdbusxml2cpp is Copyright (C) 2020 The Qt Company Ltd. * * This is an auto-generated file. * Do not edit! All changes made to it will be lost. */ #ifndef RESPONSE_CPP #define RESPONSE_CPP #include <QtCore/QByteArray> #include <QtCore/QList> #include <QtCore/QMap> #include <QtCore/QObject> #include <QtCore/QString> #include <QtCore/QStringList> #include <QtCore/QVariant> #include <QtDBus/QtDBus> /* * Proxy class for interface org.freedesktop.portal.Request */ class OrgFreedesktopPortalRequestInterface : public QDBusAbstractInterface { Q_OBJECT public: static inline const char* staticInterfaceName() { return \"org.freedesktop.portal.Request\"; } public: OrgFreedesktopPortalRequestInterface(const QString& service, const QString& path, const QDBusConnection& connection, QObject* parent = nullptr); ~OrgFreedesktopPortalRequestInterface(); public Q_SLOTS: // METHODS inline QDBusPendingReply<> Close() { QList<QVariant> argumentList; return asyncCallWithArgumentList(QStringLiteral(\"Close\"), argumentList); } Q_SIGNALS: // SIGNALS void Response(uint response, QVariantMap results); }; namespace org { namespace freedesktop { namespace portal { typedef ::OrgFreedesktopPortalRequestInterface Request; } } } #endif","title":"File request.h"},{"location":"flameshot/screengrabber_8cpp/","text":"File screengrabber.cpp # FileList > src > utils > screengrabber.cpp Go to the source code of this file. #include \"screengrabber.h\" #include \"abstractlogger.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/systemnotification.h\" #include <QApplication> #include <QDesktopWidget> #include <QGuiApplication> #include <QPixmap> #include <QScreen>","title":"File screengrabber.cpp"},{"location":"flameshot/screengrabber_8cpp/#file-screengrabbercpp","text":"FileList > src > utils > screengrabber.cpp Go to the source code of this file. #include \"screengrabber.h\" #include \"abstractlogger.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/systemnotification.h\" #include <QApplication> #include <QDesktopWidget> #include <QGuiApplication> #include <QPixmap> #include <QScreen>","title":"File screengrabber.cpp"},{"location":"flameshot/screengrabber_8cpp_source/","text":"File screengrabber.cpp # File List > src > utils > screengrabber.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"screengrabber.h\" #include \"abstractlogger.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/systemnotification.h\" #include <QApplication> #include <QDesktopWidget> #include <QGuiApplication> #include <QPixmap> #include <QScreen> #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) #include \"request.h\" #include <QDBusInterface> #include <QDBusReply> #include <QDir> #include <QUrl> #include <QUuid> #endif ScreenGrabber::ScreenGrabber(QObject* parent) : QObject(parent) {} void ScreenGrabber::freeDesktopPortal(bool& ok, QPixmap& res) { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QDBusInterface screenshotInterface( QStringLiteral(\"org.freedesktop.portal.Desktop\"), QStringLiteral(\"/org/freedesktop/portal/desktop\"), QStringLiteral(\"org.freedesktop.portal.Screenshot\")); // unique token QString token = QUuid::createUuid().toString().remove('-').remove('{').remove('}'); // premake interface auto* request = new OrgFreedesktopPortalRequestInterface( QStringLiteral(\"org.freedesktop.portal.Desktop\"), \"/org/freedesktop/portal/desktop/request/\" + QDBusConnection::sessionBus().baseService().remove(':').replace('.', '_') + \"/\" + token, QDBusConnection::sessionBus(), this); QEventLoop loop; const auto gotSignal = [&res, &loop](uint status, const QVariantMap& map) { if (status == 0) { // Parse this as URI to handle unicode properly QUrl uri = map.value(\"uri\").toString(); QString uriString = uri.toLocalFile(); res = QPixmap(uriString); res.setDevicePixelRatio(qApp->devicePixelRatio()); QFile imgFile(uriString); imgFile.remove(); } loop.quit(); }; // prevent racy situations and listen before calling screenshot QMetaObject::Connection conn = QObject::connect( request, &org::freedesktop::portal::Request::Response, gotSignal); screenshotInterface.call( QStringLiteral(\"Screenshot\"), \"\", QMap<QString, QVariant>({ { \"handle_token\", QVariant(token) }, { \"interactive\", QVariant(false) } })); loop.exec(); QObject::disconnect(conn); request->Close().waitForFinished(); request->deleteLater(); if (res.isNull()) { ok = false; } #endif } QPixmap ScreenGrabber::grabEntireDesktop(bool& ok) { ok = true; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); QPixmap screenPixmap( currentScreen->grabWindow(QApplication::desktop()->winId(), currentScreen->geometry().x(), currentScreen->geometry().y(), currentScreen->geometry().width(), currentScreen->geometry().height())); screenPixmap.setDevicePixelRatio(currentScreen->devicePixelRatio()); return screenPixmap; #elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (m_info.waylandDetected()) { QPixmap res; // handle screenshot based on DE switch (m_info.windowManager()) { case DesktopInfo::GNOME: case DesktopInfo::KDE: case DesktopInfo::QTILE: case DesktopInfo::SWAY: { freeDesktopPortal(ok, res); break; } default: ok = false; AbstractLogger::error() << tr(\"Unable to detect desktop environment (GNOME? KDE? \" \"Qile? Sway? ...)\"); AbstractLogger::error() << tr(\"Hint: try setting the XDG_CURRENT_DESKTOP environment \" \"variable.\"); break; } if (!ok) { AbstractLogger::error() << tr(\"Unable to capture screen\"); } return res; } #endif #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) || defined(Q_OS_WIN) QRect geometry = desktopGeometry(); QPixmap p(QApplication::primaryScreen()->grabWindow( QApplication::desktop()->winId(), geometry.x(), geometry.y(), geometry.width(), geometry.height())); auto screenNumber = QApplication::desktop()->screenNumber(); QScreen* screen = QApplication::screens()[screenNumber]; p.setDevicePixelRatio(screen->devicePixelRatio()); return p; #endif } QRect ScreenGrabber::screenGeometry(QScreen* screen) { QPixmap p; QRect geometry; if (m_info.waylandDetected()) { QPoint topLeft(0, 0); #ifdef Q_OS_WIN for (QScreen* const screen : QGuiApplication::screens()) { QPoint topLeftScreen = screen->geometry().topLeft(); if (topLeft.x() > topLeftScreen.x() || topLeft.y() > topLeftScreen.y()) { topLeft = topLeftScreen; } } #endif geometry = screen->geometry(); geometry.moveTo(geometry.topLeft() - topLeft); } else { QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); geometry = currentScreen->geometry(); } return geometry; } QPixmap ScreenGrabber::grabScreen(QScreen* screen, bool& ok) { QPixmap p; QRect geometry = screenGeometry(screen); if (m_info.waylandDetected()) { p = grabEntireDesktop(ok); if (ok) { return p.copy(geometry); } } else { ok = true; return screen->grabWindow( 0, geometry.x(), geometry.y(), geometry.width(), geometry.height()); } return p; } QRect ScreenGrabber::desktopGeometry() { QRect geometry; for (QScreen* const screen : QGuiApplication::screens()) { QRect scrRect = screen->geometry(); scrRect.moveTo(scrRect.x() / screen->devicePixelRatio(), scrRect.y() / screen->devicePixelRatio()); geometry = geometry.united(scrRect); } return geometry; }","title":"File screengrabber.cpp"},{"location":"flameshot/screengrabber_8cpp_source/#file-screengrabbercpp","text":"File List > src > utils > screengrabber.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"screengrabber.h\" #include \"abstractlogger.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/systemnotification.h\" #include <QApplication> #include <QDesktopWidget> #include <QGuiApplication> #include <QPixmap> #include <QScreen> #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) #include \"request.h\" #include <QDBusInterface> #include <QDBusReply> #include <QDir> #include <QUrl> #include <QUuid> #endif ScreenGrabber::ScreenGrabber(QObject* parent) : QObject(parent) {} void ScreenGrabber::freeDesktopPortal(bool& ok, QPixmap& res) { #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) QDBusInterface screenshotInterface( QStringLiteral(\"org.freedesktop.portal.Desktop\"), QStringLiteral(\"/org/freedesktop/portal/desktop\"), QStringLiteral(\"org.freedesktop.portal.Screenshot\")); // unique token QString token = QUuid::createUuid().toString().remove('-').remove('{').remove('}'); // premake interface auto* request = new OrgFreedesktopPortalRequestInterface( QStringLiteral(\"org.freedesktop.portal.Desktop\"), \"/org/freedesktop/portal/desktop/request/\" + QDBusConnection::sessionBus().baseService().remove(':').replace('.', '_') + \"/\" + token, QDBusConnection::sessionBus(), this); QEventLoop loop; const auto gotSignal = [&res, &loop](uint status, const QVariantMap& map) { if (status == 0) { // Parse this as URI to handle unicode properly QUrl uri = map.value(\"uri\").toString(); QString uriString = uri.toLocalFile(); res = QPixmap(uriString); res.setDevicePixelRatio(qApp->devicePixelRatio()); QFile imgFile(uriString); imgFile.remove(); } loop.quit(); }; // prevent racy situations and listen before calling screenshot QMetaObject::Connection conn = QObject::connect( request, &org::freedesktop::portal::Request::Response, gotSignal); screenshotInterface.call( QStringLiteral(\"Screenshot\"), \"\", QMap<QString, QVariant>({ { \"handle_token\", QVariant(token) }, { \"interactive\", QVariant(false) } })); loop.exec(); QObject::disconnect(conn); request->Close().waitForFinished(); request->deleteLater(); if (res.isNull()) { ok = false; } #endif } QPixmap ScreenGrabber::grabEntireDesktop(bool& ok) { ok = true; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); QPixmap screenPixmap( currentScreen->grabWindow(QApplication::desktop()->winId(), currentScreen->geometry().x(), currentScreen->geometry().y(), currentScreen->geometry().width(), currentScreen->geometry().height())); screenPixmap.setDevicePixelRatio(currentScreen->devicePixelRatio()); return screenPixmap; #elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (m_info.waylandDetected()) { QPixmap res; // handle screenshot based on DE switch (m_info.windowManager()) { case DesktopInfo::GNOME: case DesktopInfo::KDE: case DesktopInfo::QTILE: case DesktopInfo::SWAY: { freeDesktopPortal(ok, res); break; } default: ok = false; AbstractLogger::error() << tr(\"Unable to detect desktop environment (GNOME? KDE? \" \"Qile? Sway? ...)\"); AbstractLogger::error() << tr(\"Hint: try setting the XDG_CURRENT_DESKTOP environment \" \"variable.\"); break; } if (!ok) { AbstractLogger::error() << tr(\"Unable to capture screen\"); } return res; } #endif #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) || defined(Q_OS_WIN) QRect geometry = desktopGeometry(); QPixmap p(QApplication::primaryScreen()->grabWindow( QApplication::desktop()->winId(), geometry.x(), geometry.y(), geometry.width(), geometry.height())); auto screenNumber = QApplication::desktop()->screenNumber(); QScreen* screen = QApplication::screens()[screenNumber]; p.setDevicePixelRatio(screen->devicePixelRatio()); return p; #endif } QRect ScreenGrabber::screenGeometry(QScreen* screen) { QPixmap p; QRect geometry; if (m_info.waylandDetected()) { QPoint topLeft(0, 0); #ifdef Q_OS_WIN for (QScreen* const screen : QGuiApplication::screens()) { QPoint topLeftScreen = screen->geometry().topLeft(); if (topLeft.x() > topLeftScreen.x() || topLeft.y() > topLeftScreen.y()) { topLeft = topLeftScreen; } } #endif geometry = screen->geometry(); geometry.moveTo(geometry.topLeft() - topLeft); } else { QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); geometry = currentScreen->geometry(); } return geometry; } QPixmap ScreenGrabber::grabScreen(QScreen* screen, bool& ok) { QPixmap p; QRect geometry = screenGeometry(screen); if (m_info.waylandDetected()) { p = grabEntireDesktop(ok); if (ok) { return p.copy(geometry); } } else { ok = true; return screen->grabWindow( 0, geometry.x(), geometry.y(), geometry.width(), geometry.height()); } return p; } QRect ScreenGrabber::desktopGeometry() { QRect geometry; for (QScreen* const screen : QGuiApplication::screens()) { QRect scrRect = screen->geometry(); scrRect.moveTo(scrRect.x() / screen->devicePixelRatio(), scrRect.y() / screen->devicePixelRatio()); geometry = geometry.united(scrRect); } return geometry; }","title":"File screengrabber.cpp"},{"location":"flameshot/screengrabber_8h/","text":"File screengrabber.h # FileList > src > utils > screengrabber.h Go to the source code of this file. #include \"src/utils/desktopinfo.h\" #include <QObject> #include <QScreen> Classes # Type Name class ScreenGrabber","title":"File screengrabber.h"},{"location":"flameshot/screengrabber_8h/#file-screengrabberh","text":"FileList > src > utils > screengrabber.h Go to the source code of this file. #include \"src/utils/desktopinfo.h\" #include <QObject> #include <QScreen>","title":"File screengrabber.h"},{"location":"flameshot/screengrabber_8h/#classes","text":"Type Name class ScreenGrabber","title":"Classes"},{"location":"flameshot/screengrabber_8h_source/","text":"File screengrabber.h # File List > src > utils > screengrabber.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/utils/desktopinfo.h\" #include <QObject> #include <QScreen> class ScreenGrabber : public QObject { Q_OBJECT public: explicit ScreenGrabber(QObject* parent = nullptr); QPixmap grabEntireDesktop(bool& ok); QRect screenGeometry(QScreen* screen); QPixmap grabScreen(QScreen* screenNumber, bool& ok); void freeDesktopPortal(bool& ok, QPixmap& res); QRect desktopGeometry(); private: DesktopInfo m_info; };","title":"File screengrabber.h"},{"location":"flameshot/screengrabber_8h_source/#file-screengrabberh","text":"File List > src > utils > screengrabber.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/utils/desktopinfo.h\" #include <QObject> #include <QScreen> class ScreenGrabber : public QObject { Q_OBJECT public: explicit ScreenGrabber(QObject* parent = nullptr); QPixmap grabEntireDesktop(bool& ok); QRect screenGeometry(QScreen* screen); QPixmap grabScreen(QScreen* screenNumber, bool& ok); void freeDesktopPortal(bool& ok, QPixmap& res); QRect desktopGeometry(); private: DesktopInfo m_info; };","title":"File screengrabber.h"},{"location":"flameshot/screenshotsaver_8cpp/","text":"File screenshotsaver.cpp # FileList > src > utils > screenshotsaver.cpp Go to the source code of this file. #include \"screenshotsaver.h\" #include \"abstractlogger.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"utils/desktopinfo.h\" #include <QApplication> #include <QBuffer> #include <QClipboard> #include <QFileDialog> #include <QMessageBox> #include <QMimeData> #include <QStandardPaths> #include <qimagewriter.h> #include <qmimedatabase.h> Public Functions # Type Name QString ShowSaveFileDialog (const QString & title, const QString & directory) void saveToClipboard (const QPixmap & capture) void saveToClipboardMime (const QPixmap & capture, const QString & imageType) bool saveToFilesystem (const QPixmap & capture, const QString & path, const QString & messagePrefix) bool saveToFilesystemGUI (const QPixmap & capture) Public Functions Documentation # function ShowSaveFileDialog # QString ShowSaveFileDialog ( const QString & title, const QString & directory ) function saveToClipboard # void saveToClipboard ( const QPixmap & capture ) function saveToClipboardMime # void saveToClipboardMime ( const QPixmap & capture, const QString & imageType ) function saveToFilesystem # bool saveToFilesystem ( const QPixmap & capture, const QString & path, const QString & messagePrefix ) function saveToFilesystemGUI # bool saveToFilesystemGUI ( const QPixmap & capture )","title":"File screenshotsaver.cpp"},{"location":"flameshot/screenshotsaver_8cpp/#file-screenshotsavercpp","text":"FileList > src > utils > screenshotsaver.cpp Go to the source code of this file. #include \"screenshotsaver.h\" #include \"abstractlogger.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"utils/desktopinfo.h\" #include <QApplication> #include <QBuffer> #include <QClipboard> #include <QFileDialog> #include <QMessageBox> #include <QMimeData> #include <QStandardPaths> #include <qimagewriter.h> #include <qmimedatabase.h>","title":"File screenshotsaver.cpp"},{"location":"flameshot/screenshotsaver_8cpp/#public-functions","text":"Type Name QString ShowSaveFileDialog (const QString & title, const QString & directory) void saveToClipboard (const QPixmap & capture) void saveToClipboardMime (const QPixmap & capture, const QString & imageType) bool saveToFilesystem (const QPixmap & capture, const QString & path, const QString & messagePrefix) bool saveToFilesystemGUI (const QPixmap & capture)","title":"Public Functions"},{"location":"flameshot/screenshotsaver_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/screenshotsaver_8cpp/#function-showsavefiledialog","text":"QString ShowSaveFileDialog ( const QString & title, const QString & directory )","title":"function ShowSaveFileDialog"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetoclipboard","text":"void saveToClipboard ( const QPixmap & capture )","title":"function saveToClipboard"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetoclipboardmime","text":"void saveToClipboardMime ( const QPixmap & capture, const QString & imageType )","title":"function saveToClipboardMime"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetofilesystem","text":"bool saveToFilesystem ( const QPixmap & capture, const QString & path, const QString & messagePrefix )","title":"function saveToFilesystem"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetofilesystemgui","text":"bool saveToFilesystemGUI ( const QPixmap & capture )","title":"function saveToFilesystemGUI"},{"location":"flameshot/screenshotsaver_8cpp_source/","text":"File screenshotsaver.cpp # File List > src > utils > screenshotsaver.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"screenshotsaver.h\" #include \"abstractlogger.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"utils/desktopinfo.h\" #if USE_WAYLAND_CLIPBOARD #include <KSystemClipboard> #endif #include <QApplication> #include <QBuffer> #include <QClipboard> #include <QFileDialog> #include <QMessageBox> #include <QMimeData> #include <QStandardPaths> #include <qimagewriter.h> #include <qmimedatabase.h> #if defined(Q_OS_MACOS) #include \"src/widgets/capture/capturewidget.h\" #endif bool saveToFilesystem(const QPixmap& capture, const QString& path, const QString& messagePrefix) { QString completePath = FileNameHandler().properScreenshotPath( path, ConfigHandler().saveAsFileExtension()); QFile file{ completePath }; file.open(QIODevice::WriteOnly); bool okay = capture.save(&file); QString saveMessage = messagePrefix; QString notificationPath = completePath; if (!saveMessage.isEmpty()) { saveMessage += \" \"; } if (okay) { saveMessage += QObject::tr(\"Capture saved as \") + completePath; AbstractLogger::info().attachNotificationPath(notificationPath) << saveMessage; } else { saveMessage += QObject::tr(\"Error trying to save as \") + completePath; if (file.error() != QFile::NoError) { saveMessage += \": \" + file.errorString(); } notificationPath = \"\"; AbstractLogger::error().attachNotificationPath(notificationPath) << saveMessage; } return okay; } QString ShowSaveFileDialog(const QString& title, const QString& directory) { QFileDialog dialog(nullptr, title, directory); dialog.setAcceptMode(QFileDialog::AcceptSave); // Build string list of supported image formats QStringList mimeTypeList; foreach (auto mimeType, QImageWriter::supportedMimeTypes()) { // HEIF is meant for videos and it causes a glitch on MacOS // because the native dialog lumps together heic and heif if (mimeType != \"image/heif\") { mimeTypeList.append(mimeType); } } dialog.setMimeTypeFilters(mimeTypeList); QString suffix = ConfigHandler().saveAsFileExtension(); if (suffix.isEmpty()) { suffix = \"png\"; } QString defaultMimeType = QMimeDatabase().mimeTypeForFile(\"image.\" + suffix).name(); dialog.selectMimeTypeFilter(defaultMimeType); dialog.setDefaultSuffix(suffix); if (dialog.exec() == QDialog::Accepted) { return dialog.selectedFiles().constFirst(); } else { return {}; } } void saveToClipboardMime(const QPixmap& capture, const QString& imageType) { QByteArray array; QBuffer buffer{ &array }; QImageWriter imageWriter{ &buffer, imageType.toUpper().toUtf8() }; imageWriter.write(capture.toImage()); QPixmap formattedPixmap; bool isLoaded = formattedPixmap.loadFromData(reinterpret_cast<uchar*>(array.data()), array.size(), imageType.toUpper().toUtf8()); if (isLoaded) { auto* mimeData = new QMimeData(); #ifdef USE_WAYLAND_CLIPBOARD mimeData->setImageData(formattedPixmap.toImage()); mimeData->setData(QStringLiteral(\"x-kde-force-image-copy\"), QByteArray()); KSystemClipboard::instance()->setMimeData(mimeData, QClipboard::Clipboard); #else mimeData->setData(\"image/\" + imageType, array); QApplication::clipboard()->setMimeData(mimeData); #endif } else { AbstractLogger::error() << QObject::tr(\"Error while saving to clipboard\"); } } // If data is saved to the clipboard before the notification is sent via // dbus, the application freezes. void saveToClipboard(const QPixmap& capture) { // If we are able to properly save the file, save the file and copy to // clipboard. if ((ConfigHandler().saveAfterCopy()) && (!ConfigHandler().savePath().isEmpty())) { saveToFilesystem(capture, ConfigHandler().savePath(), QObject::tr(\"Capture saved to clipboard.\")); } else { AbstractLogger() << QObject::tr(\"Capture saved to clipboard.\"); } if (ConfigHandler().useJpgForClipboard()) { // FIXME - it doesn't work on MacOS saveToClipboardMime(capture, \"jpeg\"); } else { // Need to send message before copying to clipboard #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (DesktopInfo().waylandDetected()) { saveToClipboardMime(capture, \"png\"); } else { QApplication::clipboard()->setPixmap(capture); } #else QApplication::clipboard()->setPixmap(capture); #endif } } bool saveToFilesystemGUI(const QPixmap& capture) { bool okay = false; ConfigHandler config; QString defaultSavePath = ConfigHandler().savePath(); if (defaultSavePath.isEmpty() || !QDir(defaultSavePath).exists() || !QFileInfo(defaultSavePath).isWritable()) { defaultSavePath = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); } QString savePath = FileNameHandler().properScreenshotPath( defaultSavePath, ConfigHandler().saveAsFileExtension()); #if defined(Q_OS_MACOS) for (QWidget* widget : qApp->topLevelWidgets()) { QString className(widget->metaObject()->className()); if (0 == className.compare(CaptureWidget::staticMetaObject.className())) { widget->showNormal(); widget->hide(); break; } } #endif if (!config.savePathFixed()) { savePath = ShowSaveFileDialog(QObject::tr(\"Save screenshot\"), savePath); } if (savePath == \"\") { return okay; } QFile file{ savePath }; file.open(QIODevice::WriteOnly); okay = capture.save(&file); if (okay) { QString pathNoFile = savePath.left(savePath.lastIndexOf(QLatin1String(\"/\"))); ConfigHandler().setSavePath(pathNoFile); QString msg = QObject::tr(\"Capture saved as \") + savePath; AbstractLogger().attachNotificationPath(savePath) << msg; if (config.copyPathAfterSave()) { FlameshotDaemon::copyToClipboard( savePath, QObject::tr(\"Path copied to clipboard as \") + savePath); } } else { QString msg = QObject::tr(\"Error trying to save as \") + savePath; if (file.error() != QFile::NoError) { msg += \": \" + file.errorString(); } QMessageBox saveErrBox( QMessageBox::Warning, QObject::tr(\"Save Error\"), msg); saveErrBox.setWindowIcon(QIcon(GlobalValues::iconPath())); saveErrBox.exec(); } return okay; }","title":"File screenshotsaver.cpp"},{"location":"flameshot/screenshotsaver_8cpp_source/#file-screenshotsavercpp","text":"File List > src > utils > screenshotsaver.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"screenshotsaver.h\" #include \"abstractlogger.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/filenamehandler.h\" #include \"src/utils/globalvalues.h\" #include \"utils/desktopinfo.h\" #if USE_WAYLAND_CLIPBOARD #include <KSystemClipboard> #endif #include <QApplication> #include <QBuffer> #include <QClipboard> #include <QFileDialog> #include <QMessageBox> #include <QMimeData> #include <QStandardPaths> #include <qimagewriter.h> #include <qmimedatabase.h> #if defined(Q_OS_MACOS) #include \"src/widgets/capture/capturewidget.h\" #endif bool saveToFilesystem(const QPixmap& capture, const QString& path, const QString& messagePrefix) { QString completePath = FileNameHandler().properScreenshotPath( path, ConfigHandler().saveAsFileExtension()); QFile file{ completePath }; file.open(QIODevice::WriteOnly); bool okay = capture.save(&file); QString saveMessage = messagePrefix; QString notificationPath = completePath; if (!saveMessage.isEmpty()) { saveMessage += \" \"; } if (okay) { saveMessage += QObject::tr(\"Capture saved as \") + completePath; AbstractLogger::info().attachNotificationPath(notificationPath) << saveMessage; } else { saveMessage += QObject::tr(\"Error trying to save as \") + completePath; if (file.error() != QFile::NoError) { saveMessage += \": \" + file.errorString(); } notificationPath = \"\"; AbstractLogger::error().attachNotificationPath(notificationPath) << saveMessage; } return okay; } QString ShowSaveFileDialog(const QString& title, const QString& directory) { QFileDialog dialog(nullptr, title, directory); dialog.setAcceptMode(QFileDialog::AcceptSave); // Build string list of supported image formats QStringList mimeTypeList; foreach (auto mimeType, QImageWriter::supportedMimeTypes()) { // HEIF is meant for videos and it causes a glitch on MacOS // because the native dialog lumps together heic and heif if (mimeType != \"image/heif\") { mimeTypeList.append(mimeType); } } dialog.setMimeTypeFilters(mimeTypeList); QString suffix = ConfigHandler().saveAsFileExtension(); if (suffix.isEmpty()) { suffix = \"png\"; } QString defaultMimeType = QMimeDatabase().mimeTypeForFile(\"image.\" + suffix).name(); dialog.selectMimeTypeFilter(defaultMimeType); dialog.setDefaultSuffix(suffix); if (dialog.exec() == QDialog::Accepted) { return dialog.selectedFiles().constFirst(); } else { return {}; } } void saveToClipboardMime(const QPixmap& capture, const QString& imageType) { QByteArray array; QBuffer buffer{ &array }; QImageWriter imageWriter{ &buffer, imageType.toUpper().toUtf8() }; imageWriter.write(capture.toImage()); QPixmap formattedPixmap; bool isLoaded = formattedPixmap.loadFromData(reinterpret_cast<uchar*>(array.data()), array.size(), imageType.toUpper().toUtf8()); if (isLoaded) { auto* mimeData = new QMimeData(); #ifdef USE_WAYLAND_CLIPBOARD mimeData->setImageData(formattedPixmap.toImage()); mimeData->setData(QStringLiteral(\"x-kde-force-image-copy\"), QByteArray()); KSystemClipboard::instance()->setMimeData(mimeData, QClipboard::Clipboard); #else mimeData->setData(\"image/\" + imageType, array); QApplication::clipboard()->setMimeData(mimeData); #endif } else { AbstractLogger::error() << QObject::tr(\"Error while saving to clipboard\"); } } // If data is saved to the clipboard before the notification is sent via // dbus, the application freezes. void saveToClipboard(const QPixmap& capture) { // If we are able to properly save the file, save the file and copy to // clipboard. if ((ConfigHandler().saveAfterCopy()) && (!ConfigHandler().savePath().isEmpty())) { saveToFilesystem(capture, ConfigHandler().savePath(), QObject::tr(\"Capture saved to clipboard.\")); } else { AbstractLogger() << QObject::tr(\"Capture saved to clipboard.\"); } if (ConfigHandler().useJpgForClipboard()) { // FIXME - it doesn't work on MacOS saveToClipboardMime(capture, \"jpeg\"); } else { // Need to send message before copying to clipboard #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) if (DesktopInfo().waylandDetected()) { saveToClipboardMime(capture, \"png\"); } else { QApplication::clipboard()->setPixmap(capture); } #else QApplication::clipboard()->setPixmap(capture); #endif } } bool saveToFilesystemGUI(const QPixmap& capture) { bool okay = false; ConfigHandler config; QString defaultSavePath = ConfigHandler().savePath(); if (defaultSavePath.isEmpty() || !QDir(defaultSavePath).exists() || !QFileInfo(defaultSavePath).isWritable()) { defaultSavePath = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation); } QString savePath = FileNameHandler().properScreenshotPath( defaultSavePath, ConfigHandler().saveAsFileExtension()); #if defined(Q_OS_MACOS) for (QWidget* widget : qApp->topLevelWidgets()) { QString className(widget->metaObject()->className()); if (0 == className.compare(CaptureWidget::staticMetaObject.className())) { widget->showNormal(); widget->hide(); break; } } #endif if (!config.savePathFixed()) { savePath = ShowSaveFileDialog(QObject::tr(\"Save screenshot\"), savePath); } if (savePath == \"\") { return okay; } QFile file{ savePath }; file.open(QIODevice::WriteOnly); okay = capture.save(&file); if (okay) { QString pathNoFile = savePath.left(savePath.lastIndexOf(QLatin1String(\"/\"))); ConfigHandler().setSavePath(pathNoFile); QString msg = QObject::tr(\"Capture saved as \") + savePath; AbstractLogger().attachNotificationPath(savePath) << msg; if (config.copyPathAfterSave()) { FlameshotDaemon::copyToClipboard( savePath, QObject::tr(\"Path copied to clipboard as \") + savePath); } } else { QString msg = QObject::tr(\"Error trying to save as \") + savePath; if (file.error() != QFile::NoError) { msg += \": \" + file.errorString(); } QMessageBox saveErrBox( QMessageBox::Warning, QObject::tr(\"Save Error\"), msg); saveErrBox.setWindowIcon(QIcon(GlobalValues::iconPath())); saveErrBox.exec(); } return okay; }","title":"File screenshotsaver.cpp"},{"location":"flameshot/screenshotsaver_8h/","text":"File screenshotsaver.h # FileList > src > utils > screenshotsaver.h Go to the source code of this file. #include <QString> Public Functions # Type Name QString ShowSaveFileDialog (const QString & title, const QString & directory) void saveToClipboard (const QPixmap & capture) void saveToClipboardMime (const QPixmap & capture, const QString & imageType) bool saveToFilesystem (const QPixmap & capture, const QString & path, const QString & messagePrefix=\"\") bool saveToFilesystemGUI (const QPixmap & capture) Public Functions Documentation # function ShowSaveFileDialog # QString ShowSaveFileDialog ( const QString & title, const QString & directory ) function saveToClipboard # void saveToClipboard ( const QPixmap & capture ) function saveToClipboardMime # void saveToClipboardMime ( const QPixmap & capture, const QString & imageType ) function saveToFilesystem # bool saveToFilesystem ( const QPixmap & capture, const QString & path, const QString & messagePrefix=\"\" ) function saveToFilesystemGUI # bool saveToFilesystemGUI ( const QPixmap & capture )","title":"File screenshotsaver.h"},{"location":"flameshot/screenshotsaver_8h/#file-screenshotsaverh","text":"FileList > src > utils > screenshotsaver.h Go to the source code of this file. #include <QString>","title":"File screenshotsaver.h"},{"location":"flameshot/screenshotsaver_8h/#public-functions","text":"Type Name QString ShowSaveFileDialog (const QString & title, const QString & directory) void saveToClipboard (const QPixmap & capture) void saveToClipboardMime (const QPixmap & capture, const QString & imageType) bool saveToFilesystem (const QPixmap & capture, const QString & path, const QString & messagePrefix=\"\") bool saveToFilesystemGUI (const QPixmap & capture)","title":"Public Functions"},{"location":"flameshot/screenshotsaver_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/screenshotsaver_8h/#function-showsavefiledialog","text":"QString ShowSaveFileDialog ( const QString & title, const QString & directory )","title":"function ShowSaveFileDialog"},{"location":"flameshot/screenshotsaver_8h/#function-savetoclipboard","text":"void saveToClipboard ( const QPixmap & capture )","title":"function saveToClipboard"},{"location":"flameshot/screenshotsaver_8h/#function-savetoclipboardmime","text":"void saveToClipboardMime ( const QPixmap & capture, const QString & imageType )","title":"function saveToClipboardMime"},{"location":"flameshot/screenshotsaver_8h/#function-savetofilesystem","text":"bool saveToFilesystem ( const QPixmap & capture, const QString & path, const QString & messagePrefix=\"\" )","title":"function saveToFilesystem"},{"location":"flameshot/screenshotsaver_8h/#function-savetofilesystemgui","text":"bool saveToFilesystemGUI ( const QPixmap & capture )","title":"function saveToFilesystemGUI"},{"location":"flameshot/screenshotsaver_8h_source/","text":"File screenshotsaver.h # File List > src > utils > screenshotsaver.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class QPixmap; bool saveToFilesystem(const QPixmap& capture, const QString& path, const QString& messagePrefix = \"\"); QString ShowSaveFileDialog(const QString& title, const QString& directory); void saveToClipboardMime(const QPixmap& capture, const QString& imageType); void saveToClipboard(const QPixmap& capture); bool saveToFilesystemGUI(const QPixmap& capture);","title":"File screenshotsaver.h"},{"location":"flameshot/screenshotsaver_8h_source/#file-screenshotsaverh","text":"File List > src > utils > screenshotsaver.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QString> class QPixmap; bool saveToFilesystem(const QPixmap& capture, const QString& path, const QString& messagePrefix = \"\"); QString ShowSaveFileDialog(const QString& title, const QString& directory); void saveToClipboardMime(const QPixmap& capture, const QString& imageType); void saveToClipboard(const QPixmap& capture); bool saveToFilesystemGUI(const QPixmap& capture);","title":"File screenshotsaver.h"},{"location":"flameshot/strfparse_8cpp/","text":"File strfparse.cpp # FileList > src > utils > strfparse.cpp Go to the source code of this file. #include \"strfparse.h\" Namespaces # Type Name namespace strfparse","title":"File strfparse.cpp"},{"location":"flameshot/strfparse_8cpp/#file-strfparsecpp","text":"FileList > src > utils > strfparse.cpp Go to the source code of this file. #include \"strfparse.h\"","title":"File strfparse.cpp"},{"location":"flameshot/strfparse_8cpp/#namespaces","text":"Type Name namespace strfparse","title":"Namespaces"},{"location":"flameshot/strfparse_8cpp_source/","text":"File strfparse.cpp # File List > src > utils > strfparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include \"strfparse.h\" namespace strfparse { std::vector<std::string> split(std::string const& s, char delimiter) { std::vector<std::string> tokens; std::string token; std::istringstream tokenStream(s); while (std::getline(tokenStream, token, delimiter)) { tokens.push_back(token); } return tokens; } std::vector<char> create_specifier_list() { std::vector<char> allowed_specifier{ 'Y', 'H', 'a', 'A', 'b', 'B', 'c', 'C', 'd', 'D', 'e', 'F', 'g', 'G', 'h', 'H', 'I', 'j', 'm', 'M', 'n', 'p', 'r', 'R', 'S', 't', 'T', 'u', 'U', 'V', 'w', 'W', 'x', 'X', 'y', 'Y', 'z', 'Z' }; return allowed_specifier; } std::string replace_all(std::string input, std::string const& to_find, std::string const& to_replace) { size_t pos = 0; while ((pos = input.find(to_find, pos)) != std::string::npos) { input.replace(pos, to_find.length(), to_replace); pos += to_replace.length(); } return input; } std::vector<char> match_specifiers(std::string const& specifier, std::vector<char> allowed_specifier) { std::vector<char> spec_list; for (size_t i = 0; i < specifier.size() - 1; i++) { if (specifier[i] == '%') { spec_list.push_back(specifier[i + 1]); } } std::sort(spec_list.begin(), spec_list.end()); std::sort(allowed_specifier.begin(), allowed_specifier.end()); std::vector<char> overlap; std::set_intersection(spec_list.begin(), spec_list.end(), allowed_specifier.begin(), allowed_specifier.end(), back_inserter(overlap)); return overlap; } std::string format_time_string(std::string const& specifier) { if (specifier.empty()) { return \"\"; } std::time_t t = std::time(nullptr); char buff[100]; auto allowed_specifier = create_specifier_list(); auto overlap = match_specifiers(specifier, allowed_specifier); // Create \"Safe\" string for strftime which is the specfiers delimited by * std::string lookup_string; for (auto const& e : overlap) { lookup_string.push_back('%'); lookup_string.push_back(e); lookup_string.push_back('*'); } std::strftime( buff, sizeof(buff), lookup_string.c_str(), std::localtime(&t)); std::map<char, std::string> lookup_table; auto result = split(buff, '*'); for (size_t i = 0; i < result.size(); i++) { lookup_table.emplace(std::make_pair(overlap[i], result[i])); } // Sub into original string std::string delim = \"%\"; auto output_string = specifier; for (auto const& row : lookup_table) { auto to_find = delim + row.first; output_string = replace_all(output_string, to_find, row.second); } return output_string; } }","title":"File strfparse.cpp"},{"location":"flameshot/strfparse_8cpp_source/#file-strfparsecpp","text":"File List > src > utils > strfparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include \"strfparse.h\" namespace strfparse { std::vector<std::string> split(std::string const& s, char delimiter) { std::vector<std::string> tokens; std::string token; std::istringstream tokenStream(s); while (std::getline(tokenStream, token, delimiter)) { tokens.push_back(token); } return tokens; } std::vector<char> create_specifier_list() { std::vector<char> allowed_specifier{ 'Y', 'H', 'a', 'A', 'b', 'B', 'c', 'C', 'd', 'D', 'e', 'F', 'g', 'G', 'h', 'H', 'I', 'j', 'm', 'M', 'n', 'p', 'r', 'R', 'S', 't', 'T', 'u', 'U', 'V', 'w', 'W', 'x', 'X', 'y', 'Y', 'z', 'Z' }; return allowed_specifier; } std::string replace_all(std::string input, std::string const& to_find, std::string const& to_replace) { size_t pos = 0; while ((pos = input.find(to_find, pos)) != std::string::npos) { input.replace(pos, to_find.length(), to_replace); pos += to_replace.length(); } return input; } std::vector<char> match_specifiers(std::string const& specifier, std::vector<char> allowed_specifier) { std::vector<char> spec_list; for (size_t i = 0; i < specifier.size() - 1; i++) { if (specifier[i] == '%') { spec_list.push_back(specifier[i + 1]); } } std::sort(spec_list.begin(), spec_list.end()); std::sort(allowed_specifier.begin(), allowed_specifier.end()); std::vector<char> overlap; std::set_intersection(spec_list.begin(), spec_list.end(), allowed_specifier.begin(), allowed_specifier.end(), back_inserter(overlap)); return overlap; } std::string format_time_string(std::string const& specifier) { if (specifier.empty()) { return \"\"; } std::time_t t = std::time(nullptr); char buff[100]; auto allowed_specifier = create_specifier_list(); auto overlap = match_specifiers(specifier, allowed_specifier); // Create \"Safe\" string for strftime which is the specfiers delimited by * std::string lookup_string; for (auto const& e : overlap) { lookup_string.push_back('%'); lookup_string.push_back(e); lookup_string.push_back('*'); } std::strftime( buff, sizeof(buff), lookup_string.c_str(), std::localtime(&t)); std::map<char, std::string> lookup_table; auto result = split(buff, '*'); for (size_t i = 0; i < result.size(); i++) { lookup_table.emplace(std::make_pair(overlap[i], result[i])); } // Sub into original string std::string delim = \"%\"; auto output_string = specifier; for (auto const& row : lookup_table) { auto to_find = delim + row.first; output_string = replace_all(output_string, to_find, row.second); } return output_string; } }","title":"File strfparse.cpp"},{"location":"flameshot/strfparse_8h/","text":"File strfparse.h # FileList > src > utils > strfparse.h Go to the source code of this file. #include <algorithm> #include <ctime> #include <map> #include <sstream> #include <vector> Namespaces # Type Name namespace strfparse","title":"File strfparse.h"},{"location":"flameshot/strfparse_8h/#file-strfparseh","text":"FileList > src > utils > strfparse.h Go to the source code of this file. #include <algorithm> #include <ctime> #include <map> #include <sstream> #include <vector>","title":"File strfparse.h"},{"location":"flameshot/strfparse_8h/#namespaces","text":"Type Name namespace strfparse","title":"Namespaces"},{"location":"flameshot/strfparse_8h_source/","text":"File strfparse.h # File List > src > utils > strfparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include <algorithm> #include <ctime> #include <map> #include <sstream> #include <vector> namespace strfparse { std::vector<std::string> split(std::string const& s, char delimiter); std::vector<char> create_specifier_list(); std::string replace_all(std::string input, std::string const& to_find, std::string const& to_replace); std::vector<char> match_specifiers(std::string const& specifier, std::vector<char> allowed_specifier); std::string format_time_string(std::string const& specifier); }","title":"File strfparse.h"},{"location":"flameshot/strfparse_8h_source/#file-strfparseh","text":"File List > src > utils > strfparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Jeremy Borgman #include <algorithm> #include <ctime> #include <map> #include <sstream> #include <vector> namespace strfparse { std::vector<std::string> split(std::string const& s, char delimiter); std::vector<char> create_specifier_list(); std::string replace_all(std::string input, std::string const& to_find, std::string const& to_replace); std::vector<char> match_specifiers(std::string const& specifier, std::vector<char> allowed_specifier); std::string format_time_string(std::string const& specifier); }","title":"File strfparse.h"},{"location":"flameshot/systemnotification_8cpp/","text":"File systemnotification.cpp # FileList > src > utils > systemnotification.cpp Go to the source code of this file. #include \"systemnotification.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QUrl> #include <QDBusConnection> #include <QDBusInterface> #include <QDBusMessage> Macros # Type Name define FLAMESHOT_ICON \"flameshot\" Macro Definition Documentation # define FLAMESHOT_ICON # #define FLAMESHOT_ICON \"flameshot\"","title":"File systemnotification.cpp"},{"location":"flameshot/systemnotification_8cpp/#file-systemnotificationcpp","text":"FileList > src > utils > systemnotification.cpp Go to the source code of this file. #include \"systemnotification.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QUrl> #include <QDBusConnection> #include <QDBusInterface> #include <QDBusMessage>","title":"File systemnotification.cpp"},{"location":"flameshot/systemnotification_8cpp/#macros","text":"Type Name define FLAMESHOT_ICON \"flameshot\"","title":"Macros"},{"location":"flameshot/systemnotification_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/systemnotification_8cpp/#define-flameshot_icon","text":"#define FLAMESHOT_ICON \"flameshot\"","title":"define FLAMESHOT_ICON"},{"location":"flameshot/systemnotification_8cpp_source/","text":"File systemnotification.cpp # File List > src > utils > systemnotification.cpp Go to the documentation of this file. #include \"systemnotification.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QUrl> #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) #include <QDBusConnection> #include <QDBusInterface> #include <QDBusMessage> #else #include \"src/core/flameshotdaemon.h\" #endif // work-around for snap, which cannot install icons into // the system folder, so instead the absolute path to the // icon (saved somewhere in /snap/flameshot/...) is passed #ifndef FLAMESHOT_ICON #define FLAMESHOT_ICON \"flameshot\" #endif SystemNotification::SystemNotification(QObject* parent) : QObject(parent) , m_interface(nullptr) { #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) m_interface = new QDBusInterface(QStringLiteral(\"org.freedesktop.Notifications\"), QStringLiteral(\"/org/freedesktop/Notifications\"), QStringLiteral(\"org.freedesktop.Notifications\"), QDBusConnection::sessionBus(), this); #endif } void SystemNotification::sendMessage(const QString& text, const QString& savePath) { sendMessage(text, tr(\"Flameshot Info\"), savePath); } void SystemNotification::sendMessage(const QString& text, const QString& title, const QString& savePath, const int timeout) { if (!ConfigHandler().showDesktopNotification()) { return; } #if defined(Q_OS_MACOS) || defined(Q_OS_WIN) QMetaObject::invokeMethod( this, [&]() { // The call is queued to avoid recursive static initialization of // Flameshot and ConfigHandler. if (FlameshotDaemon::instance()) FlameshotDaemon::instance()->sendTrayNotification( text, title, timeout); }, Qt::QueuedConnection); #else QList<QVariant> args; QVariantMap hintsMap; if (!savePath.isEmpty()) { QUrl fullPath = QUrl::fromLocalFile(savePath); // allows the notification to be dragged and dropped hintsMap[QStringLiteral(\"x-kde-urls\")] = QStringList({ fullPath.toString() }); } args << (qAppName()) // appname << static_cast<unsigned int>(0) // id << FLAMESHOT_ICON // icon << title // summary << text // body << QStringList() // actions << hintsMap // hints << timeout; // timeout m_interface->callWithArgumentList( QDBus::AutoDetect, QStringLiteral(\"Notify\"), args); #endif }","title":"File systemnotification.cpp"},{"location":"flameshot/systemnotification_8cpp_source/#file-systemnotificationcpp","text":"File List > src > utils > systemnotification.cpp Go to the documentation of this file. #include \"systemnotification.h\" #include \"src/core/flameshot.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QUrl> #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) #include <QDBusConnection> #include <QDBusInterface> #include <QDBusMessage> #else #include \"src/core/flameshotdaemon.h\" #endif // work-around for snap, which cannot install icons into // the system folder, so instead the absolute path to the // icon (saved somewhere in /snap/flameshot/...) is passed #ifndef FLAMESHOT_ICON #define FLAMESHOT_ICON \"flameshot\" #endif SystemNotification::SystemNotification(QObject* parent) : QObject(parent) , m_interface(nullptr) { #if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN)) m_interface = new QDBusInterface(QStringLiteral(\"org.freedesktop.Notifications\"), QStringLiteral(\"/org/freedesktop/Notifications\"), QStringLiteral(\"org.freedesktop.Notifications\"), QDBusConnection::sessionBus(), this); #endif } void SystemNotification::sendMessage(const QString& text, const QString& savePath) { sendMessage(text, tr(\"Flameshot Info\"), savePath); } void SystemNotification::sendMessage(const QString& text, const QString& title, const QString& savePath, const int timeout) { if (!ConfigHandler().showDesktopNotification()) { return; } #if defined(Q_OS_MACOS) || defined(Q_OS_WIN) QMetaObject::invokeMethod( this, [&]() { // The call is queued to avoid recursive static initialization of // Flameshot and ConfigHandler. if (FlameshotDaemon::instance()) FlameshotDaemon::instance()->sendTrayNotification( text, title, timeout); }, Qt::QueuedConnection); #else QList<QVariant> args; QVariantMap hintsMap; if (!savePath.isEmpty()) { QUrl fullPath = QUrl::fromLocalFile(savePath); // allows the notification to be dragged and dropped hintsMap[QStringLiteral(\"x-kde-urls\")] = QStringList({ fullPath.toString() }); } args << (qAppName()) // appname << static_cast<unsigned int>(0) // id << FLAMESHOT_ICON // icon << title // summary << text // body << QStringList() // actions << hintsMap // hints << timeout; // timeout m_interface->callWithArgumentList( QDBus::AutoDetect, QStringLiteral(\"Notify\"), args); #endif }","title":"File systemnotification.cpp"},{"location":"flameshot/systemnotification_8h/","text":"File systemnotification.h # FileList > src > utils > systemnotification.h Go to the source code of this file. #include <QObject> Classes # Type Name class SystemNotification","title":"File systemnotification.h"},{"location":"flameshot/systemnotification_8h/#file-systemnotificationh","text":"FileList > src > utils > systemnotification.h Go to the source code of this file. #include <QObject>","title":"File systemnotification.h"},{"location":"flameshot/systemnotification_8h/#classes","text":"Type Name class SystemNotification","title":"Classes"},{"location":"flameshot/systemnotification_8h_source/","text":"File systemnotification.h # File List > src > utils > systemnotification.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> class QDBusInterface; class SystemNotification : public QObject { Q_OBJECT public: explicit SystemNotification(QObject* parent = nullptr); void sendMessage(const QString& text, const QString& savePath = {}); void sendMessage(const QString& text, const QString& title, const QString& savePath, const int timeout = 5000); private: QDBusInterface* m_interface; };","title":"File systemnotification.h"},{"location":"flameshot/systemnotification_8h_source/#file-systemnotificationh","text":"File List > src > utils > systemnotification.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QObject> class QDBusInterface; class SystemNotification : public QObject { Q_OBJECT public: explicit SystemNotification(QObject* parent = nullptr); void sendMessage(const QString& text, const QString& savePath = {}); void sendMessage(const QString& text, const QString& title, const QString& savePath, const int timeout = 5000); private: QDBusInterface* m_interface; };","title":"File systemnotification.h"},{"location":"flameshot/valuehandler_8cpp/","text":"File valuehandler.cpp # FileList > src > utils > valuehandler.cpp Go to the source code of this file. #include \"valuehandler.h\" #include \"capturetool.h\" #include \"colorpickerwidget.h\" #include \"confighandler.h\" #include \"screengrabber.h\" #include <QColor> #include <QFileInfo> #include <QImageWriter> #include <QKeySequence> #include <QStandardPaths> #include <QVariant> #include <QApplication> #include <utility> Public Types # Type Name typedef QList< CaptureTool::Type > BList typedef CaptureTool::Type BType Public Functions # Type Name void sortButtons (BList & buttons) Public Types Documentation # typedef BList # using BList = QList<CaptureTool::Type>; typedef BType # using BType = CaptureTool::Type; Public Functions Documentation # function sortButtons # void sortButtons ( BList & buttons )","title":"File valuehandler.cpp"},{"location":"flameshot/valuehandler_8cpp/#file-valuehandlercpp","text":"FileList > src > utils > valuehandler.cpp Go to the source code of this file. #include \"valuehandler.h\" #include \"capturetool.h\" #include \"colorpickerwidget.h\" #include \"confighandler.h\" #include \"screengrabber.h\" #include <QColor> #include <QFileInfo> #include <QImageWriter> #include <QKeySequence> #include <QStandardPaths> #include <QVariant> #include <QApplication> #include <utility>","title":"File valuehandler.cpp"},{"location":"flameshot/valuehandler_8cpp/#public-types","text":"Type Name typedef QList< CaptureTool::Type > BList typedef CaptureTool::Type BType","title":"Public Types"},{"location":"flameshot/valuehandler_8cpp/#public-functions","text":"Type Name void sortButtons (BList & buttons)","title":"Public Functions"},{"location":"flameshot/valuehandler_8cpp/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"flameshot/valuehandler_8cpp/#typedef-blist","text":"using BList = QList<CaptureTool::Type>;","title":"typedef BList"},{"location":"flameshot/valuehandler_8cpp/#typedef-btype","text":"using BType = CaptureTool::Type;","title":"typedef BType"},{"location":"flameshot/valuehandler_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/valuehandler_8cpp/#function-sortbuttons","text":"void sortButtons ( BList & buttons )","title":"function sortButtons"},{"location":"flameshot/valuehandler_8cpp_source/","text":"File valuehandler.cpp # File List > src > utils > valuehandler.cpp Go to the documentation of this file. #include \"valuehandler.h\" #include \"capturetool.h\" #include \"colorpickerwidget.h\" #include \"confighandler.h\" #include \"screengrabber.h\" #include <QColor> #include <QFileInfo> #include <QImageWriter> #include <QKeySequence> #include <QStandardPaths> #include <QVariant> // VALUE HANDLER QVariant ValueHandler::value(const QVariant& val) { if (!val.isValid() || !check(val)) { return fallback(); } else { return process(val); } } QVariant ValueHandler::fallback() { return {}; } QVariant ValueHandler::representation(const QVariant& val) { return val.toString(); } QString ValueHandler::expected() { return {}; } QVariant ValueHandler::process(const QVariant& val) { return val; } // BOOL Bool::Bool(bool def) : m_def(def) {} bool Bool::check(const QVariant& val) { QString str = val.toString(); if (str != \"true\" && str != \"false\") { return false; } return true; } QVariant Bool::fallback() { return m_def; } QString Bool::expected() { return QStringLiteral(\"true or false\"); } // STRING String::String(QString def) : m_def(std::move(def)) {} bool String::check(const QVariant&) { return true; } QVariant String::fallback() { return m_def; } QString String::expected() { return QStringLiteral(\"string\"); } // COLOR Color::Color(QColor def) : m_def(std::move(def)) {} bool Color::check(const QVariant& val) { QString str = val.toString(); // Disable #RGB, #RRRGGGBBB and #RRRRGGGGBBBB formats that QColor supports return QColor::isValidColor(str) && (str[0] != '#' || (str.length() != 4 && str.length() != 10 && str.length() != 13)); } QVariant Color::process(const QVariant& val) { QString str = val.toString(); QColor color(str); if (str.length() == 9 && str[0] == '#') { // Convert #RRGGBBAA (flameshot) to #AARRGGBB (QColor) int blue = color.blue(); color.setBlue(color.green()); color.setGreen(color.red()); color.setRed(color.alpha()); color.setAlpha(blue); } return color; } QVariant Color::fallback() { return m_def; } QVariant Color::representation(const QVariant& val) { QString str = val.toString(); QColor color(str); if (str.length() == 9 && str[0] == '#') { // Convert #AARRGGBB (QColor) to #RRGGBBAA (flameshot) int alpha = color.alpha(); color.setAlpha(color.red()); color.setRed(color.green()); color.setGreen(color.blue()); color.setBlue(alpha); } return color.name(); } QString Color::expected() { return QStringLiteral(\"color name or hex value\"); } // BOUNDED INT BoundedInt::BoundedInt(int min, int max, int def) : m_min(min) , m_max(max) , m_def(def) {} bool BoundedInt::check(const QVariant& val) { QString str = val.toString(); bool conversionOk; int num = str.toInt(&conversionOk); return conversionOk && m_min <= num && num <= m_max; } QVariant BoundedInt::fallback() { return m_def; } QString BoundedInt::expected() { return QStringLiteral(\"number between %1 and %2\").arg(m_min).arg(m_max); } // LOWER BOUNDED INT LowerBoundedInt::LowerBoundedInt(int min, int def) : m_min(min) , m_def(def) {} bool LowerBoundedInt::check(const QVariant& val) { QString str = val.toString(); bool conversionOk; int num = str.toInt(&conversionOk); return conversionOk && num >= m_min; } QVariant LowerBoundedInt::fallback() { return m_def; } QString LowerBoundedInt::expected() { return QStringLiteral(\"number >= %1\").arg(m_min); } // KEY SEQUENCE KeySequence::KeySequence(const QKeySequence& fallback) : m_fallback(fallback) {} bool KeySequence::check(const QVariant& val) { QString str = val.toString(); if (!str.isEmpty() && QKeySequence(str).toString().isEmpty()) { return false; } return true; } QVariant KeySequence::fallback() { return process(m_fallback); } QString KeySequence::expected() { return QStringLiteral(\"keyboard shortcut\"); } QVariant KeySequence::representation(const QVariant& val) { QString str(val.toString()); if (QKeySequence(str) == QKeySequence(Qt::Key_Return)) { return QStringLiteral(\"Enter\"); } return str; } QVariant KeySequence::process(const QVariant& val) { QString str(val.toString()); if (str == \"Enter\") { return QKeySequence(Qt::Key_Return).toString(); } if (str.length() > 0) { // Make the \"main\" key in sequence (last one) lower-case. const QCharRef& lastChar = str[str.length() - 1]; str.replace(str.length() - 1, 1, lastChar.toLower()); } return str; } // EXISTING DIR bool ExistingDir::check(const QVariant& val) { if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) { return false; } QFileInfo info(val.toString()); return info.isDir() && info.exists(); } QVariant ExistingDir::fallback() { using SP = QStandardPaths; for (auto location : { SP::PicturesLocation, SP::HomeLocation, SP::TempLocation }) { QString path = SP::writableLocation(location); if (QFileInfo(path).isDir()) { return path; } } return {}; } QString ExistingDir::expected() { return QStringLiteral(\"existing directory\"); } // FILENAME PATTERN bool FilenamePattern::check(const QVariant&) { return true; } QVariant FilenamePattern::fallback() { return ConfigHandler().filenamePatternDefault(); } QVariant FilenamePattern::process(const QVariant& val) { QString str = val.toString(); return !str.isEmpty() ? val : fallback(); } QString FilenamePattern::expected() { return QStringLiteral(\"please edit using the GUI\"); } // BUTTON LIST using BType = CaptureTool::Type; using BList = QList<CaptureTool::Type>; bool ButtonList::check(const QVariant& val) { // TODO stop using CTB using CTB = CaptureToolButton; auto allButtons = CTB::getIterableButtonTypes(); for (int btn : val.value<QList<int>>()) { if (!allButtons.contains(static_cast<BType>(btn))) { return false; } } return true; } // Helper void sortButtons(BList& buttons) { std::sort(buttons.begin(), buttons.end(), [](BType a, BType b) { return CaptureToolButton::getPriorityByButton(a) < CaptureToolButton::getPriorityByButton(b); }); } QVariant ButtonList::process(const QVariant& val) { auto intButtons = val.value<QList<int>>(); auto buttons = ButtonList::fromIntList(intButtons); sortButtons(buttons); return QVariant::fromValue(buttons); } QVariant ButtonList::fallback() { auto buttons = CaptureToolButton::getIterableButtonTypes(); buttons.removeOne(CaptureTool::TYPE_SIZEDECREASE); buttons.removeOne(CaptureTool::TYPE_SIZEINCREASE); sortButtons(buttons); return QVariant::fromValue(buttons); } QVariant ButtonList::representation(const QVariant& val) { auto intList = toIntList(val.value<BList>()); normalizeButtons(intList); return QVariant::fromValue(intList); } QString ButtonList::expected() { return QStringLiteral(\"please don't edit by hand\"); } QList<CaptureTool::Type> ButtonList::fromIntList(const QList<int>& l) { QList<CaptureTool::Type> buttons; buttons.reserve(l.size()); for (auto const i : l) { buttons << static_cast<CaptureTool::Type>(i); } return buttons; } QList<int> ButtonList::toIntList(const QList<CaptureTool::Type>& l) { QList<int> buttons; buttons.reserve(l.size()); for (auto const i : l) { buttons << static_cast<int>(i); } return buttons; } bool ButtonList::normalizeButtons(QList<int>& buttons) { QList<int> listTypesInt = toIntList(CaptureToolButton::getIterableButtonTypes()); bool hasChanged = false; for (int i = 0; i < buttons.size(); i++) { if (!listTypesInt.contains(buttons.at(i))) { buttons.removeAt(i); hasChanged = true; } } return hasChanged; } // USER COLORS UserColors::UserColors(int min, int max) : m_min(min) , m_max(max) {} bool UserColors::check(const QVariant& val) { if (!val.isValid()) { return false; } if (!val.canConvert(QVariant::StringList)) { return false; } for (const QString& str : val.toStringList()) { if (!QColor::isValidColor(str) && str != \"picker\") { return false; } } int sz = val.toStringList().size(); return sz >= m_min && sz <= m_max; } QVariant UserColors::process(const QVariant& val) { QStringList strColors = val.toStringList(); if (strColors.isEmpty()) { return fallback(); } QVector<QColor> colors; colors.reserve(strColors.size()); for (const QString& str : strColors) { if (str != \"picker\") { colors.append(QColor(str)); } else { colors.append(QColor()); } } return QVariant::fromValue(colors); } QVariant UserColors::fallback() { if (ConfigHandler().predefinedColorPaletteLarge()) { return QVariant::fromValue( ColorPickerWidget::getDefaultLargeColorPalette()); } else { return QVariant::fromValue( ColorPickerWidget::getDefaultSmallColorPalette()); } } QString UserColors::expected() { return QStringLiteral( \"list of colors(min %1 and max %2) separated by comma\") .arg(m_min - 1) .arg(m_max - 1); } QVariant UserColors::representation(const QVariant& val) { auto colors = val.value<QVector<QColor>>(); QStringList strColors; for (const auto& col : colors) { if (col.isValid()) { strColors.append(col.name(QColor::HexRgb)); } else { strColors.append(QStringLiteral(\"picker\")); } } return QVariant::fromValue(strColors); } // SET SAVE FILE AS EXTENSION bool SaveFileExtension::check(const QVariant& val) { if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) { return false; } QString extension = val.toString(); if (extension.startsWith(\".\")) { extension.remove(0, 1); } QStringList imageFormatList; foreach (auto imageFormat, QImageWriter::supportedImageFormats()) imageFormatList.append(imageFormat); if (!imageFormatList.contains(extension)) { return false; } return true; } QVariant SaveFileExtension::process(const QVariant& val) { QString extension = val.toString(); if (extension.startsWith(\".\")) { extension.remove(0, 1); } return QVariant::fromValue(extension); } QString SaveFileExtension::expected() { return QStringLiteral(\"supported image extension\"); } // REGION bool Region::check(const QVariant& val) { QVariant region = process(val); return process(val).isValid(); } #include <QApplication> // TODO remove after FIXME (see below) #include <utility> QVariant Region::process(const QVariant& val) { // FIXME: This is temporary, just before D-Bus is removed char** argv = new char*[1]; int* argc = new int{ 0 }; if (QGuiApplication::screens().empty()) { new QApplication(*argc, argv); } QString str = val.toString(); if (str == \"all\") { return ScreenGrabber().desktopGeometry(); } else if (str.startsWith(\"screen\")) { bool ok; int number = str.midRef(6).toInt(&ok); if (!ok || number < 0) { return {}; } return ScreenGrabber().screenGeometry(qApp->screens()[number]); } QRegExp regex(\"(-{,1}\\\\d+)\" // number (any sign) \"[x,\\\\.\\\\s]\" // separator ('x', ',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (any sign) \"[\\\\+,\\\\.\\\\s]*\" // separator ('+',',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (non-negative) \"[\\\\+,\\\\.\\\\s]*\" // separator ('+', ',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (non-negative) ); if (!regex.exactMatch(str)) { return {}; } int w, h, x, y; bool w_ok, h_ok, x_ok, y_ok; w = regex.cap(1).toInt(&w_ok); h = regex.cap(2).toInt(&h_ok); x = regex.cap(3).toInt(&x_ok); y = regex.cap(4).toInt(&y_ok); if (!(w_ok && h_ok && x_ok && y_ok)) { return {}; } return QRect(x, y, w, h).normalized(); }","title":"File valuehandler.cpp"},{"location":"flameshot/valuehandler_8cpp_source/#file-valuehandlercpp","text":"File List > src > utils > valuehandler.cpp Go to the documentation of this file. #include \"valuehandler.h\" #include \"capturetool.h\" #include \"colorpickerwidget.h\" #include \"confighandler.h\" #include \"screengrabber.h\" #include <QColor> #include <QFileInfo> #include <QImageWriter> #include <QKeySequence> #include <QStandardPaths> #include <QVariant> // VALUE HANDLER QVariant ValueHandler::value(const QVariant& val) { if (!val.isValid() || !check(val)) { return fallback(); } else { return process(val); } } QVariant ValueHandler::fallback() { return {}; } QVariant ValueHandler::representation(const QVariant& val) { return val.toString(); } QString ValueHandler::expected() { return {}; } QVariant ValueHandler::process(const QVariant& val) { return val; } // BOOL Bool::Bool(bool def) : m_def(def) {} bool Bool::check(const QVariant& val) { QString str = val.toString(); if (str != \"true\" && str != \"false\") { return false; } return true; } QVariant Bool::fallback() { return m_def; } QString Bool::expected() { return QStringLiteral(\"true or false\"); } // STRING String::String(QString def) : m_def(std::move(def)) {} bool String::check(const QVariant&) { return true; } QVariant String::fallback() { return m_def; } QString String::expected() { return QStringLiteral(\"string\"); } // COLOR Color::Color(QColor def) : m_def(std::move(def)) {} bool Color::check(const QVariant& val) { QString str = val.toString(); // Disable #RGB, #RRRGGGBBB and #RRRRGGGGBBBB formats that QColor supports return QColor::isValidColor(str) && (str[0] != '#' || (str.length() != 4 && str.length() != 10 && str.length() != 13)); } QVariant Color::process(const QVariant& val) { QString str = val.toString(); QColor color(str); if (str.length() == 9 && str[0] == '#') { // Convert #RRGGBBAA (flameshot) to #AARRGGBB (QColor) int blue = color.blue(); color.setBlue(color.green()); color.setGreen(color.red()); color.setRed(color.alpha()); color.setAlpha(blue); } return color; } QVariant Color::fallback() { return m_def; } QVariant Color::representation(const QVariant& val) { QString str = val.toString(); QColor color(str); if (str.length() == 9 && str[0] == '#') { // Convert #AARRGGBB (QColor) to #RRGGBBAA (flameshot) int alpha = color.alpha(); color.setAlpha(color.red()); color.setRed(color.green()); color.setGreen(color.blue()); color.setBlue(alpha); } return color.name(); } QString Color::expected() { return QStringLiteral(\"color name or hex value\"); } // BOUNDED INT BoundedInt::BoundedInt(int min, int max, int def) : m_min(min) , m_max(max) , m_def(def) {} bool BoundedInt::check(const QVariant& val) { QString str = val.toString(); bool conversionOk; int num = str.toInt(&conversionOk); return conversionOk && m_min <= num && num <= m_max; } QVariant BoundedInt::fallback() { return m_def; } QString BoundedInt::expected() { return QStringLiteral(\"number between %1 and %2\").arg(m_min).arg(m_max); } // LOWER BOUNDED INT LowerBoundedInt::LowerBoundedInt(int min, int def) : m_min(min) , m_def(def) {} bool LowerBoundedInt::check(const QVariant& val) { QString str = val.toString(); bool conversionOk; int num = str.toInt(&conversionOk); return conversionOk && num >= m_min; } QVariant LowerBoundedInt::fallback() { return m_def; } QString LowerBoundedInt::expected() { return QStringLiteral(\"number >= %1\").arg(m_min); } // KEY SEQUENCE KeySequence::KeySequence(const QKeySequence& fallback) : m_fallback(fallback) {} bool KeySequence::check(const QVariant& val) { QString str = val.toString(); if (!str.isEmpty() && QKeySequence(str).toString().isEmpty()) { return false; } return true; } QVariant KeySequence::fallback() { return process(m_fallback); } QString KeySequence::expected() { return QStringLiteral(\"keyboard shortcut\"); } QVariant KeySequence::representation(const QVariant& val) { QString str(val.toString()); if (QKeySequence(str) == QKeySequence(Qt::Key_Return)) { return QStringLiteral(\"Enter\"); } return str; } QVariant KeySequence::process(const QVariant& val) { QString str(val.toString()); if (str == \"Enter\") { return QKeySequence(Qt::Key_Return).toString(); } if (str.length() > 0) { // Make the \"main\" key in sequence (last one) lower-case. const QCharRef& lastChar = str[str.length() - 1]; str.replace(str.length() - 1, 1, lastChar.toLower()); } return str; } // EXISTING DIR bool ExistingDir::check(const QVariant& val) { if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) { return false; } QFileInfo info(val.toString()); return info.isDir() && info.exists(); } QVariant ExistingDir::fallback() { using SP = QStandardPaths; for (auto location : { SP::PicturesLocation, SP::HomeLocation, SP::TempLocation }) { QString path = SP::writableLocation(location); if (QFileInfo(path).isDir()) { return path; } } return {}; } QString ExistingDir::expected() { return QStringLiteral(\"existing directory\"); } // FILENAME PATTERN bool FilenamePattern::check(const QVariant&) { return true; } QVariant FilenamePattern::fallback() { return ConfigHandler().filenamePatternDefault(); } QVariant FilenamePattern::process(const QVariant& val) { QString str = val.toString(); return !str.isEmpty() ? val : fallback(); } QString FilenamePattern::expected() { return QStringLiteral(\"please edit using the GUI\"); } // BUTTON LIST using BType = CaptureTool::Type; using BList = QList<CaptureTool::Type>; bool ButtonList::check(const QVariant& val) { // TODO stop using CTB using CTB = CaptureToolButton; auto allButtons = CTB::getIterableButtonTypes(); for (int btn : val.value<QList<int>>()) { if (!allButtons.contains(static_cast<BType>(btn))) { return false; } } return true; } // Helper void sortButtons(BList& buttons) { std::sort(buttons.begin(), buttons.end(), [](BType a, BType b) { return CaptureToolButton::getPriorityByButton(a) < CaptureToolButton::getPriorityByButton(b); }); } QVariant ButtonList::process(const QVariant& val) { auto intButtons = val.value<QList<int>>(); auto buttons = ButtonList::fromIntList(intButtons); sortButtons(buttons); return QVariant::fromValue(buttons); } QVariant ButtonList::fallback() { auto buttons = CaptureToolButton::getIterableButtonTypes(); buttons.removeOne(CaptureTool::TYPE_SIZEDECREASE); buttons.removeOne(CaptureTool::TYPE_SIZEINCREASE); sortButtons(buttons); return QVariant::fromValue(buttons); } QVariant ButtonList::representation(const QVariant& val) { auto intList = toIntList(val.value<BList>()); normalizeButtons(intList); return QVariant::fromValue(intList); } QString ButtonList::expected() { return QStringLiteral(\"please don't edit by hand\"); } QList<CaptureTool::Type> ButtonList::fromIntList(const QList<int>& l) { QList<CaptureTool::Type> buttons; buttons.reserve(l.size()); for (auto const i : l) { buttons << static_cast<CaptureTool::Type>(i); } return buttons; } QList<int> ButtonList::toIntList(const QList<CaptureTool::Type>& l) { QList<int> buttons; buttons.reserve(l.size()); for (auto const i : l) { buttons << static_cast<int>(i); } return buttons; } bool ButtonList::normalizeButtons(QList<int>& buttons) { QList<int> listTypesInt = toIntList(CaptureToolButton::getIterableButtonTypes()); bool hasChanged = false; for (int i = 0; i < buttons.size(); i++) { if (!listTypesInt.contains(buttons.at(i))) { buttons.removeAt(i); hasChanged = true; } } return hasChanged; } // USER COLORS UserColors::UserColors(int min, int max) : m_min(min) , m_max(max) {} bool UserColors::check(const QVariant& val) { if (!val.isValid()) { return false; } if (!val.canConvert(QVariant::StringList)) { return false; } for (const QString& str : val.toStringList()) { if (!QColor::isValidColor(str) && str != \"picker\") { return false; } } int sz = val.toStringList().size(); return sz >= m_min && sz <= m_max; } QVariant UserColors::process(const QVariant& val) { QStringList strColors = val.toStringList(); if (strColors.isEmpty()) { return fallback(); } QVector<QColor> colors; colors.reserve(strColors.size()); for (const QString& str : strColors) { if (str != \"picker\") { colors.append(QColor(str)); } else { colors.append(QColor()); } } return QVariant::fromValue(colors); } QVariant UserColors::fallback() { if (ConfigHandler().predefinedColorPaletteLarge()) { return QVariant::fromValue( ColorPickerWidget::getDefaultLargeColorPalette()); } else { return QVariant::fromValue( ColorPickerWidget::getDefaultSmallColorPalette()); } } QString UserColors::expected() { return QStringLiteral( \"list of colors(min %1 and max %2) separated by comma\") .arg(m_min - 1) .arg(m_max - 1); } QVariant UserColors::representation(const QVariant& val) { auto colors = val.value<QVector<QColor>>(); QStringList strColors; for (const auto& col : colors) { if (col.isValid()) { strColors.append(col.name(QColor::HexRgb)); } else { strColors.append(QStringLiteral(\"picker\")); } } return QVariant::fromValue(strColors); } // SET SAVE FILE AS EXTENSION bool SaveFileExtension::check(const QVariant& val) { if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) { return false; } QString extension = val.toString(); if (extension.startsWith(\".\")) { extension.remove(0, 1); } QStringList imageFormatList; foreach (auto imageFormat, QImageWriter::supportedImageFormats()) imageFormatList.append(imageFormat); if (!imageFormatList.contains(extension)) { return false; } return true; } QVariant SaveFileExtension::process(const QVariant& val) { QString extension = val.toString(); if (extension.startsWith(\".\")) { extension.remove(0, 1); } return QVariant::fromValue(extension); } QString SaveFileExtension::expected() { return QStringLiteral(\"supported image extension\"); } // REGION bool Region::check(const QVariant& val) { QVariant region = process(val); return process(val).isValid(); } #include <QApplication> // TODO remove after FIXME (see below) #include <utility> QVariant Region::process(const QVariant& val) { // FIXME: This is temporary, just before D-Bus is removed char** argv = new char*[1]; int* argc = new int{ 0 }; if (QGuiApplication::screens().empty()) { new QApplication(*argc, argv); } QString str = val.toString(); if (str == \"all\") { return ScreenGrabber().desktopGeometry(); } else if (str.startsWith(\"screen\")) { bool ok; int number = str.midRef(6).toInt(&ok); if (!ok || number < 0) { return {}; } return ScreenGrabber().screenGeometry(qApp->screens()[number]); } QRegExp regex(\"(-{,1}\\\\d+)\" // number (any sign) \"[x,\\\\.\\\\s]\" // separator ('x', ',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (any sign) \"[\\\\+,\\\\.\\\\s]*\" // separator ('+',',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (non-negative) \"[\\\\+,\\\\.\\\\s]*\" // separator ('+', ',', '.', or whitespace) \"(-{,1}\\\\d+)\" // number (non-negative) ); if (!regex.exactMatch(str)) { return {}; } int w, h, x, y; bool w_ok, h_ok, x_ok, y_ok; w = regex.cap(1).toInt(&w_ok); h = regex.cap(2).toInt(&h_ok); x = regex.cap(3).toInt(&x_ok); y = regex.cap(4).toInt(&y_ok); if (!(w_ok && h_ok && x_ok && y_ok)) { return {}; } return QRect(x, y, w, h).normalized(); }","title":"File valuehandler.cpp"},{"location":"flameshot/valuehandler_8h/","text":"File valuehandler.h # FileList > src > utils > valuehandler.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include \"src/widgets/colorpickerwidget.h\" #include <QColor> #include <QList> #include <QString> Classes # Type Name class Bool class BoundedInt class ButtonList class Color class ExistingDir class FilenamePattern class KeySequence class LowerBoundedInt class Region class SaveFileExtension class String class UserColors class ValueHandler Handles the value of a configuration option (abstract class).","title":"File valuehandler.h"},{"location":"flameshot/valuehandler_8h/#file-valuehandlerh","text":"FileList > src > utils > valuehandler.h Go to the source code of this file. #include \"src/widgets/capture/capturetoolbutton.h\" #include \"src/widgets/colorpickerwidget.h\" #include <QColor> #include <QList> #include <QString>","title":"File valuehandler.h"},{"location":"flameshot/valuehandler_8h/#classes","text":"Type Name class Bool class BoundedInt class ButtonList class Color class ExistingDir class FilenamePattern class KeySequence class LowerBoundedInt class Region class SaveFileExtension class String class UserColors class ValueHandler Handles the value of a configuration option (abstract class).","title":"Classes"},{"location":"flameshot/valuehandler_8h_source/","text":"File valuehandler.h # File List > src > utils > valuehandler.h Go to the documentation of this file. #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include \"src/widgets/colorpickerwidget.h\" #include <QColor> #include <QList> #include <QString> class QVariant; class ValueHandler { public: virtual bool check(const QVariant& val) = 0; QVariant value(const QVariant& val); virtual QVariant fallback(); virtual QVariant representation(const QVariant& val); virtual QString expected(); protected: virtual QVariant process(const QVariant& val); }; class Bool : public ValueHandler { public: Bool(bool def); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; private: bool m_def; }; class String : public ValueHandler { public: String(QString def); bool check(const QVariant&) override; QVariant fallback() override; QString expected() override; private: QString m_def; }; class Color : public ValueHandler { public: Color(QColor def); bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QVariant representation(const QVariant& val) override; QString expected() override; private: QColor m_def; }; class BoundedInt : public ValueHandler { public: BoundedInt(int min, int max, int def); bool check(const QVariant& val) override; virtual QVariant fallback() override; QString expected() override; private: int m_min, m_max, m_def; }; class LowerBoundedInt : public ValueHandler { public: LowerBoundedInt(int min, int def); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; private: int m_min, m_def; }; class KeySequence : public ValueHandler { public: KeySequence(const QKeySequence& fallback = {}); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; QVariant representation(const QVariant& val) override; private: QKeySequence m_fallback; QVariant process(const QVariant& val) override; }; class ExistingDir : public ValueHandler { bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; }; class FilenamePattern : public ValueHandler { bool check(const QVariant&) override; QVariant fallback() override; QVariant process(const QVariant&) override; QString expected() override; }; class ButtonList : public ValueHandler { public: bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QVariant representation(const QVariant& val) override; QString expected() override; // UTILITY FUNCTIONS static QList<CaptureTool::Type> fromIntList(const QList<int>&); static QList<int> toIntList(const QList<CaptureTool::Type>& l); static bool normalizeButtons(QList<int>& buttons); }; class UserColors : public ValueHandler { public: UserColors(int min, int max); bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QString expected() override; QVariant representation(const QVariant& val) override; private: int m_min, m_max; }; class SaveFileExtension : public ValueHandler { bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QString expected() override; }; class Region : public ValueHandler { public: bool check(const QVariant& val) override; private: QVariant process(const QVariant& val) override; };","title":"File valuehandler.h"},{"location":"flameshot/valuehandler_8h_source/#file-valuehandlerh","text":"File List > src > utils > valuehandler.h Go to the documentation of this file. #pragma once #include \"src/widgets/capture/capturetoolbutton.h\" #include \"src/widgets/colorpickerwidget.h\" #include <QColor> #include <QList> #include <QString> class QVariant; class ValueHandler { public: virtual bool check(const QVariant& val) = 0; QVariant value(const QVariant& val); virtual QVariant fallback(); virtual QVariant representation(const QVariant& val); virtual QString expected(); protected: virtual QVariant process(const QVariant& val); }; class Bool : public ValueHandler { public: Bool(bool def); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; private: bool m_def; }; class String : public ValueHandler { public: String(QString def); bool check(const QVariant&) override; QVariant fallback() override; QString expected() override; private: QString m_def; }; class Color : public ValueHandler { public: Color(QColor def); bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QVariant representation(const QVariant& val) override; QString expected() override; private: QColor m_def; }; class BoundedInt : public ValueHandler { public: BoundedInt(int min, int max, int def); bool check(const QVariant& val) override; virtual QVariant fallback() override; QString expected() override; private: int m_min, m_max, m_def; }; class LowerBoundedInt : public ValueHandler { public: LowerBoundedInt(int min, int def); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; private: int m_min, m_def; }; class KeySequence : public ValueHandler { public: KeySequence(const QKeySequence& fallback = {}); bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; QVariant representation(const QVariant& val) override; private: QKeySequence m_fallback; QVariant process(const QVariant& val) override; }; class ExistingDir : public ValueHandler { bool check(const QVariant& val) override; QVariant fallback() override; QString expected() override; }; class FilenamePattern : public ValueHandler { bool check(const QVariant&) override; QVariant fallback() override; QVariant process(const QVariant&) override; QString expected() override; }; class ButtonList : public ValueHandler { public: bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QVariant representation(const QVariant& val) override; QString expected() override; // UTILITY FUNCTIONS static QList<CaptureTool::Type> fromIntList(const QList<int>&); static QList<int> toIntList(const QList<CaptureTool::Type>& l); static bool normalizeButtons(QList<int>& buttons); }; class UserColors : public ValueHandler { public: UserColors(int min, int max); bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QVariant fallback() override; QString expected() override; QVariant representation(const QVariant& val) override; private: int m_min, m_max; }; class SaveFileExtension : public ValueHandler { bool check(const QVariant& val) override; QVariant process(const QVariant& val) override; QString expected() override; }; class Region : public ValueHandler { public: bool check(const QVariant& val) override; private: QVariant process(const QVariant& val) override; };","title":"File valuehandler.h"},{"location":"flameshot/waylandutils_8cpp/","text":"File waylandutils.cpp # FileList > src > utils > waylandutils.cpp Go to the source code of this file. #include \"waylandutils.h\"","title":"File waylandutils.cpp"},{"location":"flameshot/waylandutils_8cpp/#file-waylandutilscpp","text":"FileList > src > utils > waylandutils.cpp Go to the source code of this file. #include \"waylandutils.h\"","title":"File waylandutils.cpp"},{"location":"flameshot/waylandutils_8cpp_source/","text":"File waylandutils.cpp # File List > src > utils > waylandutils.cpp Go to the documentation of this file. #include \"waylandutils.h\" WaylandUtils::WaylandUtils() {} bool WaylandUtils::waylandDetected() {}","title":"File waylandutils.cpp"},{"location":"flameshot/waylandutils_8cpp_source/#file-waylandutilscpp","text":"File List > src > utils > waylandutils.cpp Go to the documentation of this file. #include \"waylandutils.h\" WaylandUtils::WaylandUtils() {} bool WaylandUtils::waylandDetected() {}","title":"File waylandutils.cpp"},{"location":"flameshot/waylandutils_8h/","text":"File waylandutils.h # FileList > src > utils > waylandutils.h Go to the source code of this file. Classes # Type Name class WaylandUtils","title":"File waylandutils.h"},{"location":"flameshot/waylandutils_8h/#file-waylandutilsh","text":"FileList > src > utils > waylandutils.h Go to the source code of this file.","title":"File waylandutils.h"},{"location":"flameshot/waylandutils_8h/#classes","text":"Type Name class WaylandUtils","title":"Classes"},{"location":"flameshot/waylandutils_8h_source/","text":"File waylandutils.h # File List > src > utils > waylandutils.h Go to the documentation of this file. #ifndef WAYLANDUTILS_H #define WAYLANDUTILS_H class WaylandUtils { public: WaylandUtils(); static bool waylandDetected(); private: }; #endif // WAYLANDUTILS_H","title":"File waylandutils.h"},{"location":"flameshot/waylandutils_8h_source/#file-waylandutilsh","text":"File List > src > utils > waylandutils.h Go to the documentation of this file. #ifndef WAYLANDUTILS_H #define WAYLANDUTILS_H class WaylandUtils { public: WaylandUtils(); static bool waylandDetected(); private: }; #endif // WAYLANDUTILS_H","title":"File waylandutils.h"},{"location":"flameshot/winlnkfileparse_8cpp/","text":"File winlnkfileparse.cpp # FileList > src > utils > winlnkfileparse.cpp Go to the source code of this file. #include \"winlnkfileparse.h\" #include <QDir> #include <QDirIterator> #include <QFileSystemModel> #include <QImageWriter> #include <QRegularExpression> #include <QSettings> #include <QString> #include <shlobj.h>","title":"File winlnkfileparse.cpp"},{"location":"flameshot/winlnkfileparse_8cpp/#file-winlnkfileparsecpp","text":"FileList > src > utils > winlnkfileparse.cpp Go to the source code of this file. #include \"winlnkfileparse.h\" #include <QDir> #include <QDirIterator> #include <QFileSystemModel> #include <QImageWriter> #include <QRegularExpression> #include <QSettings> #include <QString> #include <shlobj.h>","title":"File winlnkfileparse.cpp"},{"location":"flameshot/winlnkfileparse_8cpp_source/","text":"File winlnkfileparse.cpp # File List > src > utils > winlnkfileparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"winlnkfileparse.h\" #include <QDir> #include <QDirIterator> #include <QFileSystemModel> #include <QImageWriter> #include <QRegularExpression> #include <QSettings> #include <QString> #include <shlobj.h> WinLnkFileParser::WinLnkFileParser() { QStringList sListImgFileExt; for (const auto& ext : QImageWriter::supportedImageFormats()) { sListImgFileExt.append(ext); } this->getImageFileExtAssociates(sListImgFileExt); } DesktopAppData WinLnkFileParser::parseLnkFile(const QFileInfo& fiLnk, bool& ok) const { DesktopAppData res; ok = true; QFileInfo fiSymlink(fiLnk.symLinkTarget()); if (!fiSymlink.exists() || !fiSymlink.fileName().endsWith(\".exe\") || fiSymlink.baseName().contains(\"unins\")) { ok = false; return res; } res.name = fiLnk.baseName(); res.exec = fiSymlink.absoluteFilePath(); // Get icon from exe QFileSystemModel* model = new QFileSystemModel; model->setRootPath(fiSymlink.path()); res.icon = model->fileIcon(model->index(fiSymlink.filePath())); if (m_GraphicAppsList.contains(fiSymlink.fileName())) { res.categories = QStringList() << \"Graphics\"; } else { res.categories = QStringList() << \"Utility\"; } for (const auto& app : m_appList) { if (app.exec == res.exec) { ok = false; break; } } if (res.exec.isEmpty() || res.name.isEmpty()) { ok = false; } return res; } int WinLnkFileParser::processDirectory(const QDir& dir) { QStringList sListMenuFilter; sListMenuFilter << \"Accessibility\" << \"Administrative Tools\" << \"Setup\" << \"System Tools\" << \"Uninstall\" << \"Update\" << \"Updater\" << \"Windows PowerShell\"; const QString sMenuFilter(\"\\\\b(\" + sListMenuFilter.join('|') + \")\\\\b\"); QRegularExpression regexfilter(sMenuFilter); bool ok; int length = m_appList.length(); // Go through all subfolders and *.lnk files QDirIterator it(dir.absolutePath(), { \"*.lnk\" }, QDir::NoFilter, QDirIterator::Subdirectories); while (it.hasNext()) { QFileInfo fiLnk(it.next()); if (!regexfilter.match(fiLnk.absoluteFilePath()).hasMatch()) { DesktopAppData app = parseLnkFile(fiLnk, ok); if (ok) { m_appList.append(app); } } } return m_appList.length() - length; } QVector<DesktopAppData> WinLnkFileParser::getAppsByCategory( const QString& category) { QVector<DesktopAppData> res; for (const DesktopAppData& app : qAsConst(m_appList)) { if (app.categories.contains(category)) { res.append(app); } } std::sort(res.begin(), res.end(), CompareAppByName()); return res; } QMap<QString, QVector<DesktopAppData>> WinLnkFileParser::getAppsByCategory( const QStringList& categories) { QMap<QString, QVector<DesktopAppData>> res; QVector<DesktopAppData> tmpAppList; for (const QString& category : categories) { tmpAppList = getAppsByCategory(category); for (const DesktopAppData& app : qAsConst(tmpAppList)) { res[category].append(app); } } return res; } QString WinLnkFileParser::getAllUsersStartMenuPath() { QString sRet(\"\"); WCHAR path[MAX_PATH]; HRESULT hr = SHGetFolderPathW(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, path); if (SUCCEEDED(hr)) { sRet = QDir(QString::fromWCharArray(path)).absolutePath(); } return sRet; } void WinLnkFileParser::getImageFileExtAssociates(const QStringList& sListImgExt) { const QString sReg(\"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\\" \"CurrentVersion\\\\Explorer\\\\FileExts\\\\.%1\\\\OpenWithList\"); for (const auto& sExt : qAsConst(sListImgExt)) { QString sPath(sReg.arg(sExt)); QSettings registry(sPath, QSettings::NativeFormat); for (const auto& key : registry.allKeys()) { if (1 == key.size()) { // Keys for OpenWith apps are a, b, c, ... QString sVal = registry.value(key, \"\").toString(); if (sVal.endsWith(\".exe\") && !m_GraphicAppsList.contains(sVal)) { m_GraphicAppsList << sVal; } } } } }","title":"File winlnkfileparse.cpp"},{"location":"flameshot/winlnkfileparse_8cpp_source/#file-winlnkfileparsecpp","text":"File List > src > utils > winlnkfileparse.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"winlnkfileparse.h\" #include <QDir> #include <QDirIterator> #include <QFileSystemModel> #include <QImageWriter> #include <QRegularExpression> #include <QSettings> #include <QString> #include <shlobj.h> WinLnkFileParser::WinLnkFileParser() { QStringList sListImgFileExt; for (const auto& ext : QImageWriter::supportedImageFormats()) { sListImgFileExt.append(ext); } this->getImageFileExtAssociates(sListImgFileExt); } DesktopAppData WinLnkFileParser::parseLnkFile(const QFileInfo& fiLnk, bool& ok) const { DesktopAppData res; ok = true; QFileInfo fiSymlink(fiLnk.symLinkTarget()); if (!fiSymlink.exists() || !fiSymlink.fileName().endsWith(\".exe\") || fiSymlink.baseName().contains(\"unins\")) { ok = false; return res; } res.name = fiLnk.baseName(); res.exec = fiSymlink.absoluteFilePath(); // Get icon from exe QFileSystemModel* model = new QFileSystemModel; model->setRootPath(fiSymlink.path()); res.icon = model->fileIcon(model->index(fiSymlink.filePath())); if (m_GraphicAppsList.contains(fiSymlink.fileName())) { res.categories = QStringList() << \"Graphics\"; } else { res.categories = QStringList() << \"Utility\"; } for (const auto& app : m_appList) { if (app.exec == res.exec) { ok = false; break; } } if (res.exec.isEmpty() || res.name.isEmpty()) { ok = false; } return res; } int WinLnkFileParser::processDirectory(const QDir& dir) { QStringList sListMenuFilter; sListMenuFilter << \"Accessibility\" << \"Administrative Tools\" << \"Setup\" << \"System Tools\" << \"Uninstall\" << \"Update\" << \"Updater\" << \"Windows PowerShell\"; const QString sMenuFilter(\"\\\\b(\" + sListMenuFilter.join('|') + \")\\\\b\"); QRegularExpression regexfilter(sMenuFilter); bool ok; int length = m_appList.length(); // Go through all subfolders and *.lnk files QDirIterator it(dir.absolutePath(), { \"*.lnk\" }, QDir::NoFilter, QDirIterator::Subdirectories); while (it.hasNext()) { QFileInfo fiLnk(it.next()); if (!regexfilter.match(fiLnk.absoluteFilePath()).hasMatch()) { DesktopAppData app = parseLnkFile(fiLnk, ok); if (ok) { m_appList.append(app); } } } return m_appList.length() - length; } QVector<DesktopAppData> WinLnkFileParser::getAppsByCategory( const QString& category) { QVector<DesktopAppData> res; for (const DesktopAppData& app : qAsConst(m_appList)) { if (app.categories.contains(category)) { res.append(app); } } std::sort(res.begin(), res.end(), CompareAppByName()); return res; } QMap<QString, QVector<DesktopAppData>> WinLnkFileParser::getAppsByCategory( const QStringList& categories) { QMap<QString, QVector<DesktopAppData>> res; QVector<DesktopAppData> tmpAppList; for (const QString& category : categories) { tmpAppList = getAppsByCategory(category); for (const DesktopAppData& app : qAsConst(tmpAppList)) { res[category].append(app); } } return res; } QString WinLnkFileParser::getAllUsersStartMenuPath() { QString sRet(\"\"); WCHAR path[MAX_PATH]; HRESULT hr = SHGetFolderPathW(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, path); if (SUCCEEDED(hr)) { sRet = QDir(QString::fromWCharArray(path)).absolutePath(); } return sRet; } void WinLnkFileParser::getImageFileExtAssociates(const QStringList& sListImgExt) { const QString sReg(\"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\\" \"CurrentVersion\\\\Explorer\\\\FileExts\\\\.%1\\\\OpenWithList\"); for (const auto& sExt : qAsConst(sListImgExt)) { QString sPath(sReg.arg(sExt)); QSettings registry(sPath, QSettings::NativeFormat); for (const auto& key : registry.allKeys()) { if (1 == key.size()) { // Keys for OpenWith apps are a, b, c, ... QString sVal = registry.value(key, \"\").toString(); if (sVal.endsWith(\".exe\") && !m_GraphicAppsList.contains(sVal)) { m_GraphicAppsList << sVal; } } } } }","title":"File winlnkfileparse.cpp"},{"location":"flameshot/winlnkfileparse_8h/","text":"File winlnkfileparse.h # FileList > src > utils > winlnkfileparse.h Go to the source code of this file. #include \"desktopfileparse.h\" #include <QFileInfo> #include <QIcon> #include <QMap> #include <QStringList> Classes # Type Name struct CompareAppByName struct WinLnkFileParser","title":"File winlnkfileparse.h"},{"location":"flameshot/winlnkfileparse_8h/#file-winlnkfileparseh","text":"FileList > src > utils > winlnkfileparse.h Go to the source code of this file. #include \"desktopfileparse.h\" #include <QFileInfo> #include <QIcon> #include <QMap> #include <QStringList>","title":"File winlnkfileparse.h"},{"location":"flameshot/winlnkfileparse_8h/#classes","text":"Type Name struct CompareAppByName struct WinLnkFileParser","title":"Classes"},{"location":"flameshot/winlnkfileparse_8h_source/","text":"File winlnkfileparse.h # File List > src > utils > winlnkfileparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"desktopfileparse.h\" #include <QFileInfo> #include <QIcon> #include <QMap> #include <QStringList> class QDir; class QString; struct CompareAppByName { bool operator()(const DesktopAppData a, const DesktopAppData b) { return (a.name < b.name); } }; struct WinLnkFileParser { WinLnkFileParser(); DesktopAppData parseLnkFile(const QFileInfo& fiLnk, bool& ok) const; int processDirectory(const QDir& dir); QString getAllUsersStartMenuPath(); QVector<DesktopAppData> getAppsByCategory(const QString& category); QMap<QString, QVector<DesktopAppData>> getAppsByCategory( const QStringList& categories); private: void getImageFileExtAssociates(const QStringList& sListImgExt); QVector<DesktopAppData> m_appList; QStringList m_GraphicAppsList; };","title":"File winlnkfileparse.h"},{"location":"flameshot/winlnkfileparse_8h_source/#file-winlnkfileparseh","text":"File List > src > utils > winlnkfileparse.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"desktopfileparse.h\" #include <QFileInfo> #include <QIcon> #include <QMap> #include <QStringList> class QDir; class QString; struct CompareAppByName { bool operator()(const DesktopAppData a, const DesktopAppData b) { return (a.name < b.name); } }; struct WinLnkFileParser { WinLnkFileParser(); DesktopAppData parseLnkFile(const QFileInfo& fiLnk, bool& ok) const; int processDirectory(const QDir& dir); QString getAllUsersStartMenuPath(); QVector<DesktopAppData> getAppsByCategory(const QString& category); QMap<QString, QVector<DesktopAppData>> getAppsByCategory( const QStringList& categories); private: void getImageFileExtAssociates(const QStringList& sListImgExt); QVector<DesktopAppData> m_appList; QStringList m_GraphicAppsList; };","title":"File winlnkfileparse.h"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/","text":"Dir widgets # FileList > src > widgets Files # Type Name file capturelauncher.cpp file capturelauncher.h file colorpickerwidget.cpp file colorpickerwidget.h file draggablewidgetmaker.cpp file draggablewidgetmaker.h file imagelabel.cpp file imagelabel.h file imguploaddialog.cpp file imguploaddialog.h file infowindow.cpp file infowindow.h file loadspinner.cpp file loadspinner.h file notificationwidget.cpp file notificationwidget.h file orientablepushbutton.cpp file orientablepushbutton.h file trayicon.cpp file trayicon.h file updatenotificationwidget.cpp file updatenotificationwidget.h file uploadhistory.cpp file uploadhistory.h file uploadlineitem.cpp file uploadlineitem.h Directories # Type Name dir capture dir panel","title":"Dir widgets"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/#dir-widgets","text":"FileList > src > widgets","title":"Dir widgets"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/#files","text":"Type Name file capturelauncher.cpp file capturelauncher.h file colorpickerwidget.cpp file colorpickerwidget.h file draggablewidgetmaker.cpp file draggablewidgetmaker.h file imagelabel.cpp file imagelabel.h file imguploaddialog.cpp file imguploaddialog.h file infowindow.cpp file infowindow.h file loadspinner.cpp file loadspinner.h file notificationwidget.cpp file notificationwidget.h file orientablepushbutton.cpp file orientablepushbutton.h file trayicon.cpp file trayicon.h file updatenotificationwidget.cpp file updatenotificationwidget.h file uploadhistory.cpp file uploadhistory.h file uploadlineitem.cpp file uploadlineitem.h","title":"Files"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/#directories","text":"Type Name dir capture dir panel","title":"Directories"},{"location":"flameshot/dir_50d9a3ace9e44a4976ace91594337bf4/","text":"Dir capture # FileList > capture Files # Type Name file buttonhandler.cpp file buttonhandler.h file capturebutton.cpp file capturebutton.h file capturetoolbutton.cpp file capturetoolbutton.h file capturetoolobjects.cpp file capturetoolobjects.h file capturewidget.cpp file capturewidget.h file colorpicker.cpp file colorpicker.h file hovereventfilter.cpp file hovereventfilter.h file magnifierwidget.cpp file magnifierwidget.h file modificationcommand.cpp file modificationcommand.h file notifierbox.cpp file notifierbox.h file overlaymessage.cpp file overlaymessage.h file selectionwidget.cpp file selectionwidget.h","title":"Dir capture"},{"location":"flameshot/dir_50d9a3ace9e44a4976ace91594337bf4/#dir-capture","text":"FileList > capture","title":"Dir capture"},{"location":"flameshot/dir_50d9a3ace9e44a4976ace91594337bf4/#files","text":"Type Name file buttonhandler.cpp file buttonhandler.h file capturebutton.cpp file capturebutton.h file capturetoolbutton.cpp file capturetoolbutton.h file capturetoolobjects.cpp file capturetoolobjects.h file capturewidget.cpp file capturewidget.h file colorpicker.cpp file colorpicker.h file hovereventfilter.cpp file hovereventfilter.h file magnifierwidget.cpp file magnifierwidget.h file modificationcommand.cpp file modificationcommand.h file notifierbox.cpp file notifierbox.h file overlaymessage.cpp file overlaymessage.h file selectionwidget.cpp file selectionwidget.h","title":"Files"},{"location":"flameshot/buttonhandler_8cpp/","text":"File buttonhandler.cpp # FileList > capture > buttonhandler.cpp Go to the source code of this file. #include \"buttonhandler.h\" #include \"src/utils/globalvalues.h\" #include <QPoint> #include <QScreen>","title":"File buttonhandler.cpp"},{"location":"flameshot/buttonhandler_8cpp/#file-buttonhandlercpp","text":"FileList > capture > buttonhandler.cpp Go to the source code of this file. #include \"buttonhandler.h\" #include \"src/utils/globalvalues.h\" #include <QPoint> #include <QScreen>","title":"File buttonhandler.cpp"},{"location":"flameshot/buttonhandler_8cpp_source/","text":"File buttonhandler.cpp # File List > capture > buttonhandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"buttonhandler.h\" #include \"src/utils/globalvalues.h\" #include <QPoint> #include <QScreen> // ButtonHandler is a habdler for every active button. It makes easier to // manipulate the buttons as a unit. ButtonHandler::ButtonHandler(const QVector<CaptureToolButton*>& v, QObject* parent) : QObject(parent) { setButtons(v); init(); } ButtonHandler::ButtonHandler(QObject* parent) : QObject(parent) { init(); } void ButtonHandler::hide() { for (CaptureToolButton* b : m_vectorButtons) { b->hide(); } } void ButtonHandler::show() { if (m_vectorButtons.isEmpty() || m_vectorButtons.first()->isVisible()) { return; } for (CaptureToolButton* b : m_vectorButtons) { b->animatedShow(); } } bool ButtonHandler::isVisible() const { bool ret = true; for (const CaptureToolButton* b : m_vectorButtons) { if (!b->isVisible()) { ret = false; break; } } return ret; } bool ButtonHandler::buttonsAreInside() const { return m_buttonsAreInside; } size_t ButtonHandler::size() const { return m_vectorButtons.size(); } // updatePosition updates the position of the buttons around the // selection area. Ignores the sides blocked by the end of the screen. // When the selection is too small it works on a virtual selection with // the original in the center. void ButtonHandler::updatePosition(const QRect& selection) { resetRegionTrack(); const int vecLength = m_vectorButtons.size(); if (vecLength == 0) { return; } // Copy of the selection area for internal modifications m_selection = intersectWithAreas(selection); updateBlockedSides(); ensureSelectionMinimunSize(); // Indicates the actual button to be moved int elemIndicator = 0; while (elemIndicator < vecLength) { // Add them inside the area when there is no more space if (m_allSidesBlocked) { m_selection = selection; positionButtonsInside(elemIndicator); break; // the while } // Number of buttons per row column int buttonsPerRow = (m_selection.width() + m_separator) / (m_buttonExtendedSize); int buttonsPerCol = (m_selection.height() + m_separator) / (m_buttonExtendedSize); // Buttons to be placed in the corners int extraButtons = (vecLength - elemIndicator) - (buttonsPerRow + buttonsPerCol) * 2; int elemsAtCorners = extraButtons > 4 ? 4 : extraButtons; int maxExtra = 2; if (m_oneHorizontalBlocked) { maxExtra = 1; } else if (m_horizontalyBlocked) { maxExtra = 0; } int elemCornersTop = qBound(0, elemsAtCorners, maxExtra); elemsAtCorners -= elemCornersTop; int elemCornersBotton = qBound(0, elemsAtCorners, maxExtra); // Add buttons at the button of the selection if (!m_blockedBotton) { int addCounter = buttonsPerRow + elemCornersBotton; // Don't add more than we have addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.center().x(), m_selection.bottom() + m_separator); if (addCounter > buttonsPerRow) { adjustHorizontalCenter(center); } // ElemIndicator, elemsAtCorners QVector<QPoint> positions = horizontalPoints(center, addCounter, true); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the right side of the selection if (!m_blockedRight && elemIndicator < vecLength) { int addCounter = buttonsPerCol; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.right() + m_separator, m_selection.center().y()); QVector<QPoint> positions = verticalPoints(center, addCounter, false); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the top of the selection if (!m_blockedTop && elemIndicator < vecLength) { int addCounter = buttonsPerRow + elemCornersTop; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.center().x(), m_selection.top() - m_buttonExtendedSize); if (addCounter == 1 + buttonsPerRow) { adjustHorizontalCenter(center); } QVector<QPoint> positions = horizontalPoints(center, addCounter, false); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the left side of the selection if (!m_blockedLeft && elemIndicator < vecLength) { int addCounter = buttonsPerCol; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.left() - m_buttonExtendedSize, m_selection.center().y()); QVector<QPoint> positions = verticalPoints(center, addCounter, true); moveButtonsToPoints(positions, elemIndicator); } // If there are elements for the next cycle, increase the size of the // base area if (elemIndicator < vecLength && !(m_allSidesBlocked)) { expandSelection(); } updateBlockedSides(); } } int ButtonHandler::calculateShift(int elements, bool reverse) const { int shift = 0; if (elements % 2 == 0) { shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2); } else { shift = m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2; } if (!reverse) { shift -= m_buttonBaseSize; } return shift; } // horizontalPoints is an auxiliary method for the button position computation. // starts from a known center and keeps adding elements horizontally // and returns the computed positions. QVector<QPoint> ButtonHandler::horizontalPoints(const QPoint& center, const int elements, const bool leftToRight) const { QVector<QPoint> res; // Distance from the center to start adding buttons int shift = calculateShift(elements, leftToRight); int x = leftToRight ? center.x() - shift : center.x() + shift; QPoint i(x, center.y()); while (elements > res.length()) { res.append(i); leftToRight ? i.setX(i.x() + m_buttonExtendedSize) : i.setX(i.x() - m_buttonExtendedSize); } return res; } // verticalPoints is an auxiliary method for the button position computation. // starts from a known center and keeps adding elements vertically // and returns the computed positions. QVector<QPoint> ButtonHandler::verticalPoints(const QPoint& center, const int elements, const bool upToDown) const { QVector<QPoint> res; // Distance from the center to start adding buttons int shift = calculateShift(elements, upToDown); int y = upToDown ? center.y() - shift : center.y() + shift; QPoint i(center.x(), y); while (elements > res.length()) { res.append(i); upToDown ? i.setY(i.y() + m_buttonExtendedSize) : i.setY(i.y() - m_buttonExtendedSize); } return res; } QRect ButtonHandler::intersectWithAreas(const QRect& rect) { QRect res; for (const QRect& r : m_screenRegions) { QRect temp = rect.intersected(r); if (temp.height() * temp.width() > res.height() * res.width()) { res = temp; } } return res; } void ButtonHandler::init() { m_separator = GlobalValues::buttonBaseSize() / 4; } void ButtonHandler::resetRegionTrack() { m_buttonsAreInside = false; } void ButtonHandler::updateBlockedSides() { QRegion screenRegion{}; for (const QRect& rect : m_screenRegions) { screenRegion += rect; } const int EXTENSION = m_separator * 2 + m_buttonBaseSize; // Right QPoint pointA(m_selection.right() + EXTENSION, m_selection.bottom()); QPoint pointB(pointA.x(), m_selection.top()); m_blockedRight = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Left pointA.setX(m_selection.left() - EXTENSION); pointB.setX(pointA.x()); m_blockedLeft = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Bottom pointA = QPoint(m_selection.left(), m_selection.bottom() + EXTENSION); pointB = QPoint(m_selection.right(), pointA.y()); m_blockedBotton = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Top pointA.setY(m_selection.top() - EXTENSION); pointB.setY(pointA.y()); m_blockedTop = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Auxiliary m_oneHorizontalBlocked = (!m_blockedRight && m_blockedLeft) || (m_blockedRight && !m_blockedLeft); m_horizontalyBlocked = (m_blockedRight && m_blockedLeft); m_allSidesBlocked = (m_blockedBotton && m_horizontalyBlocked && m_blockedTop); } void ButtonHandler::expandSelection() { int& s = m_buttonExtendedSize; m_selection = m_selection + QMargins(s, s, s, s); m_selection = intersectWithAreas(m_selection); } void ButtonHandler::positionButtonsInside(int index) { // Position the buttons in the botton-center of the main but inside of the // selection. QRect mainArea = m_selection; mainArea = intersectWithAreas(mainArea); const int buttonsPerRow = (mainArea.width()) / (m_buttonExtendedSize); if (buttonsPerRow == 0) { return; } QPoint center = QPoint(mainArea.center().x(), mainArea.bottom() - m_buttonExtendedSize); while (m_vectorButtons.size() > index) { int addCounter = buttonsPerRow; addCounter = qBound(0, addCounter, m_vectorButtons.size() - index); QVector<QPoint> positions = horizontalPoints(center, addCounter, true); moveButtonsToPoints(positions, index); center.setY(center.y() - m_buttonExtendedSize); } m_buttonsAreInside = true; } void ButtonHandler::ensureSelectionMinimunSize() { // Detect if a side is smaller than a button in order to prevent collision // and redimension the base area the the base size of a single button per // side if (m_selection.width() < m_buttonBaseSize) { if (!m_blockedLeft) { m_selection.setX(m_selection.x() - (m_buttonBaseSize - m_selection.width()) / 2); } m_selection.setWidth(m_buttonBaseSize); } if (m_selection.height() < m_buttonBaseSize) { if (!m_blockedTop) { m_selection.setY(m_selection.y() - (m_buttonBaseSize - m_selection.height()) / 2); } m_selection.setHeight(m_buttonBaseSize); } } void ButtonHandler::moveButtonsToPoints(const QVector<QPoint>& points, int& index) { for (const QPoint& p : points) { auto* button = m_vectorButtons[index]; button->move(p); ++index; } } void ButtonHandler::adjustHorizontalCenter(QPoint& center) { if (m_blockedLeft) { center.setX(center.x() + m_buttonExtendedSize / 2); } else if (m_blockedRight) { center.setX(center.x() - m_buttonExtendedSize / 2); } } // setButtons redefines the buttons of the button handler void ButtonHandler::setButtons(const QVector<CaptureToolButton*> v) { if (v.isEmpty()) { return; } for (CaptureToolButton* b : m_vectorButtons) { delete (b); } m_vectorButtons = v; m_buttonBaseSize = GlobalValues::buttonBaseSize(); m_buttonExtendedSize = m_buttonBaseSize + m_separator; } bool ButtonHandler::contains(const QPoint& p) const { if (m_vectorButtons.isEmpty()) { return false; } QPoint first(m_vectorButtons.first()->pos()); QPoint last(m_vectorButtons.last()->pos()); bool firstIsTopLeft = (first.x() <= last.x() && first.y() <= last.y()); QPoint topLeft = firstIsTopLeft ? first : last; QPoint bottonRight = firstIsTopLeft ? last : first; topLeft += QPoint(-m_separator, -m_separator); bottonRight += QPoint(m_buttonExtendedSize, m_buttonExtendedSize); QRegion r(QRect(topLeft, bottonRight).normalized()); return r.contains(p); } void ButtonHandler::updateScreenRegions(const QVector<QRect>& rects) { m_screenRegions = rects; } void ButtonHandler::updateScreenRegions(const QRect& rect) { m_screenRegions = { rect }; }","title":"File buttonhandler.cpp"},{"location":"flameshot/buttonhandler_8cpp_source/#file-buttonhandlercpp","text":"File List > capture > buttonhandler.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"buttonhandler.h\" #include \"src/utils/globalvalues.h\" #include <QPoint> #include <QScreen> // ButtonHandler is a habdler for every active button. It makes easier to // manipulate the buttons as a unit. ButtonHandler::ButtonHandler(const QVector<CaptureToolButton*>& v, QObject* parent) : QObject(parent) { setButtons(v); init(); } ButtonHandler::ButtonHandler(QObject* parent) : QObject(parent) { init(); } void ButtonHandler::hide() { for (CaptureToolButton* b : m_vectorButtons) { b->hide(); } } void ButtonHandler::show() { if (m_vectorButtons.isEmpty() || m_vectorButtons.first()->isVisible()) { return; } for (CaptureToolButton* b : m_vectorButtons) { b->animatedShow(); } } bool ButtonHandler::isVisible() const { bool ret = true; for (const CaptureToolButton* b : m_vectorButtons) { if (!b->isVisible()) { ret = false; break; } } return ret; } bool ButtonHandler::buttonsAreInside() const { return m_buttonsAreInside; } size_t ButtonHandler::size() const { return m_vectorButtons.size(); } // updatePosition updates the position of the buttons around the // selection area. Ignores the sides blocked by the end of the screen. // When the selection is too small it works on a virtual selection with // the original in the center. void ButtonHandler::updatePosition(const QRect& selection) { resetRegionTrack(); const int vecLength = m_vectorButtons.size(); if (vecLength == 0) { return; } // Copy of the selection area for internal modifications m_selection = intersectWithAreas(selection); updateBlockedSides(); ensureSelectionMinimunSize(); // Indicates the actual button to be moved int elemIndicator = 0; while (elemIndicator < vecLength) { // Add them inside the area when there is no more space if (m_allSidesBlocked) { m_selection = selection; positionButtonsInside(elemIndicator); break; // the while } // Number of buttons per row column int buttonsPerRow = (m_selection.width() + m_separator) / (m_buttonExtendedSize); int buttonsPerCol = (m_selection.height() + m_separator) / (m_buttonExtendedSize); // Buttons to be placed in the corners int extraButtons = (vecLength - elemIndicator) - (buttonsPerRow + buttonsPerCol) * 2; int elemsAtCorners = extraButtons > 4 ? 4 : extraButtons; int maxExtra = 2; if (m_oneHorizontalBlocked) { maxExtra = 1; } else if (m_horizontalyBlocked) { maxExtra = 0; } int elemCornersTop = qBound(0, elemsAtCorners, maxExtra); elemsAtCorners -= elemCornersTop; int elemCornersBotton = qBound(0, elemsAtCorners, maxExtra); // Add buttons at the button of the selection if (!m_blockedBotton) { int addCounter = buttonsPerRow + elemCornersBotton; // Don't add more than we have addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.center().x(), m_selection.bottom() + m_separator); if (addCounter > buttonsPerRow) { adjustHorizontalCenter(center); } // ElemIndicator, elemsAtCorners QVector<QPoint> positions = horizontalPoints(center, addCounter, true); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the right side of the selection if (!m_blockedRight && elemIndicator < vecLength) { int addCounter = buttonsPerCol; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.right() + m_separator, m_selection.center().y()); QVector<QPoint> positions = verticalPoints(center, addCounter, false); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the top of the selection if (!m_blockedTop && elemIndicator < vecLength) { int addCounter = buttonsPerRow + elemCornersTop; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.center().x(), m_selection.top() - m_buttonExtendedSize); if (addCounter == 1 + buttonsPerRow) { adjustHorizontalCenter(center); } QVector<QPoint> positions = horizontalPoints(center, addCounter, false); moveButtonsToPoints(positions, elemIndicator); } // Add buttons at the left side of the selection if (!m_blockedLeft && elemIndicator < vecLength) { int addCounter = buttonsPerCol; addCounter = qBound(0, addCounter, vecLength - elemIndicator); QPoint center = QPoint(m_selection.left() - m_buttonExtendedSize, m_selection.center().y()); QVector<QPoint> positions = verticalPoints(center, addCounter, true); moveButtonsToPoints(positions, elemIndicator); } // If there are elements for the next cycle, increase the size of the // base area if (elemIndicator < vecLength && !(m_allSidesBlocked)) { expandSelection(); } updateBlockedSides(); } } int ButtonHandler::calculateShift(int elements, bool reverse) const { int shift = 0; if (elements % 2 == 0) { shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2); } else { shift = m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2; } if (!reverse) { shift -= m_buttonBaseSize; } return shift; } // horizontalPoints is an auxiliary method for the button position computation. // starts from a known center and keeps adding elements horizontally // and returns the computed positions. QVector<QPoint> ButtonHandler::horizontalPoints(const QPoint& center, const int elements, const bool leftToRight) const { QVector<QPoint> res; // Distance from the center to start adding buttons int shift = calculateShift(elements, leftToRight); int x = leftToRight ? center.x() - shift : center.x() + shift; QPoint i(x, center.y()); while (elements > res.length()) { res.append(i); leftToRight ? i.setX(i.x() + m_buttonExtendedSize) : i.setX(i.x() - m_buttonExtendedSize); } return res; } // verticalPoints is an auxiliary method for the button position computation. // starts from a known center and keeps adding elements vertically // and returns the computed positions. QVector<QPoint> ButtonHandler::verticalPoints(const QPoint& center, const int elements, const bool upToDown) const { QVector<QPoint> res; // Distance from the center to start adding buttons int shift = calculateShift(elements, upToDown); int y = upToDown ? center.y() - shift : center.y() + shift; QPoint i(center.x(), y); while (elements > res.length()) { res.append(i); upToDown ? i.setY(i.y() + m_buttonExtendedSize) : i.setY(i.y() - m_buttonExtendedSize); } return res; } QRect ButtonHandler::intersectWithAreas(const QRect& rect) { QRect res; for (const QRect& r : m_screenRegions) { QRect temp = rect.intersected(r); if (temp.height() * temp.width() > res.height() * res.width()) { res = temp; } } return res; } void ButtonHandler::init() { m_separator = GlobalValues::buttonBaseSize() / 4; } void ButtonHandler::resetRegionTrack() { m_buttonsAreInside = false; } void ButtonHandler::updateBlockedSides() { QRegion screenRegion{}; for (const QRect& rect : m_screenRegions) { screenRegion += rect; } const int EXTENSION = m_separator * 2 + m_buttonBaseSize; // Right QPoint pointA(m_selection.right() + EXTENSION, m_selection.bottom()); QPoint pointB(pointA.x(), m_selection.top()); m_blockedRight = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Left pointA.setX(m_selection.left() - EXTENSION); pointB.setX(pointA.x()); m_blockedLeft = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Bottom pointA = QPoint(m_selection.left(), m_selection.bottom() + EXTENSION); pointB = QPoint(m_selection.right(), pointA.y()); m_blockedBotton = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Top pointA.setY(m_selection.top() - EXTENSION); pointB.setY(pointA.y()); m_blockedTop = !(screenRegion.contains(pointA) && screenRegion.contains(pointB)); // Auxiliary m_oneHorizontalBlocked = (!m_blockedRight && m_blockedLeft) || (m_blockedRight && !m_blockedLeft); m_horizontalyBlocked = (m_blockedRight && m_blockedLeft); m_allSidesBlocked = (m_blockedBotton && m_horizontalyBlocked && m_blockedTop); } void ButtonHandler::expandSelection() { int& s = m_buttonExtendedSize; m_selection = m_selection + QMargins(s, s, s, s); m_selection = intersectWithAreas(m_selection); } void ButtonHandler::positionButtonsInside(int index) { // Position the buttons in the botton-center of the main but inside of the // selection. QRect mainArea = m_selection; mainArea = intersectWithAreas(mainArea); const int buttonsPerRow = (mainArea.width()) / (m_buttonExtendedSize); if (buttonsPerRow == 0) { return; } QPoint center = QPoint(mainArea.center().x(), mainArea.bottom() - m_buttonExtendedSize); while (m_vectorButtons.size() > index) { int addCounter = buttonsPerRow; addCounter = qBound(0, addCounter, m_vectorButtons.size() - index); QVector<QPoint> positions = horizontalPoints(center, addCounter, true); moveButtonsToPoints(positions, index); center.setY(center.y() - m_buttonExtendedSize); } m_buttonsAreInside = true; } void ButtonHandler::ensureSelectionMinimunSize() { // Detect if a side is smaller than a button in order to prevent collision // and redimension the base area the the base size of a single button per // side if (m_selection.width() < m_buttonBaseSize) { if (!m_blockedLeft) { m_selection.setX(m_selection.x() - (m_buttonBaseSize - m_selection.width()) / 2); } m_selection.setWidth(m_buttonBaseSize); } if (m_selection.height() < m_buttonBaseSize) { if (!m_blockedTop) { m_selection.setY(m_selection.y() - (m_buttonBaseSize - m_selection.height()) / 2); } m_selection.setHeight(m_buttonBaseSize); } } void ButtonHandler::moveButtonsToPoints(const QVector<QPoint>& points, int& index) { for (const QPoint& p : points) { auto* button = m_vectorButtons[index]; button->move(p); ++index; } } void ButtonHandler::adjustHorizontalCenter(QPoint& center) { if (m_blockedLeft) { center.setX(center.x() + m_buttonExtendedSize / 2); } else if (m_blockedRight) { center.setX(center.x() - m_buttonExtendedSize / 2); } } // setButtons redefines the buttons of the button handler void ButtonHandler::setButtons(const QVector<CaptureToolButton*> v) { if (v.isEmpty()) { return; } for (CaptureToolButton* b : m_vectorButtons) { delete (b); } m_vectorButtons = v; m_buttonBaseSize = GlobalValues::buttonBaseSize(); m_buttonExtendedSize = m_buttonBaseSize + m_separator; } bool ButtonHandler::contains(const QPoint& p) const { if (m_vectorButtons.isEmpty()) { return false; } QPoint first(m_vectorButtons.first()->pos()); QPoint last(m_vectorButtons.last()->pos()); bool firstIsTopLeft = (first.x() <= last.x() && first.y() <= last.y()); QPoint topLeft = firstIsTopLeft ? first : last; QPoint bottonRight = firstIsTopLeft ? last : first; topLeft += QPoint(-m_separator, -m_separator); bottonRight += QPoint(m_buttonExtendedSize, m_buttonExtendedSize); QRegion r(QRect(topLeft, bottonRight).normalized()); return r.contains(p); } void ButtonHandler::updateScreenRegions(const QVector<QRect>& rects) { m_screenRegions = rects; } void ButtonHandler::updateScreenRegions(const QRect& rect) { m_screenRegions = { rect }; }","title":"File buttonhandler.cpp"},{"location":"flameshot/buttonhandler_8h/","text":"File buttonhandler.h # FileList > capture > buttonhandler.h Go to the source code of this file. #include \"capturetoolbutton.h\" #include <QObject> #include <QRegion> #include <QVector> Classes # Type Name class ButtonHandler","title":"File buttonhandler.h"},{"location":"flameshot/buttonhandler_8h/#file-buttonhandlerh","text":"FileList > capture > buttonhandler.h Go to the source code of this file. #include \"capturetoolbutton.h\" #include <QObject> #include <QRegion> #include <QVector>","title":"File buttonhandler.h"},{"location":"flameshot/buttonhandler_8h/#classes","text":"Type Name class ButtonHandler","title":"Classes"},{"location":"flameshot/buttonhandler_8h_source/","text":"File buttonhandler.h # File List > capture > buttonhandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetoolbutton.h\" #include <QObject> #include <QRegion> #include <QVector> class CaptureToolButton; class QRect; class QPoint; class ButtonHandler : public QObject { Q_OBJECT public: ButtonHandler(const QVector<CaptureToolButton*>&, QObject* parent = nullptr); explicit ButtonHandler(QObject* parent = nullptr); void hideSectionUnderMouse(const QPoint& p); bool isVisible() const; bool buttonsAreInside() const; size_t size() const; void setButtons(const QVector<CaptureToolButton*>); bool contains(const QPoint& p) const; void updateScreenRegions(const QVector<QRect>& rects); void updateScreenRegions(const QRect& rect); public slots: void updatePosition(const QRect& selection); void hide(); void show(); private: QVector<QPoint> horizontalPoints(const QPoint& center, const int elements, const bool leftToRight) const; QVector<QPoint> verticalPoints(const QPoint& center, const int elements, const bool upToDown) const; int calculateShift(int elements, bool reverse) const; QRect intersectWithAreas(const QRect& rect); QVector<CaptureToolButton*> m_vectorButtons; QVector<QRect> m_screenRegions; QRect m_selection; int m_separator; int m_buttonExtendedSize; int m_buttonBaseSize; bool m_buttonsAreInside; bool m_blockedRight; bool m_blockedLeft; bool m_blockedBotton; bool m_blockedTop; bool m_oneHorizontalBlocked; bool m_horizontalyBlocked; bool m_allSidesBlocked; // aux methods void init(); void resetRegionTrack(); void updateBlockedSides(); void expandSelection(); void positionButtonsInside(int index); void ensureSelectionMinimunSize(); void moveButtonsToPoints(const QVector<QPoint>& points, int& index); void adjustHorizontalCenter(QPoint& center); };","title":"File buttonhandler.h"},{"location":"flameshot/buttonhandler_8h_source/#file-buttonhandlerh","text":"File List > capture > buttonhandler.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturetoolbutton.h\" #include <QObject> #include <QRegion> #include <QVector> class CaptureToolButton; class QRect; class QPoint; class ButtonHandler : public QObject { Q_OBJECT public: ButtonHandler(const QVector<CaptureToolButton*>&, QObject* parent = nullptr); explicit ButtonHandler(QObject* parent = nullptr); void hideSectionUnderMouse(const QPoint& p); bool isVisible() const; bool buttonsAreInside() const; size_t size() const; void setButtons(const QVector<CaptureToolButton*>); bool contains(const QPoint& p) const; void updateScreenRegions(const QVector<QRect>& rects); void updateScreenRegions(const QRect& rect); public slots: void updatePosition(const QRect& selection); void hide(); void show(); private: QVector<QPoint> horizontalPoints(const QPoint& center, const int elements, const bool leftToRight) const; QVector<QPoint> verticalPoints(const QPoint& center, const int elements, const bool upToDown) const; int calculateShift(int elements, bool reverse) const; QRect intersectWithAreas(const QRect& rect); QVector<CaptureToolButton*> m_vectorButtons; QVector<QRect> m_screenRegions; QRect m_selection; int m_separator; int m_buttonExtendedSize; int m_buttonBaseSize; bool m_buttonsAreInside; bool m_blockedRight; bool m_blockedLeft; bool m_blockedBotton; bool m_blockedTop; bool m_oneHorizontalBlocked; bool m_horizontalyBlocked; bool m_allSidesBlocked; // aux methods void init(); void resetRegionTrack(); void updateBlockedSides(); void expandSelection(); void positionButtonsInside(int index); void ensureSelectionMinimunSize(); void moveButtonsToPoints(const QVector<QPoint>& points, int& index); void adjustHorizontalCenter(QPoint& center); };","title":"File buttonhandler.h"},{"location":"flameshot/capturebutton_8cpp/","text":"File capturebutton.cpp # FileList > capture > capturebutton.cpp Go to the source code of this file. #include \"capturebutton.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QGraphicsDropShadowEffect>","title":"File capturebutton.cpp"},{"location":"flameshot/capturebutton_8cpp/#file-capturebuttoncpp","text":"FileList > capture > capturebutton.cpp Go to the source code of this file. #include \"capturebutton.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QGraphicsDropShadowEffect>","title":"File capturebutton.cpp"},{"location":"flameshot/capturebutton_8cpp_source/","text":"File capturebutton.cpp # File List > capture > capturebutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturebutton.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QGraphicsDropShadowEffect> CaptureButton::CaptureButton(QWidget* parent) : QPushButton(parent) { init(); } CaptureButton::CaptureButton(const QString& text, QWidget* parent) : QPushButton(text, parent) { init(); } CaptureButton::CaptureButton(const QIcon& icon, const QString& text, QWidget* parent) : QPushButton(icon, text, parent) { init(); } void CaptureButton::init() { setCursor(Qt::ArrowCursor); setFocusPolicy(Qt::NoFocus); auto* dsEffect = new QGraphicsDropShadowEffect(this); dsEffect->setBlurRadius(5); dsEffect->setOffset(0); dsEffect->setColor(QColor(Qt::black)); setGraphicsEffect(dsEffect); } QString CaptureButton::globalStyleSheet() { return CaptureButton(nullptr).styleSheet(); } QString CaptureButton::styleSheet() const { QString baseSheet = \"CaptureButton { border: none;\" \"padding: 3px 8px;\" \"background-color: %1; color: %4 }\" \"CaptureToolButton { border-radius: %3;\" \"padding: 0; }\" \"CaptureButton:hover { background-color: %2; }\" \"CaptureButton:pressed:!hover { \" \"background-color: %1; }\"; // define color when mouse is hovering QColor contrast = ColorUtils::contrastColor(m_mainColor); // foreground color QColor color = ColorUtils::colorIsDark(m_mainColor) ? Qt::white : Qt::black; return baseSheet.arg(m_mainColor.name()) .arg(contrast.name()) .arg(GlobalValues::buttonBaseSize() / 2) .arg(color.name()); } void CaptureButton::setColor(const QColor& c) { m_mainColor = c; setStyleSheet(styleSheet()); } QColor CaptureButton::m_mainColor;","title":"File capturebutton.cpp"},{"location":"flameshot/capturebutton_8cpp_source/#file-capturebuttoncpp","text":"File List > capture > capturebutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturebutton.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QGraphicsDropShadowEffect> CaptureButton::CaptureButton(QWidget* parent) : QPushButton(parent) { init(); } CaptureButton::CaptureButton(const QString& text, QWidget* parent) : QPushButton(text, parent) { init(); } CaptureButton::CaptureButton(const QIcon& icon, const QString& text, QWidget* parent) : QPushButton(icon, text, parent) { init(); } void CaptureButton::init() { setCursor(Qt::ArrowCursor); setFocusPolicy(Qt::NoFocus); auto* dsEffect = new QGraphicsDropShadowEffect(this); dsEffect->setBlurRadius(5); dsEffect->setOffset(0); dsEffect->setColor(QColor(Qt::black)); setGraphicsEffect(dsEffect); } QString CaptureButton::globalStyleSheet() { return CaptureButton(nullptr).styleSheet(); } QString CaptureButton::styleSheet() const { QString baseSheet = \"CaptureButton { border: none;\" \"padding: 3px 8px;\" \"background-color: %1; color: %4 }\" \"CaptureToolButton { border-radius: %3;\" \"padding: 0; }\" \"CaptureButton:hover { background-color: %2; }\" \"CaptureButton:pressed:!hover { \" \"background-color: %1; }\"; // define color when mouse is hovering QColor contrast = ColorUtils::contrastColor(m_mainColor); // foreground color QColor color = ColorUtils::colorIsDark(m_mainColor) ? Qt::white : Qt::black; return baseSheet.arg(m_mainColor.name()) .arg(contrast.name()) .arg(GlobalValues::buttonBaseSize() / 2) .arg(color.name()); } void CaptureButton::setColor(const QColor& c) { m_mainColor = c; setStyleSheet(styleSheet()); } QColor CaptureButton::m_mainColor;","title":"File capturebutton.cpp"},{"location":"flameshot/capturebutton_8h/","text":"File capturebutton.h # FileList > capture > capturebutton.h Go to the source code of this file. #include <QPushButton> Classes # Type Name class CaptureButton","title":"File capturebutton.h"},{"location":"flameshot/capturebutton_8h/#file-capturebuttonh","text":"FileList > capture > capturebutton.h Go to the source code of this file. #include <QPushButton>","title":"File capturebutton.h"},{"location":"flameshot/capturebutton_8h/#classes","text":"Type Name class CaptureButton","title":"Classes"},{"location":"flameshot/capturebutton_8h_source/","text":"File capturebutton.h # File List > capture > capturebutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPushButton> class CaptureButton : public QPushButton { Q_OBJECT public: CaptureButton() = delete; CaptureButton(QWidget* parent = nullptr); CaptureButton(const QString& text, QWidget* parent = nullptr); CaptureButton(const QIcon& icon, const QString& text, QWidget* parent = nullptr); static QString globalStyleSheet(); QString styleSheet() const; void setColor(const QColor& c); private: static QColor m_mainColor; void init(); };","title":"File capturebutton.h"},{"location":"flameshot/capturebutton_8h_source/#file-capturebuttonh","text":"File List > capture > capturebutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QPushButton> class CaptureButton : public QPushButton { Q_OBJECT public: CaptureButton() = delete; CaptureButton(QWidget* parent = nullptr); CaptureButton(const QString& text, QWidget* parent = nullptr); CaptureButton(const QIcon& icon, const QString& text, QWidget* parent = nullptr); static QString globalStyleSheet(); QString styleSheet() const; void setColor(const QColor& c); private: static QColor m_mainColor; void init(); };","title":"File capturebutton.h"},{"location":"flameshot/capturetoolbutton_8cpp/","text":"File capturetoolbutton.cpp # FileList > capture > capturetoolbutton.cpp Go to the source code of this file. #include \"capturetoolbutton.h\" #include \"src/tools/capturetool.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QIcon> #include <QMouseEvent> #include <QPropertyAnimation> #include <QToolTip> Public Static Attributes # Type Name std::map< CaptureTool::Type, int > buttonTypeOrder = { { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 }, { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 }, { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 }, { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 }, { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 }, { CaptureTool::TYPE_CIRCLECOUNT, 10 }, { CaptureTool::TYPE_SELECTIONINDICATOR, 11 }, { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 }, { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 }, { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 }, { CaptureTool::TYPE_ACCEPT, 18 }, { CaptureTool::TYPE\\_OPEN\\_APP, 19 }, { CaptureTool::TYPE\\_EXIT, 20 }, { CaptureTool::TYPE\\_PIN, 21 }, { CaptureTool::TYPE\\_SIZEINCREASE, 22 }, { CaptureTool::TYPE\\_SIZEDECREASE, 23 }, } | Public Static Attributes Documentation # variable buttonTypeOrder # std::map<CaptureTool::Type, int> buttonTypeOrder;","title":"File capturetoolbutton.cpp"},{"location":"flameshot/capturetoolbutton_8cpp/#file-capturetoolbuttoncpp","text":"FileList > capture > capturetoolbutton.cpp Go to the source code of this file. #include \"capturetoolbutton.h\" #include \"src/tools/capturetool.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QIcon> #include <QMouseEvent> #include <QPropertyAnimation> #include <QToolTip>","title":"File capturetoolbutton.cpp"},{"location":"flameshot/capturetoolbutton_8cpp/#public-static-attributes","text":"Type Name std::map< CaptureTool::Type, int > buttonTypeOrder = { { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 }, { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 }, { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 }, { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 }, { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 }, { CaptureTool::TYPE_CIRCLECOUNT, 10 }, { CaptureTool::TYPE_SELECTIONINDICATOR, 11 }, { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 }, { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 }, { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 }, { CaptureTool::TYPE_ACCEPT, 18 }, { CaptureTool::TYPE\\_OPEN\\_APP, 19 }, { CaptureTool::TYPE\\_EXIT, 20 }, { CaptureTool::TYPE\\_PIN, 21 }, { CaptureTool::TYPE\\_SIZEINCREASE, 22 }, { CaptureTool::TYPE\\_SIZEDECREASE, 23 }, } |","title":"Public Static Attributes"},{"location":"flameshot/capturetoolbutton_8cpp/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"flameshot/capturetoolbutton_8cpp/#variable-buttontypeorder","text":"std::map<CaptureTool::Type, int> buttonTypeOrder;","title":"variable buttonTypeOrder"},{"location":"flameshot/capturetoolbutton_8cpp_source/","text":"File capturetoolbutton.cpp # File List > capture > capturetoolbutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturetoolbutton.h\" #include \"src/tools/capturetool.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QIcon> #include <QMouseEvent> #include <QPropertyAnimation> #include <QToolTip> // Button represents a single button of the capture widget, it can enable // multiple functionality. CaptureToolButton::CaptureToolButton(const CaptureTool::Type t, QWidget* parent) : CaptureButton(parent) , m_buttonType(t) , m_tool(nullptr) , m_emergeAnimation(nullptr) { initButton(); if (t == CaptureTool::TYPE_SELECTIONINDICATOR) { QFont f = this->font(); setFont(QFont(f.family(), 7, QFont::Bold)); } else { updateIcon(); } } CaptureToolButton::~CaptureToolButton() { if (m_tool) { delete m_tool; m_tool = nullptr; } if (m_emergeAnimation) { delete m_emergeAnimation; m_emergeAnimation = nullptr; } } void CaptureToolButton::initButton() { if (m_tool) { delete m_tool; m_tool = nullptr; } m_tool = ToolFactory().CreateTool(m_buttonType, this); resize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize()); setMask(QRegion(QRect(-1, -1, GlobalValues::buttonBaseSize() + 2, GlobalValues::buttonBaseSize() + 2), QRegion::Ellipse)); // Set a tooltip showing a shortcut in parentheses (if there is a shortcut) QString tooltip = m_tool->description(); QString shortcut = ConfigHandler().shortcut(QVariant::fromValue(m_buttonType).toString()); if (m_buttonType == CaptureTool::TYPE_COPY && ConfigHandler().copyOnDoubleClick()) { tooltip += QStringLiteral(\" (%1Left Double-Click)\") .arg(shortcut.isEmpty() ? QString() : shortcut + \" or \"); } else if (!shortcut.isEmpty()) { tooltip += QStringLiteral(\" (%1)\").arg(shortcut); } tooltip.replace(\"Return\", \"Enter\"); setToolTip(tooltip); m_emergeAnimation = new QPropertyAnimation(this, \"size\", this); m_emergeAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_emergeAnimation->setDuration(80); m_emergeAnimation->setStartValue(QSize(0, 0)); m_emergeAnimation->setEndValue( QSize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize())); } void CaptureToolButton::updateIcon() { setIcon(icon()); setIconSize(size() * 0.6); } const QList<CaptureTool::Type>& CaptureToolButton::getIterableButtonTypes() { return iterableButtonTypes; } // get icon returns the icon for the type of button QIcon CaptureToolButton::icon() const { return m_tool->icon(m_mainColor, true); } void CaptureToolButton::mousePressEvent(QMouseEvent* e) { activateWindow(); if (e->button() == Qt::LeftButton) { emit pressedButtonLeftClick(this); emit pressed(); } else if (e->button() == Qt::RightButton) { emit pressedButtonRightClick(this); emit pressed(); } } void CaptureToolButton::animatedShow() { if (!isVisible()) { show(); m_emergeAnimation->start(); connect(m_emergeAnimation, &QPropertyAnimation::finished, this, [this]() { updateIcon(); }); } } CaptureTool* CaptureToolButton::tool() const { return m_tool; } void CaptureToolButton::setColor(const QColor& c) { m_mainColor = c; CaptureButton::setColor(c); updateIcon(); } QColor CaptureToolButton::m_mainColor; static std::map<CaptureTool::Type, int> buttonTypeOrder { { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 }, { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 }, { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 }, { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 }, { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 }, { CaptureTool::TYPE_CIRCLECOUNT, 10 }, { CaptureTool::TYPE_SELECTIONINDICATOR, 11 }, { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 }, { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 }, { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 }, { CaptureTool::TYPE_ACCEPT, 18 }, #if !defined(Q_OS_MACOS) { CaptureTool::TYPE_OPEN_APP, 19 }, { CaptureTool::TYPE_EXIT, 20 }, { CaptureTool::TYPE_PIN, 21 }, #else { CaptureTool::TYPE_EXIT, 19 }, { CaptureTool::TYPE_PIN, 20 }, #endif { CaptureTool::TYPE_SIZEINCREASE, 22 }, { CaptureTool::TYPE_SIZEDECREASE, 23 }, }; int CaptureToolButton::getPriorityByButton(CaptureTool::Type b) { auto it = buttonTypeOrder.find(b); return it == buttonTypeOrder.cend() ? (int)buttonTypeOrder.size() : it->second; } QList<CaptureTool::Type> CaptureToolButton::iterableButtonTypes = { CaptureTool::TYPE_PENCIL, CaptureTool::TYPE_DRAWER, CaptureTool::TYPE_ARROW, CaptureTool::TYPE_SELECTION, CaptureTool::TYPE_RECTANGLE, CaptureTool::TYPE_CIRCLE, CaptureTool::TYPE_MARKER, CaptureTool::TYPE_TEXT, CaptureTool::TYPE_CIRCLECOUNT, CaptureTool::TYPE_PIXELATE, CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO, CaptureTool::TYPE_REDO, CaptureTool::TYPE_COPY, CaptureTool::TYPE_SAVE, CaptureTool::TYPE_EXIT, CaptureTool::TYPE_IMAGEUPLOADER, #if !defined(Q_OS_MACOS) CaptureTool::TYPE_OPEN_APP, #endif CaptureTool::TYPE_PIN, CaptureTool::TYPE_SIZEINCREASE, CaptureTool::TYPE_SIZEDECREASE, CaptureTool::TYPE_ACCEPT, };","title":"File capturetoolbutton.cpp"},{"location":"flameshot/capturetoolbutton_8cpp_source/#file-capturetoolbuttoncpp","text":"File List > capture > capturetoolbutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturetoolbutton.h\" #include \"src/tools/capturetool.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QIcon> #include <QMouseEvent> #include <QPropertyAnimation> #include <QToolTip> // Button represents a single button of the capture widget, it can enable // multiple functionality. CaptureToolButton::CaptureToolButton(const CaptureTool::Type t, QWidget* parent) : CaptureButton(parent) , m_buttonType(t) , m_tool(nullptr) , m_emergeAnimation(nullptr) { initButton(); if (t == CaptureTool::TYPE_SELECTIONINDICATOR) { QFont f = this->font(); setFont(QFont(f.family(), 7, QFont::Bold)); } else { updateIcon(); } } CaptureToolButton::~CaptureToolButton() { if (m_tool) { delete m_tool; m_tool = nullptr; } if (m_emergeAnimation) { delete m_emergeAnimation; m_emergeAnimation = nullptr; } } void CaptureToolButton::initButton() { if (m_tool) { delete m_tool; m_tool = nullptr; } m_tool = ToolFactory().CreateTool(m_buttonType, this); resize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize()); setMask(QRegion(QRect(-1, -1, GlobalValues::buttonBaseSize() + 2, GlobalValues::buttonBaseSize() + 2), QRegion::Ellipse)); // Set a tooltip showing a shortcut in parentheses (if there is a shortcut) QString tooltip = m_tool->description(); QString shortcut = ConfigHandler().shortcut(QVariant::fromValue(m_buttonType).toString()); if (m_buttonType == CaptureTool::TYPE_COPY && ConfigHandler().copyOnDoubleClick()) { tooltip += QStringLiteral(\" (%1Left Double-Click)\") .arg(shortcut.isEmpty() ? QString() : shortcut + \" or \"); } else if (!shortcut.isEmpty()) { tooltip += QStringLiteral(\" (%1)\").arg(shortcut); } tooltip.replace(\"Return\", \"Enter\"); setToolTip(tooltip); m_emergeAnimation = new QPropertyAnimation(this, \"size\", this); m_emergeAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_emergeAnimation->setDuration(80); m_emergeAnimation->setStartValue(QSize(0, 0)); m_emergeAnimation->setEndValue( QSize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize())); } void CaptureToolButton::updateIcon() { setIcon(icon()); setIconSize(size() * 0.6); } const QList<CaptureTool::Type>& CaptureToolButton::getIterableButtonTypes() { return iterableButtonTypes; } // get icon returns the icon for the type of button QIcon CaptureToolButton::icon() const { return m_tool->icon(m_mainColor, true); } void CaptureToolButton::mousePressEvent(QMouseEvent* e) { activateWindow(); if (e->button() == Qt::LeftButton) { emit pressedButtonLeftClick(this); emit pressed(); } else if (e->button() == Qt::RightButton) { emit pressedButtonRightClick(this); emit pressed(); } } void CaptureToolButton::animatedShow() { if (!isVisible()) { show(); m_emergeAnimation->start(); connect(m_emergeAnimation, &QPropertyAnimation::finished, this, [this]() { updateIcon(); }); } } CaptureTool* CaptureToolButton::tool() const { return m_tool; } void CaptureToolButton::setColor(const QColor& c) { m_mainColor = c; CaptureButton::setColor(c); updateIcon(); } QColor CaptureToolButton::m_mainColor; static std::map<CaptureTool::Type, int> buttonTypeOrder { { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 }, { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 }, { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 }, { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 }, { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 }, { CaptureTool::TYPE_CIRCLECOUNT, 10 }, { CaptureTool::TYPE_SELECTIONINDICATOR, 11 }, { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 }, { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 }, { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 }, { CaptureTool::TYPE_ACCEPT, 18 }, #if !defined(Q_OS_MACOS) { CaptureTool::TYPE_OPEN_APP, 19 }, { CaptureTool::TYPE_EXIT, 20 }, { CaptureTool::TYPE_PIN, 21 }, #else { CaptureTool::TYPE_EXIT, 19 }, { CaptureTool::TYPE_PIN, 20 }, #endif { CaptureTool::TYPE_SIZEINCREASE, 22 }, { CaptureTool::TYPE_SIZEDECREASE, 23 }, }; int CaptureToolButton::getPriorityByButton(CaptureTool::Type b) { auto it = buttonTypeOrder.find(b); return it == buttonTypeOrder.cend() ? (int)buttonTypeOrder.size() : it->second; } QList<CaptureTool::Type> CaptureToolButton::iterableButtonTypes = { CaptureTool::TYPE_PENCIL, CaptureTool::TYPE_DRAWER, CaptureTool::TYPE_ARROW, CaptureTool::TYPE_SELECTION, CaptureTool::TYPE_RECTANGLE, CaptureTool::TYPE_CIRCLE, CaptureTool::TYPE_MARKER, CaptureTool::TYPE_TEXT, CaptureTool::TYPE_CIRCLECOUNT, CaptureTool::TYPE_PIXELATE, CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO, CaptureTool::TYPE_REDO, CaptureTool::TYPE_COPY, CaptureTool::TYPE_SAVE, CaptureTool::TYPE_EXIT, CaptureTool::TYPE_IMAGEUPLOADER, #if !defined(Q_OS_MACOS) CaptureTool::TYPE_OPEN_APP, #endif CaptureTool::TYPE_PIN, CaptureTool::TYPE_SIZEINCREASE, CaptureTool::TYPE_SIZEDECREASE, CaptureTool::TYPE_ACCEPT, };","title":"File capturetoolbutton.cpp"},{"location":"flameshot/capturetoolbutton_8h/","text":"File capturetoolbutton.h # FileList > capture > capturetoolbutton.h Go to the source code of this file. #include \"capturebutton.h\" #include \"src/tools/capturetool.h\" #include <QMap> #include <QVector> Classes # Type Name class CaptureToolButton","title":"File capturetoolbutton.h"},{"location":"flameshot/capturetoolbutton_8h/#file-capturetoolbuttonh","text":"FileList > capture > capturetoolbutton.h Go to the source code of this file. #include \"capturebutton.h\" #include \"src/tools/capturetool.h\" #include <QMap> #include <QVector>","title":"File capturetoolbutton.h"},{"location":"flameshot/capturetoolbutton_8h/#classes","text":"Type Name class CaptureToolButton","title":"Classes"},{"location":"flameshot/capturetoolbutton_8h_source/","text":"File capturetoolbutton.h # File List > capture > capturetoolbutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturebutton.h\" #include \"src/tools/capturetool.h\" #include <QMap> #include <QVector> class QWidget; class QPropertyAnimation; class CaptureToolButton : public CaptureButton { Q_OBJECT public: explicit CaptureToolButton(const CaptureTool::Type, QWidget* parent = nullptr); ~CaptureToolButton(); static const QList<CaptureTool::Type>& getIterableButtonTypes(); static int getPriorityByButton(CaptureTool::Type); QString name() const; QString description() const; QIcon icon() const; CaptureTool* tool() const; void setColor(const QColor& c); void animatedShow(); protected: void mousePressEvent(QMouseEvent* e) override; static QList<CaptureTool::Type> iterableButtonTypes; CaptureTool* m_tool; signals: void pressedButtonLeftClick(CaptureToolButton*); void pressedButtonRightClick(CaptureToolButton*); private: CaptureToolButton(QWidget* parent = nullptr); CaptureTool::Type m_buttonType; QPropertyAnimation* m_emergeAnimation; static QColor m_mainColor; void initButton(); void updateIcon(); };","title":"File capturetoolbutton.h"},{"location":"flameshot/capturetoolbutton_8h_source/#file-capturetoolbuttonh","text":"File List > capture > capturetoolbutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"capturebutton.h\" #include \"src/tools/capturetool.h\" #include <QMap> #include <QVector> class QWidget; class QPropertyAnimation; class CaptureToolButton : public CaptureButton { Q_OBJECT public: explicit CaptureToolButton(const CaptureTool::Type, QWidget* parent = nullptr); ~CaptureToolButton(); static const QList<CaptureTool::Type>& getIterableButtonTypes(); static int getPriorityByButton(CaptureTool::Type); QString name() const; QString description() const; QIcon icon() const; CaptureTool* tool() const; void setColor(const QColor& c); void animatedShow(); protected: void mousePressEvent(QMouseEvent* e) override; static QList<CaptureTool::Type> iterableButtonTypes; CaptureTool* m_tool; signals: void pressedButtonLeftClick(CaptureToolButton*); void pressedButtonRightClick(CaptureToolButton*); private: CaptureToolButton(QWidget* parent = nullptr); CaptureTool::Type m_buttonType; QPropertyAnimation* m_emergeAnimation; static QColor m_mainColor; void initButton(); void updateIcon(); };","title":"File capturetoolbutton.h"},{"location":"flameshot/capturetoolobjects_8cpp/","text":"File capturetoolobjects.cpp # FileList > capture > capturetoolobjects.cpp Go to the source code of this file. #include \"capturetoolobjects.h\" Macros # Type Name define SEARCH_RADIUS_FAR 5 define SEARCH_RADIUS_NEAR 3 define SEARCH_RADIUS_TEXT_HANDICAP 5 Macro Definition Documentation # define SEARCH_RADIUS_FAR # #define SEARCH_RADIUS_FAR 5 define SEARCH_RADIUS_NEAR # #define SEARCH_RADIUS_NEAR 3 define SEARCH_RADIUS_TEXT_HANDICAP # #define SEARCH_RADIUS_TEXT_HANDICAP 5","title":"File capturetoolobjects.cpp"},{"location":"flameshot/capturetoolobjects_8cpp/#file-capturetoolobjectscpp","text":"FileList > capture > capturetoolobjects.cpp Go to the source code of this file. #include \"capturetoolobjects.h\"","title":"File capturetoolobjects.cpp"},{"location":"flameshot/capturetoolobjects_8cpp/#macros","text":"Type Name define SEARCH_RADIUS_FAR 5 define SEARCH_RADIUS_NEAR 3 define SEARCH_RADIUS_TEXT_HANDICAP 5","title":"Macros"},{"location":"flameshot/capturetoolobjects_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_far","text":"#define SEARCH_RADIUS_FAR 5","title":"define SEARCH_RADIUS_FAR"},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_near","text":"#define SEARCH_RADIUS_NEAR 3","title":"define SEARCH_RADIUS_NEAR"},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_text_handicap","text":"#define SEARCH_RADIUS_TEXT_HANDICAP 5","title":"define SEARCH_RADIUS_TEXT_HANDICAP"},{"location":"flameshot/capturetoolobjects_8cpp_source/","text":"File capturetoolobjects.cpp # File List > capture > capturetoolobjects.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yurii Puchkov & Contributors #include \"capturetoolobjects.h\" #define SEARCH_RADIUS_NEAR 3 #define SEARCH_RADIUS_FAR 5 #define SEARCH_RADIUS_TEXT_HANDICAP 5 CaptureToolObjects::CaptureToolObjects(QObject* parent) : QObject(parent) {} void CaptureToolObjects::append(const QPointer<CaptureTool>& captureTool) { if (!captureTool.isNull()) { m_captureToolObjects.append(captureTool->copy(captureTool->parent())); m_imageCache.clear(); } } void CaptureToolObjects::insert(int index, const QPointer<CaptureTool>& captureTool) { if (!captureTool.isNull() && index >= 0 && index <= m_captureToolObjects.size()) { m_captureToolObjects.insert(index, captureTool->copy(captureTool->parent())); m_imageCache.clear(); } } QPointer<CaptureTool> CaptureToolObjects::at(int index) { if (index >= 0 && index < m_captureToolObjects.size()) { return m_captureToolObjects[index]; } return nullptr; } void CaptureToolObjects::clear() { m_captureToolObjects.clear(); } QList<QPointer<CaptureTool>> CaptureToolObjects::captureToolObjects() { return m_captureToolObjects; } int CaptureToolObjects::size() { return m_captureToolObjects.size(); } void CaptureToolObjects::removeAt(int index) { if (index >= 0 && index < m_captureToolObjects.size()) { m_captureToolObjects.removeAt(index); m_imageCache.clear(); } } int CaptureToolObjects::find(const QPoint& pos, const QSize& captureSize) { if (m_captureToolObjects.empty()) { return -1; } QPixmap pixmap(captureSize); pixmap.fill(Qt::transparent); QPainter painter(&pixmap); // first attempt to find at exact position int radius = SEARCH_RADIUS_NEAR; int index = findWithRadius(painter, pixmap, pos, radius); if (-1 == index) { // second attempt to find at position with radius radius = SEARCH_RADIUS_FAR; pixmap.fill(Qt::transparent); index = findWithRadius(painter, pixmap, pos, radius); } return index; } int CaptureToolObjects::findWithRadius(QPainter& painter, QPixmap& pixmap, const QPoint& pos, int radius) { int index = m_captureToolObjects.size() - 1; bool useCache = true; m_imageCache.clear(); if (m_imageCache.size() != m_captureToolObjects.size() && index >= 0) { // TODO - is not optimal and cache will be used just after first tool // object selecting m_imageCache.clear(); useCache = false; } for (; index >= 0; --index) { int currentRadius = radius; QImage image; auto toolItem = m_captureToolObjects.at(index); if (useCache) { image = m_imageCache.at(index); } else { // create transparent image in memory and draw toolItem on it toolItem->drawSearchArea(painter, pixmap); // get color at mouse clicked position in area +/- currentRadius image = pixmap.toImage(); m_imageCache.insert(0, image); } if (toolItem->type() == CaptureTool::TYPE_TEXT) { if (currentRadius > SEARCH_RADIUS_NEAR) { // Text already has a big currentRadius and no need to search // with a bit bigger currentRadius than // SEARCH_RADIUS_TEXT_HANDICAP + SEARCH_RADIUS_NEAR continue; } // Text has spaces inside to need to take a bigger currentRadius for // text objects search currentRadius += SEARCH_RADIUS_TEXT_HANDICAP; } for (int x = pos.x() - currentRadius; x <= pos.x() + currentRadius; ++x) { for (int y = pos.y() - currentRadius; y <= pos.y() + currentRadius; ++y) { QRgb rgb = image.pixel(x, y); if (rgb != 0) { // object was found, return it index (layer index) return index; } } } } // no object at current pos found return -1; } CaptureToolObjects& CaptureToolObjects::operator=( const CaptureToolObjects& other) { // remove extra items for this if size is bigger while (this->m_captureToolObjects.size() > other.m_captureToolObjects.size()) { this->m_captureToolObjects.removeLast(); } int count = 0; for (const auto& item : other.m_captureToolObjects) { QPointer<CaptureTool> itemCopy = item->copy(item->parent()); if (count < this->m_captureToolObjects.size()) { this->m_captureToolObjects[count] = itemCopy; } else { this->m_captureToolObjects.append(itemCopy); } count++; } return *this; }","title":"File capturetoolobjects.cpp"},{"location":"flameshot/capturetoolobjects_8cpp_source/#file-capturetoolobjectscpp","text":"File List > capture > capturetoolobjects.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yurii Puchkov & Contributors #include \"capturetoolobjects.h\" #define SEARCH_RADIUS_NEAR 3 #define SEARCH_RADIUS_FAR 5 #define SEARCH_RADIUS_TEXT_HANDICAP 5 CaptureToolObjects::CaptureToolObjects(QObject* parent) : QObject(parent) {} void CaptureToolObjects::append(const QPointer<CaptureTool>& captureTool) { if (!captureTool.isNull()) { m_captureToolObjects.append(captureTool->copy(captureTool->parent())); m_imageCache.clear(); } } void CaptureToolObjects::insert(int index, const QPointer<CaptureTool>& captureTool) { if (!captureTool.isNull() && index >= 0 && index <= m_captureToolObjects.size()) { m_captureToolObjects.insert(index, captureTool->copy(captureTool->parent())); m_imageCache.clear(); } } QPointer<CaptureTool> CaptureToolObjects::at(int index) { if (index >= 0 && index < m_captureToolObjects.size()) { return m_captureToolObjects[index]; } return nullptr; } void CaptureToolObjects::clear() { m_captureToolObjects.clear(); } QList<QPointer<CaptureTool>> CaptureToolObjects::captureToolObjects() { return m_captureToolObjects; } int CaptureToolObjects::size() { return m_captureToolObjects.size(); } void CaptureToolObjects::removeAt(int index) { if (index >= 0 && index < m_captureToolObjects.size()) { m_captureToolObjects.removeAt(index); m_imageCache.clear(); } } int CaptureToolObjects::find(const QPoint& pos, const QSize& captureSize) { if (m_captureToolObjects.empty()) { return -1; } QPixmap pixmap(captureSize); pixmap.fill(Qt::transparent); QPainter painter(&pixmap); // first attempt to find at exact position int radius = SEARCH_RADIUS_NEAR; int index = findWithRadius(painter, pixmap, pos, radius); if (-1 == index) { // second attempt to find at position with radius radius = SEARCH_RADIUS_FAR; pixmap.fill(Qt::transparent); index = findWithRadius(painter, pixmap, pos, radius); } return index; } int CaptureToolObjects::findWithRadius(QPainter& painter, QPixmap& pixmap, const QPoint& pos, int radius) { int index = m_captureToolObjects.size() - 1; bool useCache = true; m_imageCache.clear(); if (m_imageCache.size() != m_captureToolObjects.size() && index >= 0) { // TODO - is not optimal and cache will be used just after first tool // object selecting m_imageCache.clear(); useCache = false; } for (; index >= 0; --index) { int currentRadius = radius; QImage image; auto toolItem = m_captureToolObjects.at(index); if (useCache) { image = m_imageCache.at(index); } else { // create transparent image in memory and draw toolItem on it toolItem->drawSearchArea(painter, pixmap); // get color at mouse clicked position in area +/- currentRadius image = pixmap.toImage(); m_imageCache.insert(0, image); } if (toolItem->type() == CaptureTool::TYPE_TEXT) { if (currentRadius > SEARCH_RADIUS_NEAR) { // Text already has a big currentRadius and no need to search // with a bit bigger currentRadius than // SEARCH_RADIUS_TEXT_HANDICAP + SEARCH_RADIUS_NEAR continue; } // Text has spaces inside to need to take a bigger currentRadius for // text objects search currentRadius += SEARCH_RADIUS_TEXT_HANDICAP; } for (int x = pos.x() - currentRadius; x <= pos.x() + currentRadius; ++x) { for (int y = pos.y() - currentRadius; y <= pos.y() + currentRadius; ++y) { QRgb rgb = image.pixel(x, y); if (rgb != 0) { // object was found, return it index (layer index) return index; } } } } // no object at current pos found return -1; } CaptureToolObjects& CaptureToolObjects::operator=( const CaptureToolObjects& other) { // remove extra items for this if size is bigger while (this->m_captureToolObjects.size() > other.m_captureToolObjects.size()) { this->m_captureToolObjects.removeLast(); } int count = 0; for (const auto& item : other.m_captureToolObjects) { QPointer<CaptureTool> itemCopy = item->copy(item->parent()); if (count < this->m_captureToolObjects.size()) { this->m_captureToolObjects[count] = itemCopy; } else { this->m_captureToolObjects.append(itemCopy); } count++; } return *this; }","title":"File capturetoolobjects.cpp"},{"location":"flameshot/capturetoolobjects_8h/","text":"File capturetoolobjects.h # FileList > capture > capturetoolobjects.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include <QList> #include <QPointer> Classes # Type Name class CaptureToolObjects","title":"File capturetoolobjects.h"},{"location":"flameshot/capturetoolobjects_8h/#file-capturetoolobjectsh","text":"FileList > capture > capturetoolobjects.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include <QList> #include <QPointer>","title":"File capturetoolobjects.h"},{"location":"flameshot/capturetoolobjects_8h/#classes","text":"Type Name class CaptureToolObjects","title":"Classes"},{"location":"flameshot/capturetoolobjects_8h_source/","text":"File capturetoolobjects.h # File List > capture > capturetoolobjects.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yurii Puchkov & Contributors #ifndef FLAMESHOT_CAPTURETOOLOBJECTS_H #define FLAMESHOT_CAPTURETOOLOBJECTS_H #include \"src/tools/capturetool.h\" #include <QList> #include <QPointer> class CaptureToolObjects : public QObject { public: explicit CaptureToolObjects(QObject* parent = nullptr); QList<QPointer<CaptureTool>> captureToolObjects(); void append(const QPointer<CaptureTool>& captureTool); void insert(int index, const QPointer<CaptureTool>& captureTool); void removeAt(int index); void clear(); int size(); int find(const QPoint& pos, const QSize& captureSize); QPointer<CaptureTool> at(int index); CaptureToolObjects& operator=(const CaptureToolObjects& other); private: int findWithRadius(QPainter& painter, QPixmap& pixmap, const QPoint& pos, int radius = 0); // class members QList<QPointer<CaptureTool>> m_captureToolObjects; QVector<QImage> m_imageCache; }; #endif // FLAMESHOT_CAPTURETOOLOBJECTS_H","title":"File capturetoolobjects.h"},{"location":"flameshot/capturetoolobjects_8h_source/#file-capturetoolobjectsh","text":"File List > capture > capturetoolobjects.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021 Yurii Puchkov & Contributors #ifndef FLAMESHOT_CAPTURETOOLOBJECTS_H #define FLAMESHOT_CAPTURETOOLOBJECTS_H #include \"src/tools/capturetool.h\" #include <QList> #include <QPointer> class CaptureToolObjects : public QObject { public: explicit CaptureToolObjects(QObject* parent = nullptr); QList<QPointer<CaptureTool>> captureToolObjects(); void append(const QPointer<CaptureTool>& captureTool); void insert(int index, const QPointer<CaptureTool>& captureTool); void removeAt(int index); void clear(); int size(); int find(const QPoint& pos, const QSize& captureSize); QPointer<CaptureTool> at(int index); CaptureToolObjects& operator=(const CaptureToolObjects& other); private: int findWithRadius(QPainter& painter, QPixmap& pixmap, const QPoint& pos, int radius = 0); // class members QList<QPointer<CaptureTool>> m_captureToolObjects; QVector<QImage> m_imageCache; }; #endif // FLAMESHOT_CAPTURETOOLOBJECTS_H","title":"File capturetoolobjects.h"},{"location":"flameshot/capturewidget_8cpp/","text":"File capturewidget.cpp # FileList > capture > capturewidget.cpp Go to the source code of this file. #include \"capturewidget.h\" #include \"abstractlogger.h\" #include \"copytool.h\" #include \"src/config/cacheutils.h\" #include \"src/config/generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/utils/systemnotification.h\" #include \"src/widgets/capture/colorpicker.h\" #include \"src/widgets/capture/hovereventfilter.h\" #include \"src/widgets/capture/modificationcommand.h\" #include \"src/widgets/capture/notifierbox.h\" #include \"src/widgets/capture/overlaymessage.h\" #include \"src/widgets/orientablepushbutton.h\" #include \"src/widgets/panel/sidepanelwidget.h\" #include \"src/widgets/panel/utilitypanel.h\" #include <QApplication> #include <QDateTime> #include <QDebug> #include <QDesktopWidget> #include <QFontMetrics> #include <QLabel> #include <QPaintEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <draggablewidgetmaker.h> #include \"src/widgets/updatenotificationwidget.h\" Macros # Type Name define MOUSE_DISTANCE_TO_START_MOVING 3 Macro Definition Documentation # define MOUSE_DISTANCE_TO_START_MOVING # #define MOUSE_DISTANCE_TO_START_MOVING 3","title":"File capturewidget.cpp"},{"location":"flameshot/capturewidget_8cpp/#file-capturewidgetcpp","text":"FileList > capture > capturewidget.cpp Go to the source code of this file. #include \"capturewidget.h\" #include \"abstractlogger.h\" #include \"copytool.h\" #include \"src/config/cacheutils.h\" #include \"src/config/generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/utils/systemnotification.h\" #include \"src/widgets/capture/colorpicker.h\" #include \"src/widgets/capture/hovereventfilter.h\" #include \"src/widgets/capture/modificationcommand.h\" #include \"src/widgets/capture/notifierbox.h\" #include \"src/widgets/capture/overlaymessage.h\" #include \"src/widgets/orientablepushbutton.h\" #include \"src/widgets/panel/sidepanelwidget.h\" #include \"src/widgets/panel/utilitypanel.h\" #include <QApplication> #include <QDateTime> #include <QDebug> #include <QDesktopWidget> #include <QFontMetrics> #include <QLabel> #include <QPaintEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <draggablewidgetmaker.h> #include \"src/widgets/updatenotificationwidget.h\"","title":"File capturewidget.cpp"},{"location":"flameshot/capturewidget_8cpp/#macros","text":"Type Name define MOUSE_DISTANCE_TO_START_MOVING 3","title":"Macros"},{"location":"flameshot/capturewidget_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/capturewidget_8cpp/#define-mouse_distance_to_start_moving","text":"#define MOUSE_DISTANCE_TO_START_MOVING 3","title":"define MOUSE_DISTANCE_TO_START_MOVING"},{"location":"flameshot/capturewidget_8cpp_source/","text":"File capturewidget.cpp # File List > capture > capturewidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.cpp, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #include \"capturewidget.h\" #include \"abstractlogger.h\" #include \"copytool.h\" #include \"src/config/cacheutils.h\" #include \"src/config/generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/utils/systemnotification.h\" #include \"src/widgets/capture/colorpicker.h\" #include \"src/widgets/capture/hovereventfilter.h\" #include \"src/widgets/capture/modificationcommand.h\" #include \"src/widgets/capture/notifierbox.h\" #include \"src/widgets/capture/overlaymessage.h\" #include \"src/widgets/orientablepushbutton.h\" #include \"src/widgets/panel/sidepanelwidget.h\" #include \"src/widgets/panel/utilitypanel.h\" #include <QApplication> #include <QDateTime> #include <QDebug> #include <QDesktopWidget> #include <QFontMetrics> #include <QLabel> #include <QPaintEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <draggablewidgetmaker.h> #if !defined(DISABLE_UPDATE_CHECKER) #include \"src/widgets/updatenotificationwidget.h\" #endif #define MOUSE_DISTANCE_TO_START_MOVING 3 // CaptureWidget is the main component used to capture the screen. It contains // an area of selection with its respective buttons. // enableSaveWindow CaptureWidget::CaptureWidget(const CaptureRequest& req, bool fullScreen, QWidget* parent) : QWidget(parent) , m_mouseIsClicked(false) , m_captureDone(false) , m_previewEnabled(true) , m_adjustmentButtonPressed(false) , m_configError(false) , m_configErrorResolved(false) , m_activeButton(nullptr) , m_activeTool(nullptr) , m_toolWidget(nullptr) , m_colorPicker(nullptr) , m_lastMouseWheel(0) #if !defined(DISABLE_UPDATE_CHECKER) , m_updateNotificationWidget(nullptr) #endif , m_activeToolIsMoved(false) , m_panel(nullptr) , m_sidePanel(nullptr) , m_selection(nullptr) , m_magnifier(nullptr) , m_existingObjectIsChanged(false) , m_startMove(false) , m_toolSizeByKeyboard(0) , m_xywhDisplay(false) { m_undoStack.setUndoLimit(ConfigHandler().undoLimit()); m_context.circleCount = 1; // Base config of the widget m_eventFilter = new HoverEventFilter(this); connect(m_eventFilter, &HoverEventFilter::hoverIn, this, &CaptureWidget::childEnter); connect(m_eventFilter, &HoverEventFilter::hoverOut, this, &CaptureWidget::childLeave); connect(&m_xywhTimer, SIGNAL(timeout()), this, SLOT(xywhTick())); setAttribute(Qt::WA_DeleteOnClose); setAttribute(Qt::WA_QuitOnClose, false); m_opacity = m_config.contrastOpacity(); m_uiColor = m_config.uiColor(); m_contrastUiColor = m_config.contrastUiColor(); setMouseTracking(true); initContext(fullScreen, req); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) // Top left of the whole set of screens QPoint topLeft(0, 0); #endif if (fullScreen) { // Grab Screenshot bool ok = true; m_context.screenshot = ScreenGrabber().grabEntireDesktop(ok); if (!ok) { AbstractLogger::error() << tr(\"Unable to capture screen\"); this->close(); } m_context.origScreenshot = m_context.screenshot; #if defined(Q_OS_WIN) // Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging #if !defined(FLAMESHOT_DEBUG_CAPTURE) setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::SubWindow // Hides the taskbar icon ); #endif for (QScreen* const screen : QGuiApplication::screens()) { QPoint topLeftScreen = screen->geometry().topLeft(); if (topLeftScreen.x() < topLeft.x()) { topLeft.setX(topLeftScreen.x()); } if (topLeftScreen.y() < topLeft.y()) { topLeft.setY(topLeftScreen.y()); } } move(topLeft); resize(pixmap().size()); #elif defined(Q_OS_MACOS) // Emulate fullscreen mode // setWindowFlags(Qt::WindowStaysOnTopHint | // Qt::BypassWindowManagerHint | // Qt::FramelessWindowHint | // Qt::NoDropShadowWindowHint | Qt::ToolTip | // Qt::Popup // ); QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); move(currentScreen->geometry().x(), currentScreen->geometry().y()); resize(currentScreen->size()); #else // Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging #if !defined(FLAMESHOT_DEBUG_CAPTURE) setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::Tool); resize(pixmap().size()); #endif #endif } QVector<QRect> areas; if (m_context.fullscreen) { QPoint topLeftOffset = QPoint(0, 0); #if defined(Q_OS_WIN) topLeftOffset = topLeft; #endif #if defined(Q_OS_MACOS) // MacOS works just with one active display, so we need to append // just one current display and keep multiple displays logic for // other OS QRect r; QScreen* screen = QGuiAppCurrentScreen().currentScreen(); r = screen->geometry(); // all calculations are processed according to (0, 0) start // point so we need to move current object to (0, 0) r.moveTo(0, 0); areas.append(r); #else for (QScreen* const screen : QGuiApplication::screens()) { QRect r = screen->geometry(); r.moveTo(r.x() / screen->devicePixelRatio(), r.y() / screen->devicePixelRatio()); r.moveTo(r.topLeft() - topLeftOffset); areas.append(r); } #endif } else { areas.append(rect()); } m_buttonHandler = new ButtonHandler(this); m_buttonHandler->updateScreenRegions(areas); m_buttonHandler->hide(); initButtons(); initSelection(); // button handler must be initialized before initShortcuts(); // must be called after initSelection // init magnify if (m_config.showMagnifier()) { m_magnifier = new MagnifierWidget( m_context.screenshot, m_uiColor, m_config.squareMagnifier(), this); } // Init color picker m_colorPicker = new ColorPicker(this); connect(m_colorPicker, &ColorPicker::colorSelected, this, [this](const QColor& c) { m_context.mousePos = mapFromGlobal(QCursor::pos()); setDrawColor(c); }); m_colorPicker->hide(); // Init tool size sigslots connect(this, &CaptureWidget::toolSizeChanged, this, &CaptureWidget::onToolSizeChanged); // Init notification widget m_notifierBox = new NotifierBox(this); m_notifierBox->hide(); connect(m_notifierBox, &NotifierBox::hidden, this, [this]() { // Show cursor if it was hidden while adjusting tool size updateCursor(); m_toolSizeByKeyboard = 0; onToolSizeChanged(m_context.toolSize); onToolSizeSettled(m_context.toolSize); }); initPanel(); m_config.checkAndHandleError(); if (m_config.hasError()) { m_configError = true; } connect(ConfigHandler::getInstance(), &ConfigHandler::error, this, [=]() { m_configError = true; m_configErrorResolved = false; OverlayMessage::instance()->update(); }); connect( ConfigHandler::getInstance(), &ConfigHandler::errorResolved, this, [=]() { m_configError = false; m_configErrorResolved = true; OverlayMessage::instance()->update(); }); OverlayMessage::init(this, QGuiAppCurrentScreen().currentScreen()->geometry()); if (m_config.showHelp()) { initHelpMessage(); OverlayMessage::push(m_helpMessage); } updateCursor(); } CaptureWidget::~CaptureWidget() { #if defined(Q_OS_MACOS) for (QWidget* widget : qApp->topLevelWidgets()) { QString className(widget->metaObject()->className()); if (0 == className.compare(CaptureWidget::staticMetaObject.className())) { widget->showNormal(); widget->hide(); break; } } #endif if (m_captureDone) { auto lastRegion = m_selection->geometry(); setLastRegion(lastRegion); QRect geometry(m_context.selection); geometry.setTopLeft(geometry.topLeft() + m_context.widgetOffset); Flameshot::instance()->exportCapture( pixmap(), geometry, m_context.request); } else { emit Flameshot::instance()->captureFailed(); } } void CaptureWidget::initButtons() { auto allButtonTypes = CaptureToolButton::getIterableButtonTypes(); auto visibleButtonTypes = m_config.buttons(); if ((m_context.request.tasks() == CaptureRequest::NO_TASK) || (m_context.request.tasks() == CaptureRequest::PRINT_GEOMETRY)) { allButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT); visibleButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT); } else { // Remove irrelevant buttons from both lists for (auto* buttonList : { &allButtonTypes, &visibleButtonTypes }) { buttonList->removeOne(CaptureTool::TYPE_SAVE); buttonList->removeOne(CaptureTool::TYPE_COPY); buttonList->removeOne(CaptureTool::TYPE_IMAGEUPLOADER); buttonList->removeOne(CaptureTool::TYPE_OPEN_APP); buttonList->removeOne(CaptureTool::TYPE_PIN); } } QVector<CaptureToolButton*> vectorButtons; // Add all buttons but hide those that were disabled in the Interface config // This will allow keyboard shortcuts for those buttons to work for (CaptureTool::Type t : allButtonTypes) { auto* b = new CaptureToolButton(t, this); if (t == CaptureTool::TYPE_SELECTIONINDICATOR) { m_sizeIndButton = b; } b->setColor(m_uiColor); b->hide(); // must be enabled for SelectionWidget's eventFilter to work correctly b->setAttribute(Qt::WA_NoMousePropagation); makeChild(b); switch (t) { case CaptureTool::TYPE_UNDO: case CaptureTool::TYPE_REDO: // nothing to do, just skip non-dynamic buttons with existing // hard coded slots break; default: // Set shortcuts for a tool QString shortcut = ConfigHandler().shortcut(QVariant::fromValue(t).toString()); if (!shortcut.isNull()) { auto shortcuts = newShortcut(shortcut, this, nullptr); for (auto* shortcut : shortcuts) { connect(shortcut, &QShortcut::activated, this, [=]() { setState(b); }); } } break; } m_tools[t] = b->tool(); connect(b->tool(), &CaptureTool::requestAction, this, &CaptureWidget::handleToolSignal); if (visibleButtonTypes.contains(t)) { connect(b, &CaptureToolButton::pressedButtonLeftClick, this, &CaptureWidget::handleButtonLeftClick); if (b->tool()->isSelectable()) { connect(b, &CaptureToolButton::pressedButtonRightClick, this, &CaptureWidget::handleButtonRightClick); } vectorButtons << b; } } m_buttonHandler->setButtons(vectorButtons); } void CaptureWidget::handleButtonRightClick(CaptureToolButton* b) { if (!b) { return; } // if button already selected, do not deselect it on right click if (!m_activeButton || m_activeButton != b) { setState(b); } if (!m_panel->isVisible()) { m_panel->show(); } } void CaptureWidget::handleButtonLeftClick(CaptureToolButton* b) { if (!b) { return; } setState(b); } void CaptureWidget::xywhTick() { m_xywhDisplay = false; repaint(); } void CaptureWidget::showxywh(bool show) { int timeout = ConfigHandler().value(\"showSelectionGeometryHideTime\").toInt(); m_xywhDisplay = show; m_xywhTimer.stop(); repaint(); if (show && timeout != 0) { m_xywhTimer.start(timeout); } } void CaptureWidget::initHelpMessage() { QList<QPair<QString, QString>> keyMap; if (keyMap.isEmpty()) { keyMap << QPair(tr(\"Mouse\"), tr(\"Select screenshot area\")); using CT = CaptureTool; for (auto toolType : { CT::TYPE_ACCEPT, CT::TYPE_SAVE, CT::TYPE_COPY }) { if (!m_tools.contains(toolType)) { continue; } auto* tool = m_tools[toolType]; QString shortcut = ConfigHandler().shortcut( QVariant::fromValue(toolType).toString()); shortcut.replace(\"Return\", \"Enter\"); if (!shortcut.isEmpty()) { keyMap << QPair(shortcut, tool->description()); } } keyMap << QPair(tr(\"Mouse Wheel\"), tr(\"Change tool size\")); keyMap << QPair(tr(\"Right Click\"), tr(\"Show color picker\")); keyMap << QPair(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\"), tr(\"Open side panel\")); keyMap << QPair(tr(\"Esc\"), tr(\"Exit\")); } m_helpMessage = OverlayMessage::compileFromKeyMap(keyMap); } QPixmap CaptureWidget::pixmap() { return m_context.selectedScreenshotArea(); } // Finish whatever the current tool is doing, if there is a current active // tool. bool CaptureWidget::commitCurrentTool() { if (m_activeTool) { processPixmapWithTool(&m_context.screenshot, m_activeTool); if (m_activeTool->isValid() && !m_activeTool->editMode() && m_toolWidget) { pushToolToStack(); } if (m_toolWidget) { m_toolWidget->update(); } releaseActiveTool(); return true; } return false; } void CaptureWidget::deleteToolWidgetOrClose() { if (m_activeButton != nullptr) { uncheckActiveTool(); } else if (m_panel->activeLayerIndex() >= 0) { // remove active tool selection m_panel->setActiveLayer(-1); } else if (m_panel->isVisible()) { // hide panel if visible m_panel->hide(); } else if (m_toolWidget) { // delete toolWidget if exists m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } else if (m_colorPicker && m_colorPicker->isVisible()) { m_colorPicker->hide(); } else { // close CaptureWidget close(); } } void CaptureWidget::releaseActiveTool() { if (m_activeTool) { if (m_activeTool->editMode()) { // Object shouldn't be deleted here because it is in the undo/redo // stack, just set current pointer to null m_activeTool->setEditMode(false); if (m_activeTool->isChanged()) { pushObjectsStateToUndoStack(); } } else { delete m_activeTool; } m_activeTool = nullptr; } if (m_toolWidget) { m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } } void CaptureWidget::uncheckActiveTool() { // uncheck active tool m_panel->setToolWidget(nullptr); m_activeButton->setColor(m_uiColor); updateTool(activeButtonTool()); m_activeButton = nullptr; releaseActiveTool(); updateSelectionState(); updateCursor(); } void CaptureWidget::paintEvent(QPaintEvent* paintEvent) { Q_UNUSED(paintEvent) QPainter painter(this); GeneralConf::xywh_position position = static_cast<GeneralConf::xywh_position>( ConfigHandler().value(\"showSelectionGeometry\").toInt()); /* QPainter::save and restore is somewhat costly so we try to guess if we need to do it here. What that means is that if you add anything to the paintEvent and want to save/restore you should add a test to the below if statement -- also if you change any of the conditions that current trigger it you'll need to change here, too */ bool save = false; if (((position != GeneralConf::xywh_none && m_selection && // clause 1: xywh display m_xywhDisplay)) || (m_activeTool && m_mouseIsClicked) || // clause 2: tool/click (m_previewEnabled && activeButtonTool() && // clause 3: mouse preview m_activeButton->tool()->showMousePreview())) { painter.save(); save = true; } painter.drawPixmap(0, 0, m_context.screenshot); if (position != GeneralConf::xywh_none && m_selection && m_xywhDisplay) { const QRect& selection = m_selection->geometry().normalized(); const qreal scale = m_context.screenshot.devicePixelRatio(); QRect xybox; QFontMetrics fm = painter.fontMetrics(); QString xy = QString(\"%1x%2+%3+%4\") .arg(static_cast<int>(selection.width() * scale)) .arg(static_cast<int>(selection.height() * scale)) .arg(static_cast<int>(selection.left() * scale)) .arg(static_cast<int>(selection.top() * scale)); xybox = fm.boundingRect(xy); // the small numbers here are just margins so the text doesn't // smack right up to the box; they aren't critical and the box // size itself is tied to the font metrics xybox.adjust(0, 0, 10, 12); // in anticipation of making the position adjustable int x0, y0; // Move these to header // adjust for small selection #if 0 // seems more usable not to do this if (xybox.width() > selection.width()) xybox.setWidth(selection.width()); if (xybox.height() > selection.height()) xybox.setHeight(selection.height()); #endif switch (position) { case GeneralConf::xywh_top_left: x0 = selection.left(); y0 = selection.top(); break; case GeneralConf::xywh_bottom_left: x0 = selection.left(); y0 = selection.bottom() - xybox.height(); break; case GeneralConf::xywh_top_right: x0 = selection.right() - xybox.width(); y0 = selection.top(); break; case GeneralConf::xywh_bottom_right: x0 = selection.right() - xybox.width(); y0 = selection.bottom() - xybox.height(); break; case GeneralConf::xywh_center: default: x0 = selection.left() + (selection.width() - xybox.width()) / 2; y0 = selection.top() + (selection.height() - xybox.height()) / 2; } QColor uicolor = ConfigHandler().uiColor(); uicolor.setAlpha(200); painter.fillRect( x0, y0, xybox.width(), xybox.height(), QBrush(uicolor)); painter.setPen(ColorUtils::colorIsDark(uicolor) ? Qt::white : Qt::black); painter.drawText(x0, y0, xybox.width(), xybox.height(), Qt::AlignVCenter | Qt::AlignHCenter, xy); } if (m_activeTool && m_mouseIsClicked) { m_activeTool->process(painter, m_context.screenshot); } else if (m_previewEnabled && activeButtonTool() && m_activeButton->tool()->showMousePreview()) { m_activeButton->tool()->paintMousePreview(painter, m_context); } if (save) painter.restore(); // draw inactive region drawInactiveRegion(&painter); if (!isActiveWindow()) { drawErrorMessage( tr(\"Flameshot has lost focus. Keyboard shortcuts won't \" \"work until you click somewhere.\"), &painter); } else if (m_configError) { drawErrorMessage(ConfigHandler().errorMessage(), &painter); } else if (m_configErrorResolved) { drawErrorMessage(tr(\"Configuration error resolved. Launch `flameshot \" \"gui` again to apply it.\"), &painter); } } void CaptureWidget::showColorPicker(const QPoint& pos) { // Try to select new object if current pos out of active object auto toolItem = activeToolObject(); if (!toolItem || (toolItem && !toolItem->boundingRect().contains(pos))) { selectToolItemAtPos(pos); } // save current state for undo/redo stack if (m_panel->activeLayerIndex() >= 0) { m_captureToolObjectsBackup = m_captureToolObjects; } // Call color picker m_colorPicker->move(pos.x() - m_colorPicker->width() / 2, pos.y() - m_colorPicker->height() / 2); m_colorPicker->raise(); m_colorPicker->show(); } bool CaptureWidget::startDrawObjectTool(const QPoint& pos) { if (activeButtonToolType() != CaptureTool::NONE && activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) { if (commitCurrentTool()) { return false; } m_activeTool = m_activeButton->tool()->copy(this); connect(this, &CaptureWidget::colorChanged, m_activeTool, &CaptureTool::onColorChanged); connect(this, &CaptureWidget::toolSizeChanged, m_activeTool, &CaptureTool::onSizeChanged); connect(m_activeTool, &CaptureTool::requestAction, this, &CaptureWidget::handleToolSignal); m_context.mousePos = pos; m_activeTool->drawStart(m_context); // TODO this is the wrong place to do this if (m_activeTool->type() == CaptureTool::TYPE_CIRCLECOUNT) { m_activeTool->setCount(m_context.circleCount++); } return true; } return false; } void CaptureWidget::pushObjectsStateToUndoStack() { m_undoStack.push(new ModificationCommand( this, m_captureToolObjects, m_captureToolObjectsBackup)); m_captureToolObjectsBackup.clear(); } int CaptureWidget::selectToolItemAtPos(const QPoint& pos) { // Try to select existing tool, \"-1\" - no active tool int activeLayerIndex = -1; auto selectionMouseSide = m_selection->getMouseSide(pos); if (m_activeButton.isNull() && m_captureToolObjects.captureToolObjects().size() > 0 && (selectionMouseSide == SelectionWidget::NO_SIDE || selectionMouseSide == SelectionWidget::CENTER)) { auto toolItem = activeToolObject(); if (!toolItem || (toolItem && !toolItem->boundingRect().contains(pos))) { activeLayerIndex = m_captureToolObjects.find(pos, size()); int oldToolSize = m_context.toolSize; m_panel->setActiveLayer(activeLayerIndex); drawObjectSelection(); if (oldToolSize != m_context.toolSize) { emit toolSizeChanged(m_context.toolSize); } } } return activeLayerIndex; } void CaptureWidget::mousePressEvent(QMouseEvent* e) { activateWindow(); m_startMove = false; m_startMovePos = QPoint(); m_mousePressedPos = e->pos(); m_activeToolOffsetToMouseOnStart = QPoint(); if (m_colorPicker->isVisible()) { updateCursor(); return; } // reset object selection if capture area selection is active if (m_selection->getMouseSide(e->pos()) != SelectionWidget::CENTER) { m_panel->setActiveLayer(-1); } if (e->button() == Qt::RightButton) { if (m_activeTool && m_activeTool->editMode()) { return; } showColorPicker(m_mousePressedPos); return; } else if (e->button() == Qt::LeftButton) { m_mouseIsClicked = true; // Click using a tool excluding tool MOVE if (startDrawObjectTool(m_mousePressedPos)) { // return if success return; } } // Commit current tool if it has edit widget and mouse click is outside // of it if (m_toolWidget && !m_toolWidget->geometry().contains(e->pos())) { commitCurrentTool(); m_panel->setToolWidget(nullptr); drawToolsData(); updateLayersPanel(); } selectToolItemAtPos(m_mousePressedPos); updateSelectionState(); updateCursor(); } void CaptureWidget::mouseDoubleClickEvent(QMouseEvent* event) { int activeLayerIndex = m_panel->activeLayerIndex(); if (activeLayerIndex != -1) { // Start object editing auto activeTool = m_captureToolObjects.at(activeLayerIndex); if (activeTool && activeTool->type() == CaptureTool::TYPE_TEXT) { m_activeTool = activeTool; m_mouseIsClicked = false; m_context.mousePos = *m_activeTool->pos(); m_captureToolObjectsBackup = m_captureToolObjects; m_activeTool->setEditMode(true); drawToolsData(); updateLayersPanel(); handleToolSignal(CaptureTool::REQ_ADD_CHILD_WIDGET); m_panel->setToolWidget(m_activeTool->configurationWidget()); } } else if (m_selection->geometry().contains(event->pos())) { if ((event->button() == Qt::LeftButton) && (m_config.copyOnDoubleClick())) { CopyTool copyTool; connect(&copyTool, &CopyTool::requestAction, this, &CaptureWidget::handleToolSignal); copyTool.pressed(m_context); qApp->processEvents(QEventLoop::ExcludeUserInputEvents); } } } void CaptureWidget::mouseMoveEvent(QMouseEvent* e) { if (m_magnifier) { if (!m_activeButton) { m_magnifier->show(); m_magnifier->update(); } else { m_magnifier->hide(); } } m_context.mousePos = e->pos(); if (e->buttons() != Qt::LeftButton) { updateTool(activeButtonTool()); updateCursor(); return; } // The rest assumes that left mouse button is clicked if (!m_activeButton && m_panel->activeLayerIndex() >= 0) { // Move existing object if (!m_startMove) { // Check for the minimal offset to start moving an object if (m_startMovePos.isNull()) { m_startMovePos = e->pos(); } if ((e->pos() - m_startMovePos).manhattanLength() > MOUSE_DISTANCE_TO_START_MOVING) { m_startMove = true; } } if (m_startMove) { QPointer<CaptureTool> activeTool = m_captureToolObjects.at(m_panel->activeLayerIndex()); if (m_activeToolOffsetToMouseOnStart.isNull()) { setCursor(Qt::ClosedHandCursor); m_activeToolOffsetToMouseOnStart = e->pos() - *activeTool->pos(); } if (!m_activeToolIsMoved) { // save state before movement for undo stack m_captureToolObjectsBackup = m_captureToolObjects; } m_activeToolIsMoved = true; // update the old region of the selection, margins are added to // ensure selection outline is updated too update(paddedUpdateRect(activeTool->boundingRect())); activeTool->move(e->pos() - m_activeToolOffsetToMouseOnStart); drawToolsData(); } } else if (m_activeTool) { // drawing with a tool if (m_adjustmentButtonPressed) { m_activeTool->drawMoveWithAdjustment(e->pos()); } else { m_activeTool->drawMove(e->pos()); } // update drawing object updateTool(m_activeTool); // Hides the buttons under the mouse. If the mouse leaves, it shows // them. if (m_buttonHandler->buttonsAreInside()) { const bool containsMouse = m_buttonHandler->contains(m_context.mousePos); if (containsMouse) { m_buttonHandler->hide(); } else if (m_selection->isVisible()) { m_buttonHandler->show(); } } } updateCursor(); } void CaptureWidget::mouseReleaseEvent(QMouseEvent* e) { if (e->button() == Qt::LeftButton && m_colorPicker->isVisible()) { // Color picker if (m_colorPicker->isVisible() && m_panel->activeLayerIndex() >= 0 && m_context.color.isValid()) { pushObjectsStateToUndoStack(); } m_colorPicker->hide(); if (!m_context.color.isValid()) { m_context.color = ConfigHandler().drawColor(); m_panel->show(); } } else if (m_mouseIsClicked) { if (m_activeTool) { // end draw/edit m_activeTool->drawEnd(m_context.mousePos); if (m_activeTool->isValid()) { pushToolToStack(); } else if (!m_toolWidget) { releaseActiveTool(); } } else { if (m_activeToolIsMoved) { m_activeToolIsMoved = false; pushObjectsStateToUndoStack(); } } } m_mouseIsClicked = false; m_activeToolIsMoved = false; updateSelectionState(); updateCursor(); } void CaptureWidget::setToolSize(int size) { int oldSize = m_context.toolSize; m_context.toolSize = qBound(1, size, maxToolSize); updateTool(activeButtonTool()); QPoint topLeft = QGuiAppCurrentScreen().currentScreen()->geometry().topLeft(); int offset = m_notifierBox->width() / 4; m_notifierBox->move(mapFromGlobal(topLeft) + QPoint(offset, offset)); m_notifierBox->showMessage(QString::number(m_context.toolSize)); if (m_context.toolSize != oldSize) { emit toolSizeChanged(m_context.toolSize); } } void CaptureWidget::keyPressEvent(QKeyEvent* e) { // If the key is a digit, change the tool size bool ok; int digit = e->text().toInt(&ok); if (ok && ((e->modifiers() == Qt::NoModifier) || e->modifiers() == Qt::KeypadModifier)) { // digit received m_toolSizeByKeyboard = 10 * m_toolSizeByKeyboard + digit; setToolSize(m_toolSizeByKeyboard); if (m_context.toolSize != m_toolSizeByKeyboard) { // The tool size was out of range and was clipped by setToolSize m_toolSizeByKeyboard = 0; } } else { m_toolSizeByKeyboard = 0; } if (!m_selection->isVisible()) { return; } else if (e->key() == Qt::Key_Control) { m_adjustmentButtonPressed = true; updateCursor(); } else if (e->key() == Qt::Key_Enter) { // Make no difference for Return and Enter keys QCoreApplication::postEvent( this, new QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier)); } } void CaptureWidget::keyReleaseEvent(QKeyEvent* e) { if (e->key() == Qt::Key_Control) { m_adjustmentButtonPressed = false; updateCursor(); } } void CaptureWidget::wheelEvent(QWheelEvent* e) { /* Mouse scroll usually gives value 120, not more or less, just how many * times. * Touchpad gives the value 2 or more (usually 2-8), it doesn't give * too big values like mouse wheel on normal scrolling, so it is almost * impossible to scroll. It's easier to calculate number of requests and do * not accept events faster that one in 200ms. * */ int toolSizeOffset = 0; if (e->angleDelta().y() >= 60) { // mouse scroll (wheel) increment toolSizeOffset = 1; } else if (e->angleDelta().y() <= -60) { // mouse scroll (wheel) decrement toolSizeOffset = -1; } else { // touchpad scroll qint64 current = QDateTime::currentMSecsSinceEpoch(); if ((current - m_lastMouseWheel) > 200) { if (e->angleDelta().y() > 0) { toolSizeOffset = 1; } else if (e->angleDelta().y() < 0) { toolSizeOffset = -1; } m_lastMouseWheel = current; } else { return; } } setToolSize(m_context.toolSize + toolSizeOffset); } void CaptureWidget::resizeEvent(QResizeEvent* e) { QWidget::resizeEvent(e); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); if (!m_context.fullscreen) { m_panel->setFixedHeight(height()); m_buttonHandler->updateScreenRegions(rect()); } } void CaptureWidget::moveEvent(QMoveEvent* e) { QWidget::moveEvent(e); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); } void CaptureWidget::changeEvent(QEvent* e) { if (e->type() == QEvent::ActivationChange) { QPoint bottomRight = rect().bottomRight(); // Update the message in the bottom right corner. A rough estimate is // used for the update rect update(QRect(bottomRight - QPoint(1000, 200), bottomRight)); } } void CaptureWidget::initContext(bool fullscreen, const CaptureRequest& req) { m_context.color = m_config.drawColor(); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); m_context.mousePos = mapFromGlobal(QCursor::pos()); m_context.toolSize = m_config.drawThickness(); m_context.fullscreen = fullscreen; // initialize m_context.request m_context.request = req; } void CaptureWidget::initPanel() { QRect panelRect = rect(); if (m_context.fullscreen) { #if (defined(Q_OS_MACOS) || defined(Q_OS_LINUX)) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); panelRect = currentScreen->geometry(); auto devicePixelRatio = currentScreen->devicePixelRatio(); panelRect.moveTo(static_cast<int>(panelRect.x() / devicePixelRatio), static_cast<int>(panelRect.y() / devicePixelRatio)); #else panelRect = QGuiApplication::primaryScreen()->geometry(); auto devicePixelRatio = QGuiApplication::primaryScreen()->devicePixelRatio(); panelRect.moveTo(panelRect.x() / devicePixelRatio, panelRect.y() / devicePixelRatio); #endif } if (ConfigHandler().showSidePanelButton()) { auto* panelToggleButton = new OrientablePushButton(tr(\"Tool Settings\"), this); makeChild(panelToggleButton); panelToggleButton->setColor(m_uiColor); panelToggleButton->setOrientation( OrientablePushButton::VerticalBottomToTop); #if defined(Q_OS_MACOS) panelToggleButton->move( 0, static_cast<int>(panelRect.height() / 2) - static_cast<int>(panelToggleButton->width() / 2)); #else panelToggleButton->move(panelRect.x(), panelRect.y() + panelRect.height() / 2 - panelToggleButton->width() / 2); #endif panelToggleButton->setCursor(Qt::ArrowCursor); (new DraggableWidgetMaker(this))->makeDraggable(panelToggleButton); connect(panelToggleButton, &QPushButton::clicked, this, &CaptureWidget::togglePanel); } m_panel = new UtilityPanel(this); m_panel->hide(); makeChild(m_panel); #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); panelRect.moveTo(mapFromGlobal(panelRect.topLeft())); m_panel->setFixedWidth(static_cast<int>(m_colorPicker->width() * 1.5)); m_panel->setFixedHeight(currentScreen->geometry().height()); #else panelRect.moveTo(mapFromGlobal(panelRect.topLeft())); panelRect.setWidth(m_colorPicker->width() * 1.5); m_panel->setGeometry(panelRect); #endif connect(m_panel, &UtilityPanel::layerChanged, this, &CaptureWidget::updateActiveLayer); connect(m_panel, &UtilityPanel::moveUpClicked, this, &CaptureWidget::onMoveCaptureToolUp); connect(m_panel, &UtilityPanel::moveDownClicked, this, &CaptureWidget::onMoveCaptureToolDown); m_sidePanel = new SidePanelWidget(&m_context.screenshot, this); connect(m_sidePanel, &SidePanelWidget::colorChanged, this, &CaptureWidget::setDrawColor); connect(m_sidePanel, &SidePanelWidget::toolSizeChanged, this, &CaptureWidget::onToolSizeChanged); connect(this, &CaptureWidget::colorChanged, m_sidePanel, &SidePanelWidget::onColorChanged); connect(this, &CaptureWidget::toolSizeChanged, m_sidePanel, &SidePanelWidget::onToolSizeChanged); connect(m_sidePanel, &SidePanelWidget::togglePanel, m_panel, &UtilityPanel::toggle); // TODO replace with a CaptureWidget signal emit m_sidePanel->colorChanged(m_context.color); emit toolSizeChanged(m_context.toolSize); m_panel->pushWidget(m_sidePanel); // Fill undo/redo/history list widget m_panel->fillCaptureTools(m_captureToolObjects.captureToolObjects()); } #if !defined(DISABLE_UPDATE_CHECKER) void CaptureWidget::showAppUpdateNotification(const QString& appLatestVersion, const QString& appLatestUrl) { if (!ConfigHandler().checkForUpdates()) { // option check for updates disabled return; } if (nullptr == m_updateNotificationWidget) { m_updateNotificationWidget = new UpdateNotificationWidget(this, appLatestVersion, appLatestUrl); } #if defined(Q_OS_MACOS) int ax = (width() - m_updateNotificationWidget->width()) / 2; #elif (defined(Q_OS_LINUX) && QT_VERSION < QT_VERSION_CHECK(5, 10, 0)) QRect helpRect = QGuiApplication::primaryScreen()->geometry(); int ax = helpRect.left() + ((helpRect.width() - m_updateNotificationWidget->width()) / 2); #else QRect helpRect; QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { helpRect = currentScreen->geometry(); } else { helpRect = QGuiApplication::primaryScreen()->geometry(); } int ax = helpRect.left() + ((helpRect.width() - m_updateNotificationWidget->width()) / 2); #endif m_updateNotificationWidget->move(ax, 0); makeChild(m_updateNotificationWidget); m_updateNotificationWidget->show(); } #endif void CaptureWidget::initSelection() { // Be mindful of the order of statements, so that slots are called properly m_selection = new SelectionWidget(m_uiColor, this); QRect initialSelection = m_context.request.initialSelection(); connect(m_selection, &SelectionWidget::geometryChanged, this, [this]() { QRect constrainedToCaptureArea = m_selection->geometry().intersected(rect()); m_context.selection = extendedRect(constrainedToCaptureArea); updateSizeIndicator(); m_buttonHandler->hide(); updateCursor(); OverlayMessage::pop(); }); connect(m_selection, &SelectionWidget::geometrySettled, this, [this]() { if (m_selection->isVisibleTo(this)) { auto& req = m_context.request; if (req.tasks() & CaptureRequest::ACCEPT_ON_SELECT) { req.removeTask(CaptureRequest::ACCEPT_ON_SELECT); m_captureDone = true; close(); } m_buttonHandler->updatePosition(m_selection->geometry()); m_buttonHandler->show(); } else { m_buttonHandler->hide(); } }); connect(m_selection, &SelectionWidget::visibilityChanged, this, [this]() { if (!m_selection->isVisible() && !m_helpMessage.isEmpty()) { OverlayMessage::push(m_helpMessage); } }); if (!initialSelection.isNull()) { const qreal scale = m_context.screenshot.devicePixelRatio(); initialSelection.moveTopLeft(initialSelection.topLeft() - mapToGlobal({})); initialSelection.setTop(initialSelection.top() / scale); initialSelection.setBottom(initialSelection.bottom() / scale); initialSelection.setLeft(initialSelection.left() / scale); initialSelection.setRight(initialSelection.right() / scale); } m_selection->setGeometry(initialSelection); m_selection->setVisible(!initialSelection.isNull()); if (!initialSelection.isNull()) { m_context.selection = extendedRect(m_selection->geometry()); emit m_selection->geometrySettled(); } updateSizeIndicator(); } void CaptureWidget::setState(CaptureToolButton* b) { if (!b) { return; } commitCurrentTool(); if (m_toolWidget && m_activeTool) { if (m_activeTool->isValid()) { pushToolToStack(); } else { releaseActiveTool(); } } if (m_activeButton != b) { auto backup = m_activeTool; // The tool is active during the pressed(). // This must be done in order to handle tool requests correctly. m_activeTool = b->tool(); m_activeTool->pressed(m_context); m_activeTool = backup; } if (b->tool()->isSelectable()) { if (m_activeButton != b) { if (m_activeButton) { m_activeButton->setColor(m_uiColor); } m_activeButton = b; m_activeButton->setColor(m_contrastUiColor); m_panel->setActiveLayer(-1); m_panel->setToolWidget(b->tool()->configurationWidget()); } else if (m_activeButton) { m_panel->clearToolWidget(); m_activeButton->setColor(m_uiColor); m_activeButton = nullptr; } m_context.toolSize = ConfigHandler().toolSize(activeButtonToolType()); emit toolSizeChanged(m_context.toolSize); updateCursor(); updateSelectionState(); updateTool(b->tool()); } } void CaptureWidget::handleToolSignal(CaptureTool::Request r) { switch (r) { case CaptureTool::REQ_CLOSE_GUI: close(); break; case CaptureTool::REQ_HIDE_GUI: hide(); break; case CaptureTool::REQ_UNDO_MODIFICATION: undo(); break; case CaptureTool::REQ_REDO_MODIFICATION: redo(); break; case CaptureTool::REQ_SHOW_COLOR_PICKER: // TODO break; case CaptureTool::REQ_CAPTURE_DONE_OK: m_captureDone = true; break; case CaptureTool::REQ_CLEAR_SELECTION: if (m_panel->activeLayerIndex() >= 0) { m_panel->setActiveLayer(-1); drawToolsData(false); } break; case CaptureTool::REQ_ADD_CHILD_WIDGET: if (!m_activeTool) { break; } if (m_toolWidget) { m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } m_toolWidget = m_activeTool->widget(); if (m_toolWidget) { makeChild(m_toolWidget); m_toolWidget->move(m_context.mousePos); m_toolWidget->show(); m_toolWidget->setFocus(); } break; case CaptureTool::REQ_ADD_EXTERNAL_WIDGETS: if (!m_activeTool) { break; } else { QWidget* w = m_activeTool->widget(); w->setAttribute(Qt::WA_DeleteOnClose); w->activateWindow(); w->show(); Flameshot::instance()->setExternalWidget(true); } break; case CaptureTool::REQ_INCREASE_TOOL_SIZE: setToolSize(m_context.toolSize + 1); break; case CaptureTool::REQ_DECREASE_TOOL_SIZE: setToolSize(m_context.toolSize - 1); break; default: break; } } void CaptureWidget::onToolSizeChanged(int t) { m_context.toolSize = t; CaptureTool* tool = activeButtonTool(); if (tool && tool->showMousePreview()) { setCursor(Qt::BlankCursor); tool->onSizeChanged(t); } // update tool size of object being drawn if (m_activeTool != nullptr) { updateTool(m_activeTool); } // update tool size of selected object auto toolItem = activeToolObject(); if (toolItem) { // Change thickness toolItem->onSizeChanged(t); if (!m_existingObjectIsChanged) { m_captureToolObjectsBackup = m_captureToolObjects; m_existingObjectIsChanged = true; } drawToolsData(); updateTool(toolItem); } // Force a repaint to prevent artifacting this->repaint(); } void CaptureWidget::onToolSizeSettled(int size) { m_config.setToolSize(activeButtonToolType(), size); } void CaptureWidget::setDrawColor(const QColor& c) { m_context.color = c; if (m_context.color.isValid()) { ConfigHandler().setDrawColor(m_context.color); emit colorChanged(c); // Update mouse preview updateTool(activeButtonTool()); // change color for the active tool auto toolItem = activeToolObject(); if (toolItem) { // Change color toolItem->onColorChanged(c); drawToolsData(); } } } void CaptureWidget::updateActiveLayer(int layer) { // TODO - refactor this part, make all objects to work with // m_activeTool->isChanged() and remove m_existingObjectIsChanged if (m_activeTool && m_activeTool->type() == CaptureTool::TYPE_TEXT && m_activeTool->isChanged()) { commitCurrentTool(); } if (m_toolWidget) { // Release active tool if it is in the editing mode but not changed and // has editing widget (ex: text tool) releaseActiveTool(); } if (m_existingObjectIsChanged) { m_existingObjectIsChanged = false; pushObjectsStateToUndoStack(); } drawToolsData(); drawObjectSelection(); updateSelectionState(); } void CaptureWidget::onMoveCaptureToolUp(int captureToolIndex) { m_captureToolObjectsBackup = m_captureToolObjects; pushObjectsStateToUndoStack(); auto tool = m_captureToolObjects.at(captureToolIndex); m_captureToolObjects.removeAt(captureToolIndex); m_captureToolObjects.insert(captureToolIndex - 1, tool); updateLayersPanel(); } void CaptureWidget::onMoveCaptureToolDown(int captureToolIndex) { m_captureToolObjectsBackup = m_captureToolObjects; pushObjectsStateToUndoStack(); auto tool = m_captureToolObjects.at(captureToolIndex); m_captureToolObjects.removeAt(captureToolIndex); m_captureToolObjects.insert(captureToolIndex + 1, tool); updateLayersPanel(); } void CaptureWidget::selectAll() { m_selection->show(); m_selection->setGeometry(rect()); emit m_selection->geometrySettled(); m_buttonHandler->show(); updateSelectionState(); } void CaptureWidget::removeToolObject(int index) { --index; if (index >= 0 && index < m_captureToolObjects.size()) { // in case this tool is circle counter int removedCircleCount = -1; const CaptureTool::Type currentToolType = m_captureToolObjects.at(index)->type(); m_captureToolObjectsBackup = m_captureToolObjects; update( paddedUpdateRect(m_captureToolObjects.at(index)->boundingRect())); if (currentToolType == CaptureTool::TYPE_CIRCLECOUNT) { removedCircleCount = m_captureToolObjects.at(index)->count(); --m_context.circleCount; // Decrement circle counter numbers starting from deleted circle for (int cnt = 0; cnt < m_captureToolObjects.size(); cnt++) { auto toolItem = m_captureToolObjects.at(cnt); if (toolItem->type() != CaptureTool::TYPE_CIRCLECOUNT) { continue; } auto circleTool = m_captureToolObjects.at(cnt); if (circleTool->count() >= removedCircleCount) { circleTool->setCount(circleTool->count() - 1); } } } m_captureToolObjects.removeAt(index); pushObjectsStateToUndoStack(); drawToolsData(); updateLayersPanel(); } } void CaptureWidget::initShortcuts() { newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_UNDO\")), this, SLOT(undo())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_REDO\")), this, SLOT(redo())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\")), this, SLOT(togglePanel())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_LEFT\")), m_selection, SLOT(resizeLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_RIGHT\")), m_selection, SLOT(resizeRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_UP\")), m_selection, SLOT(resizeUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_DOWN\")), m_selection, SLOT(resizeDown())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_LEFT\")), m_selection, SLOT(symResizeLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_RIGHT\")), m_selection, SLOT(symResizeRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_UP\")), m_selection, SLOT(symResizeUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_DOWN\")), m_selection, SLOT(symResizeDown())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_LEFT\")), m_selection, SLOT(moveLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_RIGHT\")), m_selection, SLOT(moveRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_UP\")), m_selection, SLOT(moveUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_DOWN\")), m_selection, SLOT(moveDown())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_DELETE_CURRENT_TOOL\")), this, SLOT(deleteCurrentTool())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_COMMIT_CURRENT_TOOL\")), this, SLOT(commitCurrentTool())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SELECT_ALL\")), this, SLOT(selectAll())); newShortcut(Qt::Key_Escape, this, SLOT(deleteToolWidgetOrClose())); } void CaptureWidget::deleteCurrentTool() { int oldToolSize = m_context.toolSize; m_panel->slotButtonDelete(true); drawObjectSelection(); if (oldToolSize != m_context.toolSize) { emit toolSizeChanged(m_context.toolSize); } } void CaptureWidget::updateSizeIndicator() { showxywh(); // Note: even if sizeIndButton goes away, we have to keep this! if (m_sizeIndButton) { const QRect& selection = extendedSelection(); m_sizeIndButton->setText(QStringLiteral(\"%1\\n%2\") .arg(selection.width()) .arg(selection.height())); } } void CaptureWidget::updateCursor() { if (m_colorPicker && m_colorPicker->isVisible()) { setCursor(Qt::ArrowCursor); } else if (m_activeButton != nullptr && activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) { setCursor(Qt::CrossCursor); } else if (m_selection->getMouseSide(mapFromGlobal(QCursor::pos())) != SelectionWidget::NO_SIDE) { setCursor(m_selection->cursor()); } else if (activeButtonToolType() == CaptureTool::TYPE_MOVESELECTION) { setCursor(Qt::OpenHandCursor); } else { setCursor(Qt::CrossCursor); } } void CaptureWidget::updateSelectionState() { auto toolType = activeButtonToolType(); if (toolType == CaptureTool::TYPE_MOVESELECTION) { m_selection->setIdleCentralCursor(Qt::OpenHandCursor); m_selection->setIgnoreMouse(false); } else { m_selection->setIdleCentralCursor(Qt::ArrowCursor); if (toolType == CaptureTool::NONE) { m_selection->setIgnoreMouse(m_panel->activeLayerIndex() != -1); } else { m_selection->setIgnoreMouse(true); } } } void CaptureWidget::updateTool(CaptureTool* tool) { if (!tool || !tool->showMousePreview()) { return; } static QRect oldPreviewRect, oldToolObjectRect; QRect previewRect(tool->mousePreviewRect(m_context)); previewRect += QMargins(previewRect.width(), previewRect.height(), previewRect.width(), previewRect.height()); QRect toolObjectRect = paddedUpdateRect(tool->boundingRect()); // old rects are united with current rects to handle sudden mouse movement update(previewRect); update(toolObjectRect); update(oldPreviewRect); update(oldToolObjectRect); oldPreviewRect = previewRect; oldToolObjectRect = toolObjectRect; } void CaptureWidget::updateLayersPanel() { m_panel->fillCaptureTools(m_captureToolObjects.captureToolObjects()); } void CaptureWidget::pushToolToStack() { // append current tool to the new state if (m_activeTool && m_activeButton) { disconnect(this, &CaptureWidget::colorChanged, m_activeTool, &CaptureTool::onColorChanged); disconnect(this, &CaptureWidget::toolSizeChanged, m_activeTool, &CaptureTool::onSizeChanged); if (m_panel->toolWidget()) { disconnect(m_panel->toolWidget(), nullptr, m_activeTool, nullptr); } // disable signal connect for updating layer because it may call this // function again on text objects m_panel->blockSignals(true); m_captureToolObjectsBackup = m_captureToolObjects; m_captureToolObjects.append(m_activeTool); pushObjectsStateToUndoStack(); releaseActiveTool(); drawToolsData(); updateLayersPanel(); // restore signal connection for updating layer m_panel->blockSignals(false); } } void CaptureWidget::drawToolsData(bool drawSelection) { // TODO refactor this for performance. The objects should not all be updated // at once every time QPixmap pixmapItem = m_context.origScreenshot; for (auto toolItem : m_captureToolObjects.captureToolObjects()) { processPixmapWithTool(&pixmapItem, toolItem); update(paddedUpdateRect(toolItem->boundingRect())); } m_context.screenshot = pixmapItem; if (drawSelection) { drawObjectSelection(); } } void CaptureWidget::drawObjectSelection() { auto toolItem = activeToolObject(); if (toolItem && !toolItem->editMode()) { QPainter painter(&m_context.screenshot); toolItem->drawObjectSelection(painter); // TODO move this elsewhere if (m_context.toolSize != toolItem->size()) { m_context.toolSize = toolItem->size(); } if (activeToolObject() && m_activeButton) { uncheckActiveTool(); } } } void CaptureWidget::processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool) { QPainter painter(pixmap); painter.setRenderHint(QPainter::Antialiasing); tool->process(painter, *pixmap); } CaptureTool* CaptureWidget::activeButtonTool() const { if (m_activeButton == nullptr) { return nullptr; } return m_activeButton->tool(); } CaptureTool::Type CaptureWidget::activeButtonToolType() const { auto* activeTool = activeButtonTool(); if (activeTool == nullptr) { return CaptureTool::NONE; } return activeTool->type(); } QPointer<CaptureTool> CaptureWidget::activeToolObject() { return m_captureToolObjects.at(m_panel->activeLayerIndex()); } void CaptureWidget::makeChild(QWidget* w) { w->setParent(this); w->installEventFilter(m_eventFilter); } void CaptureWidget::restoreCircleCountState() { int largest = 0; for (int cnt = 0; cnt < m_captureToolObjects.size(); cnt++) { auto toolItem = m_captureToolObjects.at(cnt); if (toolItem->type() != CaptureTool::TYPE_CIRCLECOUNT) { continue; } if (toolItem->count() > largest) { largest = toolItem->count(); } } m_context.circleCount = largest + 1; } QList<QShortcut*> CaptureWidget::newShortcut(const QKeySequence& key, QWidget* parent, const char* slot) { QList<QShortcut*> shortcuts; QString strKey = key.toString(); if (strKey.contains(\"Enter\") || strKey.contains(\"Return\")) { strKey.replace(\"Enter\", \"Return\"); shortcuts << new QShortcut(strKey, parent, slot); strKey.replace(\"Return\", \"Enter\"); shortcuts << new QShortcut(strKey, parent, slot); } else { shortcuts << new QShortcut(key, parent, slot); } return shortcuts; } void CaptureWidget::togglePanel() { m_panel->toggle(); } void CaptureWidget::childEnter() { m_previewEnabled = false; updateTool(activeButtonTool()); } void CaptureWidget::childLeave() { m_previewEnabled = true; updateTool(activeButtonTool()); } void CaptureWidget::setCaptureToolObjects( const CaptureToolObjects& captureToolObjects) { // Used for undo/redo m_captureToolObjects = captureToolObjects; drawToolsData(); updateLayersPanel(); drawObjectSelection(); } void CaptureWidget::undo() { if (m_activeTool && (m_activeTool->isChanged() || m_activeTool->editMode())) { // Remove selection on undo, at the same time commit current tool will // be called m_panel->setActiveLayer(-1); } // drawToolsData is called twice to update both previous and new regions // FIXME this is a temporary workaround drawToolsData(); m_undoStack.undo(); drawToolsData(); updateLayersPanel(); restoreCircleCountState(); } void CaptureWidget::redo() { // drawToolsData is called twice to update both previous and new regions // FIXME this is a temporary workaround drawToolsData(); m_undoStack.redo(); drawToolsData(); update(); updateLayersPanel(); restoreCircleCountState(); } QRect CaptureWidget::extendedSelection() const { if (m_selection == nullptr) { return {}; } QRect r = m_selection->geometry(); return extendedRect(r); } QRect CaptureWidget::extendedRect(const QRect& r) const { auto devicePixelRatio = m_context.screenshot.devicePixelRatio(); return { static_cast<int>(r.left() * devicePixelRatio), static_cast<int>(r.top() * devicePixelRatio), static_cast<int>(r.width() * devicePixelRatio), static_cast<int>(r.height() * devicePixelRatio) }; } QRect CaptureWidget::paddedUpdateRect(const QRect& r) const { if (r.isNull()) { return r; } else { return r + QMargins(20, 20, 20, 20); } } void CaptureWidget::drawErrorMessage(const QString& msg, QPainter* painter) { auto textRect = painter->fontMetrics().boundingRect(msg); int w = textRect.width(), h = textRect.height(); textRect = { size().width() - w - 10, size().height() - h - 5, w + 100, h + 100 }; QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (!textRect.contains(QCursor::pos(currentScreen))) { QColor textColor(Qt::white); painter->setPen(textColor); painter->drawText(textRect, msg); } } void CaptureWidget::drawInactiveRegion(QPainter* painter) { QColor overlayColor(0, 0, 0, m_opacity); painter->setBrush(overlayColor); QRect r; if (m_selection->isVisible()) { r = m_selection->geometry().normalized(); } QRegion grey(rect()); grey = grey.subtracted(r); painter->setClipRegion(grey); painter->drawRect(-1, -1, rect().width() + 1, rect().height() + 1); }","title":"File capturewidget.cpp"},{"location":"flameshot/capturewidget_8cpp_source/#file-capturewidgetcpp","text":"File List > capture > capturewidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.cpp, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #include \"capturewidget.h\" #include \"abstractlogger.h\" #include \"copytool.h\" #include \"src/config/cacheutils.h\" #include \"src/config/generalconf.h\" #include \"src/core/flameshot.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/tools/toolfactory.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/utils/systemnotification.h\" #include \"src/widgets/capture/colorpicker.h\" #include \"src/widgets/capture/hovereventfilter.h\" #include \"src/widgets/capture/modificationcommand.h\" #include \"src/widgets/capture/notifierbox.h\" #include \"src/widgets/capture/overlaymessage.h\" #include \"src/widgets/orientablepushbutton.h\" #include \"src/widgets/panel/sidepanelwidget.h\" #include \"src/widgets/panel/utilitypanel.h\" #include <QApplication> #include <QDateTime> #include <QDebug> #include <QDesktopWidget> #include <QFontMetrics> #include <QLabel> #include <QPaintEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <draggablewidgetmaker.h> #if !defined(DISABLE_UPDATE_CHECKER) #include \"src/widgets/updatenotificationwidget.h\" #endif #define MOUSE_DISTANCE_TO_START_MOVING 3 // CaptureWidget is the main component used to capture the screen. It contains // an area of selection with its respective buttons. // enableSaveWindow CaptureWidget::CaptureWidget(const CaptureRequest& req, bool fullScreen, QWidget* parent) : QWidget(parent) , m_mouseIsClicked(false) , m_captureDone(false) , m_previewEnabled(true) , m_adjustmentButtonPressed(false) , m_configError(false) , m_configErrorResolved(false) , m_activeButton(nullptr) , m_activeTool(nullptr) , m_toolWidget(nullptr) , m_colorPicker(nullptr) , m_lastMouseWheel(0) #if !defined(DISABLE_UPDATE_CHECKER) , m_updateNotificationWidget(nullptr) #endif , m_activeToolIsMoved(false) , m_panel(nullptr) , m_sidePanel(nullptr) , m_selection(nullptr) , m_magnifier(nullptr) , m_existingObjectIsChanged(false) , m_startMove(false) , m_toolSizeByKeyboard(0) , m_xywhDisplay(false) { m_undoStack.setUndoLimit(ConfigHandler().undoLimit()); m_context.circleCount = 1; // Base config of the widget m_eventFilter = new HoverEventFilter(this); connect(m_eventFilter, &HoverEventFilter::hoverIn, this, &CaptureWidget::childEnter); connect(m_eventFilter, &HoverEventFilter::hoverOut, this, &CaptureWidget::childLeave); connect(&m_xywhTimer, SIGNAL(timeout()), this, SLOT(xywhTick())); setAttribute(Qt::WA_DeleteOnClose); setAttribute(Qt::WA_QuitOnClose, false); m_opacity = m_config.contrastOpacity(); m_uiColor = m_config.uiColor(); m_contrastUiColor = m_config.contrastUiColor(); setMouseTracking(true); initContext(fullScreen, req); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) // Top left of the whole set of screens QPoint topLeft(0, 0); #endif if (fullScreen) { // Grab Screenshot bool ok = true; m_context.screenshot = ScreenGrabber().grabEntireDesktop(ok); if (!ok) { AbstractLogger::error() << tr(\"Unable to capture screen\"); this->close(); } m_context.origScreenshot = m_context.screenshot; #if defined(Q_OS_WIN) // Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging #if !defined(FLAMESHOT_DEBUG_CAPTURE) setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::SubWindow // Hides the taskbar icon ); #endif for (QScreen* const screen : QGuiApplication::screens()) { QPoint topLeftScreen = screen->geometry().topLeft(); if (topLeftScreen.x() < topLeft.x()) { topLeft.setX(topLeftScreen.x()); } if (topLeftScreen.y() < topLeft.y()) { topLeft.setY(topLeftScreen.y()); } } move(topLeft); resize(pixmap().size()); #elif defined(Q_OS_MACOS) // Emulate fullscreen mode // setWindowFlags(Qt::WindowStaysOnTopHint | // Qt::BypassWindowManagerHint | // Qt::FramelessWindowHint | // Qt::NoDropShadowWindowHint | Qt::ToolTip | // Qt::Popup // ); QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); move(currentScreen->geometry().x(), currentScreen->geometry().y()); resize(currentScreen->size()); #else // Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging #if !defined(FLAMESHOT_DEBUG_CAPTURE) setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::Tool); resize(pixmap().size()); #endif #endif } QVector<QRect> areas; if (m_context.fullscreen) { QPoint topLeftOffset = QPoint(0, 0); #if defined(Q_OS_WIN) topLeftOffset = topLeft; #endif #if defined(Q_OS_MACOS) // MacOS works just with one active display, so we need to append // just one current display and keep multiple displays logic for // other OS QRect r; QScreen* screen = QGuiAppCurrentScreen().currentScreen(); r = screen->geometry(); // all calculations are processed according to (0, 0) start // point so we need to move current object to (0, 0) r.moveTo(0, 0); areas.append(r); #else for (QScreen* const screen : QGuiApplication::screens()) { QRect r = screen->geometry(); r.moveTo(r.x() / screen->devicePixelRatio(), r.y() / screen->devicePixelRatio()); r.moveTo(r.topLeft() - topLeftOffset); areas.append(r); } #endif } else { areas.append(rect()); } m_buttonHandler = new ButtonHandler(this); m_buttonHandler->updateScreenRegions(areas); m_buttonHandler->hide(); initButtons(); initSelection(); // button handler must be initialized before initShortcuts(); // must be called after initSelection // init magnify if (m_config.showMagnifier()) { m_magnifier = new MagnifierWidget( m_context.screenshot, m_uiColor, m_config.squareMagnifier(), this); } // Init color picker m_colorPicker = new ColorPicker(this); connect(m_colorPicker, &ColorPicker::colorSelected, this, [this](const QColor& c) { m_context.mousePos = mapFromGlobal(QCursor::pos()); setDrawColor(c); }); m_colorPicker->hide(); // Init tool size sigslots connect(this, &CaptureWidget::toolSizeChanged, this, &CaptureWidget::onToolSizeChanged); // Init notification widget m_notifierBox = new NotifierBox(this); m_notifierBox->hide(); connect(m_notifierBox, &NotifierBox::hidden, this, [this]() { // Show cursor if it was hidden while adjusting tool size updateCursor(); m_toolSizeByKeyboard = 0; onToolSizeChanged(m_context.toolSize); onToolSizeSettled(m_context.toolSize); }); initPanel(); m_config.checkAndHandleError(); if (m_config.hasError()) { m_configError = true; } connect(ConfigHandler::getInstance(), &ConfigHandler::error, this, [=]() { m_configError = true; m_configErrorResolved = false; OverlayMessage::instance()->update(); }); connect( ConfigHandler::getInstance(), &ConfigHandler::errorResolved, this, [=]() { m_configError = false; m_configErrorResolved = true; OverlayMessage::instance()->update(); }); OverlayMessage::init(this, QGuiAppCurrentScreen().currentScreen()->geometry()); if (m_config.showHelp()) { initHelpMessage(); OverlayMessage::push(m_helpMessage); } updateCursor(); } CaptureWidget::~CaptureWidget() { #if defined(Q_OS_MACOS) for (QWidget* widget : qApp->topLevelWidgets()) { QString className(widget->metaObject()->className()); if (0 == className.compare(CaptureWidget::staticMetaObject.className())) { widget->showNormal(); widget->hide(); break; } } #endif if (m_captureDone) { auto lastRegion = m_selection->geometry(); setLastRegion(lastRegion); QRect geometry(m_context.selection); geometry.setTopLeft(geometry.topLeft() + m_context.widgetOffset); Flameshot::instance()->exportCapture( pixmap(), geometry, m_context.request); } else { emit Flameshot::instance()->captureFailed(); } } void CaptureWidget::initButtons() { auto allButtonTypes = CaptureToolButton::getIterableButtonTypes(); auto visibleButtonTypes = m_config.buttons(); if ((m_context.request.tasks() == CaptureRequest::NO_TASK) || (m_context.request.tasks() == CaptureRequest::PRINT_GEOMETRY)) { allButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT); visibleButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT); } else { // Remove irrelevant buttons from both lists for (auto* buttonList : { &allButtonTypes, &visibleButtonTypes }) { buttonList->removeOne(CaptureTool::TYPE_SAVE); buttonList->removeOne(CaptureTool::TYPE_COPY); buttonList->removeOne(CaptureTool::TYPE_IMAGEUPLOADER); buttonList->removeOne(CaptureTool::TYPE_OPEN_APP); buttonList->removeOne(CaptureTool::TYPE_PIN); } } QVector<CaptureToolButton*> vectorButtons; // Add all buttons but hide those that were disabled in the Interface config // This will allow keyboard shortcuts for those buttons to work for (CaptureTool::Type t : allButtonTypes) { auto* b = new CaptureToolButton(t, this); if (t == CaptureTool::TYPE_SELECTIONINDICATOR) { m_sizeIndButton = b; } b->setColor(m_uiColor); b->hide(); // must be enabled for SelectionWidget's eventFilter to work correctly b->setAttribute(Qt::WA_NoMousePropagation); makeChild(b); switch (t) { case CaptureTool::TYPE_UNDO: case CaptureTool::TYPE_REDO: // nothing to do, just skip non-dynamic buttons with existing // hard coded slots break; default: // Set shortcuts for a tool QString shortcut = ConfigHandler().shortcut(QVariant::fromValue(t).toString()); if (!shortcut.isNull()) { auto shortcuts = newShortcut(shortcut, this, nullptr); for (auto* shortcut : shortcuts) { connect(shortcut, &QShortcut::activated, this, [=]() { setState(b); }); } } break; } m_tools[t] = b->tool(); connect(b->tool(), &CaptureTool::requestAction, this, &CaptureWidget::handleToolSignal); if (visibleButtonTypes.contains(t)) { connect(b, &CaptureToolButton::pressedButtonLeftClick, this, &CaptureWidget::handleButtonLeftClick); if (b->tool()->isSelectable()) { connect(b, &CaptureToolButton::pressedButtonRightClick, this, &CaptureWidget::handleButtonRightClick); } vectorButtons << b; } } m_buttonHandler->setButtons(vectorButtons); } void CaptureWidget::handleButtonRightClick(CaptureToolButton* b) { if (!b) { return; } // if button already selected, do not deselect it on right click if (!m_activeButton || m_activeButton != b) { setState(b); } if (!m_panel->isVisible()) { m_panel->show(); } } void CaptureWidget::handleButtonLeftClick(CaptureToolButton* b) { if (!b) { return; } setState(b); } void CaptureWidget::xywhTick() { m_xywhDisplay = false; repaint(); } void CaptureWidget::showxywh(bool show) { int timeout = ConfigHandler().value(\"showSelectionGeometryHideTime\").toInt(); m_xywhDisplay = show; m_xywhTimer.stop(); repaint(); if (show && timeout != 0) { m_xywhTimer.start(timeout); } } void CaptureWidget::initHelpMessage() { QList<QPair<QString, QString>> keyMap; if (keyMap.isEmpty()) { keyMap << QPair(tr(\"Mouse\"), tr(\"Select screenshot area\")); using CT = CaptureTool; for (auto toolType : { CT::TYPE_ACCEPT, CT::TYPE_SAVE, CT::TYPE_COPY }) { if (!m_tools.contains(toolType)) { continue; } auto* tool = m_tools[toolType]; QString shortcut = ConfigHandler().shortcut( QVariant::fromValue(toolType).toString()); shortcut.replace(\"Return\", \"Enter\"); if (!shortcut.isEmpty()) { keyMap << QPair(shortcut, tool->description()); } } keyMap << QPair(tr(\"Mouse Wheel\"), tr(\"Change tool size\")); keyMap << QPair(tr(\"Right Click\"), tr(\"Show color picker\")); keyMap << QPair(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\"), tr(\"Open side panel\")); keyMap << QPair(tr(\"Esc\"), tr(\"Exit\")); } m_helpMessage = OverlayMessage::compileFromKeyMap(keyMap); } QPixmap CaptureWidget::pixmap() { return m_context.selectedScreenshotArea(); } // Finish whatever the current tool is doing, if there is a current active // tool. bool CaptureWidget::commitCurrentTool() { if (m_activeTool) { processPixmapWithTool(&m_context.screenshot, m_activeTool); if (m_activeTool->isValid() && !m_activeTool->editMode() && m_toolWidget) { pushToolToStack(); } if (m_toolWidget) { m_toolWidget->update(); } releaseActiveTool(); return true; } return false; } void CaptureWidget::deleteToolWidgetOrClose() { if (m_activeButton != nullptr) { uncheckActiveTool(); } else if (m_panel->activeLayerIndex() >= 0) { // remove active tool selection m_panel->setActiveLayer(-1); } else if (m_panel->isVisible()) { // hide panel if visible m_panel->hide(); } else if (m_toolWidget) { // delete toolWidget if exists m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } else if (m_colorPicker && m_colorPicker->isVisible()) { m_colorPicker->hide(); } else { // close CaptureWidget close(); } } void CaptureWidget::releaseActiveTool() { if (m_activeTool) { if (m_activeTool->editMode()) { // Object shouldn't be deleted here because it is in the undo/redo // stack, just set current pointer to null m_activeTool->setEditMode(false); if (m_activeTool->isChanged()) { pushObjectsStateToUndoStack(); } } else { delete m_activeTool; } m_activeTool = nullptr; } if (m_toolWidget) { m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } } void CaptureWidget::uncheckActiveTool() { // uncheck active tool m_panel->setToolWidget(nullptr); m_activeButton->setColor(m_uiColor); updateTool(activeButtonTool()); m_activeButton = nullptr; releaseActiveTool(); updateSelectionState(); updateCursor(); } void CaptureWidget::paintEvent(QPaintEvent* paintEvent) { Q_UNUSED(paintEvent) QPainter painter(this); GeneralConf::xywh_position position = static_cast<GeneralConf::xywh_position>( ConfigHandler().value(\"showSelectionGeometry\").toInt()); /* QPainter::save and restore is somewhat costly so we try to guess if we need to do it here. What that means is that if you add anything to the paintEvent and want to save/restore you should add a test to the below if statement -- also if you change any of the conditions that current trigger it you'll need to change here, too */ bool save = false; if (((position != GeneralConf::xywh_none && m_selection && // clause 1: xywh display m_xywhDisplay)) || (m_activeTool && m_mouseIsClicked) || // clause 2: tool/click (m_previewEnabled && activeButtonTool() && // clause 3: mouse preview m_activeButton->tool()->showMousePreview())) { painter.save(); save = true; } painter.drawPixmap(0, 0, m_context.screenshot); if (position != GeneralConf::xywh_none && m_selection && m_xywhDisplay) { const QRect& selection = m_selection->geometry().normalized(); const qreal scale = m_context.screenshot.devicePixelRatio(); QRect xybox; QFontMetrics fm = painter.fontMetrics(); QString xy = QString(\"%1x%2+%3+%4\") .arg(static_cast<int>(selection.width() * scale)) .arg(static_cast<int>(selection.height() * scale)) .arg(static_cast<int>(selection.left() * scale)) .arg(static_cast<int>(selection.top() * scale)); xybox = fm.boundingRect(xy); // the small numbers here are just margins so the text doesn't // smack right up to the box; they aren't critical and the box // size itself is tied to the font metrics xybox.adjust(0, 0, 10, 12); // in anticipation of making the position adjustable int x0, y0; // Move these to header // adjust for small selection #if 0 // seems more usable not to do this if (xybox.width() > selection.width()) xybox.setWidth(selection.width()); if (xybox.height() > selection.height()) xybox.setHeight(selection.height()); #endif switch (position) { case GeneralConf::xywh_top_left: x0 = selection.left(); y0 = selection.top(); break; case GeneralConf::xywh_bottom_left: x0 = selection.left(); y0 = selection.bottom() - xybox.height(); break; case GeneralConf::xywh_top_right: x0 = selection.right() - xybox.width(); y0 = selection.top(); break; case GeneralConf::xywh_bottom_right: x0 = selection.right() - xybox.width(); y0 = selection.bottom() - xybox.height(); break; case GeneralConf::xywh_center: default: x0 = selection.left() + (selection.width() - xybox.width()) / 2; y0 = selection.top() + (selection.height() - xybox.height()) / 2; } QColor uicolor = ConfigHandler().uiColor(); uicolor.setAlpha(200); painter.fillRect( x0, y0, xybox.width(), xybox.height(), QBrush(uicolor)); painter.setPen(ColorUtils::colorIsDark(uicolor) ? Qt::white : Qt::black); painter.drawText(x0, y0, xybox.width(), xybox.height(), Qt::AlignVCenter | Qt::AlignHCenter, xy); } if (m_activeTool && m_mouseIsClicked) { m_activeTool->process(painter, m_context.screenshot); } else if (m_previewEnabled && activeButtonTool() && m_activeButton->tool()->showMousePreview()) { m_activeButton->tool()->paintMousePreview(painter, m_context); } if (save) painter.restore(); // draw inactive region drawInactiveRegion(&painter); if (!isActiveWindow()) { drawErrorMessage( tr(\"Flameshot has lost focus. Keyboard shortcuts won't \" \"work until you click somewhere.\"), &painter); } else if (m_configError) { drawErrorMessage(ConfigHandler().errorMessage(), &painter); } else if (m_configErrorResolved) { drawErrorMessage(tr(\"Configuration error resolved. Launch `flameshot \" \"gui` again to apply it.\"), &painter); } } void CaptureWidget::showColorPicker(const QPoint& pos) { // Try to select new object if current pos out of active object auto toolItem = activeToolObject(); if (!toolItem || (toolItem && !toolItem->boundingRect().contains(pos))) { selectToolItemAtPos(pos); } // save current state for undo/redo stack if (m_panel->activeLayerIndex() >= 0) { m_captureToolObjectsBackup = m_captureToolObjects; } // Call color picker m_colorPicker->move(pos.x() - m_colorPicker->width() / 2, pos.y() - m_colorPicker->height() / 2); m_colorPicker->raise(); m_colorPicker->show(); } bool CaptureWidget::startDrawObjectTool(const QPoint& pos) { if (activeButtonToolType() != CaptureTool::NONE && activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) { if (commitCurrentTool()) { return false; } m_activeTool = m_activeButton->tool()->copy(this); connect(this, &CaptureWidget::colorChanged, m_activeTool, &CaptureTool::onColorChanged); connect(this, &CaptureWidget::toolSizeChanged, m_activeTool, &CaptureTool::onSizeChanged); connect(m_activeTool, &CaptureTool::requestAction, this, &CaptureWidget::handleToolSignal); m_context.mousePos = pos; m_activeTool->drawStart(m_context); // TODO this is the wrong place to do this if (m_activeTool->type() == CaptureTool::TYPE_CIRCLECOUNT) { m_activeTool->setCount(m_context.circleCount++); } return true; } return false; } void CaptureWidget::pushObjectsStateToUndoStack() { m_undoStack.push(new ModificationCommand( this, m_captureToolObjects, m_captureToolObjectsBackup)); m_captureToolObjectsBackup.clear(); } int CaptureWidget::selectToolItemAtPos(const QPoint& pos) { // Try to select existing tool, \"-1\" - no active tool int activeLayerIndex = -1; auto selectionMouseSide = m_selection->getMouseSide(pos); if (m_activeButton.isNull() && m_captureToolObjects.captureToolObjects().size() > 0 && (selectionMouseSide == SelectionWidget::NO_SIDE || selectionMouseSide == SelectionWidget::CENTER)) { auto toolItem = activeToolObject(); if (!toolItem || (toolItem && !toolItem->boundingRect().contains(pos))) { activeLayerIndex = m_captureToolObjects.find(pos, size()); int oldToolSize = m_context.toolSize; m_panel->setActiveLayer(activeLayerIndex); drawObjectSelection(); if (oldToolSize != m_context.toolSize) { emit toolSizeChanged(m_context.toolSize); } } } return activeLayerIndex; } void CaptureWidget::mousePressEvent(QMouseEvent* e) { activateWindow(); m_startMove = false; m_startMovePos = QPoint(); m_mousePressedPos = e->pos(); m_activeToolOffsetToMouseOnStart = QPoint(); if (m_colorPicker->isVisible()) { updateCursor(); return; } // reset object selection if capture area selection is active if (m_selection->getMouseSide(e->pos()) != SelectionWidget::CENTER) { m_panel->setActiveLayer(-1); } if (e->button() == Qt::RightButton) { if (m_activeTool && m_activeTool->editMode()) { return; } showColorPicker(m_mousePressedPos); return; } else if (e->button() == Qt::LeftButton) { m_mouseIsClicked = true; // Click using a tool excluding tool MOVE if (startDrawObjectTool(m_mousePressedPos)) { // return if success return; } } // Commit current tool if it has edit widget and mouse click is outside // of it if (m_toolWidget && !m_toolWidget->geometry().contains(e->pos())) { commitCurrentTool(); m_panel->setToolWidget(nullptr); drawToolsData(); updateLayersPanel(); } selectToolItemAtPos(m_mousePressedPos); updateSelectionState(); updateCursor(); } void CaptureWidget::mouseDoubleClickEvent(QMouseEvent* event) { int activeLayerIndex = m_panel->activeLayerIndex(); if (activeLayerIndex != -1) { // Start object editing auto activeTool = m_captureToolObjects.at(activeLayerIndex); if (activeTool && activeTool->type() == CaptureTool::TYPE_TEXT) { m_activeTool = activeTool; m_mouseIsClicked = false; m_context.mousePos = *m_activeTool->pos(); m_captureToolObjectsBackup = m_captureToolObjects; m_activeTool->setEditMode(true); drawToolsData(); updateLayersPanel(); handleToolSignal(CaptureTool::REQ_ADD_CHILD_WIDGET); m_panel->setToolWidget(m_activeTool->configurationWidget()); } } else if (m_selection->geometry().contains(event->pos())) { if ((event->button() == Qt::LeftButton) && (m_config.copyOnDoubleClick())) { CopyTool copyTool; connect(&copyTool, &CopyTool::requestAction, this, &CaptureWidget::handleToolSignal); copyTool.pressed(m_context); qApp->processEvents(QEventLoop::ExcludeUserInputEvents); } } } void CaptureWidget::mouseMoveEvent(QMouseEvent* e) { if (m_magnifier) { if (!m_activeButton) { m_magnifier->show(); m_magnifier->update(); } else { m_magnifier->hide(); } } m_context.mousePos = e->pos(); if (e->buttons() != Qt::LeftButton) { updateTool(activeButtonTool()); updateCursor(); return; } // The rest assumes that left mouse button is clicked if (!m_activeButton && m_panel->activeLayerIndex() >= 0) { // Move existing object if (!m_startMove) { // Check for the minimal offset to start moving an object if (m_startMovePos.isNull()) { m_startMovePos = e->pos(); } if ((e->pos() - m_startMovePos).manhattanLength() > MOUSE_DISTANCE_TO_START_MOVING) { m_startMove = true; } } if (m_startMove) { QPointer<CaptureTool> activeTool = m_captureToolObjects.at(m_panel->activeLayerIndex()); if (m_activeToolOffsetToMouseOnStart.isNull()) { setCursor(Qt::ClosedHandCursor); m_activeToolOffsetToMouseOnStart = e->pos() - *activeTool->pos(); } if (!m_activeToolIsMoved) { // save state before movement for undo stack m_captureToolObjectsBackup = m_captureToolObjects; } m_activeToolIsMoved = true; // update the old region of the selection, margins are added to // ensure selection outline is updated too update(paddedUpdateRect(activeTool->boundingRect())); activeTool->move(e->pos() - m_activeToolOffsetToMouseOnStart); drawToolsData(); } } else if (m_activeTool) { // drawing with a tool if (m_adjustmentButtonPressed) { m_activeTool->drawMoveWithAdjustment(e->pos()); } else { m_activeTool->drawMove(e->pos()); } // update drawing object updateTool(m_activeTool); // Hides the buttons under the mouse. If the mouse leaves, it shows // them. if (m_buttonHandler->buttonsAreInside()) { const bool containsMouse = m_buttonHandler->contains(m_context.mousePos); if (containsMouse) { m_buttonHandler->hide(); } else if (m_selection->isVisible()) { m_buttonHandler->show(); } } } updateCursor(); } void CaptureWidget::mouseReleaseEvent(QMouseEvent* e) { if (e->button() == Qt::LeftButton && m_colorPicker->isVisible()) { // Color picker if (m_colorPicker->isVisible() && m_panel->activeLayerIndex() >= 0 && m_context.color.isValid()) { pushObjectsStateToUndoStack(); } m_colorPicker->hide(); if (!m_context.color.isValid()) { m_context.color = ConfigHandler().drawColor(); m_panel->show(); } } else if (m_mouseIsClicked) { if (m_activeTool) { // end draw/edit m_activeTool->drawEnd(m_context.mousePos); if (m_activeTool->isValid()) { pushToolToStack(); } else if (!m_toolWidget) { releaseActiveTool(); } } else { if (m_activeToolIsMoved) { m_activeToolIsMoved = false; pushObjectsStateToUndoStack(); } } } m_mouseIsClicked = false; m_activeToolIsMoved = false; updateSelectionState(); updateCursor(); } void CaptureWidget::setToolSize(int size) { int oldSize = m_context.toolSize; m_context.toolSize = qBound(1, size, maxToolSize); updateTool(activeButtonTool()); QPoint topLeft = QGuiAppCurrentScreen().currentScreen()->geometry().topLeft(); int offset = m_notifierBox->width() / 4; m_notifierBox->move(mapFromGlobal(topLeft) + QPoint(offset, offset)); m_notifierBox->showMessage(QString::number(m_context.toolSize)); if (m_context.toolSize != oldSize) { emit toolSizeChanged(m_context.toolSize); } } void CaptureWidget::keyPressEvent(QKeyEvent* e) { // If the key is a digit, change the tool size bool ok; int digit = e->text().toInt(&ok); if (ok && ((e->modifiers() == Qt::NoModifier) || e->modifiers() == Qt::KeypadModifier)) { // digit received m_toolSizeByKeyboard = 10 * m_toolSizeByKeyboard + digit; setToolSize(m_toolSizeByKeyboard); if (m_context.toolSize != m_toolSizeByKeyboard) { // The tool size was out of range and was clipped by setToolSize m_toolSizeByKeyboard = 0; } } else { m_toolSizeByKeyboard = 0; } if (!m_selection->isVisible()) { return; } else if (e->key() == Qt::Key_Control) { m_adjustmentButtonPressed = true; updateCursor(); } else if (e->key() == Qt::Key_Enter) { // Make no difference for Return and Enter keys QCoreApplication::postEvent( this, new QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier)); } } void CaptureWidget::keyReleaseEvent(QKeyEvent* e) { if (e->key() == Qt::Key_Control) { m_adjustmentButtonPressed = false; updateCursor(); } } void CaptureWidget::wheelEvent(QWheelEvent* e) { /* Mouse scroll usually gives value 120, not more or less, just how many * times. * Touchpad gives the value 2 or more (usually 2-8), it doesn't give * too big values like mouse wheel on normal scrolling, so it is almost * impossible to scroll. It's easier to calculate number of requests and do * not accept events faster that one in 200ms. * */ int toolSizeOffset = 0; if (e->angleDelta().y() >= 60) { // mouse scroll (wheel) increment toolSizeOffset = 1; } else if (e->angleDelta().y() <= -60) { // mouse scroll (wheel) decrement toolSizeOffset = -1; } else { // touchpad scroll qint64 current = QDateTime::currentMSecsSinceEpoch(); if ((current - m_lastMouseWheel) > 200) { if (e->angleDelta().y() > 0) { toolSizeOffset = 1; } else if (e->angleDelta().y() < 0) { toolSizeOffset = -1; } m_lastMouseWheel = current; } else { return; } } setToolSize(m_context.toolSize + toolSizeOffset); } void CaptureWidget::resizeEvent(QResizeEvent* e) { QWidget::resizeEvent(e); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); if (!m_context.fullscreen) { m_panel->setFixedHeight(height()); m_buttonHandler->updateScreenRegions(rect()); } } void CaptureWidget::moveEvent(QMoveEvent* e) { QWidget::moveEvent(e); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); } void CaptureWidget::changeEvent(QEvent* e) { if (e->type() == QEvent::ActivationChange) { QPoint bottomRight = rect().bottomRight(); // Update the message in the bottom right corner. A rough estimate is // used for the update rect update(QRect(bottomRight - QPoint(1000, 200), bottomRight)); } } void CaptureWidget::initContext(bool fullscreen, const CaptureRequest& req) { m_context.color = m_config.drawColor(); m_context.widgetOffset = mapToGlobal(QPoint(0, 0)); m_context.mousePos = mapFromGlobal(QCursor::pos()); m_context.toolSize = m_config.drawThickness(); m_context.fullscreen = fullscreen; // initialize m_context.request m_context.request = req; } void CaptureWidget::initPanel() { QRect panelRect = rect(); if (m_context.fullscreen) { #if (defined(Q_OS_MACOS) || defined(Q_OS_LINUX)) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); panelRect = currentScreen->geometry(); auto devicePixelRatio = currentScreen->devicePixelRatio(); panelRect.moveTo(static_cast<int>(panelRect.x() / devicePixelRatio), static_cast<int>(panelRect.y() / devicePixelRatio)); #else panelRect = QGuiApplication::primaryScreen()->geometry(); auto devicePixelRatio = QGuiApplication::primaryScreen()->devicePixelRatio(); panelRect.moveTo(panelRect.x() / devicePixelRatio, panelRect.y() / devicePixelRatio); #endif } if (ConfigHandler().showSidePanelButton()) { auto* panelToggleButton = new OrientablePushButton(tr(\"Tool Settings\"), this); makeChild(panelToggleButton); panelToggleButton->setColor(m_uiColor); panelToggleButton->setOrientation( OrientablePushButton::VerticalBottomToTop); #if defined(Q_OS_MACOS) panelToggleButton->move( 0, static_cast<int>(panelRect.height() / 2) - static_cast<int>(panelToggleButton->width() / 2)); #else panelToggleButton->move(panelRect.x(), panelRect.y() + panelRect.height() / 2 - panelToggleButton->width() / 2); #endif panelToggleButton->setCursor(Qt::ArrowCursor); (new DraggableWidgetMaker(this))->makeDraggable(panelToggleButton); connect(panelToggleButton, &QPushButton::clicked, this, &CaptureWidget::togglePanel); } m_panel = new UtilityPanel(this); m_panel->hide(); makeChild(m_panel); #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); panelRect.moveTo(mapFromGlobal(panelRect.topLeft())); m_panel->setFixedWidth(static_cast<int>(m_colorPicker->width() * 1.5)); m_panel->setFixedHeight(currentScreen->geometry().height()); #else panelRect.moveTo(mapFromGlobal(panelRect.topLeft())); panelRect.setWidth(m_colorPicker->width() * 1.5); m_panel->setGeometry(panelRect); #endif connect(m_panel, &UtilityPanel::layerChanged, this, &CaptureWidget::updateActiveLayer); connect(m_panel, &UtilityPanel::moveUpClicked, this, &CaptureWidget::onMoveCaptureToolUp); connect(m_panel, &UtilityPanel::moveDownClicked, this, &CaptureWidget::onMoveCaptureToolDown); m_sidePanel = new SidePanelWidget(&m_context.screenshot, this); connect(m_sidePanel, &SidePanelWidget::colorChanged, this, &CaptureWidget::setDrawColor); connect(m_sidePanel, &SidePanelWidget::toolSizeChanged, this, &CaptureWidget::onToolSizeChanged); connect(this, &CaptureWidget::colorChanged, m_sidePanel, &SidePanelWidget::onColorChanged); connect(this, &CaptureWidget::toolSizeChanged, m_sidePanel, &SidePanelWidget::onToolSizeChanged); connect(m_sidePanel, &SidePanelWidget::togglePanel, m_panel, &UtilityPanel::toggle); // TODO replace with a CaptureWidget signal emit m_sidePanel->colorChanged(m_context.color); emit toolSizeChanged(m_context.toolSize); m_panel->pushWidget(m_sidePanel); // Fill undo/redo/history list widget m_panel->fillCaptureTools(m_captureToolObjects.captureToolObjects()); } #if !defined(DISABLE_UPDATE_CHECKER) void CaptureWidget::showAppUpdateNotification(const QString& appLatestVersion, const QString& appLatestUrl) { if (!ConfigHandler().checkForUpdates()) { // option check for updates disabled return; } if (nullptr == m_updateNotificationWidget) { m_updateNotificationWidget = new UpdateNotificationWidget(this, appLatestVersion, appLatestUrl); } #if defined(Q_OS_MACOS) int ax = (width() - m_updateNotificationWidget->width()) / 2; #elif (defined(Q_OS_LINUX) && QT_VERSION < QT_VERSION_CHECK(5, 10, 0)) QRect helpRect = QGuiApplication::primaryScreen()->geometry(); int ax = helpRect.left() + ((helpRect.width() - m_updateNotificationWidget->width()) / 2); #else QRect helpRect; QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { helpRect = currentScreen->geometry(); } else { helpRect = QGuiApplication::primaryScreen()->geometry(); } int ax = helpRect.left() + ((helpRect.width() - m_updateNotificationWidget->width()) / 2); #endif m_updateNotificationWidget->move(ax, 0); makeChild(m_updateNotificationWidget); m_updateNotificationWidget->show(); } #endif void CaptureWidget::initSelection() { // Be mindful of the order of statements, so that slots are called properly m_selection = new SelectionWidget(m_uiColor, this); QRect initialSelection = m_context.request.initialSelection(); connect(m_selection, &SelectionWidget::geometryChanged, this, [this]() { QRect constrainedToCaptureArea = m_selection->geometry().intersected(rect()); m_context.selection = extendedRect(constrainedToCaptureArea); updateSizeIndicator(); m_buttonHandler->hide(); updateCursor(); OverlayMessage::pop(); }); connect(m_selection, &SelectionWidget::geometrySettled, this, [this]() { if (m_selection->isVisibleTo(this)) { auto& req = m_context.request; if (req.tasks() & CaptureRequest::ACCEPT_ON_SELECT) { req.removeTask(CaptureRequest::ACCEPT_ON_SELECT); m_captureDone = true; close(); } m_buttonHandler->updatePosition(m_selection->geometry()); m_buttonHandler->show(); } else { m_buttonHandler->hide(); } }); connect(m_selection, &SelectionWidget::visibilityChanged, this, [this]() { if (!m_selection->isVisible() && !m_helpMessage.isEmpty()) { OverlayMessage::push(m_helpMessage); } }); if (!initialSelection.isNull()) { const qreal scale = m_context.screenshot.devicePixelRatio(); initialSelection.moveTopLeft(initialSelection.topLeft() - mapToGlobal({})); initialSelection.setTop(initialSelection.top() / scale); initialSelection.setBottom(initialSelection.bottom() / scale); initialSelection.setLeft(initialSelection.left() / scale); initialSelection.setRight(initialSelection.right() / scale); } m_selection->setGeometry(initialSelection); m_selection->setVisible(!initialSelection.isNull()); if (!initialSelection.isNull()) { m_context.selection = extendedRect(m_selection->geometry()); emit m_selection->geometrySettled(); } updateSizeIndicator(); } void CaptureWidget::setState(CaptureToolButton* b) { if (!b) { return; } commitCurrentTool(); if (m_toolWidget && m_activeTool) { if (m_activeTool->isValid()) { pushToolToStack(); } else { releaseActiveTool(); } } if (m_activeButton != b) { auto backup = m_activeTool; // The tool is active during the pressed(). // This must be done in order to handle tool requests correctly. m_activeTool = b->tool(); m_activeTool->pressed(m_context); m_activeTool = backup; } if (b->tool()->isSelectable()) { if (m_activeButton != b) { if (m_activeButton) { m_activeButton->setColor(m_uiColor); } m_activeButton = b; m_activeButton->setColor(m_contrastUiColor); m_panel->setActiveLayer(-1); m_panel->setToolWidget(b->tool()->configurationWidget()); } else if (m_activeButton) { m_panel->clearToolWidget(); m_activeButton->setColor(m_uiColor); m_activeButton = nullptr; } m_context.toolSize = ConfigHandler().toolSize(activeButtonToolType()); emit toolSizeChanged(m_context.toolSize); updateCursor(); updateSelectionState(); updateTool(b->tool()); } } void CaptureWidget::handleToolSignal(CaptureTool::Request r) { switch (r) { case CaptureTool::REQ_CLOSE_GUI: close(); break; case CaptureTool::REQ_HIDE_GUI: hide(); break; case CaptureTool::REQ_UNDO_MODIFICATION: undo(); break; case CaptureTool::REQ_REDO_MODIFICATION: redo(); break; case CaptureTool::REQ_SHOW_COLOR_PICKER: // TODO break; case CaptureTool::REQ_CAPTURE_DONE_OK: m_captureDone = true; break; case CaptureTool::REQ_CLEAR_SELECTION: if (m_panel->activeLayerIndex() >= 0) { m_panel->setActiveLayer(-1); drawToolsData(false); } break; case CaptureTool::REQ_ADD_CHILD_WIDGET: if (!m_activeTool) { break; } if (m_toolWidget) { m_toolWidget->hide(); delete m_toolWidget; m_toolWidget = nullptr; } m_toolWidget = m_activeTool->widget(); if (m_toolWidget) { makeChild(m_toolWidget); m_toolWidget->move(m_context.mousePos); m_toolWidget->show(); m_toolWidget->setFocus(); } break; case CaptureTool::REQ_ADD_EXTERNAL_WIDGETS: if (!m_activeTool) { break; } else { QWidget* w = m_activeTool->widget(); w->setAttribute(Qt::WA_DeleteOnClose); w->activateWindow(); w->show(); Flameshot::instance()->setExternalWidget(true); } break; case CaptureTool::REQ_INCREASE_TOOL_SIZE: setToolSize(m_context.toolSize + 1); break; case CaptureTool::REQ_DECREASE_TOOL_SIZE: setToolSize(m_context.toolSize - 1); break; default: break; } } void CaptureWidget::onToolSizeChanged(int t) { m_context.toolSize = t; CaptureTool* tool = activeButtonTool(); if (tool && tool->showMousePreview()) { setCursor(Qt::BlankCursor); tool->onSizeChanged(t); } // update tool size of object being drawn if (m_activeTool != nullptr) { updateTool(m_activeTool); } // update tool size of selected object auto toolItem = activeToolObject(); if (toolItem) { // Change thickness toolItem->onSizeChanged(t); if (!m_existingObjectIsChanged) { m_captureToolObjectsBackup = m_captureToolObjects; m_existingObjectIsChanged = true; } drawToolsData(); updateTool(toolItem); } // Force a repaint to prevent artifacting this->repaint(); } void CaptureWidget::onToolSizeSettled(int size) { m_config.setToolSize(activeButtonToolType(), size); } void CaptureWidget::setDrawColor(const QColor& c) { m_context.color = c; if (m_context.color.isValid()) { ConfigHandler().setDrawColor(m_context.color); emit colorChanged(c); // Update mouse preview updateTool(activeButtonTool()); // change color for the active tool auto toolItem = activeToolObject(); if (toolItem) { // Change color toolItem->onColorChanged(c); drawToolsData(); } } } void CaptureWidget::updateActiveLayer(int layer) { // TODO - refactor this part, make all objects to work with // m_activeTool->isChanged() and remove m_existingObjectIsChanged if (m_activeTool && m_activeTool->type() == CaptureTool::TYPE_TEXT && m_activeTool->isChanged()) { commitCurrentTool(); } if (m_toolWidget) { // Release active tool if it is in the editing mode but not changed and // has editing widget (ex: text tool) releaseActiveTool(); } if (m_existingObjectIsChanged) { m_existingObjectIsChanged = false; pushObjectsStateToUndoStack(); } drawToolsData(); drawObjectSelection(); updateSelectionState(); } void CaptureWidget::onMoveCaptureToolUp(int captureToolIndex) { m_captureToolObjectsBackup = m_captureToolObjects; pushObjectsStateToUndoStack(); auto tool = m_captureToolObjects.at(captureToolIndex); m_captureToolObjects.removeAt(captureToolIndex); m_captureToolObjects.insert(captureToolIndex - 1, tool); updateLayersPanel(); } void CaptureWidget::onMoveCaptureToolDown(int captureToolIndex) { m_captureToolObjectsBackup = m_captureToolObjects; pushObjectsStateToUndoStack(); auto tool = m_captureToolObjects.at(captureToolIndex); m_captureToolObjects.removeAt(captureToolIndex); m_captureToolObjects.insert(captureToolIndex + 1, tool); updateLayersPanel(); } void CaptureWidget::selectAll() { m_selection->show(); m_selection->setGeometry(rect()); emit m_selection->geometrySettled(); m_buttonHandler->show(); updateSelectionState(); } void CaptureWidget::removeToolObject(int index) { --index; if (index >= 0 && index < m_captureToolObjects.size()) { // in case this tool is circle counter int removedCircleCount = -1; const CaptureTool::Type currentToolType = m_captureToolObjects.at(index)->type(); m_captureToolObjectsBackup = m_captureToolObjects; update( paddedUpdateRect(m_captureToolObjects.at(index)->boundingRect())); if (currentToolType == CaptureTool::TYPE_CIRCLECOUNT) { removedCircleCount = m_captureToolObjects.at(index)->count(); --m_context.circleCount; // Decrement circle counter numbers starting from deleted circle for (int cnt = 0; cnt < m_captureToolObjects.size(); cnt++) { auto toolItem = m_captureToolObjects.at(cnt); if (toolItem->type() != CaptureTool::TYPE_CIRCLECOUNT) { continue; } auto circleTool = m_captureToolObjects.at(cnt); if (circleTool->count() >= removedCircleCount) { circleTool->setCount(circleTool->count() - 1); } } } m_captureToolObjects.removeAt(index); pushObjectsStateToUndoStack(); drawToolsData(); updateLayersPanel(); } } void CaptureWidget::initShortcuts() { newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_UNDO\")), this, SLOT(undo())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_REDO\")), this, SLOT(redo())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\")), this, SLOT(togglePanel())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_LEFT\")), m_selection, SLOT(resizeLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_RIGHT\")), m_selection, SLOT(resizeRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_UP\")), m_selection, SLOT(resizeUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_DOWN\")), m_selection, SLOT(resizeDown())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_LEFT\")), m_selection, SLOT(symResizeLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_RIGHT\")), m_selection, SLOT(symResizeRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_UP\")), m_selection, SLOT(symResizeUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_DOWN\")), m_selection, SLOT(symResizeDown())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_LEFT\")), m_selection, SLOT(moveLeft())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_RIGHT\")), m_selection, SLOT(moveRight())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_UP\")), m_selection, SLOT(moveUp())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_DOWN\")), m_selection, SLOT(moveDown())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_DELETE_CURRENT_TOOL\")), this, SLOT(deleteCurrentTool())); newShortcut( QKeySequence(ConfigHandler().shortcut(\"TYPE_COMMIT_CURRENT_TOOL\")), this, SLOT(commitCurrentTool())); newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SELECT_ALL\")), this, SLOT(selectAll())); newShortcut(Qt::Key_Escape, this, SLOT(deleteToolWidgetOrClose())); } void CaptureWidget::deleteCurrentTool() { int oldToolSize = m_context.toolSize; m_panel->slotButtonDelete(true); drawObjectSelection(); if (oldToolSize != m_context.toolSize) { emit toolSizeChanged(m_context.toolSize); } } void CaptureWidget::updateSizeIndicator() { showxywh(); // Note: even if sizeIndButton goes away, we have to keep this! if (m_sizeIndButton) { const QRect& selection = extendedSelection(); m_sizeIndButton->setText(QStringLiteral(\"%1\\n%2\") .arg(selection.width()) .arg(selection.height())); } } void CaptureWidget::updateCursor() { if (m_colorPicker && m_colorPicker->isVisible()) { setCursor(Qt::ArrowCursor); } else if (m_activeButton != nullptr && activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) { setCursor(Qt::CrossCursor); } else if (m_selection->getMouseSide(mapFromGlobal(QCursor::pos())) != SelectionWidget::NO_SIDE) { setCursor(m_selection->cursor()); } else if (activeButtonToolType() == CaptureTool::TYPE_MOVESELECTION) { setCursor(Qt::OpenHandCursor); } else { setCursor(Qt::CrossCursor); } } void CaptureWidget::updateSelectionState() { auto toolType = activeButtonToolType(); if (toolType == CaptureTool::TYPE_MOVESELECTION) { m_selection->setIdleCentralCursor(Qt::OpenHandCursor); m_selection->setIgnoreMouse(false); } else { m_selection->setIdleCentralCursor(Qt::ArrowCursor); if (toolType == CaptureTool::NONE) { m_selection->setIgnoreMouse(m_panel->activeLayerIndex() != -1); } else { m_selection->setIgnoreMouse(true); } } } void CaptureWidget::updateTool(CaptureTool* tool) { if (!tool || !tool->showMousePreview()) { return; } static QRect oldPreviewRect, oldToolObjectRect; QRect previewRect(tool->mousePreviewRect(m_context)); previewRect += QMargins(previewRect.width(), previewRect.height(), previewRect.width(), previewRect.height()); QRect toolObjectRect = paddedUpdateRect(tool->boundingRect()); // old rects are united with current rects to handle sudden mouse movement update(previewRect); update(toolObjectRect); update(oldPreviewRect); update(oldToolObjectRect); oldPreviewRect = previewRect; oldToolObjectRect = toolObjectRect; } void CaptureWidget::updateLayersPanel() { m_panel->fillCaptureTools(m_captureToolObjects.captureToolObjects()); } void CaptureWidget::pushToolToStack() { // append current tool to the new state if (m_activeTool && m_activeButton) { disconnect(this, &CaptureWidget::colorChanged, m_activeTool, &CaptureTool::onColorChanged); disconnect(this, &CaptureWidget::toolSizeChanged, m_activeTool, &CaptureTool::onSizeChanged); if (m_panel->toolWidget()) { disconnect(m_panel->toolWidget(), nullptr, m_activeTool, nullptr); } // disable signal connect for updating layer because it may call this // function again on text objects m_panel->blockSignals(true); m_captureToolObjectsBackup = m_captureToolObjects; m_captureToolObjects.append(m_activeTool); pushObjectsStateToUndoStack(); releaseActiveTool(); drawToolsData(); updateLayersPanel(); // restore signal connection for updating layer m_panel->blockSignals(false); } } void CaptureWidget::drawToolsData(bool drawSelection) { // TODO refactor this for performance. The objects should not all be updated // at once every time QPixmap pixmapItem = m_context.origScreenshot; for (auto toolItem : m_captureToolObjects.captureToolObjects()) { processPixmapWithTool(&pixmapItem, toolItem); update(paddedUpdateRect(toolItem->boundingRect())); } m_context.screenshot = pixmapItem; if (drawSelection) { drawObjectSelection(); } } void CaptureWidget::drawObjectSelection() { auto toolItem = activeToolObject(); if (toolItem && !toolItem->editMode()) { QPainter painter(&m_context.screenshot); toolItem->drawObjectSelection(painter); // TODO move this elsewhere if (m_context.toolSize != toolItem->size()) { m_context.toolSize = toolItem->size(); } if (activeToolObject() && m_activeButton) { uncheckActiveTool(); } } } void CaptureWidget::processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool) { QPainter painter(pixmap); painter.setRenderHint(QPainter::Antialiasing); tool->process(painter, *pixmap); } CaptureTool* CaptureWidget::activeButtonTool() const { if (m_activeButton == nullptr) { return nullptr; } return m_activeButton->tool(); } CaptureTool::Type CaptureWidget::activeButtonToolType() const { auto* activeTool = activeButtonTool(); if (activeTool == nullptr) { return CaptureTool::NONE; } return activeTool->type(); } QPointer<CaptureTool> CaptureWidget::activeToolObject() { return m_captureToolObjects.at(m_panel->activeLayerIndex()); } void CaptureWidget::makeChild(QWidget* w) { w->setParent(this); w->installEventFilter(m_eventFilter); } void CaptureWidget::restoreCircleCountState() { int largest = 0; for (int cnt = 0; cnt < m_captureToolObjects.size(); cnt++) { auto toolItem = m_captureToolObjects.at(cnt); if (toolItem->type() != CaptureTool::TYPE_CIRCLECOUNT) { continue; } if (toolItem->count() > largest) { largest = toolItem->count(); } } m_context.circleCount = largest + 1; } QList<QShortcut*> CaptureWidget::newShortcut(const QKeySequence& key, QWidget* parent, const char* slot) { QList<QShortcut*> shortcuts; QString strKey = key.toString(); if (strKey.contains(\"Enter\") || strKey.contains(\"Return\")) { strKey.replace(\"Enter\", \"Return\"); shortcuts << new QShortcut(strKey, parent, slot); strKey.replace(\"Return\", \"Enter\"); shortcuts << new QShortcut(strKey, parent, slot); } else { shortcuts << new QShortcut(key, parent, slot); } return shortcuts; } void CaptureWidget::togglePanel() { m_panel->toggle(); } void CaptureWidget::childEnter() { m_previewEnabled = false; updateTool(activeButtonTool()); } void CaptureWidget::childLeave() { m_previewEnabled = true; updateTool(activeButtonTool()); } void CaptureWidget::setCaptureToolObjects( const CaptureToolObjects& captureToolObjects) { // Used for undo/redo m_captureToolObjects = captureToolObjects; drawToolsData(); updateLayersPanel(); drawObjectSelection(); } void CaptureWidget::undo() { if (m_activeTool && (m_activeTool->isChanged() || m_activeTool->editMode())) { // Remove selection on undo, at the same time commit current tool will // be called m_panel->setActiveLayer(-1); } // drawToolsData is called twice to update both previous and new regions // FIXME this is a temporary workaround drawToolsData(); m_undoStack.undo(); drawToolsData(); updateLayersPanel(); restoreCircleCountState(); } void CaptureWidget::redo() { // drawToolsData is called twice to update both previous and new regions // FIXME this is a temporary workaround drawToolsData(); m_undoStack.redo(); drawToolsData(); update(); updateLayersPanel(); restoreCircleCountState(); } QRect CaptureWidget::extendedSelection() const { if (m_selection == nullptr) { return {}; } QRect r = m_selection->geometry(); return extendedRect(r); } QRect CaptureWidget::extendedRect(const QRect& r) const { auto devicePixelRatio = m_context.screenshot.devicePixelRatio(); return { static_cast<int>(r.left() * devicePixelRatio), static_cast<int>(r.top() * devicePixelRatio), static_cast<int>(r.width() * devicePixelRatio), static_cast<int>(r.height() * devicePixelRatio) }; } QRect CaptureWidget::paddedUpdateRect(const QRect& r) const { if (r.isNull()) { return r; } else { return r + QMargins(20, 20, 20, 20); } } void CaptureWidget::drawErrorMessage(const QString& msg, QPainter* painter) { auto textRect = painter->fontMetrics().boundingRect(msg); int w = textRect.width(), h = textRect.height(); textRect = { size().width() - w - 10, size().height() - h - 5, w + 100, h + 100 }; QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (!textRect.contains(QCursor::pos(currentScreen))) { QColor textColor(Qt::white); painter->setPen(textColor); painter->drawText(textRect, msg); } } void CaptureWidget::drawInactiveRegion(QPainter* painter) { QColor overlayColor(0, 0, 0, m_opacity); painter->setBrush(overlayColor); QRect r; if (m_selection->isVisible()) { r = m_selection->geometry().normalized(); } QRegion grey(rect()); grey = grey.subtracted(r); painter->setClipRegion(grey); painter->drawRect(-1, -1, rect().width() + 1, rect().height() + 1); }","title":"File capturewidget.cpp"},{"location":"flameshot/capturewidget_8h/","text":"File capturewidget.h # FileList > capture > capturewidget.h Go to the source code of this file. #include \"buttonhandler.h\" #include \"capturetoolbutton.h\" #include \"capturetoolobjects.h\" #include \"src/config/generalconf.h\" #include \"src/tools/capturecontext.h\" #include \"src/tools/capturetool.h\" #include \"src/utils/confighandler.h\" #include \"src/widgets/capture/magnifierwidget.h\" #include \"src/widgets/capture/selectionwidget.h\" #include <QPointer> #include <QTimer> #include <QUndoStack> #include <QWidget> Classes # Type Name class CaptureWidget","title":"File capturewidget.h"},{"location":"flameshot/capturewidget_8h/#file-capturewidgeth","text":"FileList > capture > capturewidget.h Go to the source code of this file. #include \"buttonhandler.h\" #include \"capturetoolbutton.h\" #include \"capturetoolobjects.h\" #include \"src/config/generalconf.h\" #include \"src/tools/capturecontext.h\" #include \"src/tools/capturetool.h\" #include \"src/utils/confighandler.h\" #include \"src/widgets/capture/magnifierwidget.h\" #include \"src/widgets/capture/selectionwidget.h\" #include <QPointer> #include <QTimer> #include <QUndoStack> #include <QWidget>","title":"File capturewidget.h"},{"location":"flameshot/capturewidget_8h/#classes","text":"Type Name class CaptureWidget","title":"Classes"},{"location":"flameshot/capturewidget_8h_source/","text":"File capturewidget.h # File List > capture > capturewidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #pragma once #include \"buttonhandler.h\" #include \"capturetoolbutton.h\" #include \"capturetoolobjects.h\" #include \"src/config/generalconf.h\" #include \"src/tools/capturecontext.h\" #include \"src/tools/capturetool.h\" #include \"src/utils/confighandler.h\" #include \"src/widgets/capture/magnifierwidget.h\" #include \"src/widgets/capture/selectionwidget.h\" #include <QPointer> #include <QTimer> #include <QUndoStack> #include <QWidget> class QLabel; class QPaintEvent; class QResizeEvent; class QMouseEvent; class QShortcut; class QNetworkAccessManager; class QNetworkReply; class ColorPicker; class NotifierBox; class HoverEventFilter; #if !defined(DISABLE_UPDATE_CHECKER) class UpdateNotificationWidget; #endif class UtilityPanel; class SidePanelWidget; class CaptureWidget : public QWidget { Q_OBJECT public: explicit CaptureWidget(const CaptureRequest& req, bool fullScreen = true, QWidget* parent = nullptr); ~CaptureWidget(); QPixmap pixmap(); void setCaptureToolObjects(const CaptureToolObjects& captureToolObjects); #if !defined(DISABLE_UPDATE_CHECKER) void showAppUpdateNotification(const QString& appLatestVersion, const QString& appLatestUrl); #endif public slots: bool commitCurrentTool(); void deleteToolWidgetOrClose(); signals: void colorChanged(const QColor& c); void toolSizeChanged(int size); private slots: void undo(); void redo(); void togglePanel(); void childEnter(); void childLeave(); void deleteCurrentTool(); void setState(CaptureToolButton* b); void handleToolSignal(CaptureTool::Request r); void handleButtonLeftClick(CaptureToolButton* b); void handleButtonRightClick(CaptureToolButton* b); void setDrawColor(const QColor& c); void onToolSizeChanged(int size); void onToolSizeSettled(int size); void updateActiveLayer(int layer); void onMoveCaptureToolUp(int captureToolIndex); void onMoveCaptureToolDown(int captureToolIndex); void selectAll(); void xywhTick(); public: void removeToolObject(int index = -1); void showxywh(bool show = true); protected: void paintEvent(QPaintEvent* paintEvent) override; void mousePressEvent(QMouseEvent* mouseEvent) override; void mouseMoveEvent(QMouseEvent* mouseEvent) override; void mouseReleaseEvent(QMouseEvent* mouseEvent) override; void mouseDoubleClickEvent(QMouseEvent* event) override; void keyPressEvent(QKeyEvent* keyEvent) override; void keyReleaseEvent(QKeyEvent* keyEvent) override; void wheelEvent(QWheelEvent* wheelEvent) override; void resizeEvent(QResizeEvent* resizeEvent) override; void moveEvent(QMoveEvent* moveEvent) override; void changeEvent(QEvent* changeEvent) override; private: void pushObjectsStateToUndoStack(); void releaseActiveTool(); void uncheckActiveTool(); int selectToolItemAtPos(const QPoint& pos); void showColorPicker(const QPoint& pos); bool startDrawObjectTool(const QPoint& pos); QPointer<CaptureTool> activeToolObject(); void initContext(bool fullscreen, const CaptureRequest& req); void initPanel(); void initSelection(); void initShortcuts(); void initButtons(); void initHelpMessage(); void updateSizeIndicator(); void updateCursor(); void updateSelectionState(); void updateTool(CaptureTool* tool); void updateLayersPanel(); void pushToolToStack(); void makeChild(QWidget* w); void restoreCircleCountState(); QList<QShortcut*> newShortcut(const QKeySequence& key, QWidget* parent, const char* slot); void setToolSize(int size); QRect extendedSelection() const; QRect extendedRect(const QRect& r) const; QRect paddedUpdateRect(const QRect& r) const; void drawErrorMessage(const QString& msg, QPainter* painter); void drawInactiveRegion(QPainter* painter); void drawToolsData(bool drawSelection = true); void drawObjectSelection(); void processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool); CaptureTool* activeButtonTool() const; CaptureTool::Type activeButtonToolType() const; // Class members // Context information CaptureContext m_context; // Main ui color QColor m_uiColor; // Secondary ui color QColor m_contrastUiColor; // Outside selection opacity int m_opacity; int m_toolSizeByKeyboard; // utility flags bool m_mouseIsClicked; bool m_newSelection; bool m_movingSelection; bool m_captureDone; bool m_previewEnabled; bool m_adjustmentButtonPressed; bool m_configError; bool m_configErrorResolved; #if !defined(DISABLE_UPDATE_CHECKER) UpdateNotificationWidget* m_updateNotificationWidget; #endif quint64 m_lastMouseWheel; QPointer<CaptureToolButton> m_sizeIndButton; // Last pressed button QPointer<CaptureToolButton> m_activeButton; QPointer<CaptureTool> m_activeTool; bool m_activeToolIsMoved; QPointer<QWidget> m_toolWidget; ButtonHandler* m_buttonHandler; UtilityPanel* m_panel; SidePanelWidget* m_sidePanel; ColorPicker* m_colorPicker; ConfigHandler m_config; NotifierBox* m_notifierBox; HoverEventFilter* m_eventFilter; SelectionWidget* m_selection; MagnifierWidget* m_magnifier; QString m_helpMessage; SelectionWidget::SideType m_mouseOverHandle; QMap<CaptureTool::Type, CaptureTool*> m_tools; CaptureToolObjects m_captureToolObjects; CaptureToolObjects m_captureToolObjectsBackup; QPoint m_mousePressedPos; QPoint m_activeToolOffsetToMouseOnStart; // XYWH display position and timer bool m_xywhDisplay; QTimer m_xywhTimer; QUndoStack m_undoStack; bool m_existingObjectIsChanged; // For start moving after more than X offset QPoint m_startMovePos; bool m_startMove; };","title":"File capturewidget.h"},{"location":"flameshot/capturewidget_8h_source/#file-capturewidgeth","text":"File List > capture > capturewidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #pragma once #include \"buttonhandler.h\" #include \"capturetoolbutton.h\" #include \"capturetoolobjects.h\" #include \"src/config/generalconf.h\" #include \"src/tools/capturecontext.h\" #include \"src/tools/capturetool.h\" #include \"src/utils/confighandler.h\" #include \"src/widgets/capture/magnifierwidget.h\" #include \"src/widgets/capture/selectionwidget.h\" #include <QPointer> #include <QTimer> #include <QUndoStack> #include <QWidget> class QLabel; class QPaintEvent; class QResizeEvent; class QMouseEvent; class QShortcut; class QNetworkAccessManager; class QNetworkReply; class ColorPicker; class NotifierBox; class HoverEventFilter; #if !defined(DISABLE_UPDATE_CHECKER) class UpdateNotificationWidget; #endif class UtilityPanel; class SidePanelWidget; class CaptureWidget : public QWidget { Q_OBJECT public: explicit CaptureWidget(const CaptureRequest& req, bool fullScreen = true, QWidget* parent = nullptr); ~CaptureWidget(); QPixmap pixmap(); void setCaptureToolObjects(const CaptureToolObjects& captureToolObjects); #if !defined(DISABLE_UPDATE_CHECKER) void showAppUpdateNotification(const QString& appLatestVersion, const QString& appLatestUrl); #endif public slots: bool commitCurrentTool(); void deleteToolWidgetOrClose(); signals: void colorChanged(const QColor& c); void toolSizeChanged(int size); private slots: void undo(); void redo(); void togglePanel(); void childEnter(); void childLeave(); void deleteCurrentTool(); void setState(CaptureToolButton* b); void handleToolSignal(CaptureTool::Request r); void handleButtonLeftClick(CaptureToolButton* b); void handleButtonRightClick(CaptureToolButton* b); void setDrawColor(const QColor& c); void onToolSizeChanged(int size); void onToolSizeSettled(int size); void updateActiveLayer(int layer); void onMoveCaptureToolUp(int captureToolIndex); void onMoveCaptureToolDown(int captureToolIndex); void selectAll(); void xywhTick(); public: void removeToolObject(int index = -1); void showxywh(bool show = true); protected: void paintEvent(QPaintEvent* paintEvent) override; void mousePressEvent(QMouseEvent* mouseEvent) override; void mouseMoveEvent(QMouseEvent* mouseEvent) override; void mouseReleaseEvent(QMouseEvent* mouseEvent) override; void mouseDoubleClickEvent(QMouseEvent* event) override; void keyPressEvent(QKeyEvent* keyEvent) override; void keyReleaseEvent(QKeyEvent* keyEvent) override; void wheelEvent(QWheelEvent* wheelEvent) override; void resizeEvent(QResizeEvent* resizeEvent) override; void moveEvent(QMoveEvent* moveEvent) override; void changeEvent(QEvent* changeEvent) override; private: void pushObjectsStateToUndoStack(); void releaseActiveTool(); void uncheckActiveTool(); int selectToolItemAtPos(const QPoint& pos); void showColorPicker(const QPoint& pos); bool startDrawObjectTool(const QPoint& pos); QPointer<CaptureTool> activeToolObject(); void initContext(bool fullscreen, const CaptureRequest& req); void initPanel(); void initSelection(); void initShortcuts(); void initButtons(); void initHelpMessage(); void updateSizeIndicator(); void updateCursor(); void updateSelectionState(); void updateTool(CaptureTool* tool); void updateLayersPanel(); void pushToolToStack(); void makeChild(QWidget* w); void restoreCircleCountState(); QList<QShortcut*> newShortcut(const QKeySequence& key, QWidget* parent, const char* slot); void setToolSize(int size); QRect extendedSelection() const; QRect extendedRect(const QRect& r) const; QRect paddedUpdateRect(const QRect& r) const; void drawErrorMessage(const QString& msg, QPainter* painter); void drawInactiveRegion(QPainter* painter); void drawToolsData(bool drawSelection = true); void drawObjectSelection(); void processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool); CaptureTool* activeButtonTool() const; CaptureTool::Type activeButtonToolType() const; // Class members // Context information CaptureContext m_context; // Main ui color QColor m_uiColor; // Secondary ui color QColor m_contrastUiColor; // Outside selection opacity int m_opacity; int m_toolSizeByKeyboard; // utility flags bool m_mouseIsClicked; bool m_newSelection; bool m_movingSelection; bool m_captureDone; bool m_previewEnabled; bool m_adjustmentButtonPressed; bool m_configError; bool m_configErrorResolved; #if !defined(DISABLE_UPDATE_CHECKER) UpdateNotificationWidget* m_updateNotificationWidget; #endif quint64 m_lastMouseWheel; QPointer<CaptureToolButton> m_sizeIndButton; // Last pressed button QPointer<CaptureToolButton> m_activeButton; QPointer<CaptureTool> m_activeTool; bool m_activeToolIsMoved; QPointer<QWidget> m_toolWidget; ButtonHandler* m_buttonHandler; UtilityPanel* m_panel; SidePanelWidget* m_sidePanel; ColorPicker* m_colorPicker; ConfigHandler m_config; NotifierBox* m_notifierBox; HoverEventFilter* m_eventFilter; SelectionWidget* m_selection; MagnifierWidget* m_magnifier; QString m_helpMessage; SelectionWidget::SideType m_mouseOverHandle; QMap<CaptureTool::Type, CaptureTool*> m_tools; CaptureToolObjects m_captureToolObjects; CaptureToolObjects m_captureToolObjectsBackup; QPoint m_mousePressedPos; QPoint m_activeToolOffsetToMouseOnStart; // XYWH display position and timer bool m_xywhDisplay; QTimer m_xywhTimer; QUndoStack m_undoStack; bool m_existingObjectIsChanged; // For start moving after more than X offset QPoint m_startMovePos; bool m_startMove; };","title":"File capturewidget.h"},{"location":"flameshot/colorpicker_8cpp/","text":"File colorpicker.cpp # FileList > capture > colorpicker.cpp Go to the source code of this file. #include \"colorpicker.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpicker.cpp"},{"location":"flameshot/colorpicker_8cpp/#file-colorpickercpp","text":"FileList > capture > colorpicker.cpp Go to the source code of this file. #include \"colorpicker.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpicker.cpp"},{"location":"flameshot/colorpicker_8cpp_source/","text":"File colorpicker.cpp # File List > capture > colorpicker.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"colorpicker.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter> ColorPicker::ColorPicker(QWidget* parent) : ColorPickerWidget(parent) { setMouseTracking(true); ConfigHandler config; QColor drawColor = config.drawColor(); for (int i = 0; i < m_colorList.size(); ++i) { if (m_colorList.at(i) == drawColor) { m_selectedIndex = i; m_lastIndex = i; break; } } } void ColorPicker::mouseMoveEvent(QMouseEvent* e) { for (int i = 0; i < m_colorList.size(); ++i) { if (m_colorAreaList.at(i).contains(e->pos())) { m_selectedIndex = i; update(m_colorAreaList.at(i) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = i; break; } } } void ColorPicker::showEvent(QShowEvent* event) { grabMouse(); } void ColorPicker::hideEvent(QHideEvent* event) { releaseMouse(); emit colorSelected(m_colorList.at(m_selectedIndex)); }","title":"File colorpicker.cpp"},{"location":"flameshot/colorpicker_8cpp_source/#file-colorpickercpp","text":"File List > capture > colorpicker.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"colorpicker.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter> ColorPicker::ColorPicker(QWidget* parent) : ColorPickerWidget(parent) { setMouseTracking(true); ConfigHandler config; QColor drawColor = config.drawColor(); for (int i = 0; i < m_colorList.size(); ++i) { if (m_colorList.at(i) == drawColor) { m_selectedIndex = i; m_lastIndex = i; break; } } } void ColorPicker::mouseMoveEvent(QMouseEvent* e) { for (int i = 0; i < m_colorList.size(); ++i) { if (m_colorAreaList.at(i).contains(e->pos())) { m_selectedIndex = i; update(m_colorAreaList.at(i) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = i; break; } } } void ColorPicker::showEvent(QShowEvent* event) { grabMouse(); } void ColorPicker::hideEvent(QHideEvent* event) { releaseMouse(); emit colorSelected(m_colorList.at(m_selectedIndex)); }","title":"File colorpicker.cpp"},{"location":"flameshot/colorpicker_8h/","text":"File colorpicker.h # FileList > capture > colorpicker.h Go to the source code of this file. #include \"src/widgets/colorpickerwidget.h\" Classes # Type Name class ColorPicker","title":"File colorpicker.h"},{"location":"flameshot/colorpicker_8h/#file-colorpickerh","text":"FileList > capture > colorpicker.h Go to the source code of this file. #include \"src/widgets/colorpickerwidget.h\"","title":"File colorpicker.h"},{"location":"flameshot/colorpicker_8h/#classes","text":"Type Name class ColorPicker","title":"Classes"},{"location":"flameshot/colorpicker_8h_source/","text":"File colorpicker.h # File List > capture > colorpicker.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/colorpickerwidget.h\" class ColorPicker : public ColorPickerWidget { Q_OBJECT public: explicit ColorPicker(QWidget* parent = nullptr); signals: void colorSelected(QColor c); protected: void showEvent(QShowEvent* event) override; void hideEvent(QHideEvent* event) override; void mouseMoveEvent(QMouseEvent* e) override; };","title":"File colorpicker.h"},{"location":"flameshot/colorpicker_8h_source/#file-colorpickerh","text":"File List > capture > colorpicker.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/widgets/colorpickerwidget.h\" class ColorPicker : public ColorPickerWidget { Q_OBJECT public: explicit ColorPicker(QWidget* parent = nullptr); signals: void colorSelected(QColor c); protected: void showEvent(QShowEvent* event) override; void hideEvent(QHideEvent* event) override; void mouseMoveEvent(QMouseEvent* e) override; };","title":"File colorpicker.h"},{"location":"flameshot/hovereventfilter_8cpp/","text":"File hovereventfilter.cpp # FileList > capture > hovereventfilter.cpp Go to the source code of this file. #include \"hovereventfilter.h\" #include <QEvent>","title":"File hovereventfilter.cpp"},{"location":"flameshot/hovereventfilter_8cpp/#file-hovereventfiltercpp","text":"FileList > capture > hovereventfilter.cpp Go to the source code of this file. #include \"hovereventfilter.h\" #include <QEvent>","title":"File hovereventfilter.cpp"},{"location":"flameshot/hovereventfilter_8cpp_source/","text":"File hovereventfilter.cpp # File List > capture > hovereventfilter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #include \"hovereventfilter.h\" #include <QEvent> HoverEventFilter::HoverEventFilter(QObject* parent) : QObject(parent) {} bool HoverEventFilter::eventFilter(QObject* watched, QEvent* event) { QEvent::Type t = event->type(); switch (t) { case QEvent::Enter: emit hoverIn(watched); break; case QEvent::Leave: emit hoverOut(watched); break; default: break; } return false; }","title":"File hovereventfilter.cpp"},{"location":"flameshot/hovereventfilter_8cpp_source/#file-hovereventfiltercpp","text":"File List > capture > hovereventfilter.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #include \"hovereventfilter.h\" #include <QEvent> HoverEventFilter::HoverEventFilter(QObject* parent) : QObject(parent) {} bool HoverEventFilter::eventFilter(QObject* watched, QEvent* event) { QEvent::Type t = event->type(); switch (t) { case QEvent::Enter: emit hoverIn(watched); break; case QEvent::Leave: emit hoverOut(watched); break; default: break; } return false; }","title":"File hovereventfilter.cpp"},{"location":"flameshot/hovereventfilter_8h/","text":"File hovereventfilter.h # FileList > capture > hovereventfilter.h Go to the source code of this file. #include <QObject> Classes # Type Name class HoverEventFilter","title":"File hovereventfilter.h"},{"location":"flameshot/hovereventfilter_8h/#file-hovereventfilterh","text":"FileList > capture > hovereventfilter.h Go to the source code of this file. #include <QObject>","title":"File hovereventfilter.h"},{"location":"flameshot/hovereventfilter_8h/#classes","text":"Type Name class HoverEventFilter","title":"Classes"},{"location":"flameshot/hovereventfilter_8h_source/","text":"File hovereventfilter.h # File List > capture > hovereventfilter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #pragma once #include <QObject> class HoverEventFilter : public QObject { Q_OBJECT public: explicit HoverEventFilter(QObject* parent = nullptr); signals: void hoverIn(QObject*); void hoverOut(QObject*); protected: bool eventFilter(QObject* watched, QEvent* event); };","title":"File hovereventfilter.h"},{"location":"flameshot/hovereventfilter_8h_source/#file-hovereventfilterh","text":"File List > capture > hovereventfilter.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on Lightscreen areadialog.h, Copyright 2017 Christian Kaiser // <info@ckaiser.com.ar> released under the GNU GPL2 // <https://www.gnu.org/licenses/gpl-2.0.txt> // Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007 // Luca Gugelmann <lucag@student.ethz.ch> released under the GNU LGPL // <http://www.gnu.org/licenses/old-licenses/library.txt> #pragma once #include <QObject> class HoverEventFilter : public QObject { Q_OBJECT public: explicit HoverEventFilter(QObject* parent = nullptr); signals: void hoverIn(QObject*); void hoverOut(QObject*); protected: bool eventFilter(QObject* watched, QEvent* event); };","title":"File hovereventfilter.h"},{"location":"flameshot/magnifierwidget_8cpp/","text":"File magnifierwidget.cpp # FileList > capture > magnifierwidget.cpp Go to the source code of this file. #include \"magnifierwidget.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPainterPath> #include <QPen> #include <QPixmap>","title":"File magnifierwidget.cpp"},{"location":"flameshot/magnifierwidget_8cpp/#file-magnifierwidgetcpp","text":"FileList > capture > magnifierwidget.cpp Go to the source code of this file. #include \"magnifierwidget.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPainterPath> #include <QPen> #include <QPixmap>","title":"File magnifierwidget.cpp"},{"location":"flameshot/magnifierwidget_8cpp_source/","text":"File magnifierwidget.cpp # File List > capture > magnifierwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"magnifierwidget.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPainterPath> #include <QPen> #include <QPixmap> MagnifierWidget::MagnifierWidget(const QPixmap& p, const QColor& c, bool isSquare, QWidget* parent) : QWidget(parent) , m_color(c) , m_borderColor(c) , m_screenshot(p) , m_square(isSquare) { setFixedSize(parent->width(), parent->height()); setAttribute(Qt::WA_TransparentForMouseEvents); m_color.setAlpha(130); // add padding for circular magnifier QImage padded(p.width() + 2 * m_magPixels, p.height() + 2 * m_magPixels, QImage::Format_ARGB32); padded.fill(Qt::black); QPainter painter(&padded); painter.drawPixmap(m_magPixels, m_magPixels, p); m_paddedScreenshot.convertFromImage(padded); } void MagnifierWidget::paintEvent(QPaintEvent*) { QPainter p(this); if (m_square) { drawMagnifier(p); } else { drawMagnifierCircle(p); } } void MagnifierWidget::drawMagnifierCircle(QPainter& painter) { auto relativeCursor = QCursor::pos(); auto translated = QWidget::mapFromGlobal(relativeCursor); auto x = translated.x() + m_magPixels; auto y = translated.y() + m_magPixels; int magX = static_cast<int>(x * m_devicePixelRatio - m_magPixels); int magY = static_cast<int>(y * m_devicePixelRatio - m_magPixels); QRectF magniRect(magX, magY, m_pixels, m_pixels); qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2; if (drawPosX > width() - m_pixels * magZoom / 2) { drawPosX = x - m_magOffset - m_pixels * magZoom / 2; } qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2; if (drawPosY > height() - m_pixels * magZoom / 2) { drawPosY = y - m_magOffset - m_pixels * magZoom / 2; } QPointF drawPos(drawPosX, drawPosY); QRectF crossHairTop(drawPos.x() + magZoom * (-0.5), drawPos.y() - magZoom * (m_magPixels + 0.5), magZoom, magZoom * (m_magPixels)); QRectF crossHairRight(drawPos.x() + magZoom * (0.5), drawPos.y() + magZoom * (-0.5), magZoom * (m_magPixels), magZoom); QRectF crossHairBottom(drawPos.x() + magZoom * (-0.5), drawPos.y() + magZoom * (0.5), magZoom, magZoom * (m_magPixels)); QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5), drawPos.y() + magZoom * (-0.5), magZoom * (m_magPixels), magZoom); QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1, drawPos.y() - magZoom * (m_magPixels + 0.5) - 1, m_pixels * magZoom + 2, m_pixels * magZoom + 2); const auto frag = QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom); painter.setRenderHint(QPainter::Antialiasing, true); QPainterPath path = QPainterPath(); path.addEllipse(drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2); painter.setClipPath(path); painter.drawPixmapFragments( &frag, 1, m_paddedScreenshot, QPainter::OpaqueHint); painter.setCompositionMode(QPainter::CompositionMode_SourceOver); for (const auto& rect : { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) { painter.fillRect(rect, m_color); } QPen pen(m_borderColor); pen.setWidth(4); painter.setPen(pen); painter.drawEllipse( drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2); } // https://invent.kde.org/graphics/spectacle/-/blob/master/src/QuickEditor/QuickEditor.cpp#L841 void MagnifierWidget::drawMagnifier(QPainter& painter) { auto relativeCursor = QCursor::pos(); auto translated = QWidget::mapFromGlobal(relativeCursor); auto x = translated.x(); auto y = translated.y(); int magX = static_cast<int>(x * m_devicePixelRatio - m_magPixels); int offsetX = 0; if (magX < 0) { offsetX = magX; magX = 0; } else { const int maxX = m_screenshot.width() - m_pixels; if (magX > maxX) { offsetX = magX - maxX; magX = maxX; } } int magY = static_cast<int>(y * m_devicePixelRatio - m_magPixels); int offsetY = 0; if (magY < 0) { offsetY = magY; magY = 0; } else { const int maxY = m_screenshot.height() - m_pixels; if (magY > maxY) { offsetY = magY - maxY; magY = maxY; } } QRectF magniRect(magX, magY, m_pixels, m_pixels); qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2; if (drawPosX > width() - m_pixels * magZoom / 2) { drawPosX = x - m_magOffset - m_pixels * magZoom / 2; } qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2; if (drawPosY > height() - m_pixels * magZoom / 2) { drawPosY = y - m_magOffset - m_pixels * magZoom / 2; } QPointF drawPos(drawPosX, drawPosY); QRectF crossHairTop(drawPos.x() + magZoom * (offsetX - 0.5), drawPos.y() - magZoom * (m_magPixels + 0.5), magZoom, magZoom * (m_magPixels + offsetY)); QRectF crossHairRight(drawPos.x() + magZoom * (0.5 + offsetX), drawPos.y() + magZoom * (offsetY - 0.5), magZoom * (m_magPixels - offsetX), magZoom); QRectF crossHairBottom(drawPos.x() + magZoom * (offsetX - 0.5), drawPos.y() + magZoom * (0.5 + offsetY), magZoom, magZoom * (m_magPixels - offsetY)); QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5), drawPos.y() + magZoom * (offsetY - 0.5), magZoom * (m_magPixels + offsetX), magZoom); QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1, drawPos.y() - magZoom * (m_magPixels + 0.5) - 1, m_pixels * magZoom + 2, m_pixels * magZoom + 2); const auto frag = QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom); painter.fillRect(crossHairBorder, m_borderColor); painter.drawPixmapFragments(&frag, 1, m_screenshot, QPainter::OpaqueHint); painter.setCompositionMode(QPainter::CompositionMode_SourceOver); for (const auto& rect : { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) { painter.fillRect(rect, m_color); } }","title":"File magnifierwidget.cpp"},{"location":"flameshot/magnifierwidget_8cpp_source/#file-magnifierwidgetcpp","text":"File List > capture > magnifierwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"magnifierwidget.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPainterPath> #include <QPen> #include <QPixmap> MagnifierWidget::MagnifierWidget(const QPixmap& p, const QColor& c, bool isSquare, QWidget* parent) : QWidget(parent) , m_color(c) , m_borderColor(c) , m_screenshot(p) , m_square(isSquare) { setFixedSize(parent->width(), parent->height()); setAttribute(Qt::WA_TransparentForMouseEvents); m_color.setAlpha(130); // add padding for circular magnifier QImage padded(p.width() + 2 * m_magPixels, p.height() + 2 * m_magPixels, QImage::Format_ARGB32); padded.fill(Qt::black); QPainter painter(&padded); painter.drawPixmap(m_magPixels, m_magPixels, p); m_paddedScreenshot.convertFromImage(padded); } void MagnifierWidget::paintEvent(QPaintEvent*) { QPainter p(this); if (m_square) { drawMagnifier(p); } else { drawMagnifierCircle(p); } } void MagnifierWidget::drawMagnifierCircle(QPainter& painter) { auto relativeCursor = QCursor::pos(); auto translated = QWidget::mapFromGlobal(relativeCursor); auto x = translated.x() + m_magPixels; auto y = translated.y() + m_magPixels; int magX = static_cast<int>(x * m_devicePixelRatio - m_magPixels); int magY = static_cast<int>(y * m_devicePixelRatio - m_magPixels); QRectF magniRect(magX, magY, m_pixels, m_pixels); qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2; if (drawPosX > width() - m_pixels * magZoom / 2) { drawPosX = x - m_magOffset - m_pixels * magZoom / 2; } qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2; if (drawPosY > height() - m_pixels * magZoom / 2) { drawPosY = y - m_magOffset - m_pixels * magZoom / 2; } QPointF drawPos(drawPosX, drawPosY); QRectF crossHairTop(drawPos.x() + magZoom * (-0.5), drawPos.y() - magZoom * (m_magPixels + 0.5), magZoom, magZoom * (m_magPixels)); QRectF crossHairRight(drawPos.x() + magZoom * (0.5), drawPos.y() + magZoom * (-0.5), magZoom * (m_magPixels), magZoom); QRectF crossHairBottom(drawPos.x() + magZoom * (-0.5), drawPos.y() + magZoom * (0.5), magZoom, magZoom * (m_magPixels)); QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5), drawPos.y() + magZoom * (-0.5), magZoom * (m_magPixels), magZoom); QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1, drawPos.y() - magZoom * (m_magPixels + 0.5) - 1, m_pixels * magZoom + 2, m_pixels * magZoom + 2); const auto frag = QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom); painter.setRenderHint(QPainter::Antialiasing, true); QPainterPath path = QPainterPath(); path.addEllipse(drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2); painter.setClipPath(path); painter.drawPixmapFragments( &frag, 1, m_paddedScreenshot, QPainter::OpaqueHint); painter.setCompositionMode(QPainter::CompositionMode_SourceOver); for (const auto& rect : { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) { painter.fillRect(rect, m_color); } QPen pen(m_borderColor); pen.setWidth(4); painter.setPen(pen); painter.drawEllipse( drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2); } // https://invent.kde.org/graphics/spectacle/-/blob/master/src/QuickEditor/QuickEditor.cpp#L841 void MagnifierWidget::drawMagnifier(QPainter& painter) { auto relativeCursor = QCursor::pos(); auto translated = QWidget::mapFromGlobal(relativeCursor); auto x = translated.x(); auto y = translated.y(); int magX = static_cast<int>(x * m_devicePixelRatio - m_magPixels); int offsetX = 0; if (magX < 0) { offsetX = magX; magX = 0; } else { const int maxX = m_screenshot.width() - m_pixels; if (magX > maxX) { offsetX = magX - maxX; magX = maxX; } } int magY = static_cast<int>(y * m_devicePixelRatio - m_magPixels); int offsetY = 0; if (magY < 0) { offsetY = magY; magY = 0; } else { const int maxY = m_screenshot.height() - m_pixels; if (magY > maxY) { offsetY = magY - maxY; magY = maxY; } } QRectF magniRect(magX, magY, m_pixels, m_pixels); qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2; if (drawPosX > width() - m_pixels * magZoom / 2) { drawPosX = x - m_magOffset - m_pixels * magZoom / 2; } qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2; if (drawPosY > height() - m_pixels * magZoom / 2) { drawPosY = y - m_magOffset - m_pixels * magZoom / 2; } QPointF drawPos(drawPosX, drawPosY); QRectF crossHairTop(drawPos.x() + magZoom * (offsetX - 0.5), drawPos.y() - magZoom * (m_magPixels + 0.5), magZoom, magZoom * (m_magPixels + offsetY)); QRectF crossHairRight(drawPos.x() + magZoom * (0.5 + offsetX), drawPos.y() + magZoom * (offsetY - 0.5), magZoom * (m_magPixels - offsetX), magZoom); QRectF crossHairBottom(drawPos.x() + magZoom * (offsetX - 0.5), drawPos.y() + magZoom * (0.5 + offsetY), magZoom, magZoom * (m_magPixels - offsetY)); QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5), drawPos.y() + magZoom * (offsetY - 0.5), magZoom * (m_magPixels + offsetX), magZoom); QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1, drawPos.y() - magZoom * (m_magPixels + 0.5) - 1, m_pixels * magZoom + 2, m_pixels * magZoom + 2); const auto frag = QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom); painter.fillRect(crossHairBorder, m_borderColor); painter.drawPixmapFragments(&frag, 1, m_screenshot, QPainter::OpaqueHint); painter.setCompositionMode(QPainter::CompositionMode_SourceOver); for (const auto& rect : { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) { painter.fillRect(rect, m_color); } }","title":"File magnifierwidget.cpp"},{"location":"flameshot/magnifierwidget_8h/","text":"File magnifierwidget.h # FileList > capture > magnifierwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class MagnifierWidget","title":"File magnifierwidget.h"},{"location":"flameshot/magnifierwidget_8h/#file-magnifierwidgeth","text":"FileList > capture > magnifierwidget.h Go to the source code of this file. #include <QWidget>","title":"File magnifierwidget.h"},{"location":"flameshot/magnifierwidget_8h/#classes","text":"Type Name class MagnifierWidget","title":"Classes"},{"location":"flameshot/magnifierwidget_8h_source/","text":"File magnifierwidget.h # File List > capture > magnifierwidget.h Go to the documentation of this file. #pragma once #include <QWidget> class QPropertyAnimation; class MagnifierWidget : public QWidget { Q_OBJECT public: explicit MagnifierWidget(const QPixmap& p, const QColor& c, bool isSquare, QWidget* parent = nullptr); protected: void paintEvent(QPaintEvent*) override; private: const int m_magPixels = 8; const int m_magOffset = 16; const int magZoom = 10; const int m_pixels = 2 * m_magPixels + 1; const int m_devicePixelRatio = 1; bool m_square; QColor m_color; QColor m_borderColor; QPixmap m_screenshot; QPixmap m_paddedScreenshot; void drawMagnifier(QPainter& painter); void drawMagnifierCircle(QPainter& painter); };","title":"File magnifierwidget.h"},{"location":"flameshot/magnifierwidget_8h_source/#file-magnifierwidgeth","text":"File List > capture > magnifierwidget.h Go to the documentation of this file. #pragma once #include <QWidget> class QPropertyAnimation; class MagnifierWidget : public QWidget { Q_OBJECT public: explicit MagnifierWidget(const QPixmap& p, const QColor& c, bool isSquare, QWidget* parent = nullptr); protected: void paintEvent(QPaintEvent*) override; private: const int m_magPixels = 8; const int m_magOffset = 16; const int magZoom = 10; const int m_pixels = 2 * m_magPixels + 1; const int m_devicePixelRatio = 1; bool m_square; QColor m_color; QColor m_borderColor; QPixmap m_screenshot; QPixmap m_paddedScreenshot; void drawMagnifier(QPainter& painter); void drawMagnifierCircle(QPainter& painter); };","title":"File magnifierwidget.h"},{"location":"flameshot/modificationcommand_8cpp/","text":"File modificationcommand.cpp # FileList > capture > modificationcommand.cpp Go to the source code of this file. #include \"modificationcommand.h\" #include \"capturewidget.h\"","title":"File modificationcommand.cpp"},{"location":"flameshot/modificationcommand_8cpp/#file-modificationcommandcpp","text":"FileList > capture > modificationcommand.cpp Go to the source code of this file. #include \"modificationcommand.h\" #include \"capturewidget.h\"","title":"File modificationcommand.cpp"},{"location":"flameshot/modificationcommand_8cpp_source/","text":"File modificationcommand.cpp # File List > capture > modificationcommand.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"modificationcommand.h\" #include \"capturewidget.h\" ModificationCommand::ModificationCommand( CaptureWidget* captureWidget, const CaptureToolObjects& captureToolObjects, const CaptureToolObjects& captureToolObjectsBackup) : m_captureWidget(captureWidget) { m_captureToolObjects = captureToolObjects; m_captureToolObjectsBackup = captureToolObjectsBackup; } void ModificationCommand::undo() { m_captureWidget->setCaptureToolObjects(m_captureToolObjectsBackup); } void ModificationCommand::redo() { m_captureWidget->setCaptureToolObjects(m_captureToolObjects); }","title":"File modificationcommand.cpp"},{"location":"flameshot/modificationcommand_8cpp_source/#file-modificationcommandcpp","text":"File List > capture > modificationcommand.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"modificationcommand.h\" #include \"capturewidget.h\" ModificationCommand::ModificationCommand( CaptureWidget* captureWidget, const CaptureToolObjects& captureToolObjects, const CaptureToolObjects& captureToolObjectsBackup) : m_captureWidget(captureWidget) { m_captureToolObjects = captureToolObjects; m_captureToolObjectsBackup = captureToolObjectsBackup; } void ModificationCommand::undo() { m_captureWidget->setCaptureToolObjects(m_captureToolObjectsBackup); } void ModificationCommand::redo() { m_captureWidget->setCaptureToolObjects(m_captureToolObjects); }","title":"File modificationcommand.cpp"},{"location":"flameshot/modificationcommand_8h/","text":"File modificationcommand.h # FileList > capture > modificationcommand.h Go to the source code of this file. #include \"capturetoolobjects.h\" #include <QUndoCommand> Classes # Type Name class ModificationCommand","title":"File modificationcommand.h"},{"location":"flameshot/modificationcommand_8h/#file-modificationcommandh","text":"FileList > capture > modificationcommand.h Go to the source code of this file. #include \"capturetoolobjects.h\" #include <QUndoCommand>","title":"File modificationcommand.h"},{"location":"flameshot/modificationcommand_8h/#classes","text":"Type Name class ModificationCommand","title":"Classes"},{"location":"flameshot/modificationcommand_8h_source/","text":"File modificationcommand.h # File List > capture > modificationcommand.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturetoolobjects.h\" #include <QUndoCommand> #ifndef FLAMESHOT_MODIFICATIONCOMMAND_H #define FLAMESHOT_MODIFICATIONCOMMAND_H class CaptureWidget; class ModificationCommand : public QUndoCommand { public: ModificationCommand(CaptureWidget* captureWidget, const CaptureToolObjects& captureToolObjects, const CaptureToolObjects& captureToolObjectsBackup); virtual void undo() override; virtual void redo() override; private: CaptureToolObjects m_captureToolObjects; CaptureToolObjects m_captureToolObjectsBackup; CaptureWidget* m_captureWidget; }; #endif // FLAMESHOT_MODIFICATIONCOMMAND_H","title":"File modificationcommand.h"},{"location":"flameshot/modificationcommand_8h_source/#file-modificationcommandh","text":"File List > capture > modificationcommand.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"capturetoolobjects.h\" #include <QUndoCommand> #ifndef FLAMESHOT_MODIFICATIONCOMMAND_H #define FLAMESHOT_MODIFICATIONCOMMAND_H class CaptureWidget; class ModificationCommand : public QUndoCommand { public: ModificationCommand(CaptureWidget* captureWidget, const CaptureToolObjects& captureToolObjects, const CaptureToolObjects& captureToolObjectsBackup); virtual void undo() override; virtual void redo() override; private: CaptureToolObjects m_captureToolObjects; CaptureToolObjects m_captureToolObjectsBackup; CaptureWidget* m_captureWidget; }; #endif // FLAMESHOT_MODIFICATIONCOMMAND_H","title":"File modificationcommand.h"},{"location":"flameshot/notifierbox_8cpp/","text":"File notifierbox.cpp # FileList > capture > notifierbox.cpp Go to the source code of this file. #include \"notifierbox.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QPainter> #include <QTimer>","title":"File notifierbox.cpp"},{"location":"flameshot/notifierbox_8cpp/#file-notifierboxcpp","text":"FileList > capture > notifierbox.cpp Go to the source code of this file. #include \"notifierbox.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QPainter> #include <QTimer>","title":"File notifierbox.cpp"},{"location":"flameshot/notifierbox_8cpp_source/","text":"File notifierbox.cpp # File List > capture > notifierbox.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"notifierbox.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QPainter> #include <QTimer> NotifierBox::NotifierBox(QWidget* parent) : QWidget(parent) { m_timer = new QTimer(this); m_timer->setSingleShot(true); m_timer->setInterval(600); connect(m_timer, &QTimer::timeout, this, &NotifierBox::hide); m_bgColor = ConfigHandler().uiColor(); m_foregroundColor = (ColorUtils::colorIsDark(m_bgColor) ? Qt::white : Qt::black); m_bgColor.setAlpha(180); const int size = (GlobalValues::buttonBaseSize() + GlobalValues::buttonBaseSize() / 2) * qApp->devicePixelRatio(); setFixedSize(QSize(size, size)); } void NotifierBox::enterEvent(QEvent*) { hide(); } void NotifierBox::paintEvent(QPaintEvent*) { QPainter painter(this); // draw Ellipse painter.setRenderHint(QPainter::Antialiasing); painter.setBrush(QBrush(m_bgColor, Qt::SolidPattern)); painter.setPen(QPen(Qt::transparent)); painter.drawEllipse(rect()); // Draw the text: painter.setPen(QPen(m_foregroundColor)); painter.drawText(rect(), Qt::AlignCenter, m_message); } void NotifierBox::showMessage(const QString& msg) { m_message = msg; update(); show(); m_timer->start(); } void NotifierBox::showColor(const QColor& color) { Q_UNUSED(color) m_message = QLatin1String(\"\"); } void NotifierBox::hideEvent(QHideEvent* event) { emit hidden(); }","title":"File notifierbox.cpp"},{"location":"flameshot/notifierbox_8cpp_source/#file-notifierboxcpp","text":"File List > capture > notifierbox.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"notifierbox.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QPainter> #include <QTimer> NotifierBox::NotifierBox(QWidget* parent) : QWidget(parent) { m_timer = new QTimer(this); m_timer->setSingleShot(true); m_timer->setInterval(600); connect(m_timer, &QTimer::timeout, this, &NotifierBox::hide); m_bgColor = ConfigHandler().uiColor(); m_foregroundColor = (ColorUtils::colorIsDark(m_bgColor) ? Qt::white : Qt::black); m_bgColor.setAlpha(180); const int size = (GlobalValues::buttonBaseSize() + GlobalValues::buttonBaseSize() / 2) * qApp->devicePixelRatio(); setFixedSize(QSize(size, size)); } void NotifierBox::enterEvent(QEvent*) { hide(); } void NotifierBox::paintEvent(QPaintEvent*) { QPainter painter(this); // draw Ellipse painter.setRenderHint(QPainter::Antialiasing); painter.setBrush(QBrush(m_bgColor, Qt::SolidPattern)); painter.setPen(QPen(Qt::transparent)); painter.drawEllipse(rect()); // Draw the text: painter.setPen(QPen(m_foregroundColor)); painter.drawText(rect(), Qt::AlignCenter, m_message); } void NotifierBox::showMessage(const QString& msg) { m_message = msg; update(); show(); m_timer->start(); } void NotifierBox::showColor(const QColor& color) { Q_UNUSED(color) m_message = QLatin1String(\"\"); } void NotifierBox::hideEvent(QHideEvent* event) { emit hidden(); }","title":"File notifierbox.cpp"},{"location":"flameshot/notifierbox_8h/","text":"File notifierbox.h # FileList > capture > notifierbox.h Go to the source code of this file. #include <QWidget> Classes # Type Name class NotifierBox","title":"File notifierbox.h"},{"location":"flameshot/notifierbox_8h/#file-notifierboxh","text":"FileList > capture > notifierbox.h Go to the source code of this file. #include <QWidget>","title":"File notifierbox.h"},{"location":"flameshot/notifierbox_8h/#classes","text":"Type Name class NotifierBox","title":"Classes"},{"location":"flameshot/notifierbox_8h_source/","text":"File notifierbox.h # File List > capture > notifierbox.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QTimer; class NotifierBox : public QWidget { Q_OBJECT public: explicit NotifierBox(QWidget* parent = nullptr); protected: virtual void enterEvent(QEvent*) override; virtual void paintEvent(QPaintEvent*) override; signals: void hidden(); public slots: void showMessage(const QString& msg); void showColor(const QColor& color); private: QTimer* m_timer; QString m_message; QColor m_bgColor; QColor m_foregroundColor; void hideEvent(QHideEvent* event) override; };","title":"File notifierbox.h"},{"location":"flameshot/notifierbox_8h_source/#file-notifierboxh","text":"File List > capture > notifierbox.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QTimer; class NotifierBox : public QWidget { Q_OBJECT public: explicit NotifierBox(QWidget* parent = nullptr); protected: virtual void enterEvent(QEvent*) override; virtual void paintEvent(QPaintEvent*) override; signals: void hidden(); public slots: void showMessage(const QString& msg); void showColor(const QColor& color); private: QTimer* m_timer; QString m_message; QColor m_bgColor; QColor m_foregroundColor; void hideEvent(QHideEvent* event) override; };","title":"File notifierbox.h"},{"location":"flameshot/overlaymessage_8cpp/","text":"File overlaymessage.cpp # FileList > capture > overlaymessage.cpp Go to the source code of this file. #include \"overlaymessage.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include <QApplication> #include <QDebug> #include <QLabel> #include <QPainter> #include <QPen> #include <QScreen>","title":"File overlaymessage.cpp"},{"location":"flameshot/overlaymessage_8cpp/#file-overlaymessagecpp","text":"FileList > capture > overlaymessage.cpp Go to the source code of this file. #include \"overlaymessage.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include <QApplication> #include <QDebug> #include <QLabel> #include <QPainter> #include <QPen> #include <QScreen>","title":"File overlaymessage.cpp"},{"location":"flameshot/overlaymessage_8cpp_source/","text":"File overlaymessage.cpp # File List > capture > overlaymessage.cpp Go to the documentation of this file. #include \"overlaymessage.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include <QApplication> #include <QDebug> #include <QLabel> #include <QPainter> #include <QPen> #include <QScreen> OverlayMessage::OverlayMessage(QWidget* parent, const QRect& targetArea) : QLabel(parent) , m_targetArea(targetArea) { // NOTE: do not call the static functions from the constructor m_instance = this; m_messageStack.push(QString()); // Default message is empty setAttribute(Qt::WA_TransparentForMouseEvents); setAttribute(Qt::WA_AlwaysStackOnTop); setAlignment(Qt::AlignCenter); setTextFormat(Qt::RichText); m_fillColor = ConfigHandler().uiColor(); int opacity = ConfigHandler().contrastOpacity(); m_textColor = (ColorUtils::colorIsDark(m_fillColor) ? Qt::white : Qt::black); // map a background opacity range 0-255 to a fill opacity range 190-160 // we do this because an opaque background makes the box look opaque too m_fillColor.setAlpha(160 + (180 - 220) / (255.0 - 0) * (opacity - 255)); setStyleSheet( QStringLiteral(\"QLabel { color: %1; }\").arg(m_textColor.name())); setMargin(QApplication::fontMetrics().height() / 2); QWidget::hide(); } void OverlayMessage::init(QWidget* parent, const QRect& targetArea) { new OverlayMessage(parent, targetArea); } void OverlayMessage::push(const QString& msg) { m_instance->m_messageStack.push(msg); m_instance->setText(m_instance->m_messageStack.top()); setVisibility(true); } void OverlayMessage::pop() { if (m_instance->m_messageStack.size() > 1) { m_instance->m_messageStack.pop(); } m_instance->setText(m_instance->m_messageStack.top()); setVisibility(m_instance->m_messageStack.size() > 1); } void OverlayMessage::setVisibility(bool visible) { m_instance->updateGeometry(); m_instance->setVisible(visible); } OverlayMessage* OverlayMessage::instance() { return m_instance; } void OverlayMessage::pushKeyMap(const QList<QPair<QString, QString>>& map) { push(compileFromKeyMap(map)); } QString OverlayMessage::compileFromKeyMap( const QList<QPair<QString, QString>>& map) { QString str = QStringLiteral(\"<table>\"); for (const auto& pair : map) { str += QStringLiteral(\"<tr>\" \"<td align=\\\"right\\\"><b>%1 </b></td>\" \"<td align=\\\"left\\\">&nbsp;&nbsp;%2</td>\" \"</tr>\") .arg(pair.first) .arg(pair.second); } str += QStringLiteral(\"</table>\"); return str; } void OverlayMessage::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); painter.setBrush(QBrush(m_fillColor, Qt::SolidPattern)); painter.setPen(QPen(m_textColor, 1.5)); float margin = painter.pen().widthF(); painter.drawRoundedRect( rect() - QMarginsF(margin, margin, margin, margin), 5, 5); return QLabel::paintEvent(e); } QRect OverlayMessage::boundingRect() const { QRect geom = QRect(QPoint(), sizeHint()); geom.moveCenter(m_targetArea.center()); return geom; } void OverlayMessage::updateGeometry() { setGeometry(boundingRect()); QLabel::updateGeometry(); } OverlayMessage* OverlayMessage::m_instance = nullptr;","title":"File overlaymessage.cpp"},{"location":"flameshot/overlaymessage_8cpp_source/#file-overlaymessagecpp","text":"File List > capture > overlaymessage.cpp Go to the documentation of this file. #include \"overlaymessage.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include <QApplication> #include <QDebug> #include <QLabel> #include <QPainter> #include <QPen> #include <QScreen> OverlayMessage::OverlayMessage(QWidget* parent, const QRect& targetArea) : QLabel(parent) , m_targetArea(targetArea) { // NOTE: do not call the static functions from the constructor m_instance = this; m_messageStack.push(QString()); // Default message is empty setAttribute(Qt::WA_TransparentForMouseEvents); setAttribute(Qt::WA_AlwaysStackOnTop); setAlignment(Qt::AlignCenter); setTextFormat(Qt::RichText); m_fillColor = ConfigHandler().uiColor(); int opacity = ConfigHandler().contrastOpacity(); m_textColor = (ColorUtils::colorIsDark(m_fillColor) ? Qt::white : Qt::black); // map a background opacity range 0-255 to a fill opacity range 190-160 // we do this because an opaque background makes the box look opaque too m_fillColor.setAlpha(160 + (180 - 220) / (255.0 - 0) * (opacity - 255)); setStyleSheet( QStringLiteral(\"QLabel { color: %1; }\").arg(m_textColor.name())); setMargin(QApplication::fontMetrics().height() / 2); QWidget::hide(); } void OverlayMessage::init(QWidget* parent, const QRect& targetArea) { new OverlayMessage(parent, targetArea); } void OverlayMessage::push(const QString& msg) { m_instance->m_messageStack.push(msg); m_instance->setText(m_instance->m_messageStack.top()); setVisibility(true); } void OverlayMessage::pop() { if (m_instance->m_messageStack.size() > 1) { m_instance->m_messageStack.pop(); } m_instance->setText(m_instance->m_messageStack.top()); setVisibility(m_instance->m_messageStack.size() > 1); } void OverlayMessage::setVisibility(bool visible) { m_instance->updateGeometry(); m_instance->setVisible(visible); } OverlayMessage* OverlayMessage::instance() { return m_instance; } void OverlayMessage::pushKeyMap(const QList<QPair<QString, QString>>& map) { push(compileFromKeyMap(map)); } QString OverlayMessage::compileFromKeyMap( const QList<QPair<QString, QString>>& map) { QString str = QStringLiteral(\"<table>\"); for (const auto& pair : map) { str += QStringLiteral(\"<tr>\" \"<td align=\\\"right\\\"><b>%1 </b></td>\" \"<td align=\\\"left\\\">&nbsp;&nbsp;%2</td>\" \"</tr>\") .arg(pair.first) .arg(pair.second); } str += QStringLiteral(\"</table>\"); return str; } void OverlayMessage::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); painter.setBrush(QBrush(m_fillColor, Qt::SolidPattern)); painter.setPen(QPen(m_textColor, 1.5)); float margin = painter.pen().widthF(); painter.drawRoundedRect( rect() - QMarginsF(margin, margin, margin, margin), 5, 5); return QLabel::paintEvent(e); } QRect OverlayMessage::boundingRect() const { QRect geom = QRect(QPoint(), sizeHint()); geom.moveCenter(m_targetArea.center()); return geom; } void OverlayMessage::updateGeometry() { setGeometry(boundingRect()); QLabel::updateGeometry(); } OverlayMessage* OverlayMessage::m_instance = nullptr;","title":"File overlaymessage.cpp"},{"location":"flameshot/overlaymessage_8h/","text":"File overlaymessage.h # FileList > capture > overlaymessage.h Go to the source code of this file. #include <QLabel> #include <QStack> Classes # Type Name class OverlayMessage Overlay a message in capture mode.","title":"File overlaymessage.h"},{"location":"flameshot/overlaymessage_8h/#file-overlaymessageh","text":"FileList > capture > overlaymessage.h Go to the source code of this file. #include <QLabel> #include <QStack>","title":"File overlaymessage.h"},{"location":"flameshot/overlaymessage_8h/#classes","text":"Type Name class OverlayMessage Overlay a message in capture mode.","title":"Classes"},{"location":"flameshot/overlaymessage_8h_source/","text":"File overlaymessage.h # File List > capture > overlaymessage.h Go to the documentation of this file. #pragma once #include <QLabel> #include <QStack> class OverlayMessage : public QLabel { public: OverlayMessage() = delete; static void init(QWidget* parent, const QRect& targetArea); static void push(const QString& msg); static void pop(); static void setVisibility(bool visible); static OverlayMessage* instance(); static void pushKeyMap(const QList<QPair<QString, QString>>& map); static QString compileFromKeyMap(const QList<QPair<QString, QString>>& map); private: QStack<QString> m_messageStack; QRect m_targetArea; QColor m_fillColor, m_textColor; static OverlayMessage* m_instance; OverlayMessage(QWidget* parent, const QRect& center); void paintEvent(QPaintEvent*) override; QRect boundingRect() const; void updateGeometry(); };","title":"File overlaymessage.h"},{"location":"flameshot/overlaymessage_8h_source/#file-overlaymessageh","text":"File List > capture > overlaymessage.h Go to the documentation of this file. #pragma once #include <QLabel> #include <QStack> class OverlayMessage : public QLabel { public: OverlayMessage() = delete; static void init(QWidget* parent, const QRect& targetArea); static void push(const QString& msg); static void pop(); static void setVisibility(bool visible); static OverlayMessage* instance(); static void pushKeyMap(const QList<QPair<QString, QString>>& map); static QString compileFromKeyMap(const QList<QPair<QString, QString>>& map); private: QStack<QString> m_messageStack; QRect m_targetArea; QColor m_fillColor, m_textColor; static OverlayMessage* m_instance; OverlayMessage(QWidget* parent, const QRect& center); void paintEvent(QPaintEvent*) override; QRect boundingRect() const; void updateGeometry(); };","title":"File overlaymessage.h"},{"location":"flameshot/selectionwidget_8cpp/","text":"File selectionwidget.cpp # FileList > capture > selectionwidget.cpp Go to the source code of this file. #include \"selectionwidget.h\" #include \"capturetool.h\" #include \"capturetoolbutton.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPropertyAnimation> #include <QTimer> #include <utility> Public Functions # Type Name SelectionWidget::SideType getProperSide (SelectionWidget::SideType side, const QRect & r) Macros # Type Name define MARGIN (m_THandle.width()) Public Functions Documentation # function getProperSide # SelectionWidget::SideType getProperSide ( SelectionWidget::SideType side, const QRect & r ) Macro Definition Documentation # define MARGIN # #define MARGIN (m_THandle.width())","title":"File selectionwidget.cpp"},{"location":"flameshot/selectionwidget_8cpp/#file-selectionwidgetcpp","text":"FileList > capture > selectionwidget.cpp Go to the source code of this file. #include \"selectionwidget.h\" #include \"capturetool.h\" #include \"capturetoolbutton.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPropertyAnimation> #include <QTimer> #include <utility>","title":"File selectionwidget.cpp"},{"location":"flameshot/selectionwidget_8cpp/#public-functions","text":"Type Name SelectionWidget::SideType getProperSide (SelectionWidget::SideType side, const QRect & r)","title":"Public Functions"},{"location":"flameshot/selectionwidget_8cpp/#macros","text":"Type Name define MARGIN (m_THandle.width())","title":"Macros"},{"location":"flameshot/selectionwidget_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/selectionwidget_8cpp/#function-getproperside","text":"SelectionWidget::SideType getProperSide ( SelectionWidget::SideType side, const QRect & r )","title":"function getProperSide"},{"location":"flameshot/selectionwidget_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/selectionwidget_8cpp/#define-margin","text":"#define MARGIN (m_THandle.width())","title":"define MARGIN"},{"location":"flameshot/selectionwidget_8cpp_source/","text":"File selectionwidget.cpp # File List > capture > selectionwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"selectionwidget.h\" #include \"capturetool.h\" #include \"capturetoolbutton.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPropertyAnimation> #include <QTimer> #include <utility> #define MARGIN (m_THandle.width()) SelectionWidget::SelectionWidget(QColor c, QWidget* parent) : QWidget(parent) , m_color(std::move(c)) , m_activeSide(NO_SIDE) , m_ignoreMouse(false) { // prevents this widget from consuming CaptureToolButton mouse events setAttribute(Qt::WA_TransparentForMouseEvents); parent->installEventFilter(this); m_animation = new QPropertyAnimation(this, \"geometry\", this); m_animation->setEasingCurve(QEasingCurve::InOutQuad); m_animation->setDuration(200); connect(m_animation, &QPropertyAnimation::finished, this, [this]() { emit geometrySettled(); }); int sideVal = GlobalValues::buttonBaseSize() * 0.6; int handleSide = sideVal / 2; const QRect areaRect(0, 0, sideVal, sideVal); const QRect handleRect(0, 0, handleSide, handleSide); m_TLHandle = m_TRHandle = m_BLHandle = m_BRHandle = m_LHandle = m_THandle = m_RHandle = m_BHandle = handleRect; m_TLArea = m_TRArea = m_BLArea = m_BRArea = areaRect; m_areaOffset = QPoint(-sideVal / 2, -sideVal / 2); m_handleOffset = QPoint(-handleSide / 2, -handleSide / 2); } SelectionWidget::SideType SelectionWidget::getMouseSide( const QPoint& mousePos) const { if (!isVisible()) { return NO_SIDE; } QPoint localPos = mapFromParent(mousePos); if (m_TLArea.contains(localPos)) { return TOPLEFT_SIDE; } else if (m_TRArea.contains(localPos)) { return TOPRIGHT_SIDE; } else if (m_BLArea.contains(localPos)) { return BOTTOMLEFT_SIDE; } else if (m_BRArea.contains(localPos)) { return BOTTOMRIGHT_SIDE; } else if (m_LArea.contains(localPos)) { return LEFT_SIDE; } else if (m_TArea.contains(localPos)) { return TOP_SIDE; } else if (m_RArea.contains(localPos)) { return RIGHT_SIDE; } else if (m_BArea.contains(localPos)) { return BOTTOM_SIDE; } else if (rect().contains(localPos)) { return CENTER; } else { return NO_SIDE; } } QVector<QRect> SelectionWidget::handlerAreas() { QVector<QRect> areas; areas << m_TLHandle << m_TRHandle << m_BLHandle << m_BRHandle << m_LHandle << m_THandle << m_RHandle << m_BHandle; return areas; } // helper function SelectionWidget::SideType getProperSide(SelectionWidget::SideType side, const QRect& r) { using SideType = SelectionWidget::SideType; int intSide = side; if (r.right() < r.left()) { intSide ^= SideType::LEFT_SIDE; intSide ^= SideType::RIGHT_SIDE; } if (r.bottom() < r.top()) { intSide ^= SideType::TOP_SIDE; intSide ^= SideType::BOTTOM_SIDE; } return (SideType)intSide; } void SelectionWidget::setIgnoreMouse(bool ignore) { m_ignoreMouse = ignore; updateCursor(); } void SelectionWidget::setIdleCentralCursor(const QCursor& cursor) { m_idleCentralCursor = cursor; } void SelectionWidget::setGeometryAnimated(const QRect& r) { if (isVisible()) { m_animation->setStartValue(geometry()); m_animation->setEndValue(r); m_animation->start(); } } void SelectionWidget::setGeometry(const QRect& r) { QWidget::setGeometry(r + QMargins(MARGIN, MARGIN, MARGIN, MARGIN)); updateCursor(); if (isVisible()) { emit geometryChanged(); } } QRect SelectionWidget::geometry() const { return QWidget::geometry() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN); } QRect SelectionWidget::fullGeometry() const { return QWidget::geometry(); } QRect SelectionWidget::rect() const { return QWidget::rect() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN); } bool SelectionWidget::eventFilter(QObject* obj, QEvent* event) { if (m_ignoreMouse && dynamic_cast<QMouseEvent*>(event)) { m_activeSide = NO_SIDE; unsetCursor(); } else if (event->type() == QEvent::MouseButtonRelease) { parentMouseReleaseEvent(static_cast<QMouseEvent*>(event)); } else if (event->type() == QEvent::MouseButtonPress) { parentMousePressEvent(static_cast<QMouseEvent*>(event)); } else if (event->type() == QEvent::MouseMove) { parentMouseMoveEvent(static_cast<QMouseEvent*>(event)); } return false; } void SelectionWidget::parentMousePressEvent(QMouseEvent* e) { if (e->button() != Qt::LeftButton) { return; } m_dragStartPos = e->pos(); m_activeSide = getMouseSide(e->pos()); } void SelectionWidget::parentMouseReleaseEvent(QMouseEvent* e) { // released outside of the selection area if (!getMouseSide(e->pos())) { hide(); } m_activeSide = NO_SIDE; updateCursor(); emit geometrySettled(); } void SelectionWidget::parentMouseMoveEvent(QMouseEvent* e) { updateCursor(); if (e->buttons() != Qt::LeftButton) { return; } SideType mouseSide = m_activeSide; if (!m_activeSide) { mouseSide = getMouseSide(e->pos()); } QPoint pos; if (!isVisible() || !mouseSide) { show(); m_activeSide = TOPLEFT_SIDE; pos = m_dragStartPos; setGeometry({ pos, pos }); } else { pos = e->pos(); } auto geom = geometry(); float aspectRatio = (float)geom.width() / (float)geom.height(); bool symmetryMod = qApp->keyboardModifiers() & Qt::ShiftModifier; bool preserveAspect = qApp->keyboardModifiers() & Qt::ControlModifier; QPoint newTopLeft = geom.topLeft(), newBottomRight = geom.bottomRight(); int oldLeft = newTopLeft.rx(), oldRight = newBottomRight.rx(), oldTop = newTopLeft.ry(), oldBottom = newBottomRight.ry(); int &newLeft = newTopLeft.rx(), &newRight = newBottomRight.rx(), &newTop = newTopLeft.ry(), &newBottom = newBottomRight.ry(); switch (mouseSide) { case TOPLEFT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(oldRight - pos.x()) / (float)(oldBottom - pos.y()) > aspectRatio) { /* width longer than expected width, hence increase * height to compensate for the aspect ratio */ newLeft = pos.x(); newTop = oldBottom - (int)(((float)(oldRight - pos.x())) / aspectRatio); } else { /* height longer than expected height, hence increase * width to compensate for the aspect ratio */ newTop = pos.y(); newLeft = oldRight - (int)(((float)(oldBottom - pos.y())) * aspectRatio); } } else { newTopLeft = pos; } } break; case BOTTOMRIGHT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(pos.x() - oldLeft) / (float)(pos.y() - oldTop) > aspectRatio) { newRight = pos.x(); newBottom = oldTop + (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } else { newBottom = pos.y(); newRight = oldLeft + (int)(((float)(pos.y() - oldTop)) * aspectRatio); } } else { newBottomRight = pos; } } break; case TOPRIGHT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(pos.x() - oldLeft) / (float)(oldBottom - pos.y()) > aspectRatio) { newRight = pos.x(); newTop = oldBottom - (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } else { newTop = pos.y(); newRight = oldLeft + (int)(((float)(oldBottom - pos.y())) * aspectRatio); } } else { newTop = pos.y(); newRight = pos.x(); } } break; case BOTTOMLEFT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(oldRight - pos.x()) / (float)(pos.y() - oldTop) > aspectRatio) { newLeft = pos.x(); newBottom = oldTop + (int)(((float)(oldRight - pos.x())) / aspectRatio); } else { newBottom = pos.y(); newLeft = oldRight - (int)(((float)(pos.y() - oldTop)) * aspectRatio); } } else { newBottom = pos.y(); newLeft = pos.x(); } } break; case LEFT_SIDE: if (m_activeSide) { newLeft = pos.x(); if (preserveAspect) { /* By default bottom edge moves when dragging sides, this * behavior feels natural */ newBottom = oldTop + (int)(((float)(oldRight - pos.x())) / aspectRatio); } } break; case RIGHT_SIDE: if (m_activeSide) { newRight = pos.x(); if (preserveAspect) { newBottom = oldTop + (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } } break; case TOP_SIDE: if (m_activeSide) { newTop = pos.y(); if (preserveAspect) { /* By default right edge moves when dragging sides, this * behavior feels natural */ newRight = oldLeft + (int)(((float)(oldBottom - pos.y()) * aspectRatio)); } } break; case BOTTOM_SIDE: if (m_activeSide) { newBottom = pos.y(); if (preserveAspect) { newRight = oldLeft + (int)(((float)(pos.y() - oldTop) * aspectRatio)); } } break; default: if (m_activeSide) { move(this->pos() + pos - m_dragStartPos); m_dragStartPos = pos; /* do nothing special in case of preserveAspect */ } return; } // finalize geometry change if (m_activeSide) { if (symmetryMod) { QPoint deltaTopLeft = newTopLeft - geom.topLeft(); QPoint deltaBottomRight = newBottomRight - geom.bottomRight(); newTopLeft = geom.topLeft() + deltaTopLeft - deltaBottomRight; newBottomRight = geom.bottomRight() + deltaBottomRight - deltaTopLeft; } geom = { newTopLeft, newBottomRight }; setGeometry(geom.normalized()); m_activeSide = getProperSide(m_activeSide, geom); } m_dragStartPos = e->pos(); } void SelectionWidget::paintEvent(QPaintEvent*) { QPainter p(this); p.setPen(m_color); p.drawRect(rect() + QMargins(0, 0, -1, -1)); p.setRenderHint(QPainter::Antialiasing); p.setBrush(m_color); for (auto rect : handlerAreas()) { p.drawEllipse(rect); } } void SelectionWidget::resizeEvent(QResizeEvent*) { updateAreas(); if (isVisible()) { emit geometryChanged(); } } void SelectionWidget::moveEvent(QMoveEvent*) { updateAreas(); if (isVisible()) { emit geometryChanged(); } } void SelectionWidget::showEvent(QShowEvent*) { emit visibilityChanged(); } void SelectionWidget::hideEvent(QHideEvent*) { emit visibilityChanged(); } void SelectionWidget::updateColor(const QColor& c) { m_color = c; } void SelectionWidget::moveLeft() { setGeometryByKeyboard(geometry().adjusted(-1, 0, -1, 0)); } void SelectionWidget::moveRight() { setGeometryByKeyboard(geometry().adjusted(1, 0, 1, 0)); } void SelectionWidget::moveUp() { setGeometryByKeyboard(geometry().adjusted(0, -1, 0, -1)); } void SelectionWidget::moveDown() { setGeometryByKeyboard(geometry().adjusted(0, 1, 0, 1)); } void SelectionWidget::resizeLeft() { setGeometryByKeyboard(geometry().adjusted(0, 0, -1, 0)); } void SelectionWidget::resizeRight() { setGeometryByKeyboard(geometry().adjusted(0, 0, 1, 0)); } void SelectionWidget::resizeUp() { setGeometryByKeyboard(geometry().adjusted(0, 0, 0, -1)); } void SelectionWidget::resizeDown() { setGeometryByKeyboard(geometry().adjusted(0, 0, 0, 1)); } void SelectionWidget::symResizeLeft() { setGeometryByKeyboard(geometry().adjusted(1, 0, -1, 0)); } void SelectionWidget::symResizeRight() { setGeometryByKeyboard(geometry().adjusted(-1, 0, 1, 0)); } void SelectionWidget::symResizeUp() { setGeometryByKeyboard(geometry().adjusted(0, -1, 0, 1)); } void SelectionWidget::symResizeDown() { setGeometryByKeyboard(geometry().adjusted(0, 1, 0, -1)); } void SelectionWidget::updateAreas() { QRect r = rect(); m_TLArea.moveTo(r.topLeft() + m_areaOffset); m_TRArea.moveTo(r.topRight() + m_areaOffset); m_BLArea.moveTo(r.bottomLeft() + m_areaOffset); m_BRArea.moveTo(r.bottomRight() + m_areaOffset); m_LArea = QRect(m_TLArea.bottomLeft(), m_BLArea.topRight()); m_TArea = QRect(m_TLArea.topRight(), m_TRArea.bottomLeft()); m_RArea = QRect(m_TRArea.bottomLeft(), m_BRArea.topRight()); m_BArea = QRect(m_BLArea.topRight(), m_BRArea.bottomLeft()); m_TLHandle.moveTo(m_TLArea.center() + m_handleOffset); m_BLHandle.moveTo(m_BLArea.center() + m_handleOffset); m_TRHandle.moveTo(m_TRArea.center() + m_handleOffset); m_BRHandle.moveTo(m_BRArea.center() + m_handleOffset); m_LHandle.moveTo(m_LArea.center() + m_handleOffset); m_THandle.moveTo(m_TArea.center() + m_handleOffset); m_RHandle.moveTo(m_RArea.center() + m_handleOffset); m_BHandle.moveTo(m_BArea.center() + m_handleOffset); } void SelectionWidget::updateCursor() { SideType mouseSide = m_activeSide; if (!m_activeSide) { mouseSide = getMouseSide(parentWidget()->mapFromGlobal(QCursor::pos())); } switch (mouseSide) { case TOPLEFT_SIDE: setCursor(Qt::SizeFDiagCursor); break; case BOTTOMRIGHT_SIDE: setCursor(Qt::SizeFDiagCursor); break; case TOPRIGHT_SIDE: setCursor(Qt::SizeBDiagCursor); break; case BOTTOMLEFT_SIDE: setCursor(Qt::SizeBDiagCursor); break; case LEFT_SIDE: setCursor(Qt::SizeHorCursor); break; case RIGHT_SIDE: setCursor(Qt::SizeHorCursor); break; case TOP_SIDE: setCursor(Qt::SizeVerCursor); break; case BOTTOM_SIDE: setCursor(Qt::SizeVerCursor); break; default: if (m_activeSide) { setCursor(Qt::ClosedHandCursor); } else { setCursor(m_idleCentralCursor); return; } break; } } void SelectionWidget::setGeometryByKeyboard(const QRect& r) { static QTimer timer; QRect rect = r.intersected(parentWidget()->rect()); if (rect.width() <= 0) { rect.setWidth(1); } if (rect.height() <= 0) { rect.setHeight(1); } setGeometry(rect); connect(&timer, &QTimer::timeout, this, &SelectionWidget::geometrySettled, Qt::UniqueConnection); timer.start(400); }","title":"File selectionwidget.cpp"},{"location":"flameshot/selectionwidget_8cpp_source/#file-selectionwidgetcpp","text":"File List > capture > selectionwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"selectionwidget.h\" #include \"capturetool.h\" #include \"capturetoolbutton.h\" #include \"src/utils/globalvalues.h\" #include <QApplication> #include <QEvent> #include <QMouseEvent> #include <QPainter> #include <QPropertyAnimation> #include <QTimer> #include <utility> #define MARGIN (m_THandle.width()) SelectionWidget::SelectionWidget(QColor c, QWidget* parent) : QWidget(parent) , m_color(std::move(c)) , m_activeSide(NO_SIDE) , m_ignoreMouse(false) { // prevents this widget from consuming CaptureToolButton mouse events setAttribute(Qt::WA_TransparentForMouseEvents); parent->installEventFilter(this); m_animation = new QPropertyAnimation(this, \"geometry\", this); m_animation->setEasingCurve(QEasingCurve::InOutQuad); m_animation->setDuration(200); connect(m_animation, &QPropertyAnimation::finished, this, [this]() { emit geometrySettled(); }); int sideVal = GlobalValues::buttonBaseSize() * 0.6; int handleSide = sideVal / 2; const QRect areaRect(0, 0, sideVal, sideVal); const QRect handleRect(0, 0, handleSide, handleSide); m_TLHandle = m_TRHandle = m_BLHandle = m_BRHandle = m_LHandle = m_THandle = m_RHandle = m_BHandle = handleRect; m_TLArea = m_TRArea = m_BLArea = m_BRArea = areaRect; m_areaOffset = QPoint(-sideVal / 2, -sideVal / 2); m_handleOffset = QPoint(-handleSide / 2, -handleSide / 2); } SelectionWidget::SideType SelectionWidget::getMouseSide( const QPoint& mousePos) const { if (!isVisible()) { return NO_SIDE; } QPoint localPos = mapFromParent(mousePos); if (m_TLArea.contains(localPos)) { return TOPLEFT_SIDE; } else if (m_TRArea.contains(localPos)) { return TOPRIGHT_SIDE; } else if (m_BLArea.contains(localPos)) { return BOTTOMLEFT_SIDE; } else if (m_BRArea.contains(localPos)) { return BOTTOMRIGHT_SIDE; } else if (m_LArea.contains(localPos)) { return LEFT_SIDE; } else if (m_TArea.contains(localPos)) { return TOP_SIDE; } else if (m_RArea.contains(localPos)) { return RIGHT_SIDE; } else if (m_BArea.contains(localPos)) { return BOTTOM_SIDE; } else if (rect().contains(localPos)) { return CENTER; } else { return NO_SIDE; } } QVector<QRect> SelectionWidget::handlerAreas() { QVector<QRect> areas; areas << m_TLHandle << m_TRHandle << m_BLHandle << m_BRHandle << m_LHandle << m_THandle << m_RHandle << m_BHandle; return areas; } // helper function SelectionWidget::SideType getProperSide(SelectionWidget::SideType side, const QRect& r) { using SideType = SelectionWidget::SideType; int intSide = side; if (r.right() < r.left()) { intSide ^= SideType::LEFT_SIDE; intSide ^= SideType::RIGHT_SIDE; } if (r.bottom() < r.top()) { intSide ^= SideType::TOP_SIDE; intSide ^= SideType::BOTTOM_SIDE; } return (SideType)intSide; } void SelectionWidget::setIgnoreMouse(bool ignore) { m_ignoreMouse = ignore; updateCursor(); } void SelectionWidget::setIdleCentralCursor(const QCursor& cursor) { m_idleCentralCursor = cursor; } void SelectionWidget::setGeometryAnimated(const QRect& r) { if (isVisible()) { m_animation->setStartValue(geometry()); m_animation->setEndValue(r); m_animation->start(); } } void SelectionWidget::setGeometry(const QRect& r) { QWidget::setGeometry(r + QMargins(MARGIN, MARGIN, MARGIN, MARGIN)); updateCursor(); if (isVisible()) { emit geometryChanged(); } } QRect SelectionWidget::geometry() const { return QWidget::geometry() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN); } QRect SelectionWidget::fullGeometry() const { return QWidget::geometry(); } QRect SelectionWidget::rect() const { return QWidget::rect() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN); } bool SelectionWidget::eventFilter(QObject* obj, QEvent* event) { if (m_ignoreMouse && dynamic_cast<QMouseEvent*>(event)) { m_activeSide = NO_SIDE; unsetCursor(); } else if (event->type() == QEvent::MouseButtonRelease) { parentMouseReleaseEvent(static_cast<QMouseEvent*>(event)); } else if (event->type() == QEvent::MouseButtonPress) { parentMousePressEvent(static_cast<QMouseEvent*>(event)); } else if (event->type() == QEvent::MouseMove) { parentMouseMoveEvent(static_cast<QMouseEvent*>(event)); } return false; } void SelectionWidget::parentMousePressEvent(QMouseEvent* e) { if (e->button() != Qt::LeftButton) { return; } m_dragStartPos = e->pos(); m_activeSide = getMouseSide(e->pos()); } void SelectionWidget::parentMouseReleaseEvent(QMouseEvent* e) { // released outside of the selection area if (!getMouseSide(e->pos())) { hide(); } m_activeSide = NO_SIDE; updateCursor(); emit geometrySettled(); } void SelectionWidget::parentMouseMoveEvent(QMouseEvent* e) { updateCursor(); if (e->buttons() != Qt::LeftButton) { return; } SideType mouseSide = m_activeSide; if (!m_activeSide) { mouseSide = getMouseSide(e->pos()); } QPoint pos; if (!isVisible() || !mouseSide) { show(); m_activeSide = TOPLEFT_SIDE; pos = m_dragStartPos; setGeometry({ pos, pos }); } else { pos = e->pos(); } auto geom = geometry(); float aspectRatio = (float)geom.width() / (float)geom.height(); bool symmetryMod = qApp->keyboardModifiers() & Qt::ShiftModifier; bool preserveAspect = qApp->keyboardModifiers() & Qt::ControlModifier; QPoint newTopLeft = geom.topLeft(), newBottomRight = geom.bottomRight(); int oldLeft = newTopLeft.rx(), oldRight = newBottomRight.rx(), oldTop = newTopLeft.ry(), oldBottom = newBottomRight.ry(); int &newLeft = newTopLeft.rx(), &newRight = newBottomRight.rx(), &newTop = newTopLeft.ry(), &newBottom = newBottomRight.ry(); switch (mouseSide) { case TOPLEFT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(oldRight - pos.x()) / (float)(oldBottom - pos.y()) > aspectRatio) { /* width longer than expected width, hence increase * height to compensate for the aspect ratio */ newLeft = pos.x(); newTop = oldBottom - (int)(((float)(oldRight - pos.x())) / aspectRatio); } else { /* height longer than expected height, hence increase * width to compensate for the aspect ratio */ newTop = pos.y(); newLeft = oldRight - (int)(((float)(oldBottom - pos.y())) * aspectRatio); } } else { newTopLeft = pos; } } break; case BOTTOMRIGHT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(pos.x() - oldLeft) / (float)(pos.y() - oldTop) > aspectRatio) { newRight = pos.x(); newBottom = oldTop + (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } else { newBottom = pos.y(); newRight = oldLeft + (int)(((float)(pos.y() - oldTop)) * aspectRatio); } } else { newBottomRight = pos; } } break; case TOPRIGHT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(pos.x() - oldLeft) / (float)(oldBottom - pos.y()) > aspectRatio) { newRight = pos.x(); newTop = oldBottom - (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } else { newTop = pos.y(); newRight = oldLeft + (int)(((float)(oldBottom - pos.y())) * aspectRatio); } } else { newTop = pos.y(); newRight = pos.x(); } } break; case BOTTOMLEFT_SIDE: if (m_activeSide) { if (preserveAspect) { if ((float)(oldRight - pos.x()) / (float)(pos.y() - oldTop) > aspectRatio) { newLeft = pos.x(); newBottom = oldTop + (int)(((float)(oldRight - pos.x())) / aspectRatio); } else { newBottom = pos.y(); newLeft = oldRight - (int)(((float)(pos.y() - oldTop)) * aspectRatio); } } else { newBottom = pos.y(); newLeft = pos.x(); } } break; case LEFT_SIDE: if (m_activeSide) { newLeft = pos.x(); if (preserveAspect) { /* By default bottom edge moves when dragging sides, this * behavior feels natural */ newBottom = oldTop + (int)(((float)(oldRight - pos.x())) / aspectRatio); } } break; case RIGHT_SIDE: if (m_activeSide) { newRight = pos.x(); if (preserveAspect) { newBottom = oldTop + (int)(((float)(pos.x() - oldLeft)) / aspectRatio); } } break; case TOP_SIDE: if (m_activeSide) { newTop = pos.y(); if (preserveAspect) { /* By default right edge moves when dragging sides, this * behavior feels natural */ newRight = oldLeft + (int)(((float)(oldBottom - pos.y()) * aspectRatio)); } } break; case BOTTOM_SIDE: if (m_activeSide) { newBottom = pos.y(); if (preserveAspect) { newRight = oldLeft + (int)(((float)(pos.y() - oldTop) * aspectRatio)); } } break; default: if (m_activeSide) { move(this->pos() + pos - m_dragStartPos); m_dragStartPos = pos; /* do nothing special in case of preserveAspect */ } return; } // finalize geometry change if (m_activeSide) { if (symmetryMod) { QPoint deltaTopLeft = newTopLeft - geom.topLeft(); QPoint deltaBottomRight = newBottomRight - geom.bottomRight(); newTopLeft = geom.topLeft() + deltaTopLeft - deltaBottomRight; newBottomRight = geom.bottomRight() + deltaBottomRight - deltaTopLeft; } geom = { newTopLeft, newBottomRight }; setGeometry(geom.normalized()); m_activeSide = getProperSide(m_activeSide, geom); } m_dragStartPos = e->pos(); } void SelectionWidget::paintEvent(QPaintEvent*) { QPainter p(this); p.setPen(m_color); p.drawRect(rect() + QMargins(0, 0, -1, -1)); p.setRenderHint(QPainter::Antialiasing); p.setBrush(m_color); for (auto rect : handlerAreas()) { p.drawEllipse(rect); } } void SelectionWidget::resizeEvent(QResizeEvent*) { updateAreas(); if (isVisible()) { emit geometryChanged(); } } void SelectionWidget::moveEvent(QMoveEvent*) { updateAreas(); if (isVisible()) { emit geometryChanged(); } } void SelectionWidget::showEvent(QShowEvent*) { emit visibilityChanged(); } void SelectionWidget::hideEvent(QHideEvent*) { emit visibilityChanged(); } void SelectionWidget::updateColor(const QColor& c) { m_color = c; } void SelectionWidget::moveLeft() { setGeometryByKeyboard(geometry().adjusted(-1, 0, -1, 0)); } void SelectionWidget::moveRight() { setGeometryByKeyboard(geometry().adjusted(1, 0, 1, 0)); } void SelectionWidget::moveUp() { setGeometryByKeyboard(geometry().adjusted(0, -1, 0, -1)); } void SelectionWidget::moveDown() { setGeometryByKeyboard(geometry().adjusted(0, 1, 0, 1)); } void SelectionWidget::resizeLeft() { setGeometryByKeyboard(geometry().adjusted(0, 0, -1, 0)); } void SelectionWidget::resizeRight() { setGeometryByKeyboard(geometry().adjusted(0, 0, 1, 0)); } void SelectionWidget::resizeUp() { setGeometryByKeyboard(geometry().adjusted(0, 0, 0, -1)); } void SelectionWidget::resizeDown() { setGeometryByKeyboard(geometry().adjusted(0, 0, 0, 1)); } void SelectionWidget::symResizeLeft() { setGeometryByKeyboard(geometry().adjusted(1, 0, -1, 0)); } void SelectionWidget::symResizeRight() { setGeometryByKeyboard(geometry().adjusted(-1, 0, 1, 0)); } void SelectionWidget::symResizeUp() { setGeometryByKeyboard(geometry().adjusted(0, -1, 0, 1)); } void SelectionWidget::symResizeDown() { setGeometryByKeyboard(geometry().adjusted(0, 1, 0, -1)); } void SelectionWidget::updateAreas() { QRect r = rect(); m_TLArea.moveTo(r.topLeft() + m_areaOffset); m_TRArea.moveTo(r.topRight() + m_areaOffset); m_BLArea.moveTo(r.bottomLeft() + m_areaOffset); m_BRArea.moveTo(r.bottomRight() + m_areaOffset); m_LArea = QRect(m_TLArea.bottomLeft(), m_BLArea.topRight()); m_TArea = QRect(m_TLArea.topRight(), m_TRArea.bottomLeft()); m_RArea = QRect(m_TRArea.bottomLeft(), m_BRArea.topRight()); m_BArea = QRect(m_BLArea.topRight(), m_BRArea.bottomLeft()); m_TLHandle.moveTo(m_TLArea.center() + m_handleOffset); m_BLHandle.moveTo(m_BLArea.center() + m_handleOffset); m_TRHandle.moveTo(m_TRArea.center() + m_handleOffset); m_BRHandle.moveTo(m_BRArea.center() + m_handleOffset); m_LHandle.moveTo(m_LArea.center() + m_handleOffset); m_THandle.moveTo(m_TArea.center() + m_handleOffset); m_RHandle.moveTo(m_RArea.center() + m_handleOffset); m_BHandle.moveTo(m_BArea.center() + m_handleOffset); } void SelectionWidget::updateCursor() { SideType mouseSide = m_activeSide; if (!m_activeSide) { mouseSide = getMouseSide(parentWidget()->mapFromGlobal(QCursor::pos())); } switch (mouseSide) { case TOPLEFT_SIDE: setCursor(Qt::SizeFDiagCursor); break; case BOTTOMRIGHT_SIDE: setCursor(Qt::SizeFDiagCursor); break; case TOPRIGHT_SIDE: setCursor(Qt::SizeBDiagCursor); break; case BOTTOMLEFT_SIDE: setCursor(Qt::SizeBDiagCursor); break; case LEFT_SIDE: setCursor(Qt::SizeHorCursor); break; case RIGHT_SIDE: setCursor(Qt::SizeHorCursor); break; case TOP_SIDE: setCursor(Qt::SizeVerCursor); break; case BOTTOM_SIDE: setCursor(Qt::SizeVerCursor); break; default: if (m_activeSide) { setCursor(Qt::ClosedHandCursor); } else { setCursor(m_idleCentralCursor); return; } break; } } void SelectionWidget::setGeometryByKeyboard(const QRect& r) { static QTimer timer; QRect rect = r.intersected(parentWidget()->rect()); if (rect.width() <= 0) { rect.setWidth(1); } if (rect.height() <= 0) { rect.setHeight(1); } setGeometry(rect); connect(&timer, &QTimer::timeout, this, &SelectionWidget::geometrySettled, Qt::UniqueConnection); timer.start(400); }","title":"File selectionwidget.cpp"},{"location":"flameshot/selectionwidget_8h/","text":"File selectionwidget.h # FileList > capture > selectionwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class SelectionWidget","title":"File selectionwidget.h"},{"location":"flameshot/selectionwidget_8h/#file-selectionwidgeth","text":"FileList > capture > selectionwidget.h Go to the source code of this file. #include <QWidget>","title":"File selectionwidget.h"},{"location":"flameshot/selectionwidget_8h/#classes","text":"Type Name class SelectionWidget","title":"Classes"},{"location":"flameshot/selectionwidget_8h_source/","text":"File selectionwidget.h # File List > capture > selectionwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QPropertyAnimation; class SelectionWidget : public QWidget { Q_OBJECT public: enum SideType { NO_SIDE = 0, TOP_SIDE = 0b0001, BOTTOM_SIDE = 0b0010, RIGHT_SIDE = 0b0100, LEFT_SIDE = 0b1000, TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE, BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE, TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE, BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE, CENTER = 0b10000, }; explicit SelectionWidget(QColor c, QWidget* parent = nullptr); SideType getMouseSide(const QPoint& mousePos) const; QVector<QRect> handlerAreas(); void setIgnoreMouse(bool ignore); void setIdleCentralCursor(const QCursor& cursor); void setGeometryAnimated(const QRect& r); void setGeometry(const QRect& r); QRect geometry() const; QRect fullGeometry() const; QRect rect() const; protected: bool eventFilter(QObject*, QEvent*) override; void parentMousePressEvent(QMouseEvent* e); void parentMouseReleaseEvent(QMouseEvent* e); void parentMouseMoveEvent(QMouseEvent* e); void paintEvent(QPaintEvent*) override; void resizeEvent(QResizeEvent*) override; void moveEvent(QMoveEvent*) override; void showEvent(QShowEvent*) override; void hideEvent(QHideEvent*) override; signals: void animationEnded(); void geometryChanged(); void geometrySettled(); void visibilityChanged(); public slots: void updateColor(const QColor& c); void moveLeft(); void moveRight(); void moveUp(); void moveDown(); void resizeLeft(); void resizeRight(); void resizeUp(); void resizeDown(); void symResizeLeft(); void symResizeRight(); void symResizeUp(); void symResizeDown(); private: void updateAreas(); void updateCursor(); void setGeometryByKeyboard(const QRect& r); QPropertyAnimation* m_animation; QColor m_color; QPoint m_areaOffset; QPoint m_handleOffset; QPoint m_dragStartPos; SideType m_activeSide; QCursor m_idleCentralCursor; bool m_ignoreMouse; bool m_mouseStartMove; // naming convention for handles // T top, B bottom, R Right, L left // 2 letters: a corner // 1 letter: the handle on the middle of the corresponding side QRect m_TLHandle, m_TRHandle, m_BLHandle, m_BRHandle; QRect m_LHandle, m_THandle, m_RHandle, m_BHandle; QRect m_TLArea, m_TRArea, m_BLArea, m_BRArea; QRect m_LArea, m_TArea, m_RArea, m_BArea; };","title":"File selectionwidget.h"},{"location":"flameshot/selectionwidget_8h_source/#file-selectionwidgeth","text":"File List > capture > selectionwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QPropertyAnimation; class SelectionWidget : public QWidget { Q_OBJECT public: enum SideType { NO_SIDE = 0, TOP_SIDE = 0b0001, BOTTOM_SIDE = 0b0010, RIGHT_SIDE = 0b0100, LEFT_SIDE = 0b1000, TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE, BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE, TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE, BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE, CENTER = 0b10000, }; explicit SelectionWidget(QColor c, QWidget* parent = nullptr); SideType getMouseSide(const QPoint& mousePos) const; QVector<QRect> handlerAreas(); void setIgnoreMouse(bool ignore); void setIdleCentralCursor(const QCursor& cursor); void setGeometryAnimated(const QRect& r); void setGeometry(const QRect& r); QRect geometry() const; QRect fullGeometry() const; QRect rect() const; protected: bool eventFilter(QObject*, QEvent*) override; void parentMousePressEvent(QMouseEvent* e); void parentMouseReleaseEvent(QMouseEvent* e); void parentMouseMoveEvent(QMouseEvent* e); void paintEvent(QPaintEvent*) override; void resizeEvent(QResizeEvent*) override; void moveEvent(QMoveEvent*) override; void showEvent(QShowEvent*) override; void hideEvent(QHideEvent*) override; signals: void animationEnded(); void geometryChanged(); void geometrySettled(); void visibilityChanged(); public slots: void updateColor(const QColor& c); void moveLeft(); void moveRight(); void moveUp(); void moveDown(); void resizeLeft(); void resizeRight(); void resizeUp(); void resizeDown(); void symResizeLeft(); void symResizeRight(); void symResizeUp(); void symResizeDown(); private: void updateAreas(); void updateCursor(); void setGeometryByKeyboard(const QRect& r); QPropertyAnimation* m_animation; QColor m_color; QPoint m_areaOffset; QPoint m_handleOffset; QPoint m_dragStartPos; SideType m_activeSide; QCursor m_idleCentralCursor; bool m_ignoreMouse; bool m_mouseStartMove; // naming convention for handles // T top, B bottom, R Right, L left // 2 letters: a corner // 1 letter: the handle on the middle of the corresponding side QRect m_TLHandle, m_TRHandle, m_BLHandle, m_BRHandle; QRect m_LHandle, m_THandle, m_RHandle, m_BHandle; QRect m_TLArea, m_TRArea, m_BLArea, m_BRArea; QRect m_LArea, m_TArea, m_RArea, m_BArea; };","title":"File selectionwidget.h"},{"location":"flameshot/capturelauncher_8cpp/","text":"File capturelauncher.cpp # FileList > src > widgets > capturelauncher.cpp Go to the source code of this file. #include \"capturelauncher.h\" #include \"./ui_capturelauncher.h\" #include \"src/config/cacheutils.h\" #include \"src/core/flameshot.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include <QMimeData>","title":"File capturelauncher.cpp"},{"location":"flameshot/capturelauncher_8cpp/#file-capturelaunchercpp","text":"FileList > src > widgets > capturelauncher.cpp Go to the source code of this file. #include \"capturelauncher.h\" #include \"./ui_capturelauncher.h\" #include \"src/config/cacheutils.h\" #include \"src/core/flameshot.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include <QMimeData>","title":"File capturelauncher.cpp"},{"location":"flameshot/capturelauncher_8cpp_source/","text":"File capturelauncher.cpp # File List > src > widgets > capturelauncher.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica & Contributors #include \"capturelauncher.h\" #include \"./ui_capturelauncher.h\" #include \"src/config/cacheutils.h\" #include \"src/core/flameshot.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include <QMimeData> // https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSWidget.cpp // https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSMainWindow.cpp CaptureLauncher::CaptureLauncher(QDialog* parent) : QDialog(parent) , ui(new Ui::CaptureLauncher) { qApp->installEventFilter(this); // see eventFilter() ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); bool ok; ui->imagePreview->setScreenshot(ScreenGrabber().grabEntireDesktop(ok)); ui->imagePreview->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); ui->captureType->insertItem( 1, tr(\"Rectangular Region\"), CaptureRequest::GRAPHICAL_MODE); #if defined(Q_OS_MACOS) // Following to MacOS philosophy (one application cannot be displayed on // more than one display) ui->captureType->insertItem( 2, tr(\"Full Screen (Current Display)\"), CaptureRequest::FULLSCREEN_MODE); #else ui->captureType->insertItem( 2, tr(\"Full Screen (All Monitors)\"), CaptureRequest::FULLSCREEN_MODE); #endif ui->delayTime->setSpecialValueText(tr(\"No Delay\")); ui->launchButton->setFocus(); // Function to add or remove plural to seconds connect(ui->delayTime, static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged), this, [this](int val) { QString suffix = val == 1 ? tr(\" second\") : tr(\" seconds\"); this->ui->delayTime->setSuffix(suffix); }); connect(ui->launchButton, &QPushButton::clicked, this, &CaptureLauncher::startCapture); connect(ui->captureType, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this]() { auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) { ui->sizeLabel->show(); ui->screenshotX->show(); ui->screenshotY->show(); ui->screenshotWidth->show(); ui->screenshotHeight->show(); } else { ui->sizeLabel->hide(); ui->screenshotX->hide(); ui->screenshotY->hide(); ui->screenshotWidth->hide(); ui->screenshotHeight->hide(); } }); auto lastRegion = getLastRegion(); ui->screenshotX->setText(QString::number(lastRegion.x())); ui->screenshotY->setText(QString::number(lastRegion.y())); ui->screenshotWidth->setText(QString::number(lastRegion.width())); ui->screenshotHeight->setText(QString::number(lastRegion.height())); show(); } // HACK: // https://github.com/KDE/spectacle/blob/fa1e780b8bf3df3ac36c410b9ece4ace041f401b/src/Gui/KSMainWindow.cpp#L70 void CaptureLauncher::startCapture() { ui->launchButton->setEnabled(false); hide(); auto const additionalDelayToHideUI = 600; auto const secondsToMilliseconds = 1000; auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); CaptureRequest req(mode, additionalDelayToHideUI + ui->delayTime->value() * secondsToMilliseconds); if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) { req.setInitialSelection(QRect(ui->screenshotX->text().toInt(), ui->screenshotY->text().toInt(), ui->screenshotWidth->text().toInt(), ui->screenshotHeight->text().toInt())); } connectCaptureSlots(); Flameshot::instance()->requestCapture(req); } void CaptureLauncher::connectCaptureSlots() const { connect(Flameshot::instance(), &Flameshot::captureTaken, this, &CaptureLauncher::onCaptureTaken); connect(Flameshot::instance(), &Flameshot::captureFailed, this, &CaptureLauncher::onCaptureFailed); } void CaptureLauncher::disconnectCaptureSlots() const { // Hack for MacOS // for some strange reasons MacOS sends multiple \"captureTaken\" signals // (random number, usually from 1 up to 20). // So now it enables signal on \"Capture new screenshot\" button and disables // on first success of fail. disconnect(Flameshot::instance(), &Flameshot::captureTaken, this, &CaptureLauncher::onCaptureTaken); disconnect(Flameshot::instance(), &Flameshot::captureFailed, this, &CaptureLauncher::onCaptureFailed); } void CaptureLauncher::onCaptureTaken(QPixmap const& screenshot) { // MacOS specific, more details in the function disconnectCaptureSlots() disconnectCaptureSlots(); ui->imagePreview->setScreenshot(screenshot); show(); auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); if (mode == CaptureRequest::FULLSCREEN_MODE) { saveToFilesystemGUI(screenshot); } ui->launchButton->setEnabled(true); } void CaptureLauncher::onCaptureFailed() { // MacOS specific, more details in the function disconnectCaptureSlots() disconnectCaptureSlots(); show(); ui->launchButton->setEnabled(true); } CaptureLauncher::~CaptureLauncher() { delete ui; }","title":"File capturelauncher.cpp"},{"location":"flameshot/capturelauncher_8cpp_source/#file-capturelaunchercpp","text":"File List > src > widgets > capturelauncher.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica & Contributors #include \"capturelauncher.h\" #include \"./ui_capturelauncher.h\" #include \"src/config/cacheutils.h\" #include \"src/core/flameshot.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/screengrabber.h\" #include \"src/utils/screenshotsaver.h\" #include \"src/widgets/imagelabel.h\" #include <QMimeData> // https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSWidget.cpp // https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSMainWindow.cpp CaptureLauncher::CaptureLauncher(QDialog* parent) : QDialog(parent) , ui(new Ui::CaptureLauncher) { qApp->installEventFilter(this); // see eventFilter() ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(GlobalValues::iconPath())); bool ok; ui->imagePreview->setScreenshot(ScreenGrabber().grabEntireDesktop(ok)); ui->imagePreview->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); ui->captureType->insertItem( 1, tr(\"Rectangular Region\"), CaptureRequest::GRAPHICAL_MODE); #if defined(Q_OS_MACOS) // Following to MacOS philosophy (one application cannot be displayed on // more than one display) ui->captureType->insertItem( 2, tr(\"Full Screen (Current Display)\"), CaptureRequest::FULLSCREEN_MODE); #else ui->captureType->insertItem( 2, tr(\"Full Screen (All Monitors)\"), CaptureRequest::FULLSCREEN_MODE); #endif ui->delayTime->setSpecialValueText(tr(\"No Delay\")); ui->launchButton->setFocus(); // Function to add or remove plural to seconds connect(ui->delayTime, static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged), this, [this](int val) { QString suffix = val == 1 ? tr(\" second\") : tr(\" seconds\"); this->ui->delayTime->setSuffix(suffix); }); connect(ui->launchButton, &QPushButton::clicked, this, &CaptureLauncher::startCapture); connect(ui->captureType, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this]() { auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) { ui->sizeLabel->show(); ui->screenshotX->show(); ui->screenshotY->show(); ui->screenshotWidth->show(); ui->screenshotHeight->show(); } else { ui->sizeLabel->hide(); ui->screenshotX->hide(); ui->screenshotY->hide(); ui->screenshotWidth->hide(); ui->screenshotHeight->hide(); } }); auto lastRegion = getLastRegion(); ui->screenshotX->setText(QString::number(lastRegion.x())); ui->screenshotY->setText(QString::number(lastRegion.y())); ui->screenshotWidth->setText(QString::number(lastRegion.width())); ui->screenshotHeight->setText(QString::number(lastRegion.height())); show(); } // HACK: // https://github.com/KDE/spectacle/blob/fa1e780b8bf3df3ac36c410b9ece4ace041f401b/src/Gui/KSMainWindow.cpp#L70 void CaptureLauncher::startCapture() { ui->launchButton->setEnabled(false); hide(); auto const additionalDelayToHideUI = 600; auto const secondsToMilliseconds = 1000; auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); CaptureRequest req(mode, additionalDelayToHideUI + ui->delayTime->value() * secondsToMilliseconds); if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) { req.setInitialSelection(QRect(ui->screenshotX->text().toInt(), ui->screenshotY->text().toInt(), ui->screenshotWidth->text().toInt(), ui->screenshotHeight->text().toInt())); } connectCaptureSlots(); Flameshot::instance()->requestCapture(req); } void CaptureLauncher::connectCaptureSlots() const { connect(Flameshot::instance(), &Flameshot::captureTaken, this, &CaptureLauncher::onCaptureTaken); connect(Flameshot::instance(), &Flameshot::captureFailed, this, &CaptureLauncher::onCaptureFailed); } void CaptureLauncher::disconnectCaptureSlots() const { // Hack for MacOS // for some strange reasons MacOS sends multiple \"captureTaken\" signals // (random number, usually from 1 up to 20). // So now it enables signal on \"Capture new screenshot\" button and disables // on first success of fail. disconnect(Flameshot::instance(), &Flameshot::captureTaken, this, &CaptureLauncher::onCaptureTaken); disconnect(Flameshot::instance(), &Flameshot::captureFailed, this, &CaptureLauncher::onCaptureFailed); } void CaptureLauncher::onCaptureTaken(QPixmap const& screenshot) { // MacOS specific, more details in the function disconnectCaptureSlots() disconnectCaptureSlots(); ui->imagePreview->setScreenshot(screenshot); show(); auto mode = static_cast<CaptureRequest::CaptureMode>( ui->captureType->currentData().toInt()); if (mode == CaptureRequest::FULLSCREEN_MODE) { saveToFilesystemGUI(screenshot); } ui->launchButton->setEnabled(true); } void CaptureLauncher::onCaptureFailed() { // MacOS specific, more details in the function disconnectCaptureSlots() disconnectCaptureSlots(); show(); ui->launchButton->setEnabled(true); } CaptureLauncher::~CaptureLauncher() { delete ui; }","title":"File capturelauncher.cpp"},{"location":"flameshot/capturelauncher_8h/","text":"File capturelauncher.h # FileList > src > widgets > capturelauncher.h Go to the source code of this file. #include <QDialog> Namespaces # Type Name namespace Ui Classes # Type Name class CaptureLauncher","title":"File capturelauncher.h"},{"location":"flameshot/capturelauncher_8h/#file-capturelauncherh","text":"FileList > src > widgets > capturelauncher.h Go to the source code of this file. #include <QDialog>","title":"File capturelauncher.h"},{"location":"flameshot/capturelauncher_8h/#namespaces","text":"Type Name namespace Ui","title":"Namespaces"},{"location":"flameshot/capturelauncher_8h/#classes","text":"Type Name class CaptureLauncher","title":"Classes"},{"location":"flameshot/capturelauncher_8h_source/","text":"File capturelauncher.h # File List > src > widgets > capturelauncher.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica & Contributors #pragma once #include <QDialog> QT_BEGIN_NAMESPACE namespace Ui { class CaptureLauncher; } QT_END_NAMESPACE class CaptureLauncher : public QDialog { Q_OBJECT public: explicit CaptureLauncher(QDialog* parent = nullptr); ~CaptureLauncher(); private: Ui::CaptureLauncher* ui; void connectCaptureSlots() const; void disconnectCaptureSlots() const; private slots: void startCapture(); void onCaptureTaken(QPixmap const& p); void onCaptureFailed(); };","title":"File capturelauncher.h"},{"location":"flameshot/capturelauncher_8h_source/#file-capturelauncherh","text":"File List > src > widgets > capturelauncher.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica & Contributors #pragma once #include <QDialog> QT_BEGIN_NAMESPACE namespace Ui { class CaptureLauncher; } QT_END_NAMESPACE class CaptureLauncher : public QDialog { Q_OBJECT public: explicit CaptureLauncher(QDialog* parent = nullptr); ~CaptureLauncher(); private: Ui::CaptureLauncher* ui; void connectCaptureSlots() const; void disconnectCaptureSlots() const; private slots: void startCapture(); void onCaptureTaken(QPixmap const& p); void onCaptureFailed(); };","title":"File capturelauncher.h"},{"location":"flameshot/colorpickerwidget_8cpp/","text":"File colorpickerwidget.cpp # FileList > src > widgets > colorpickerwidget.cpp Go to the source code of this file. #include \"colorpickerwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpickerwidget.cpp"},{"location":"flameshot/colorpickerwidget_8cpp/#file-colorpickerwidgetcpp","text":"FileList > src > widgets > colorpickerwidget.cpp Go to the source code of this file. #include \"colorpickerwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter>","title":"File colorpickerwidget.cpp"},{"location":"flameshot/colorpickerwidget_8cpp_source/","text":"File colorpickerwidget.cpp # File List > src > widgets > colorpickerwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickerwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter> ColorPickerWidget::ColorPickerWidget(QWidget* parent) : QWidget(parent) , m_selectedIndex(1) , m_lastIndex(1) { initColorPicker(); } const QVector<QColor>& ColorPickerWidget::getDefaultSmallColorPalette() { return defaultSmallColorPalette; } const QVector<QColor>& ColorPickerWidget::getDefaultLargeColorPalette() { return defaultLargeColorPalette; } void ColorPickerWidget::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); painter.setPen(QColor(Qt::black)); for (int i = 0; i < m_colorAreaList.size(); ++i) { if (e->region().contains(m_colorAreaList.at(i))) { painter.setClipRegion(e->region()); repaint(i, painter); } } } void ColorPickerWidget::repaint(int i, QPainter& painter) { // draw the highlight when we have to draw the selected color if (i == m_selectedIndex) { auto c = QColor(m_uiColor); c.setAlpha(155); painter.setBrush(c); c.setAlpha(100); painter.setPen(c); QRect highlight = m_colorAreaList.at(i); const int highlightThickness = 6; // makes the highlight and color circles concentric highlight.moveTo(highlight.x() - (highlightThickness / 2), highlight.y() - (highlightThickness / 2)); highlight.setHeight(highlight.height() + highlightThickness); highlight.setWidth(highlight.width() + highlightThickness); painter.drawRoundedRect(highlight, 100, 100); painter.setPen(QColor(Qt::black)); } // draw available colors if (m_colorList.at(i).isValid()) { // draw preset color painter.setBrush(QColor(m_colorList.at(i))); painter.drawRoundedRect(m_colorAreaList.at(i), 100, 100); } else { // draw rainbow (part) for custom color QRect lastRect = m_colorAreaList.at(i); int nStep = 1; int nSteps = lastRect.height() / nStep; // 0.02 - start rainbow color, 0.33 - end rainbow color from range: // 0.0 - 1.0 float h = 0.02; for (int radius = nSteps; radius > 0; radius -= nStep * 2) { // calculate color float fHStep = (0.33 - h) / (nSteps / nStep / 2); QColor color = QColor::fromHslF(h, 0.95, 0.5); // set color and draw circle painter.setPen(color); painter.setBrush(color); painter.drawRoundedRect(lastRect, 100, 100); // set next color, circle geometry h += fHStep; lastRect.setX(lastRect.x() + nStep); lastRect.setY(lastRect.y() + nStep); lastRect.setHeight(lastRect.height() - nStep); lastRect.setWidth(lastRect.width() - nStep); painter.setPen(QColor(Qt::black)); } } } void ColorPickerWidget::updateSelection(int index) { m_selectedIndex = index; update(m_colorAreaList.at(index) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = index; } void ColorPickerWidget::updateWidget() { m_colorAreaList.clear(); initColorPicker(); update(); } void ColorPickerWidget::initColorPicker() { ConfigHandler config; m_colorList = config.userColors(); m_colorAreaSize = GlobalValues::buttonBaseSize() * 0.6; // save the color values in member variables for faster access m_uiColor = config.uiColor(); // extraSize represents the extra space needed for the highlight of the // selected color. const int extraSize = 6; const double slope = 3; double radius = slope * m_colorList.size() + GlobalValues::buttonBaseSize(); setMinimumSize(radius * 2 + m_colorAreaSize + extraSize, radius * 2 + m_colorAreaSize + extraSize); resize(radius * 2 + m_colorAreaSize + extraSize, radius * 2 + m_colorAreaSize + extraSize); double degree = (double)360 / m_colorList.size(); double degreeAcum = 90; // this line is the radius of the circle which will be rotated to add // the color components. QLineF baseLine = QLineF(QPoint(radius + extraSize / 2, radius + extraSize / 2), QPoint(radius + extraSize / 2, extraSize / 2)); for (int i = 0; i < m_colorList.size(); ++i) { m_colorAreaList.append(QRect( baseLine.x2(), baseLine.y2(), m_colorAreaSize, m_colorAreaSize)); degreeAcum += degree; baseLine.setAngle(degreeAcum); } } QVector<QColor> ColorPickerWidget::defaultSmallColorPalette = { QColor(), Qt::darkRed, Qt::red, Qt::yellow, Qt::green, Qt::darkGreen, Qt::cyan, Qt::blue, Qt::magenta, Qt::darkMagenta }; QVector<QColor> ColorPickerWidget::defaultLargeColorPalette = { QColor(), Qt::white, Qt::red, Qt::green, Qt::blue, Qt::black, Qt::darkRed, Qt::darkGreen, Qt::darkBlue, Qt::darkGray, Qt::cyan, Qt::magenta, Qt::yellow, Qt::lightGray, Qt::darkCyan, Qt::darkMagenta, Qt::darkYellow };","title":"File colorpickerwidget.cpp"},{"location":"flameshot/colorpickerwidget_8cpp_source/#file-colorpickerwidgetcpp","text":"File List > src > widgets > colorpickerwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #include \"colorpickerwidget.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QMouseEvent> #include <QPainter> ColorPickerWidget::ColorPickerWidget(QWidget* parent) : QWidget(parent) , m_selectedIndex(1) , m_lastIndex(1) { initColorPicker(); } const QVector<QColor>& ColorPickerWidget::getDefaultSmallColorPalette() { return defaultSmallColorPalette; } const QVector<QColor>& ColorPickerWidget::getDefaultLargeColorPalette() { return defaultLargeColorPalette; } void ColorPickerWidget::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); painter.setPen(QColor(Qt::black)); for (int i = 0; i < m_colorAreaList.size(); ++i) { if (e->region().contains(m_colorAreaList.at(i))) { painter.setClipRegion(e->region()); repaint(i, painter); } } } void ColorPickerWidget::repaint(int i, QPainter& painter) { // draw the highlight when we have to draw the selected color if (i == m_selectedIndex) { auto c = QColor(m_uiColor); c.setAlpha(155); painter.setBrush(c); c.setAlpha(100); painter.setPen(c); QRect highlight = m_colorAreaList.at(i); const int highlightThickness = 6; // makes the highlight and color circles concentric highlight.moveTo(highlight.x() - (highlightThickness / 2), highlight.y() - (highlightThickness / 2)); highlight.setHeight(highlight.height() + highlightThickness); highlight.setWidth(highlight.width() + highlightThickness); painter.drawRoundedRect(highlight, 100, 100); painter.setPen(QColor(Qt::black)); } // draw available colors if (m_colorList.at(i).isValid()) { // draw preset color painter.setBrush(QColor(m_colorList.at(i))); painter.drawRoundedRect(m_colorAreaList.at(i), 100, 100); } else { // draw rainbow (part) for custom color QRect lastRect = m_colorAreaList.at(i); int nStep = 1; int nSteps = lastRect.height() / nStep; // 0.02 - start rainbow color, 0.33 - end rainbow color from range: // 0.0 - 1.0 float h = 0.02; for (int radius = nSteps; radius > 0; radius -= nStep * 2) { // calculate color float fHStep = (0.33 - h) / (nSteps / nStep / 2); QColor color = QColor::fromHslF(h, 0.95, 0.5); // set color and draw circle painter.setPen(color); painter.setBrush(color); painter.drawRoundedRect(lastRect, 100, 100); // set next color, circle geometry h += fHStep; lastRect.setX(lastRect.x() + nStep); lastRect.setY(lastRect.y() + nStep); lastRect.setHeight(lastRect.height() - nStep); lastRect.setWidth(lastRect.width() - nStep); painter.setPen(QColor(Qt::black)); } } } void ColorPickerWidget::updateSelection(int index) { m_selectedIndex = index; update(m_colorAreaList.at(index) + QMargins(10, 10, 10, 10)); update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10)); m_lastIndex = index; } void ColorPickerWidget::updateWidget() { m_colorAreaList.clear(); initColorPicker(); update(); } void ColorPickerWidget::initColorPicker() { ConfigHandler config; m_colorList = config.userColors(); m_colorAreaSize = GlobalValues::buttonBaseSize() * 0.6; // save the color values in member variables for faster access m_uiColor = config.uiColor(); // extraSize represents the extra space needed for the highlight of the // selected color. const int extraSize = 6; const double slope = 3; double radius = slope * m_colorList.size() + GlobalValues::buttonBaseSize(); setMinimumSize(radius * 2 + m_colorAreaSize + extraSize, radius * 2 + m_colorAreaSize + extraSize); resize(radius * 2 + m_colorAreaSize + extraSize, radius * 2 + m_colorAreaSize + extraSize); double degree = (double)360 / m_colorList.size(); double degreeAcum = 90; // this line is the radius of the circle which will be rotated to add // the color components. QLineF baseLine = QLineF(QPoint(radius + extraSize / 2, radius + extraSize / 2), QPoint(radius + extraSize / 2, extraSize / 2)); for (int i = 0; i < m_colorList.size(); ++i) { m_colorAreaList.append(QRect( baseLine.x2(), baseLine.y2(), m_colorAreaSize, m_colorAreaSize)); degreeAcum += degree; baseLine.setAngle(degreeAcum); } } QVector<QColor> ColorPickerWidget::defaultSmallColorPalette = { QColor(), Qt::darkRed, Qt::red, Qt::yellow, Qt::green, Qt::darkGreen, Qt::cyan, Qt::blue, Qt::magenta, Qt::darkMagenta }; QVector<QColor> ColorPickerWidget::defaultLargeColorPalette = { QColor(), Qt::white, Qt::red, Qt::green, Qt::blue, Qt::black, Qt::darkRed, Qt::darkGreen, Qt::darkBlue, Qt::darkGray, Qt::cyan, Qt::magenta, Qt::yellow, Qt::lightGray, Qt::darkCyan, Qt::darkMagenta, Qt::darkYellow };","title":"File colorpickerwidget.cpp"},{"location":"flameshot/colorpickerwidget_8h/","text":"File colorpickerwidget.h # FileList > src > widgets > colorpickerwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class ColorPickerWidget","title":"File colorpickerwidget.h"},{"location":"flameshot/colorpickerwidget_8h/#file-colorpickerwidgeth","text":"FileList > src > widgets > colorpickerwidget.h Go to the source code of this file. #include <QWidget>","title":"File colorpickerwidget.h"},{"location":"flameshot/colorpickerwidget_8h/#classes","text":"Type Name class ColorPickerWidget","title":"Classes"},{"location":"flameshot/colorpickerwidget_8h_source/","text":"File colorpickerwidget.h # File List > src > widgets > colorpickerwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include <QWidget> class ColorPickerWidget : public QWidget { Q_OBJECT public: explicit ColorPickerWidget(QWidget* parent = nullptr); static const QVector<QColor>& getDefaultSmallColorPalette(); static const QVector<QColor>& getDefaultLargeColorPalette(); void updateWidget(); void updateSelection(int index); protected: void paintEvent(QPaintEvent* event) override; void repaint(int i, QPainter& painter); int m_colorAreaSize; int m_selectedIndex, m_lastIndex; QVector<QRect> m_colorAreaList; QVector<QColor> m_colorList; QColor m_uiColor; private: void initColorPicker(); static QVector<QColor> defaultSmallColorPalette, defaultLargeColorPalette; };","title":"File colorpickerwidget.h"},{"location":"flameshot/colorpickerwidget_8h_source/#file-colorpickerwidgeth","text":"File List > src > widgets > colorpickerwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2022 Dearsh Oberoi #pragma once #include <QWidget> class ColorPickerWidget : public QWidget { Q_OBJECT public: explicit ColorPickerWidget(QWidget* parent = nullptr); static const QVector<QColor>& getDefaultSmallColorPalette(); static const QVector<QColor>& getDefaultLargeColorPalette(); void updateWidget(); void updateSelection(int index); protected: void paintEvent(QPaintEvent* event) override; void repaint(int i, QPainter& painter); int m_colorAreaSize; int m_selectedIndex, m_lastIndex; QVector<QRect> m_colorAreaList; QVector<QColor> m_colorList; QColor m_uiColor; private: void initColorPicker(); static QVector<QColor> defaultSmallColorPalette, defaultLargeColorPalette; };","title":"File colorpickerwidget.h"},{"location":"flameshot/draggablewidgetmaker_8cpp/","text":"File draggablewidgetmaker.cpp # FileList > src > widgets > draggablewidgetmaker.cpp Go to the source code of this file. #include \"draggablewidgetmaker.h\" #include <QMouseEvent>","title":"File draggablewidgetmaker.cpp"},{"location":"flameshot/draggablewidgetmaker_8cpp/#file-draggablewidgetmakercpp","text":"FileList > src > widgets > draggablewidgetmaker.cpp Go to the source code of this file. #include \"draggablewidgetmaker.h\" #include <QMouseEvent>","title":"File draggablewidgetmaker.cpp"},{"location":"flameshot/draggablewidgetmaker_8cpp_source/","text":"File draggablewidgetmaker.cpp # File List > src > widgets > draggablewidgetmaker.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"draggablewidgetmaker.h\" #include <QMouseEvent> DraggableWidgetMaker::DraggableWidgetMaker(QObject* parent) : QObject(parent) {} void DraggableWidgetMaker::makeDraggable(QWidget* widget) { widget->installEventFilter(this); } bool DraggableWidgetMaker::eventFilter(QObject* obj, QEvent* event) { auto* widget = static_cast<QWidget*>(obj); // based on https://stackoverflow.com/a/12221360/964478 switch (event->type()) { case QEvent::MouseButtonPress: { auto* mouseEvent = static_cast<QMouseEvent*>(event); m_isPressing = false; m_isDragging = false; if (mouseEvent->button() == Qt::LeftButton) { m_isPressing = true; m_mousePressPos = mouseEvent->globalPos(); m_mouseMovePos = m_mousePressPos; } } break; case QEvent::MouseMove: { auto* mouseEvent = static_cast<QMouseEvent*>(event); if (m_isPressing) { QPoint widgetPos = widget->mapToGlobal(widget->pos()); QPoint eventPos = mouseEvent->globalPos(); QPoint diff = eventPos - m_mouseMovePos; QPoint newPos = widgetPos + diff; widget->move(widget->mapFromGlobal(newPos)); if (!m_isDragging) { QPoint totalMovedDiff = eventPos - m_mousePressPos; if (totalMovedDiff.manhattanLength() > 3) { m_isDragging = true; } } m_mouseMovePos = eventPos; } } break; case QEvent::MouseButtonRelease: { m_isPressing = false; if (m_isDragging) { m_isDragging = false; event->ignore(); return true; } } break; default: break; } return QObject::eventFilter(obj, event); }","title":"File draggablewidgetmaker.cpp"},{"location":"flameshot/draggablewidgetmaker_8cpp_source/#file-draggablewidgetmakercpp","text":"File List > src > widgets > draggablewidgetmaker.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"draggablewidgetmaker.h\" #include <QMouseEvent> DraggableWidgetMaker::DraggableWidgetMaker(QObject* parent) : QObject(parent) {} void DraggableWidgetMaker::makeDraggable(QWidget* widget) { widget->installEventFilter(this); } bool DraggableWidgetMaker::eventFilter(QObject* obj, QEvent* event) { auto* widget = static_cast<QWidget*>(obj); // based on https://stackoverflow.com/a/12221360/964478 switch (event->type()) { case QEvent::MouseButtonPress: { auto* mouseEvent = static_cast<QMouseEvent*>(event); m_isPressing = false; m_isDragging = false; if (mouseEvent->button() == Qt::LeftButton) { m_isPressing = true; m_mousePressPos = mouseEvent->globalPos(); m_mouseMovePos = m_mousePressPos; } } break; case QEvent::MouseMove: { auto* mouseEvent = static_cast<QMouseEvent*>(event); if (m_isPressing) { QPoint widgetPos = widget->mapToGlobal(widget->pos()); QPoint eventPos = mouseEvent->globalPos(); QPoint diff = eventPos - m_mouseMovePos; QPoint newPos = widgetPos + diff; widget->move(widget->mapFromGlobal(newPos)); if (!m_isDragging) { QPoint totalMovedDiff = eventPos - m_mousePressPos; if (totalMovedDiff.manhattanLength() > 3) { m_isDragging = true; } } m_mouseMovePos = eventPos; } } break; case QEvent::MouseButtonRelease: { m_isPressing = false; if (m_isDragging) { m_isDragging = false; event->ignore(); return true; } } break; default: break; } return QObject::eventFilter(obj, event); }","title":"File draggablewidgetmaker.cpp"},{"location":"flameshot/draggablewidgetmaker_8h/","text":"File draggablewidgetmaker.h # FileList > src > widgets > draggablewidgetmaker.h Go to the source code of this file. #include <QEvent> #include <QObject> #include <QPoint> #include <QWidget> Classes # Type Name class DraggableWidgetMaker","title":"File draggablewidgetmaker.h"},{"location":"flameshot/draggablewidgetmaker_8h/#file-draggablewidgetmakerh","text":"FileList > src > widgets > draggablewidgetmaker.h Go to the source code of this file. #include <QEvent> #include <QObject> #include <QPoint> #include <QWidget>","title":"File draggablewidgetmaker.h"},{"location":"flameshot/draggablewidgetmaker_8h/#classes","text":"Type Name class DraggableWidgetMaker","title":"Classes"},{"location":"flameshot/draggablewidgetmaker_8h_source/","text":"File draggablewidgetmaker.h # File List > src > widgets > draggablewidgetmaker.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QEvent> #include <QObject> #include <QPoint> #include <QWidget> class DraggableWidgetMaker : public QObject { Q_OBJECT public: DraggableWidgetMaker(QObject* parent = nullptr); void makeDraggable(QWidget* widget); protected: bool eventFilter(QObject* obj, QEvent* event) override; private: bool m_isPressing = false; bool m_isDragging = false; QPoint m_mouseMovePos; QPoint m_mousePressPos; };","title":"File draggablewidgetmaker.h"},{"location":"flameshot/draggablewidgetmaker_8h_source/#file-draggablewidgetmakerh","text":"File List > src > widgets > draggablewidgetmaker.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QEvent> #include <QObject> #include <QPoint> #include <QWidget> class DraggableWidgetMaker : public QObject { Q_OBJECT public: DraggableWidgetMaker(QObject* parent = nullptr); void makeDraggable(QWidget* widget); protected: bool eventFilter(QObject* obj, QEvent* event) override; private: bool m_isPressing = false; bool m_isDragging = false; QPoint m_mouseMovePos; QPoint m_mousePressPos; };","title":"File draggablewidgetmaker.h"},{"location":"flameshot/imagelabel_8cpp/","text":"File imagelabel.cpp # FileList > src > widgets > imagelabel.cpp Go to the source code of this file. #include \"imagelabel.h\"","title":"File imagelabel.cpp"},{"location":"flameshot/imagelabel_8cpp/#file-imagelabelcpp","text":"FileList > src > widgets > imagelabel.cpp Go to the source code of this file. #include \"imagelabel.h\"","title":"File imagelabel.cpp"},{"location":"flameshot/imagelabel_8cpp_source/","text":"File imagelabel.cpp # File List > src > widgets > imagelabel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // This code is a modified version of the KDE software Spectacle // /src/Gui/KSImageWidget.cpp commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9 #include \"imagelabel.h\" ImageLabel::ImageLabel(QWidget* parent) : QLabel(parent) , m_pixmap(QPixmap()) { m_DSEffect = new QGraphicsDropShadowEffect(this); m_DSEffect->setBlurRadius(5); m_DSEffect->setOffset(0); m_DSEffect->setColor(QColor(Qt::black)); setGraphicsEffect(m_DSEffect); setCursor(Qt::OpenHandCursor); setAlignment(Qt::AlignCenter); setMinimumSize(size()); } void ImageLabel::setScreenshot(const QPixmap& pixmap) { m_pixmap = pixmap; const QString tooltip = QStringLiteral(\"%1x%2 px\").arg(m_pixmap.width()).arg(m_pixmap.height()); setToolTip(tooltip); setScaledPixmap(); } void ImageLabel::setScaledPixmap() { const qreal scale = qApp->devicePixelRatio(); QPixmap scaledPixmap = m_pixmap.scaled( size() * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation); scaledPixmap.setDevicePixelRatio(scale); setPixmap(scaledPixmap); } // drag handlers void ImageLabel::mousePressEvent(QMouseEvent* event) { if (event->button() == Qt::LeftButton) { m_dragStartPosition = event->pos(); setCursor(Qt::ClosedHandCursor); } } void ImageLabel::mouseReleaseEvent(QMouseEvent* event) { if (event->button() == Qt::LeftButton) { setCursor(Qt::OpenHandCursor); } } void ImageLabel::mouseMoveEvent(QMouseEvent* event) { if (!(event->buttons() & Qt::LeftButton)) { return; } if ((event->pos() - m_dragStartPosition).manhattanLength() < QGuiApplication::styleHints()->startDragDistance()) { return; } setCursor(Qt::OpenHandCursor); emit dragInitiated(); } // resize handler void ImageLabel::resizeEvent(QResizeEvent* event) { Q_UNUSED(event) setScaledPixmap(); }","title":"File imagelabel.cpp"},{"location":"flameshot/imagelabel_8cpp_source/#file-imagelabelcpp","text":"File List > src > widgets > imagelabel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // This code is a modified version of the KDE software Spectacle // /src/Gui/KSImageWidget.cpp commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9 #include \"imagelabel.h\" ImageLabel::ImageLabel(QWidget* parent) : QLabel(parent) , m_pixmap(QPixmap()) { m_DSEffect = new QGraphicsDropShadowEffect(this); m_DSEffect->setBlurRadius(5); m_DSEffect->setOffset(0); m_DSEffect->setColor(QColor(Qt::black)); setGraphicsEffect(m_DSEffect); setCursor(Qt::OpenHandCursor); setAlignment(Qt::AlignCenter); setMinimumSize(size()); } void ImageLabel::setScreenshot(const QPixmap& pixmap) { m_pixmap = pixmap; const QString tooltip = QStringLiteral(\"%1x%2 px\").arg(m_pixmap.width()).arg(m_pixmap.height()); setToolTip(tooltip); setScaledPixmap(); } void ImageLabel::setScaledPixmap() { const qreal scale = qApp->devicePixelRatio(); QPixmap scaledPixmap = m_pixmap.scaled( size() * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation); scaledPixmap.setDevicePixelRatio(scale); setPixmap(scaledPixmap); } // drag handlers void ImageLabel::mousePressEvent(QMouseEvent* event) { if (event->button() == Qt::LeftButton) { m_dragStartPosition = event->pos(); setCursor(Qt::ClosedHandCursor); } } void ImageLabel::mouseReleaseEvent(QMouseEvent* event) { if (event->button() == Qt::LeftButton) { setCursor(Qt::OpenHandCursor); } } void ImageLabel::mouseMoveEvent(QMouseEvent* event) { if (!(event->buttons() & Qt::LeftButton)) { return; } if ((event->pos() - m_dragStartPosition).manhattanLength() < QGuiApplication::styleHints()->startDragDistance()) { return; } setCursor(Qt::OpenHandCursor); emit dragInitiated(); } // resize handler void ImageLabel::resizeEvent(QResizeEvent* event) { Q_UNUSED(event) setScaledPixmap(); }","title":"File imagelabel.cpp"},{"location":"flameshot/imagelabel_8h/","text":"File imagelabel.h # FileList > src > widgets > imagelabel.h Go to the source code of this file. #include <QColor> #include <QGraphicsDropShadowEffect> #include <QGuiApplication> #include <QLabel> #include <QMouseEvent> #include <QPixmap> #include <QPoint> #include <QStyleHints> Classes # Type Name class ImageLabel","title":"File imagelabel.h"},{"location":"flameshot/imagelabel_8h/#file-imagelabelh","text":"FileList > src > widgets > imagelabel.h Go to the source code of this file. #include <QColor> #include <QGraphicsDropShadowEffect> #include <QGuiApplication> #include <QLabel> #include <QMouseEvent> #include <QPixmap> #include <QPoint> #include <QStyleHints>","title":"File imagelabel.h"},{"location":"flameshot/imagelabel_8h/#classes","text":"Type Name class ImageLabel","title":"Classes"},{"location":"flameshot/imagelabel_8h_source/","text":"File imagelabel.h # File List > src > widgets > imagelabel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // This code is a modified version of the KDE software Spectacle // /src/Gui/KSImageWidget.h commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9 #pragma once #include <QColor> #include <QGraphicsDropShadowEffect> #include <QGuiApplication> #include <QLabel> #include <QMouseEvent> #include <QPixmap> #include <QPoint> #include <QStyleHints> class ImageLabel : public QLabel { Q_OBJECT public: explicit ImageLabel(QWidget* parent = nullptr); void setScreenshot(const QPixmap& pixmap); signals: void dragInitiated(); protected: void mousePressEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void mouseReleaseEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void mouseMoveEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void resizeEvent(QResizeEvent* event) Q_DECL_OVERRIDE; private: void setScaledPixmap(); QGraphicsDropShadowEffect* m_DSEffect; QPixmap m_pixmap; QPoint m_dragStartPosition; };","title":"File imagelabel.h"},{"location":"flameshot/imagelabel_8h_source/#file-imagelabelh","text":"File List > src > widgets > imagelabel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // This code is a modified version of the KDE software Spectacle // /src/Gui/KSImageWidget.h commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9 #pragma once #include <QColor> #include <QGraphicsDropShadowEffect> #include <QGuiApplication> #include <QLabel> #include <QMouseEvent> #include <QPixmap> #include <QPoint> #include <QStyleHints> class ImageLabel : public QLabel { Q_OBJECT public: explicit ImageLabel(QWidget* parent = nullptr); void setScreenshot(const QPixmap& pixmap); signals: void dragInitiated(); protected: void mousePressEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void mouseReleaseEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void mouseMoveEvent(QMouseEvent* event) Q_DECL_OVERRIDE; void resizeEvent(QResizeEvent* event) Q_DECL_OVERRIDE; private: void setScaledPixmap(); QGraphicsDropShadowEffect* m_DSEffect; QPixmap m_pixmap; QPoint m_dragStartPosition; };","title":"File imagelabel.h"},{"location":"flameshot/imguploaddialog_8cpp/","text":"File imguploaddialog.cpp # FileList > src > widgets > imguploaddialog.cpp Go to the source code of this file. #include \"imguploaddialog.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QCheckBox> #include <QDialogButtonBox> #include <QLabel> #include <QVBoxLayout>","title":"File imguploaddialog.cpp"},{"location":"flameshot/imguploaddialog_8cpp/#file-imguploaddialogcpp","text":"FileList > src > widgets > imguploaddialog.cpp Go to the source code of this file. #include \"imguploaddialog.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QCheckBox> #include <QDialogButtonBox> #include <QLabel> #include <QVBoxLayout>","title":"File imguploaddialog.cpp"},{"location":"flameshot/imguploaddialog_8cpp_source/","text":"File imguploaddialog.cpp # File List > src > widgets > imguploaddialog.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploaddialog.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QCheckBox> #include <QDialogButtonBox> #include <QLabel> #include <QVBoxLayout> ImgUploadDialog::ImgUploadDialog(QDialog* parent) : QDialog(parent) { setAttribute(Qt::WA_DeleteOnClose); setMinimumSize(400, 120); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Upload Confirmation\")); layout = new QVBoxLayout(this); m_uploadLabel = new QLabel(tr(\"Do you want to upload this capture?\"), this); layout->addWidget(m_uploadLabel); buttonBox = new QDialogButtonBox(QDialogButtonBox::Yes | QDialogButtonBox::No); connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept); connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject); layout->addWidget(buttonBox); m_uploadWithoutConfirmation = new QCheckBox(tr(\"Upload without confirmation\"), this); m_uploadWithoutConfirmation->setToolTip(tr(\"Upload without confirmation\")); connect(m_uploadWithoutConfirmation, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setUploadWithoutConfirmation(checked); }); layout->addWidget(m_uploadWithoutConfirmation); }","title":"File imguploaddialog.cpp"},{"location":"flameshot/imguploaddialog_8cpp_source/#file-imguploaddialogcpp","text":"File List > src > widgets > imguploaddialog.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"imguploaddialog.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/globalvalues.h\" #include <QCheckBox> #include <QDialogButtonBox> #include <QLabel> #include <QVBoxLayout> ImgUploadDialog::ImgUploadDialog(QDialog* parent) : QDialog(parent) { setAttribute(Qt::WA_DeleteOnClose); setMinimumSize(400, 120); setWindowIcon(QIcon(GlobalValues::iconPath())); setWindowTitle(tr(\"Upload Confirmation\")); layout = new QVBoxLayout(this); m_uploadLabel = new QLabel(tr(\"Do you want to upload this capture?\"), this); layout->addWidget(m_uploadLabel); buttonBox = new QDialogButtonBox(QDialogButtonBox::Yes | QDialogButtonBox::No); connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept); connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject); layout->addWidget(buttonBox); m_uploadWithoutConfirmation = new QCheckBox(tr(\"Upload without confirmation\"), this); m_uploadWithoutConfirmation->setToolTip(tr(\"Upload without confirmation\")); connect(m_uploadWithoutConfirmation, &QCheckBox::clicked, [](bool checked) { ConfigHandler().setUploadWithoutConfirmation(checked); }); layout->addWidget(m_uploadWithoutConfirmation); }","title":"File imguploaddialog.cpp"},{"location":"flameshot/imguploaddialog_8h/","text":"File imguploaddialog.h # FileList > src > widgets > imguploaddialog.h Go to the source code of this file. #include <QDialog> Classes # Type Name class ImgUploadDialog","title":"File imguploaddialog.h"},{"location":"flameshot/imguploaddialog_8h/#file-imguploaddialogh","text":"FileList > src > widgets > imguploaddialog.h Go to the source code of this file. #include <QDialog>","title":"File imguploaddialog.h"},{"location":"flameshot/imguploaddialog_8h/#classes","text":"Type Name class ImgUploadDialog","title":"Classes"},{"location":"flameshot/imguploaddialog_8h_source/","text":"File imguploaddialog.h # File List > src > widgets > imguploaddialog.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QDialog> class QCheckBox; class QLabel; class QDialogButtonBox; class QVBoxLayout; class ImgUploadDialog : public QDialog { Q_OBJECT public: explicit ImgUploadDialog(QDialog* parent = nullptr); private: QCheckBox* m_uploadWithoutConfirmation; QLabel* m_uploadLabel; QDialogButtonBox* buttonBox; QVBoxLayout* layout; };","title":"File imguploaddialog.h"},{"location":"flameshot/imguploaddialog_8h_source/#file-imguploaddialogh","text":"File List > src > widgets > imguploaddialog.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QDialog> class QCheckBox; class QLabel; class QDialogButtonBox; class QVBoxLayout; class ImgUploadDialog : public QDialog { Q_OBJECT public: explicit ImgUploadDialog(QDialog* parent = nullptr); private: QCheckBox* m_uploadWithoutConfirmation; QLabel* m_uploadLabel; QDialogButtonBox* buttonBox; QVBoxLayout* layout; };","title":"File imguploaddialog.h"},{"location":"flameshot/infowindow_8cpp/","text":"File infowindow.cpp # FileList > src > widgets > infowindow.cpp Go to the source code of this file. #include \"infowindow.h\" #include \"./ui_infowindow.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include <QKeyEvent> #include <QScreen> Public Functions # Type Name QString generateKernelString () Public Functions Documentation # function generateKernelString # QString generateKernelString ()","title":"File infowindow.cpp"},{"location":"flameshot/infowindow_8cpp/#file-infowindowcpp","text":"FileList > src > widgets > infowindow.cpp Go to the source code of this file. #include \"infowindow.h\" #include \"./ui_infowindow.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include <QKeyEvent> #include <QScreen>","title":"File infowindow.cpp"},{"location":"flameshot/infowindow_8cpp/#public-functions","text":"Type Name QString generateKernelString ()","title":"Public Functions"},{"location":"flameshot/infowindow_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/infowindow_8cpp/#function-generatekernelstring","text":"QString generateKernelString ()","title":"function generateKernelString"},{"location":"flameshot/infowindow_8cpp_source/","text":"File infowindow.cpp # File List > src > widgets > infowindow.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman & Contributors #include \"infowindow.h\" #include \"./ui_infowindow.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include <QKeyEvent> #include <QScreen> InfoWindow::InfoWindow(QWidget* parent) : QWidget(parent) , ui(new Ui::InfoWindow) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); ui->IconSVG->setPixmap(QPixmap(GlobalValues::iconPath())); ui->VersionDetails->setText(GlobalValues::versionInfo()); ui->OperatingSystemDetails->setText(generateKernelString()); #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) QRect position = frameGeometry(); QScreen* screen = QGuiAppCurrentScreen().currentScreen(); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); #endif show(); } InfoWindow::~InfoWindow() { delete ui; } void InfoWindow::keyPressEvent(QKeyEvent* event) { if (event->key() == Qt::Key_Escape) { close(); } } QString generateKernelString() { QString kernelVersion = QSysInfo::kernelType() + \": \" + QSysInfo::kernelVersion() + \"\\n\" + QSysInfo::productType() + \": \" + QSysInfo::productVersion(); return kernelVersion; } void InfoWindow::on_CopyInfoButton_clicked() { FlameshotDaemon::copyToClipboard(GlobalValues::versionInfo() + \"\\n\" + generateKernelString()); }","title":"File infowindow.cpp"},{"location":"flameshot/infowindow_8cpp_source/#file-infowindowcpp","text":"File List > src > widgets > infowindow.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman & Contributors #include \"infowindow.h\" #include \"./ui_infowindow.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/globalvalues.h\" #include <QKeyEvent> #include <QScreen> InfoWindow::InfoWindow(QWidget* parent) : QWidget(parent) , ui(new Ui::InfoWindow) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); ui->IconSVG->setPixmap(QPixmap(GlobalValues::iconPath())); ui->VersionDetails->setText(GlobalValues::versionInfo()); ui->OperatingSystemDetails->setText(generateKernelString()); #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)) QRect position = frameGeometry(); QScreen* screen = QGuiAppCurrentScreen().currentScreen(); position.moveCenter(screen->availableGeometry().center()); move(position.topLeft()); #endif show(); } InfoWindow::~InfoWindow() { delete ui; } void InfoWindow::keyPressEvent(QKeyEvent* event) { if (event->key() == Qt::Key_Escape) { close(); } } QString generateKernelString() { QString kernelVersion = QSysInfo::kernelType() + \": \" + QSysInfo::kernelVersion() + \"\\n\" + QSysInfo::productType() + \": \" + QSysInfo::productVersion(); return kernelVersion; } void InfoWindow::on_CopyInfoButton_clicked() { FlameshotDaemon::copyToClipboard(GlobalValues::versionInfo() + \"\\n\" + generateKernelString()); }","title":"File infowindow.cpp"},{"location":"flameshot/infowindow_8h/","text":"File infowindow.h # FileList > src > widgets > infowindow.h Go to the source code of this file. #include <QWidget> Namespaces # Type Name namespace Ui Classes # Type Name class InfoWindow Public Functions # Type Name QString generateKernelString () Public Functions Documentation # function generateKernelString # QString generateKernelString ()","title":"File infowindow.h"},{"location":"flameshot/infowindow_8h/#file-infowindowh","text":"FileList > src > widgets > infowindow.h Go to the source code of this file. #include <QWidget>","title":"File infowindow.h"},{"location":"flameshot/infowindow_8h/#namespaces","text":"Type Name namespace Ui","title":"Namespaces"},{"location":"flameshot/infowindow_8h/#classes","text":"Type Name class InfoWindow","title":"Classes"},{"location":"flameshot/infowindow_8h/#public-functions","text":"Type Name QString generateKernelString ()","title":"Public Functions"},{"location":"flameshot/infowindow_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/infowindow_8h/#function-generatekernelstring","text":"QString generateKernelString ()","title":"function generateKernelString"},{"location":"flameshot/infowindow_8h_source/","text":"File infowindow.h # File List > src > widgets > infowindow.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman & Contributors #pragma once #include <QWidget> QT_BEGIN_NAMESPACE namespace Ui { class InfoWindow; } QT_END_NAMESPACE class InfoWindow : public QWidget { Q_OBJECT public: explicit InfoWindow(QWidget* parent = nullptr); ~InfoWindow(); private: Ui::InfoWindow* ui; protected: void keyPressEvent(QKeyEvent* event); private slots: void on_CopyInfoButton_clicked(); }; QString generateKernelString();","title":"File infowindow.h"},{"location":"flameshot/infowindow_8h_source/#file-infowindowh","text":"File List > src > widgets > infowindow.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman & Contributors #pragma once #include <QWidget> QT_BEGIN_NAMESPACE namespace Ui { class InfoWindow; } QT_END_NAMESPACE class InfoWindow : public QWidget { Q_OBJECT public: explicit InfoWindow(QWidget* parent = nullptr); ~InfoWindow(); private: Ui::InfoWindow* ui; protected: void keyPressEvent(QKeyEvent* event); private slots: void on_CopyInfoButton_clicked(); }; QString generateKernelString();","title":"File infowindow.h"},{"location":"flameshot/loadspinner_8cpp/","text":"File loadspinner.cpp # FileList > src > widgets > loadspinner.cpp Go to the source code of this file. #include \"loadspinner.h\" #include <QApplication> #include <QPaintEvent> #include <QPainter> #include <QTimer> Macros # Type Name define OFFSET 5 Macro Definition Documentation # define OFFSET # #define OFFSET 5","title":"File loadspinner.cpp"},{"location":"flameshot/loadspinner_8cpp/#file-loadspinnercpp","text":"FileList > src > widgets > loadspinner.cpp Go to the source code of this file. #include \"loadspinner.h\" #include <QApplication> #include <QPaintEvent> #include <QPainter> #include <QTimer>","title":"File loadspinner.cpp"},{"location":"flameshot/loadspinner_8cpp/#macros","text":"Type Name define OFFSET 5","title":"Macros"},{"location":"flameshot/loadspinner_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/loadspinner_8cpp/#define-offset","text":"#define OFFSET 5","title":"define OFFSET"},{"location":"flameshot/loadspinner_8cpp_source/","text":"File loadspinner.cpp # File List > src > widgets > loadspinner.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"loadspinner.h\" #include <QApplication> #include <QPaintEvent> #include <QPainter> #include <QTimer> #define OFFSET 5 LoadSpinner::LoadSpinner(QWidget* parent) : QWidget(parent) , m_span(0) , m_growing(true) { setAttribute(Qt::WA_TranslucentBackground); const int size = QApplication::fontMetrics().height() * 8; setFixedSize(size, size); updateFrame(); // init timer m_timer = new QTimer(this); connect(m_timer, &QTimer::timeout, this, &LoadSpinner::rotate); m_timer->setInterval(30); } void LoadSpinner::setColor(const QColor& c) { m_color = c; } void LoadSpinner::setWidth(int w) { setFixedSize(w, w); updateFrame(); } void LoadSpinner::setHeight(int h) { setFixedSize(h, h); updateFrame(); } void LoadSpinner::start() { m_timer->start(); } void LoadSpinner::stop() { m_timer->stop(); } void LoadSpinner::paintEvent(QPaintEvent*) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing, true); auto pen = QPen(m_color); pen.setWidth(height() / 10); painter.setPen(pen); painter.setOpacity(0.2); painter.drawArc(m_frame, 0, 5760); painter.setOpacity(1.0); painter.drawArc(m_frame, (m_startAngle * 16), (m_span * 16)); } void LoadSpinner::rotate() { const int advance = 3; const int grow = 8; if (m_growing) { m_startAngle = (m_startAngle + advance) % 360; m_span += grow; if (m_span > 260) { m_growing = false; } } else { m_startAngle = (m_startAngle + grow) % 360; m_span = m_span + advance - grow; if (m_span < 10) { m_growing = true; } } update(); } void LoadSpinner::updateFrame() { m_frame = QRect(OFFSET, OFFSET, width() - OFFSET * 2, height() - OFFSET * 2); }","title":"File loadspinner.cpp"},{"location":"flameshot/loadspinner_8cpp_source/#file-loadspinnercpp","text":"File List > src > widgets > loadspinner.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"loadspinner.h\" #include <QApplication> #include <QPaintEvent> #include <QPainter> #include <QTimer> #define OFFSET 5 LoadSpinner::LoadSpinner(QWidget* parent) : QWidget(parent) , m_span(0) , m_growing(true) { setAttribute(Qt::WA_TranslucentBackground); const int size = QApplication::fontMetrics().height() * 8; setFixedSize(size, size); updateFrame(); // init timer m_timer = new QTimer(this); connect(m_timer, &QTimer::timeout, this, &LoadSpinner::rotate); m_timer->setInterval(30); } void LoadSpinner::setColor(const QColor& c) { m_color = c; } void LoadSpinner::setWidth(int w) { setFixedSize(w, w); updateFrame(); } void LoadSpinner::setHeight(int h) { setFixedSize(h, h); updateFrame(); } void LoadSpinner::start() { m_timer->start(); } void LoadSpinner::stop() { m_timer->stop(); } void LoadSpinner::paintEvent(QPaintEvent*) { QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing, true); auto pen = QPen(m_color); pen.setWidth(height() / 10); painter.setPen(pen); painter.setOpacity(0.2); painter.drawArc(m_frame, 0, 5760); painter.setOpacity(1.0); painter.drawArc(m_frame, (m_startAngle * 16), (m_span * 16)); } void LoadSpinner::rotate() { const int advance = 3; const int grow = 8; if (m_growing) { m_startAngle = (m_startAngle + advance) % 360; m_span += grow; if (m_span > 260) { m_growing = false; } } else { m_startAngle = (m_startAngle + grow) % 360; m_span = m_span + advance - grow; if (m_span < 10) { m_growing = true; } } update(); } void LoadSpinner::updateFrame() { m_frame = QRect(OFFSET, OFFSET, width() - OFFSET * 2, height() - OFFSET * 2); }","title":"File loadspinner.cpp"},{"location":"flameshot/loadspinner_8h/","text":"File loadspinner.h # FileList > src > widgets > loadspinner.h Go to the source code of this file. #include <QWidget> Classes # Type Name class LoadSpinner","title":"File loadspinner.h"},{"location":"flameshot/loadspinner_8h/#file-loadspinnerh","text":"FileList > src > widgets > loadspinner.h Go to the source code of this file. #include <QWidget>","title":"File loadspinner.h"},{"location":"flameshot/loadspinner_8h/#classes","text":"Type Name class LoadSpinner","title":"Classes"},{"location":"flameshot/loadspinner_8h_source/","text":"File loadspinner.h # File List > src > widgets > loadspinner.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class LoadSpinner : public QWidget { Q_OBJECT public: explicit LoadSpinner(QWidget* parent = nullptr); void setColor(const QColor& c); void setWidth(int w); void setHeight(int h); void start(); void stop(); protected: void paintEvent(QPaintEvent*); private slots: void rotate(); private: QColor m_color; QTimer* m_timer; int m_startAngle = 0; int m_span = 180; bool m_growing; QRect m_frame; void updateFrame(); };","title":"File loadspinner.h"},{"location":"flameshot/loadspinner_8h_source/#file-loadspinnerh","text":"File List > src > widgets > loadspinner.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class LoadSpinner : public QWidget { Q_OBJECT public: explicit LoadSpinner(QWidget* parent = nullptr); void setColor(const QColor& c); void setWidth(int w); void setHeight(int h); void start(); void stop(); protected: void paintEvent(QPaintEvent*); private slots: void rotate(); private: QColor m_color; QTimer* m_timer; int m_startAngle = 0; int m_span = 180; bool m_growing; QRect m_frame; void updateFrame(); };","title":"File loadspinner.h"},{"location":"flameshot/notificationwidget_8cpp/","text":"File notificationwidget.cpp # FileList > src > widgets > notificationwidget.cpp Go to the source code of this file. #include \"notificationwidget.h\" #include <QFrame> #include <QIcon> #include <QLabel> #include <QPropertyAnimation> #include <QTimer> #include <QVBoxLayout>","title":"File notificationwidget.cpp"},{"location":"flameshot/notificationwidget_8cpp/#file-notificationwidgetcpp","text":"FileList > src > widgets > notificationwidget.cpp Go to the source code of this file. #include \"notificationwidget.h\" #include <QFrame> #include <QIcon> #include <QLabel> #include <QPropertyAnimation> #include <QTimer> #include <QVBoxLayout>","title":"File notificationwidget.cpp"},{"location":"flameshot/notificationwidget_8cpp_source/","text":"File notificationwidget.cpp # File List > src > widgets > notificationwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"notificationwidget.h\" #include <QFrame> #include <QIcon> #include <QLabel> #include <QPropertyAnimation> #include <QTimer> #include <QVBoxLayout> NotificationWidget::NotificationWidget(QWidget* parent) : QWidget(parent) { m_timer = new QTimer(this); m_timer->setSingleShot(true); m_timer->setInterval(7000); connect(m_timer, &QTimer::timeout, this, &NotificationWidget::animatedHide); m_content = new QFrame(); m_layout = new QVBoxLayout(); m_label = new QLabel(m_content); m_label->hide(); m_showAnimation = new QPropertyAnimation(m_content, \"geometry\", this); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_content, \"geometry\", this); m_hideAnimation->setDuration(300); connect( m_hideAnimation, &QPropertyAnimation::finished, m_label, &QLabel::hide); auto* mainLayout = new QVBoxLayout(); setLayout(mainLayout); mainLayout->addWidget(m_content); m_layout->addWidget(m_label, 0, Qt::AlignHCenter); m_content->setLayout(m_layout); setFixedHeight(40); } void NotificationWidget::showMessage(const QString& msg) { m_label->setText(msg); m_label->show(); animatedShow(); } void NotificationWidget::animatedShow() { m_showAnimation->setStartValue(QRect(0, 0, width(), 0)); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_showAnimation->start(); m_timer->start(); } void NotificationWidget::animatedHide() { m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(0, 0, width(), 0)); m_hideAnimation->start(); }","title":"File notificationwidget.cpp"},{"location":"flameshot/notificationwidget_8cpp_source/#file-notificationwidgetcpp","text":"File List > src > widgets > notificationwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"notificationwidget.h\" #include <QFrame> #include <QIcon> #include <QLabel> #include <QPropertyAnimation> #include <QTimer> #include <QVBoxLayout> NotificationWidget::NotificationWidget(QWidget* parent) : QWidget(parent) { m_timer = new QTimer(this); m_timer->setSingleShot(true); m_timer->setInterval(7000); connect(m_timer, &QTimer::timeout, this, &NotificationWidget::animatedHide); m_content = new QFrame(); m_layout = new QVBoxLayout(); m_label = new QLabel(m_content); m_label->hide(); m_showAnimation = new QPropertyAnimation(m_content, \"geometry\", this); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_content, \"geometry\", this); m_hideAnimation->setDuration(300); connect( m_hideAnimation, &QPropertyAnimation::finished, m_label, &QLabel::hide); auto* mainLayout = new QVBoxLayout(); setLayout(mainLayout); mainLayout->addWidget(m_content); m_layout->addWidget(m_label, 0, Qt::AlignHCenter); m_content->setLayout(m_layout); setFixedHeight(40); } void NotificationWidget::showMessage(const QString& msg) { m_label->setText(msg); m_label->show(); animatedShow(); } void NotificationWidget::animatedShow() { m_showAnimation->setStartValue(QRect(0, 0, width(), 0)); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_showAnimation->start(); m_timer->start(); } void NotificationWidget::animatedHide() { m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(0, 0, width(), 0)); m_hideAnimation->start(); }","title":"File notificationwidget.cpp"},{"location":"flameshot/notificationwidget_8h/","text":"File notificationwidget.h # FileList > src > widgets > notificationwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class NotificationWidget","title":"File notificationwidget.h"},{"location":"flameshot/notificationwidget_8h/#file-notificationwidgeth","text":"FileList > src > widgets > notificationwidget.h Go to the source code of this file. #include <QWidget>","title":"File notificationwidget.h"},{"location":"flameshot/notificationwidget_8h/#classes","text":"Type Name class NotificationWidget","title":"Classes"},{"location":"flameshot/notificationwidget_8h_source/","text":"File notificationwidget.h # File List > src > widgets > notificationwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QLabel; class QTimer; class QPropertyAnimation; class QVBoxLayout; class QFrame; class NotificationWidget : public QWidget { Q_OBJECT public: explicit NotificationWidget(QWidget* parent = nullptr); void showMessage(const QString& msg); private: QLabel* m_label; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; QVBoxLayout* m_layout; QFrame* m_content; QTimer* m_timer; void animatedShow(); void animatedHide(); };","title":"File notificationwidget.h"},{"location":"flameshot/notificationwidget_8h_source/#file-notificationwidgeth","text":"File List > src > widgets > notificationwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include <QWidget> class QLabel; class QTimer; class QPropertyAnimation; class QVBoxLayout; class QFrame; class NotificationWidget : public QWidget { Q_OBJECT public: explicit NotificationWidget(QWidget* parent = nullptr); void showMessage(const QString& msg); private: QLabel* m_label; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; QVBoxLayout* m_layout; QFrame* m_content; QTimer* m_timer; void animatedShow(); void animatedHide(); };","title":"File notificationwidget.h"},{"location":"flameshot/orientablepushbutton_8cpp/","text":"File orientablepushbutton.cpp # FileList > src > widgets > orientablepushbutton.cpp Go to the source code of this file. #include \"orientablepushbutton.h\" #include <QPainter> #include <QStyleOptionButton> #include <QStylePainter>","title":"File orientablepushbutton.cpp"},{"location":"flameshot/orientablepushbutton_8cpp/#file-orientablepushbuttoncpp","text":"FileList > src > widgets > orientablepushbutton.cpp Go to the source code of this file. #include \"orientablepushbutton.h\" #include <QPainter> #include <QStyleOptionButton> #include <QStylePainter>","title":"File orientablepushbutton.cpp"},{"location":"flameshot/orientablepushbutton_8cpp_source/","text":"File orientablepushbutton.cpp # File List > src > widgets > orientablepushbutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on https://stackoverflow.com/a/53135675/964478 #include \"orientablepushbutton.h\" #include <QPainter> #include <QStyleOptionButton> #include <QStylePainter> OrientablePushButton::OrientablePushButton(QWidget* parent) : CaptureButton(parent) {} OrientablePushButton::OrientablePushButton(const QString& text, QWidget* parent) : CaptureButton(text, parent) {} OrientablePushButton::OrientablePushButton(const QIcon& icon, const QString& text, QWidget* parent) : CaptureButton(icon, text, parent) {} QSize OrientablePushButton::sizeHint() const { QSize sh = QPushButton::sizeHint(); if (m_orientation != OrientablePushButton::Horizontal) { sh.transpose(); } return sh; } void OrientablePushButton::paintEvent(QPaintEvent* event) { Q_UNUSED(event) QStylePainter painter(this); QStyleOptionButton option; initStyleOption(&option); if (m_orientation == OrientablePushButton::VerticalTopToBottom) { painter.rotate(90); painter.translate(0, -1 * width()); option.rect = option.rect.transposed(); } else if (m_orientation == OrientablePushButton::VerticalBottomToTop) { painter.rotate(-90); painter.translate(-1 * height(), 0); option.rect = option.rect.transposed(); } painter.drawControl(QStyle::CE_PushButton, option); } OrientablePushButton::Orientation OrientablePushButton::orientation() const { return m_orientation; } void OrientablePushButton::setOrientation( const OrientablePushButton::Orientation& orientation) { m_orientation = orientation; }","title":"File orientablepushbutton.cpp"},{"location":"flameshot/orientablepushbutton_8cpp_source/#file-orientablepushbuttoncpp","text":"File List > src > widgets > orientablepushbutton.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on https://stackoverflow.com/a/53135675/964478 #include \"orientablepushbutton.h\" #include <QPainter> #include <QStyleOptionButton> #include <QStylePainter> OrientablePushButton::OrientablePushButton(QWidget* parent) : CaptureButton(parent) {} OrientablePushButton::OrientablePushButton(const QString& text, QWidget* parent) : CaptureButton(text, parent) {} OrientablePushButton::OrientablePushButton(const QIcon& icon, const QString& text, QWidget* parent) : CaptureButton(icon, text, parent) {} QSize OrientablePushButton::sizeHint() const { QSize sh = QPushButton::sizeHint(); if (m_orientation != OrientablePushButton::Horizontal) { sh.transpose(); } return sh; } void OrientablePushButton::paintEvent(QPaintEvent* event) { Q_UNUSED(event) QStylePainter painter(this); QStyleOptionButton option; initStyleOption(&option); if (m_orientation == OrientablePushButton::VerticalTopToBottom) { painter.rotate(90); painter.translate(0, -1 * width()); option.rect = option.rect.transposed(); } else if (m_orientation == OrientablePushButton::VerticalBottomToTop) { painter.rotate(-90); painter.translate(-1 * height(), 0); option.rect = option.rect.transposed(); } painter.drawControl(QStyle::CE_PushButton, option); } OrientablePushButton::Orientation OrientablePushButton::orientation() const { return m_orientation; } void OrientablePushButton::setOrientation( const OrientablePushButton::Orientation& orientation) { m_orientation = orientation; }","title":"File orientablepushbutton.cpp"},{"location":"flameshot/orientablepushbutton_8h/","text":"File orientablepushbutton.h # FileList > src > widgets > orientablepushbutton.h Go to the source code of this file. #include \"capture/capturebutton.h\" #include <QPushButton> Classes # Type Name class OrientablePushButton","title":"File orientablepushbutton.h"},{"location":"flameshot/orientablepushbutton_8h/#file-orientablepushbuttonh","text":"FileList > src > widgets > orientablepushbutton.h Go to the source code of this file. #include \"capture/capturebutton.h\" #include <QPushButton>","title":"File orientablepushbutton.h"},{"location":"flameshot/orientablepushbutton_8h/#classes","text":"Type Name class OrientablePushButton","title":"Classes"},{"location":"flameshot/orientablepushbutton_8h_source/","text":"File orientablepushbutton.h # File List > src > widgets > orientablepushbutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on https://stackoverflow.com/a/53135675/964478 #pragma once #include \"capture/capturebutton.h\" #include <QPushButton> class OrientablePushButton : public CaptureButton { Q_OBJECT public: enum Orientation { Horizontal, VerticalTopToBottom, VerticalBottomToTop }; OrientablePushButton(QWidget* parent = nullptr); OrientablePushButton(const QString& text, QWidget* parent = nullptr); OrientablePushButton(const QIcon& icon, const QString& text, QWidget* parent = nullptr); QSize sizeHint() const; OrientablePushButton::Orientation orientation() const; void setOrientation(const OrientablePushButton::Orientation& orientation); protected: void paintEvent(QPaintEvent* event); private: Orientation m_orientation = Horizontal; };","title":"File orientablepushbutton.h"},{"location":"flameshot/orientablepushbutton_8h_source/#file-orientablepushbuttonh","text":"File List > src > widgets > orientablepushbutton.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors // Based on https://stackoverflow.com/a/53135675/964478 #pragma once #include \"capture/capturebutton.h\" #include <QPushButton> class OrientablePushButton : public CaptureButton { Q_OBJECT public: enum Orientation { Horizontal, VerticalTopToBottom, VerticalBottomToTop }; OrientablePushButton(QWidget* parent = nullptr); OrientablePushButton(const QString& text, QWidget* parent = nullptr); OrientablePushButton(const QIcon& icon, const QString& text, QWidget* parent = nullptr); QSize sizeHint() const; OrientablePushButton::Orientation orientation() const; void setOrientation(const OrientablePushButton::Orientation& orientation); protected: void paintEvent(QPaintEvent* event); private: Orientation m_orientation = Horizontal; };","title":"File orientablepushbutton.h"},{"location":"flameshot/dir_e79db7da44a022b7c1e2f0b610359347/","text":"Dir panel # FileList > panel Files # Type Name file colorgrabwidget.cpp file colorgrabwidget.h file sidepanelwidget.cpp file sidepanelwidget.h file utilitypanel.cpp file utilitypanel.h","title":"Dir panel"},{"location":"flameshot/dir_e79db7da44a022b7c1e2f0b610359347/#dir-panel","text":"FileList > panel","title":"Dir panel"},{"location":"flameshot/dir_e79db7da44a022b7c1e2f0b610359347/#files","text":"Type Name file colorgrabwidget.cpp file colorgrabwidget.h file sidepanelwidget.cpp file sidepanelwidget.h file utilitypanel.cpp file utilitypanel.h","title":"Files"},{"location":"flameshot/colorgrabwidget_8cpp/","text":"File colorgrabwidget.cpp # FileList > panel > colorgrabwidget.cpp Go to the source code of this file. #include \"colorgrabwidget.h\" #include \"sidepanelwidget.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include \"overlaymessage.h\" #include \"src/core/qguiappcurrentscreen.h\" #include <QApplication> #include <QDebug> #include <QKeyEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <QTimer> #include <stdexcept> Macros # Type Name define WIDTH1 77 define WIDTH2 165 define ZOOM1 11 define ZOOM2 15 Macro Definition Documentation # define WIDTH1 # #define WIDTH1 77 define WIDTH2 # #define WIDTH2 165 define ZOOM1 # #define ZOOM1 11 define ZOOM2 # #define ZOOM2 15","title":"File colorgrabwidget.cpp"},{"location":"flameshot/colorgrabwidget_8cpp/#file-colorgrabwidgetcpp","text":"FileList > panel > colorgrabwidget.cpp Go to the source code of this file. #include \"colorgrabwidget.h\" #include \"sidepanelwidget.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include \"overlaymessage.h\" #include \"src/core/qguiappcurrentscreen.h\" #include <QApplication> #include <QDebug> #include <QKeyEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <QTimer> #include <stdexcept>","title":"File colorgrabwidget.cpp"},{"location":"flameshot/colorgrabwidget_8cpp/#macros","text":"Type Name define WIDTH1 77 define WIDTH2 165 define ZOOM1 11 define ZOOM2 15","title":"Macros"},{"location":"flameshot/colorgrabwidget_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"flameshot/colorgrabwidget_8cpp/#define-width1","text":"#define WIDTH1 77","title":"define WIDTH1"},{"location":"flameshot/colorgrabwidget_8cpp/#define-width2","text":"#define WIDTH2 165","title":"define WIDTH2"},{"location":"flameshot/colorgrabwidget_8cpp/#define-zoom1","text":"#define ZOOM1 11","title":"define ZOOM1"},{"location":"flameshot/colorgrabwidget_8cpp/#define-zoom2","text":"#define ZOOM2 15","title":"define ZOOM2"},{"location":"flameshot/colorgrabwidget_8cpp_source/","text":"File colorgrabwidget.cpp # File List > panel > colorgrabwidget.cpp Go to the documentation of this file. #include \"colorgrabwidget.h\" #include \"sidepanelwidget.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include \"overlaymessage.h\" #include \"src/core/qguiappcurrentscreen.h\" #include <QApplication> #include <QDebug> #include <QKeyEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <QTimer> #include <stdexcept> // Width (= height) and zoom level of the widget before the user clicks #define WIDTH1 77 #define ZOOM1 11 // Width (= height) and zoom level of the widget after the user clicks #define WIDTH2 165 #define ZOOM2 15 // NOTE: WIDTH1(2) should be divisible by ZOOM1(2) for best precision. // WIDTH1 should be odd so the cursor can be centered on a pixel. ColorGrabWidget::ColorGrabWidget(QPixmap* p, QWidget* parent) : QWidget(parent) , m_pixmap(p) , m_mousePressReceived(false) , m_extraZoomActive(false) , m_magnifierActive(false) { if (p == nullptr) { throw std::logic_error(\"Pixmap must not be null\"); } setAttribute(Qt::WA_DeleteOnClose); // We don't need this widget to receive mouse events because we use // eventFilter on other objects that do setAttribute(Qt::WA_TransparentForMouseEvents); setAttribute(Qt::WA_QuitOnClose, false); // On Windows: don't activate the widget so CaptureWidget remains active setAttribute(Qt::WA_ShowWithoutActivating); setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::WindowDoesNotAcceptFocus); setMouseTracking(true); } void ColorGrabWidget::startGrabbing() { // NOTE: grabMouse() would prevent move events being received // With this method we just need to make sure that mouse press and release // events get consumed before they reach their target widget. // This is undone in the destructor. qApp->setOverrideCursor(Qt::CrossCursor); qApp->installEventFilter(this); OverlayMessage::pushKeyMap( { { tr(\"Enter or Left Click\"), tr(\"Accept color\") }, { tr(\"Hold Left Click\"), tr(\"Precisely select color\") }, { tr(\"Space or Right Click\"), tr(\"Toggle magnifier\") }, { tr(\"Esc\"), tr(\"Cancel\") } }); } QColor ColorGrabWidget::color() { return m_color; } bool ColorGrabWidget::eventFilter(QObject*, QEvent* event) { // Consume shortcut events and handle key presses from whole app if (event->type() == QEvent::KeyPress || event->type() == QEvent::Shortcut) { QKeySequence key = event->type() == QEvent::KeyPress ? static_cast<QKeyEvent*>(event)->key() : static_cast<QShortcutEvent*>(event)->key(); if (key == Qt::Key_Escape) { emit grabAborted(); finalize(); } else if (key == Qt::Key_Return || key == Qt::Key_Enter) { emit colorGrabbed(m_color); finalize(); } else if (key == Qt::Key_Space && !m_extraZoomActive) { setMagnifierActive(!m_magnifierActive); } return true; } else if (event->type() == QEvent::MouseMove) { // NOTE: This relies on the fact that CaptureWidget tracks mouse moves if (m_extraZoomActive && !geometry().contains(cursorPos())) { setExtraZoomActive(false); return true; } if (!m_extraZoomActive && !m_magnifierActive) { // This fixes an issue when the mouse leaves the zoom area before // the widget even appears. hide(); } if (!m_extraZoomActive) { // Update only before the user clicks the mouse, after the mouse // press the widget remains static. updateWidget(); } // Hide overlay message when cursor is over it OverlayMessage* overlayMsg = OverlayMessage::instance(); overlayMsg->setVisibility( !overlayMsg->geometry().contains(cursorPos())); m_color = getColorAtPoint(cursorPos()); emit colorUpdated(m_color); return true; } else if (event->type() == QEvent::MouseButtonPress) { m_mousePressReceived = true; auto* e = static_cast<QMouseEvent*>(event); if (e->buttons() == Qt::RightButton) { setMagnifierActive(!m_magnifierActive); } else if (e->buttons() == Qt::LeftButton) { setExtraZoomActive(true); } return true; } else if (event->type() == QEvent::MouseButtonRelease) { if (!m_mousePressReceived) { // Do not consume event if it corresponds to the mouse press that // triggered the color grabbing in the first place. This prevents // focus issues in the capture widget when the color grabber is // closed. return false; } auto* e = static_cast<QMouseEvent*>(event); if (e->button() == Qt::LeftButton && m_extraZoomActive) { emit colorGrabbed(getColorAtPoint(cursorPos())); finalize(); } return true; } else if (event->type() == QEvent::MouseButtonDblClick) { return true; } return false; } void ColorGrabWidget::paintEvent(QPaintEvent*) { QPainter painter(this); painter.drawImage(QRectF(0, 0, width(), height()), m_previewImage); } void ColorGrabWidget::showEvent(QShowEvent*) { updateWidget(); } QPoint ColorGrabWidget::cursorPos() const { return QCursor::pos(QGuiAppCurrentScreen().currentScreen()); } QColor ColorGrabWidget::getColorAtPoint(const QPoint& p) const { if (m_extraZoomActive && geometry().contains(p)) { QPoint point = mapFromGlobal(p); // we divide coordinate-wise to avoid rounding to nearest return m_previewImage.pixel( QPoint(point.x() / ZOOM2, point.y() / ZOOM2)); } QPoint point = p; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { point = QPoint((p.x() - currentScreen->geometry().x()) * currentScreen->devicePixelRatio(), (p.y() - currentScreen->geometry().y()) * currentScreen->devicePixelRatio()); } #endif QPixmap pixel = m_pixmap->copy(QRect(point, point)); return pixel.toImage().pixel(0, 0); } void ColorGrabWidget::setExtraZoomActive(bool active) { m_extraZoomActive = active; if (!active && !m_magnifierActive) { hide(); } else { if (!isVisible()) { QTimer::singleShot(250, this, [this]() { show(); }); } else { QTimer::singleShot(250, this, [this]() { updateWidget(); }); } } } void ColorGrabWidget::setMagnifierActive(bool active) { m_magnifierActive = active; setVisible(active); } void ColorGrabWidget::updateWidget() { int width = m_extraZoomActive ? WIDTH2 : WIDTH1; float zoom = m_extraZoomActive ? ZOOM2 : ZOOM1; // Set window size and move its center to the mouse cursor QRect rect(0, 0, width, width); auto realCursorPos = cursorPos(); auto adjustedCursorPos = realCursorPos; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { adjustedCursorPos = QPoint((realCursorPos.x() - currentScreen->geometry().x()) * currentScreen->devicePixelRatio(), (realCursorPos.y() - currentScreen->geometry().y()) * currentScreen->devicePixelRatio()); } #endif rect.moveCenter(cursorPos()); setGeometry(rect); // Store a pixmap containing the zoomed-in section around the cursor QRect sourceRect(0, 0, width / zoom, width / zoom); sourceRect.moveCenter(adjustedCursorPos); m_previewImage = m_pixmap->copy(sourceRect).toImage(); // Repaint update(); } void ColorGrabWidget::finalize() { qApp->removeEventFilter(this); qApp->restoreOverrideCursor(); OverlayMessage::pop(); close(); }","title":"File colorgrabwidget.cpp"},{"location":"flameshot/colorgrabwidget_8cpp_source/#file-colorgrabwidgetcpp","text":"File List > panel > colorgrabwidget.cpp Go to the documentation of this file. #include \"colorgrabwidget.h\" #include \"sidepanelwidget.h\" #include \"colorutils.h\" #include \"confighandler.h\" #include \"overlaymessage.h\" #include \"src/core/qguiappcurrentscreen.h\" #include <QApplication> #include <QDebug> #include <QKeyEvent> #include <QPainter> #include <QScreen> #include <QShortcut> #include <QTimer> #include <stdexcept> // Width (= height) and zoom level of the widget before the user clicks #define WIDTH1 77 #define ZOOM1 11 // Width (= height) and zoom level of the widget after the user clicks #define WIDTH2 165 #define ZOOM2 15 // NOTE: WIDTH1(2) should be divisible by ZOOM1(2) for best precision. // WIDTH1 should be odd so the cursor can be centered on a pixel. ColorGrabWidget::ColorGrabWidget(QPixmap* p, QWidget* parent) : QWidget(parent) , m_pixmap(p) , m_mousePressReceived(false) , m_extraZoomActive(false) , m_magnifierActive(false) { if (p == nullptr) { throw std::logic_error(\"Pixmap must not be null\"); } setAttribute(Qt::WA_DeleteOnClose); // We don't need this widget to receive mouse events because we use // eventFilter on other objects that do setAttribute(Qt::WA_TransparentForMouseEvents); setAttribute(Qt::WA_QuitOnClose, false); // On Windows: don't activate the widget so CaptureWidget remains active setAttribute(Qt::WA_ShowWithoutActivating); setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::WindowDoesNotAcceptFocus); setMouseTracking(true); } void ColorGrabWidget::startGrabbing() { // NOTE: grabMouse() would prevent move events being received // With this method we just need to make sure that mouse press and release // events get consumed before they reach their target widget. // This is undone in the destructor. qApp->setOverrideCursor(Qt::CrossCursor); qApp->installEventFilter(this); OverlayMessage::pushKeyMap( { { tr(\"Enter or Left Click\"), tr(\"Accept color\") }, { tr(\"Hold Left Click\"), tr(\"Precisely select color\") }, { tr(\"Space or Right Click\"), tr(\"Toggle magnifier\") }, { tr(\"Esc\"), tr(\"Cancel\") } }); } QColor ColorGrabWidget::color() { return m_color; } bool ColorGrabWidget::eventFilter(QObject*, QEvent* event) { // Consume shortcut events and handle key presses from whole app if (event->type() == QEvent::KeyPress || event->type() == QEvent::Shortcut) { QKeySequence key = event->type() == QEvent::KeyPress ? static_cast<QKeyEvent*>(event)->key() : static_cast<QShortcutEvent*>(event)->key(); if (key == Qt::Key_Escape) { emit grabAborted(); finalize(); } else if (key == Qt::Key_Return || key == Qt::Key_Enter) { emit colorGrabbed(m_color); finalize(); } else if (key == Qt::Key_Space && !m_extraZoomActive) { setMagnifierActive(!m_magnifierActive); } return true; } else if (event->type() == QEvent::MouseMove) { // NOTE: This relies on the fact that CaptureWidget tracks mouse moves if (m_extraZoomActive && !geometry().contains(cursorPos())) { setExtraZoomActive(false); return true; } if (!m_extraZoomActive && !m_magnifierActive) { // This fixes an issue when the mouse leaves the zoom area before // the widget even appears. hide(); } if (!m_extraZoomActive) { // Update only before the user clicks the mouse, after the mouse // press the widget remains static. updateWidget(); } // Hide overlay message when cursor is over it OverlayMessage* overlayMsg = OverlayMessage::instance(); overlayMsg->setVisibility( !overlayMsg->geometry().contains(cursorPos())); m_color = getColorAtPoint(cursorPos()); emit colorUpdated(m_color); return true; } else if (event->type() == QEvent::MouseButtonPress) { m_mousePressReceived = true; auto* e = static_cast<QMouseEvent*>(event); if (e->buttons() == Qt::RightButton) { setMagnifierActive(!m_magnifierActive); } else if (e->buttons() == Qt::LeftButton) { setExtraZoomActive(true); } return true; } else if (event->type() == QEvent::MouseButtonRelease) { if (!m_mousePressReceived) { // Do not consume event if it corresponds to the mouse press that // triggered the color grabbing in the first place. This prevents // focus issues in the capture widget when the color grabber is // closed. return false; } auto* e = static_cast<QMouseEvent*>(event); if (e->button() == Qt::LeftButton && m_extraZoomActive) { emit colorGrabbed(getColorAtPoint(cursorPos())); finalize(); } return true; } else if (event->type() == QEvent::MouseButtonDblClick) { return true; } return false; } void ColorGrabWidget::paintEvent(QPaintEvent*) { QPainter painter(this); painter.drawImage(QRectF(0, 0, width(), height()), m_previewImage); } void ColorGrabWidget::showEvent(QShowEvent*) { updateWidget(); } QPoint ColorGrabWidget::cursorPos() const { return QCursor::pos(QGuiAppCurrentScreen().currentScreen()); } QColor ColorGrabWidget::getColorAtPoint(const QPoint& p) const { if (m_extraZoomActive && geometry().contains(p)) { QPoint point = mapFromGlobal(p); // we divide coordinate-wise to avoid rounding to nearest return m_previewImage.pixel( QPoint(point.x() / ZOOM2, point.y() / ZOOM2)); } QPoint point = p; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { point = QPoint((p.x() - currentScreen->geometry().x()) * currentScreen->devicePixelRatio(), (p.y() - currentScreen->geometry().y()) * currentScreen->devicePixelRatio()); } #endif QPixmap pixel = m_pixmap->copy(QRect(point, point)); return pixel.toImage().pixel(0, 0); } void ColorGrabWidget::setExtraZoomActive(bool active) { m_extraZoomActive = active; if (!active && !m_magnifierActive) { hide(); } else { if (!isVisible()) { QTimer::singleShot(250, this, [this]() { show(); }); } else { QTimer::singleShot(250, this, [this]() { updateWidget(); }); } } } void ColorGrabWidget::setMagnifierActive(bool active) { m_magnifierActive = active; setVisible(active); } void ColorGrabWidget::updateWidget() { int width = m_extraZoomActive ? WIDTH2 : WIDTH1; float zoom = m_extraZoomActive ? ZOOM2 : ZOOM1; // Set window size and move its center to the mouse cursor QRect rect(0, 0, width, width); auto realCursorPos = cursorPos(); auto adjustedCursorPos = realCursorPos; #if defined(Q_OS_MACOS) QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen(); if (currentScreen) { adjustedCursorPos = QPoint((realCursorPos.x() - currentScreen->geometry().x()) * currentScreen->devicePixelRatio(), (realCursorPos.y() - currentScreen->geometry().y()) * currentScreen->devicePixelRatio()); } #endif rect.moveCenter(cursorPos()); setGeometry(rect); // Store a pixmap containing the zoomed-in section around the cursor QRect sourceRect(0, 0, width / zoom, width / zoom); sourceRect.moveCenter(adjustedCursorPos); m_previewImage = m_pixmap->copy(sourceRect).toImage(); // Repaint update(); } void ColorGrabWidget::finalize() { qApp->removeEventFilter(this); qApp->restoreOverrideCursor(); OverlayMessage::pop(); close(); }","title":"File colorgrabwidget.cpp"},{"location":"flameshot/colorgrabwidget_8h/","text":"File colorgrabwidget.h # FileList > panel > colorgrabwidget.h Go to the source code of this file. #include <QWidget> Classes # Type Name class ColorGrabWidget","title":"File colorgrabwidget.h"},{"location":"flameshot/colorgrabwidget_8h/#file-colorgrabwidgeth","text":"FileList > panel > colorgrabwidget.h Go to the source code of this file. #include <QWidget>","title":"File colorgrabwidget.h"},{"location":"flameshot/colorgrabwidget_8h/#classes","text":"Type Name class ColorGrabWidget","title":"Classes"},{"location":"flameshot/colorgrabwidget_8h_source/","text":"File colorgrabwidget.h # File List > panel > colorgrabwidget.h Go to the documentation of this file. #ifndef COLORGRABWIDGET_H #define COLORGRABWIDGET_H #include <QWidget> class SidePanelWidget; class OverlayMessage; class ColorGrabWidget : public QWidget { Q_OBJECT public: ColorGrabWidget(QPixmap* p, QWidget* parent = nullptr); void startGrabbing(); QColor color(); signals: void colorUpdated(const QColor& color); void colorGrabbed(const QColor& color); void grabAborted(); private: bool eventFilter(QObject* obj, QEvent* event) override; void paintEvent(QPaintEvent* e) override; void showEvent(QShowEvent* event) override; QPoint cursorPos() const; QColor getColorAtPoint(const QPoint& point) const; void setExtraZoomActive(bool active); void setMagnifierActive(bool active); void updateWidget(); void finalize(); QPixmap* m_pixmap; QImage m_previewImage; QColor m_color; bool m_mousePressReceived; bool m_extraZoomActive; bool m_magnifierActive; }; #endif // COLORGRABWIDGET_H","title":"File colorgrabwidget.h"},{"location":"flameshot/colorgrabwidget_8h_source/#file-colorgrabwidgeth","text":"File List > panel > colorgrabwidget.h Go to the documentation of this file. #ifndef COLORGRABWIDGET_H #define COLORGRABWIDGET_H #include <QWidget> class SidePanelWidget; class OverlayMessage; class ColorGrabWidget : public QWidget { Q_OBJECT public: ColorGrabWidget(QPixmap* p, QWidget* parent = nullptr); void startGrabbing(); QColor color(); signals: void colorUpdated(const QColor& color); void colorGrabbed(const QColor& color); void grabAborted(); private: bool eventFilter(QObject* obj, QEvent* event) override; void paintEvent(QPaintEvent* e) override; void showEvent(QShowEvent* event) override; QPoint cursorPos() const; QColor getColorAtPoint(const QPoint& point) const; void setExtraZoomActive(bool active); void setMagnifierActive(bool active); void updateWidget(); void finalize(); QPixmap* m_pixmap; QImage m_previewImage; QColor m_color; bool m_mousePressReceived; bool m_extraZoomActive; bool m_magnifierActive; }; #endif // COLORGRABWIDGET_H","title":"File colorgrabwidget.h"},{"location":"flameshot/sidepanelwidget_8cpp/","text":"File sidepanelwidget.cpp # FileList > panel > sidepanelwidget.cpp Go to the source code of this file. #include \"sidepanelwidget.h\" #include \"colorgrabwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/pathinfo.h\" #include \"utilitypanel.h\" #include <QApplication> #include <QKeyEvent> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QShortcut> #include <QSlider> #include <QVBoxLayout>","title":"File sidepanelwidget.cpp"},{"location":"flameshot/sidepanelwidget_8cpp/#file-sidepanelwidgetcpp","text":"FileList > panel > sidepanelwidget.cpp Go to the source code of this file. #include \"sidepanelwidget.h\" #include \"colorgrabwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/pathinfo.h\" #include \"utilitypanel.h\" #include <QApplication> #include <QKeyEvent> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QShortcut> #include <QSlider> #include <QVBoxLayout>","title":"File sidepanelwidget.cpp"},{"location":"flameshot/sidepanelwidget_8cpp_source/","text":"File sidepanelwidget.cpp # File List > panel > sidepanelwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"sidepanelwidget.h\" #include \"colorgrabwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/pathinfo.h\" #include \"utilitypanel.h\" #include <QApplication> #include <QKeyEvent> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QShortcut> #include <QSlider> #include <QVBoxLayout> #if defined(Q_OS_MACOS) #include <QScreen> #endif SidePanelWidget::SidePanelWidget(QPixmap* p, QWidget* parent) : QWidget(parent) , m_layout(new QVBoxLayout(this)) , m_pixmap(p) { if (parent != nullptr) { parent->installEventFilter(this); } auto* colorLayout = new QGridLayout(); // Create Active Tool Size auto* toolSizeHBox = new QHBoxLayout(); auto* activeToolSizeText = new QLabel(tr(\"Active tool size: \")); m_toolSizeSpin = new QSpinBox(this); m_toolSizeSpin->setRange(1, maxToolSize); m_toolSizeSpin->setSingleStep(1); m_toolSizeSpin->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed); toolSizeHBox->addWidget(activeToolSizeText); toolSizeHBox->addWidget(m_toolSizeSpin); m_toolSizeSlider = new QSlider(Qt::Horizontal); m_toolSizeSlider->setRange(1, maxToolSize); m_toolSizeSlider->setValue(m_toolSize); m_toolSizeSlider->setMinimumWidth(minSliderWidth); colorLayout->addLayout(toolSizeHBox, 0, 0); colorLayout->addWidget(m_toolSizeSlider, 1, 0); // Create Active Color auto* colorHBox = new QHBoxLayout(); auto* colorText = new QLabel(tr(\"Active Color: \")); m_colorLabel = new QLabel(); m_colorLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed); colorHBox->addWidget(colorText); colorHBox->addWidget(m_colorLabel); colorLayout->addLayout(colorHBox, 2, 0); m_layout->addLayout(colorLayout); m_colorWheel = new color_widgets::ColorWheel(this); m_colorWheel->setColor(m_color); m_colorHex = new QLineEdit(this); m_colorHex->setAlignment(Qt::AlignCenter); QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); QIcon grabIcon(modifier + \"colorize.svg\"); m_colorGrabButton = new QPushButton(grabIcon, tr(\"Grab Color\")); m_layout->addWidget(m_colorGrabButton); m_layout->addWidget(m_colorWheel); m_layout->addWidget(m_colorHex); // tool size sigslots connect(m_toolSizeSpin, static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged), this, &SidePanelWidget::toolSizeChanged); connect(m_toolSizeSlider, &QSlider::valueChanged, this, &SidePanelWidget::toolSizeChanged); connect(this, &SidePanelWidget::toolSizeChanged, this, &SidePanelWidget::onToolSizeChanged); // color hex editor sigslots connect(m_colorHex, &QLineEdit::editingFinished, this, [=]() { if (!QColor::isValidColor(m_colorHex->text())) { m_colorHex->setText(m_color.name(QColor::HexRgb)); } else { emit colorChanged(m_colorHex->text()); } }); // color grab button sigslots connect(m_colorGrabButton, &QPushButton::pressed, this, &SidePanelWidget::startColorGrab); // color wheel sigslots // re-emit ColorWheel::colorSelected as SidePanelWidget::colorChanged connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, &SidePanelWidget::colorChanged); } void SidePanelWidget::onColorChanged(const QColor& color) { m_color = color; updateColorNoWheel(color); m_colorWheel->setColor(color); } void SidePanelWidget::onToolSizeChanged(int t) { m_toolSize = qBound(0, t, maxToolSize); m_toolSizeSlider->setValue(m_toolSize); m_toolSizeSpin->setValue(m_toolSize); } void SidePanelWidget::startColorGrab() { m_revertColor = m_color; m_colorGrabber = new ColorGrabWidget(m_pixmap); connect(m_colorGrabber, &ColorGrabWidget::colorUpdated, this, &SidePanelWidget::onTemporaryColorUpdated); connect(m_colorGrabber, &ColorGrabWidget::colorGrabbed, this, &SidePanelWidget::onColorGrabFinished); connect(m_colorGrabber, &ColorGrabWidget::grabAborted, this, &SidePanelWidget::onColorGrabAborted); emit togglePanel(); m_colorGrabber->startGrabbing(); } void SidePanelWidget::onColorGrabFinished() { finalizeGrab(); m_color = m_colorGrabber->color(); emit colorChanged(m_color); } void SidePanelWidget::onColorGrabAborted() { finalizeGrab(); // Restore color that was selected before we started grabbing onColorChanged(m_revertColor); } void SidePanelWidget::onTemporaryColorUpdated(const QColor& color) { updateColorNoWheel(color); } void SidePanelWidget::finalizeGrab() { emit togglePanel(); } void SidePanelWidget::updateColorNoWheel(const QColor& c) { m_colorLabel->setStyleSheet( QStringLiteral(\"QLabel { background-color : %1; }\").arg(c.name())); m_colorHex->setText(c.name(QColor::HexRgb)); } bool SidePanelWidget::eventFilter(QObject* obj, QEvent* event) { if (event->type() == QEvent::ShortcutOverride) { // Override Escape shortcut from CaptureWidget auto* e = static_cast<QKeyEvent*>(event); if (e->key() == Qt::Key_Escape && m_colorHex->hasFocus()) { m_colorHex->clearFocus(); e->accept(); return true; } } else if (event->type() == QEvent::MouseButtonPress) { // Clicks outside of the Color Hex editor m_colorHex->clearFocus(); } return QWidget::eventFilter(obj, event); } void SidePanelWidget::hideEvent(QHideEvent* event) { QWidget::hideEvent(event); m_colorHex->clearFocus(); }","title":"File sidepanelwidget.cpp"},{"location":"flameshot/sidepanelwidget_8cpp_source/#file-sidepanelwidgetcpp","text":"File List > panel > sidepanelwidget.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"sidepanelwidget.h\" #include \"colorgrabwidget.h\" #include \"src/core/qguiappcurrentscreen.h\" #include \"src/utils/colorutils.h\" #include \"src/utils/pathinfo.h\" #include \"utilitypanel.h\" #include <QApplication> #include <QKeyEvent> #include <QLabel> #include <QLineEdit> #include <QPushButton> #include <QShortcut> #include <QSlider> #include <QVBoxLayout> #if defined(Q_OS_MACOS) #include <QScreen> #endif SidePanelWidget::SidePanelWidget(QPixmap* p, QWidget* parent) : QWidget(parent) , m_layout(new QVBoxLayout(this)) , m_pixmap(p) { if (parent != nullptr) { parent->installEventFilter(this); } auto* colorLayout = new QGridLayout(); // Create Active Tool Size auto* toolSizeHBox = new QHBoxLayout(); auto* activeToolSizeText = new QLabel(tr(\"Active tool size: \")); m_toolSizeSpin = new QSpinBox(this); m_toolSizeSpin->setRange(1, maxToolSize); m_toolSizeSpin->setSingleStep(1); m_toolSizeSpin->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed); toolSizeHBox->addWidget(activeToolSizeText); toolSizeHBox->addWidget(m_toolSizeSpin); m_toolSizeSlider = new QSlider(Qt::Horizontal); m_toolSizeSlider->setRange(1, maxToolSize); m_toolSizeSlider->setValue(m_toolSize); m_toolSizeSlider->setMinimumWidth(minSliderWidth); colorLayout->addLayout(toolSizeHBox, 0, 0); colorLayout->addWidget(m_toolSizeSlider, 1, 0); // Create Active Color auto* colorHBox = new QHBoxLayout(); auto* colorText = new QLabel(tr(\"Active Color: \")); m_colorLabel = new QLabel(); m_colorLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed); colorHBox->addWidget(colorText); colorHBox->addWidget(m_colorLabel); colorLayout->addLayout(colorHBox, 2, 0); m_layout->addLayout(colorLayout); m_colorWheel = new color_widgets::ColorWheel(this); m_colorWheel->setColor(m_color); m_colorHex = new QLineEdit(this); m_colorHex->setAlignment(Qt::AlignCenter); QColor background = this->palette().window().color(); bool isDark = ColorUtils::colorIsDark(background); QString modifier = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); QIcon grabIcon(modifier + \"colorize.svg\"); m_colorGrabButton = new QPushButton(grabIcon, tr(\"Grab Color\")); m_layout->addWidget(m_colorGrabButton); m_layout->addWidget(m_colorWheel); m_layout->addWidget(m_colorHex); // tool size sigslots connect(m_toolSizeSpin, static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged), this, &SidePanelWidget::toolSizeChanged); connect(m_toolSizeSlider, &QSlider::valueChanged, this, &SidePanelWidget::toolSizeChanged); connect(this, &SidePanelWidget::toolSizeChanged, this, &SidePanelWidget::onToolSizeChanged); // color hex editor sigslots connect(m_colorHex, &QLineEdit::editingFinished, this, [=]() { if (!QColor::isValidColor(m_colorHex->text())) { m_colorHex->setText(m_color.name(QColor::HexRgb)); } else { emit colorChanged(m_colorHex->text()); } }); // color grab button sigslots connect(m_colorGrabButton, &QPushButton::pressed, this, &SidePanelWidget::startColorGrab); // color wheel sigslots // re-emit ColorWheel::colorSelected as SidePanelWidget::colorChanged connect(m_colorWheel, &color_widgets::ColorWheel::colorSelected, this, &SidePanelWidget::colorChanged); } void SidePanelWidget::onColorChanged(const QColor& color) { m_color = color; updateColorNoWheel(color); m_colorWheel->setColor(color); } void SidePanelWidget::onToolSizeChanged(int t) { m_toolSize = qBound(0, t, maxToolSize); m_toolSizeSlider->setValue(m_toolSize); m_toolSizeSpin->setValue(m_toolSize); } void SidePanelWidget::startColorGrab() { m_revertColor = m_color; m_colorGrabber = new ColorGrabWidget(m_pixmap); connect(m_colorGrabber, &ColorGrabWidget::colorUpdated, this, &SidePanelWidget::onTemporaryColorUpdated); connect(m_colorGrabber, &ColorGrabWidget::colorGrabbed, this, &SidePanelWidget::onColorGrabFinished); connect(m_colorGrabber, &ColorGrabWidget::grabAborted, this, &SidePanelWidget::onColorGrabAborted); emit togglePanel(); m_colorGrabber->startGrabbing(); } void SidePanelWidget::onColorGrabFinished() { finalizeGrab(); m_color = m_colorGrabber->color(); emit colorChanged(m_color); } void SidePanelWidget::onColorGrabAborted() { finalizeGrab(); // Restore color that was selected before we started grabbing onColorChanged(m_revertColor); } void SidePanelWidget::onTemporaryColorUpdated(const QColor& color) { updateColorNoWheel(color); } void SidePanelWidget::finalizeGrab() { emit togglePanel(); } void SidePanelWidget::updateColorNoWheel(const QColor& c) { m_colorLabel->setStyleSheet( QStringLiteral(\"QLabel { background-color : %1; }\").arg(c.name())); m_colorHex->setText(c.name(QColor::HexRgb)); } bool SidePanelWidget::eventFilter(QObject* obj, QEvent* event) { if (event->type() == QEvent::ShortcutOverride) { // Override Escape shortcut from CaptureWidget auto* e = static_cast<QKeyEvent*>(event); if (e->key() == Qt::Key_Escape && m_colorHex->hasFocus()) { m_colorHex->clearFocus(); e->accept(); return true; } } else if (event->type() == QEvent::MouseButtonPress) { // Clicks outside of the Color Hex editor m_colorHex->clearFocus(); } return QWidget::eventFilter(obj, event); } void SidePanelWidget::hideEvent(QHideEvent* event) { QWidget::hideEvent(event); m_colorHex->clearFocus(); }","title":"File sidepanelwidget.cpp"},{"location":"flameshot/sidepanelwidget_8h/","text":"File sidepanelwidget.h # FileList > panel > sidepanelwidget.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include <QSpinBox> #include <QWidget> Classes # Type Name class SidePanelWidget Public Attributes # Type Name constexpr int maxToolSize = = 50 constexpr int minSliderWidth = = 100 Public Attributes Documentation # variable maxToolSize # constexpr int maxToolSize; variable minSliderWidth # constexpr int minSliderWidth;","title":"File sidepanelwidget.h"},{"location":"flameshot/sidepanelwidget_8h/#file-sidepanelwidgeth","text":"FileList > panel > sidepanelwidget.h Go to the source code of this file. #include \"QtColorWidgets/color_wheel.hpp\" #include <QSpinBox> #include <QWidget>","title":"File sidepanelwidget.h"},{"location":"flameshot/sidepanelwidget_8h/#classes","text":"Type Name class SidePanelWidget","title":"Classes"},{"location":"flameshot/sidepanelwidget_8h/#public-attributes","text":"Type Name constexpr int maxToolSize = = 50 constexpr int minSliderWidth = = 100","title":"Public Attributes"},{"location":"flameshot/sidepanelwidget_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"flameshot/sidepanelwidget_8h/#variable-maxtoolsize","text":"constexpr int maxToolSize;","title":"variable maxToolSize"},{"location":"flameshot/sidepanelwidget_8h/#variable-minsliderwidth","text":"constexpr int minSliderWidth;","title":"variable minSliderWidth"},{"location":"flameshot/sidepanelwidget_8h_source/","text":"File sidepanelwidget.h # File List > panel > sidepanelwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include <QSpinBox> #include <QWidget> class QVBoxLayout; class QPushButton; class QLabel; class QLineEdit; class ColorGrabWidget; class QColorPickingEventFilter; class QSlider; constexpr int maxToolSize = 50; constexpr int minSliderWidth = 100; class SidePanelWidget : public QWidget { Q_OBJECT friend class QColorPickingEventFilter; public: explicit SidePanelWidget(QPixmap* p, QWidget* parent = nullptr); signals: void colorChanged(const QColor& color); void toolSizeChanged(int size); void togglePanel(); public slots: void onToolSizeChanged(int tool); void onColorChanged(const QColor& color); private slots: void startColorGrab(); void onColorGrabFinished(); void onColorGrabAborted(); void onTemporaryColorUpdated(const QColor& color); private: void finalizeGrab(); void updateColorNoWheel(const QColor& color); bool eventFilter(QObject* obj, QEvent* event) override; void hideEvent(QHideEvent* event) override; QVBoxLayout* m_layout; QPushButton* m_colorGrabButton; ColorGrabWidget* m_colorGrabber{}; color_widgets::ColorWheel* m_colorWheel; QLabel* m_colorLabel; QLineEdit* m_colorHex; QPixmap* m_pixmap; QColor m_color; QColor m_revertColor; QSpinBox* m_toolSizeSpin; QSlider* m_toolSizeSlider; int m_toolSize{}; };","title":"File sidepanelwidget.h"},{"location":"flameshot/sidepanelwidget_8h_source/#file-sidepanelwidgeth","text":"File List > panel > sidepanelwidget.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"QtColorWidgets/color_wheel.hpp\" #include <QSpinBox> #include <QWidget> class QVBoxLayout; class QPushButton; class QLabel; class QLineEdit; class ColorGrabWidget; class QColorPickingEventFilter; class QSlider; constexpr int maxToolSize = 50; constexpr int minSliderWidth = 100; class SidePanelWidget : public QWidget { Q_OBJECT friend class QColorPickingEventFilter; public: explicit SidePanelWidget(QPixmap* p, QWidget* parent = nullptr); signals: void colorChanged(const QColor& color); void toolSizeChanged(int size); void togglePanel(); public slots: void onToolSizeChanged(int tool); void onColorChanged(const QColor& color); private slots: void startColorGrab(); void onColorGrabFinished(); void onColorGrabAborted(); void onTemporaryColorUpdated(const QColor& color); private: void finalizeGrab(); void updateColorNoWheel(const QColor& color); bool eventFilter(QObject* obj, QEvent* event) override; void hideEvent(QHideEvent* event) override; QVBoxLayout* m_layout; QPushButton* m_colorGrabButton; ColorGrabWidget* m_colorGrabber{}; color_widgets::ColorWheel* m_colorWheel; QLabel* m_colorLabel; QLineEdit* m_colorHex; QPixmap* m_pixmap; QColor m_color; QColor m_revertColor; QSpinBox* m_toolSizeSpin; QSlider* m_toolSizeSlider; int m_toolSize{}; };","title":"File sidepanelwidget.h"},{"location":"flameshot/utilitypanel_8cpp/","text":"File utilitypanel.cpp # FileList > panel > utilitypanel.cpp Go to the source code of this file. #include \"utilitypanel.h\" #include \"capturewidget.h\" #include <QHBoxLayout> #include <QListWidget> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer>","title":"File utilitypanel.cpp"},{"location":"flameshot/utilitypanel_8cpp/#file-utilitypanelcpp","text":"FileList > panel > utilitypanel.cpp Go to the source code of this file. #include \"utilitypanel.h\" #include \"capturewidget.h\" #include <QHBoxLayout> #include <QListWidget> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer>","title":"File utilitypanel.cpp"},{"location":"flameshot/utilitypanel_8cpp_source/","text":"File utilitypanel.cpp # File List > panel > utilitypanel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"utilitypanel.h\" #include \"capturewidget.h\" #include <QHBoxLayout> #include <QListWidget> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> UtilityPanel::UtilityPanel(CaptureWidget* captureWidget) : QWidget(captureWidget) , m_captureWidget(captureWidget) , m_internalPanel(nullptr) , m_upLayout(nullptr) , m_bottomLayout(nullptr) , m_layout(nullptr) , m_showAnimation(nullptr) , m_hideAnimation(nullptr) , m_layersLayout(nullptr) , m_captureTools(nullptr) , m_buttonDelete(nullptr) , m_buttonMoveUp(nullptr) , m_buttonMoveDown(nullptr) { initInternalPanel(); setAttribute(Qt::WA_TransparentForMouseEvents); setCursor(Qt::ArrowCursor); m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_hideAnimation->setDuration(300); connect(m_hideAnimation, &QPropertyAnimation::finished, m_internalPanel, &QWidget::hide); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) move(0, 0); #endif hide(); } QWidget* UtilityPanel::toolWidget() const { return m_toolWidget; } void UtilityPanel::setToolWidget(QWidget* widget) { if (m_toolWidget != nullptr) { m_toolWidget->hide(); m_toolWidget->setParent(this); m_toolWidget->deleteLater(); } if (widget != nullptr) { m_toolWidget = widget; m_toolWidget->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Preferred); m_upLayout->addWidget(widget); } } void UtilityPanel::clearToolWidget() { if (m_toolWidget != nullptr) { m_toolWidget->deleteLater(); } } void UtilityPanel::pushWidget(QWidget* widget) { m_layout->insertWidget(m_layout->count() - 1, widget); } void UtilityPanel::show() { setAttribute(Qt::WA_TransparentForMouseEvents, false); m_showAnimation->setStartValue(QRect(-width(), 0, 0, height())); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_internalPanel->show(); m_showAnimation->start(); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) move(0, 0); #endif QWidget::show(); } void UtilityPanel::hide() { setAttribute(Qt::WA_TransparentForMouseEvents); m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(-width(), 0, 0, height())); m_hideAnimation->start(); m_internalPanel->hide(); QWidget::hide(); } void UtilityPanel::toggle() { if (m_internalPanel->isHidden()) { show(); } else { hide(); } } void UtilityPanel::initInternalPanel() { m_internalPanel = new QScrollArea(this); m_internalPanel->setAttribute(Qt::WA_NoMousePropagation); auto* widget = new QWidget(); m_internalPanel->setWidget(widget); m_internalPanel->setWidgetResizable(true); m_layout = new QVBoxLayout(); m_upLayout = new QVBoxLayout(); m_bottomLayout = new QVBoxLayout(); m_layersLayout = new QVBoxLayout(); m_layout->addLayout(m_upLayout); m_layout->addLayout(m_bottomLayout); m_bottomLayout->addLayout(m_layersLayout); widget->setLayout(m_layout); QColor bgColor = palette().window().color(); bgColor.setAlphaF(0.0); m_internalPanel->setStyleSheet( QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name())); m_internalPanel->hide(); m_captureTools = new QListWidget(this); connect(m_captureTools, SIGNAL(currentRowChanged(int)), this, SLOT(onCurrentRowChanged(int))); auto* layersButtons = new QHBoxLayout(); m_layersLayout->addLayout(layersButtons); m_layersLayout->addWidget(m_captureTools); bool isDark = ColorUtils::colorIsDark(bgColor); QString coloredIconPath = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); m_buttonDelete = new QPushButton(this); m_buttonDelete->setIcon(QIcon(coloredIconPath + \"delete.svg\")); m_buttonDelete->setMinimumWidth(m_buttonDelete->height()); m_buttonDelete->setDisabled(true); m_buttonMoveUp = new QPushButton(this); m_buttonMoveUp->setIcon(QIcon(coloredIconPath + \"move_up.svg\")); m_buttonMoveUp->setMinimumWidth(m_buttonMoveUp->height()); m_buttonMoveUp->setDisabled(true); m_buttonMoveDown = new QPushButton(this); m_buttonMoveDown->setIcon(QIcon(coloredIconPath + \"move_down.svg\")); m_buttonMoveDown->setMinimumWidth(m_buttonMoveDown->height()); m_buttonMoveDown->setDisabled(true); layersButtons->addWidget(m_buttonDelete); layersButtons->addWidget(m_buttonMoveUp); layersButtons->addWidget(m_buttonMoveDown); layersButtons->addStretch(); connect(m_buttonDelete, SIGNAL(clicked(bool)), this, SLOT(slotButtonDelete(bool))); connect(m_buttonMoveUp, &QPushButton::clicked, this, &UtilityPanel::slotUpClicked); connect(m_buttonMoveDown, &QPushButton::clicked, this, &UtilityPanel::slotDownClicked); // Bottom auto* closeButton = new QPushButton(this); closeButton->setText(tr(\"Close\")); connect(closeButton, &QPushButton::clicked, this, &UtilityPanel::toggle); m_bottomLayout->addWidget(closeButton); } void UtilityPanel::fillCaptureTools( const QList<QPointer<CaptureTool>>& captureToolObjects) { int currentSelection = m_captureTools->currentRow(); m_captureTools->clear(); m_captureTools->addItem(tr(\"<Empty>\")); for (auto toolItem : captureToolObjects) { auto* item = new QListWidgetItem( toolItem->icon(QColor(Qt::white), false), toolItem->info()); m_captureTools->addItem(item); } if (currentSelection >= 0 && currentSelection < m_captureTools->count()) { m_captureTools->setCurrentRow(currentSelection); } } void UtilityPanel::setActiveLayer(int index) { Q_ASSERT(index >= -1); m_captureTools->setCurrentRow(index + 1); } int UtilityPanel::activeLayerIndex() { return m_captureTools->currentRow() >= 0 ? m_captureTools->currentRow() - 1 : -1; } void UtilityPanel::onCurrentRowChanged(int currentRow) { m_buttonDelete->setDisabled(currentRow <= 0); m_buttonMoveDown->setDisabled(currentRow == 0 || currentRow + 1 == m_captureTools->count()); m_buttonMoveUp->setDisabled(currentRow <= 1); emit layerChanged(activeLayerIndex()); } void UtilityPanel::slotUpClicked(bool clicked) { Q_UNUSED(clicked); // subtract 1 because there's <empty> in m_captureTools as [0] element int toolRow = m_captureTools->currentRow() - 1; m_captureTools->setCurrentRow(toolRow); emit moveUpClicked(toolRow); } void UtilityPanel::slotDownClicked(bool clicked) { Q_UNUSED(clicked); // subtract 1 because there's <empty> in m_captureTools as [0] element int toolRow = m_captureTools->currentRow() - 1; m_captureTools->setCurrentRow(toolRow + 2); emit moveDownClicked(toolRow); } void UtilityPanel::slotButtonDelete(bool clicked) { Q_UNUSED(clicked) int currentRow = m_captureTools->currentRow(); if (currentRow > 0) { m_captureWidget->removeToolObject(currentRow); if (currentRow >= m_captureTools->count()) { currentRow = m_captureTools->count() - 1; } } else { currentRow = 0; } m_captureTools->setCurrentRow(currentRow); } bool UtilityPanel::isVisible() const { return !m_internalPanel->isHidden(); }","title":"File utilitypanel.cpp"},{"location":"flameshot/utilitypanel_8cpp_source/#file-utilitypanelcpp","text":"File List > panel > utilitypanel.cpp Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #include \"utilitypanel.h\" #include \"capturewidget.h\" #include <QHBoxLayout> #include <QListWidget> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> UtilityPanel::UtilityPanel(CaptureWidget* captureWidget) : QWidget(captureWidget) , m_captureWidget(captureWidget) , m_internalPanel(nullptr) , m_upLayout(nullptr) , m_bottomLayout(nullptr) , m_layout(nullptr) , m_showAnimation(nullptr) , m_hideAnimation(nullptr) , m_layersLayout(nullptr) , m_captureTools(nullptr) , m_buttonDelete(nullptr) , m_buttonMoveUp(nullptr) , m_buttonMoveDown(nullptr) { initInternalPanel(); setAttribute(Qt::WA_TransparentForMouseEvents); setCursor(Qt::ArrowCursor); m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_hideAnimation->setDuration(300); connect(m_hideAnimation, &QPropertyAnimation::finished, m_internalPanel, &QWidget::hide); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) move(0, 0); #endif hide(); } QWidget* UtilityPanel::toolWidget() const { return m_toolWidget; } void UtilityPanel::setToolWidget(QWidget* widget) { if (m_toolWidget != nullptr) { m_toolWidget->hide(); m_toolWidget->setParent(this); m_toolWidget->deleteLater(); } if (widget != nullptr) { m_toolWidget = widget; m_toolWidget->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Preferred); m_upLayout->addWidget(widget); } } void UtilityPanel::clearToolWidget() { if (m_toolWidget != nullptr) { m_toolWidget->deleteLater(); } } void UtilityPanel::pushWidget(QWidget* widget) { m_layout->insertWidget(m_layout->count() - 1, widget); } void UtilityPanel::show() { setAttribute(Qt::WA_TransparentForMouseEvents, false); m_showAnimation->setStartValue(QRect(-width(), 0, 0, height())); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_internalPanel->show(); m_showAnimation->start(); #if (defined(Q_OS_WIN) || defined(Q_OS_MACOS)) move(0, 0); #endif QWidget::show(); } void UtilityPanel::hide() { setAttribute(Qt::WA_TransparentForMouseEvents); m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(-width(), 0, 0, height())); m_hideAnimation->start(); m_internalPanel->hide(); QWidget::hide(); } void UtilityPanel::toggle() { if (m_internalPanel->isHidden()) { show(); } else { hide(); } } void UtilityPanel::initInternalPanel() { m_internalPanel = new QScrollArea(this); m_internalPanel->setAttribute(Qt::WA_NoMousePropagation); auto* widget = new QWidget(); m_internalPanel->setWidget(widget); m_internalPanel->setWidgetResizable(true); m_layout = new QVBoxLayout(); m_upLayout = new QVBoxLayout(); m_bottomLayout = new QVBoxLayout(); m_layersLayout = new QVBoxLayout(); m_layout->addLayout(m_upLayout); m_layout->addLayout(m_bottomLayout); m_bottomLayout->addLayout(m_layersLayout); widget->setLayout(m_layout); QColor bgColor = palette().window().color(); bgColor.setAlphaF(0.0); m_internalPanel->setStyleSheet( QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name())); m_internalPanel->hide(); m_captureTools = new QListWidget(this); connect(m_captureTools, SIGNAL(currentRowChanged(int)), this, SLOT(onCurrentRowChanged(int))); auto* layersButtons = new QHBoxLayout(); m_layersLayout->addLayout(layersButtons); m_layersLayout->addWidget(m_captureTools); bool isDark = ColorUtils::colorIsDark(bgColor); QString coloredIconPath = isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath(); m_buttonDelete = new QPushButton(this); m_buttonDelete->setIcon(QIcon(coloredIconPath + \"delete.svg\")); m_buttonDelete->setMinimumWidth(m_buttonDelete->height()); m_buttonDelete->setDisabled(true); m_buttonMoveUp = new QPushButton(this); m_buttonMoveUp->setIcon(QIcon(coloredIconPath + \"move_up.svg\")); m_buttonMoveUp->setMinimumWidth(m_buttonMoveUp->height()); m_buttonMoveUp->setDisabled(true); m_buttonMoveDown = new QPushButton(this); m_buttonMoveDown->setIcon(QIcon(coloredIconPath + \"move_down.svg\")); m_buttonMoveDown->setMinimumWidth(m_buttonMoveDown->height()); m_buttonMoveDown->setDisabled(true); layersButtons->addWidget(m_buttonDelete); layersButtons->addWidget(m_buttonMoveUp); layersButtons->addWidget(m_buttonMoveDown); layersButtons->addStretch(); connect(m_buttonDelete, SIGNAL(clicked(bool)), this, SLOT(slotButtonDelete(bool))); connect(m_buttonMoveUp, &QPushButton::clicked, this, &UtilityPanel::slotUpClicked); connect(m_buttonMoveDown, &QPushButton::clicked, this, &UtilityPanel::slotDownClicked); // Bottom auto* closeButton = new QPushButton(this); closeButton->setText(tr(\"Close\")); connect(closeButton, &QPushButton::clicked, this, &UtilityPanel::toggle); m_bottomLayout->addWidget(closeButton); } void UtilityPanel::fillCaptureTools( const QList<QPointer<CaptureTool>>& captureToolObjects) { int currentSelection = m_captureTools->currentRow(); m_captureTools->clear(); m_captureTools->addItem(tr(\"<Empty>\")); for (auto toolItem : captureToolObjects) { auto* item = new QListWidgetItem( toolItem->icon(QColor(Qt::white), false), toolItem->info()); m_captureTools->addItem(item); } if (currentSelection >= 0 && currentSelection < m_captureTools->count()) { m_captureTools->setCurrentRow(currentSelection); } } void UtilityPanel::setActiveLayer(int index) { Q_ASSERT(index >= -1); m_captureTools->setCurrentRow(index + 1); } int UtilityPanel::activeLayerIndex() { return m_captureTools->currentRow() >= 0 ? m_captureTools->currentRow() - 1 : -1; } void UtilityPanel::onCurrentRowChanged(int currentRow) { m_buttonDelete->setDisabled(currentRow <= 0); m_buttonMoveDown->setDisabled(currentRow == 0 || currentRow + 1 == m_captureTools->count()); m_buttonMoveUp->setDisabled(currentRow <= 1); emit layerChanged(activeLayerIndex()); } void UtilityPanel::slotUpClicked(bool clicked) { Q_UNUSED(clicked); // subtract 1 because there's <empty> in m_captureTools as [0] element int toolRow = m_captureTools->currentRow() - 1; m_captureTools->setCurrentRow(toolRow); emit moveUpClicked(toolRow); } void UtilityPanel::slotDownClicked(bool clicked) { Q_UNUSED(clicked); // subtract 1 because there's <empty> in m_captureTools as [0] element int toolRow = m_captureTools->currentRow() - 1; m_captureTools->setCurrentRow(toolRow + 2); emit moveDownClicked(toolRow); } void UtilityPanel::slotButtonDelete(bool clicked) { Q_UNUSED(clicked) int currentRow = m_captureTools->currentRow(); if (currentRow > 0) { m_captureWidget->removeToolObject(currentRow); if (currentRow >= m_captureTools->count()) { currentRow = m_captureTools->count() - 1; } } else { currentRow = 0; } m_captureTools->setCurrentRow(currentRow); } bool UtilityPanel::isVisible() const { return !m_internalPanel->isHidden(); }","title":"File utilitypanel.cpp"},{"location":"flameshot/utilitypanel_8h/","text":"File utilitypanel.h # FileList > panel > utilitypanel.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include <QPointer> #include <QWidget> Classes # Type Name class UtilityPanel","title":"File utilitypanel.h"},{"location":"flameshot/utilitypanel_8h/#file-utilitypanelh","text":"FileList > panel > utilitypanel.h Go to the source code of this file. #include \"src/tools/capturetool.h\" #include <QPointer> #include <QWidget>","title":"File utilitypanel.h"},{"location":"flameshot/utilitypanel_8h/#classes","text":"Type Name class UtilityPanel","title":"Classes"},{"location":"flameshot/utilitypanel_8h_source/","text":"File utilitypanel.h # File List > panel > utilitypanel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include <QPointer> #include <QWidget> class QVBoxLayout; class QPropertyAnimation; class QScrollArea; class QPushButton; class QListWidget; class QPushButton; class CaptureWidget; class UtilityPanel : public QWidget { Q_OBJECT public: explicit UtilityPanel(CaptureWidget* captureWidget); [[nodiscard]] QWidget* toolWidget() const; void setToolWidget(QWidget* weight); void clearToolWidget(); void pushWidget(QWidget* widget); void hide(); void show(); void fillCaptureTools( const QList<QPointer<CaptureTool>>& captureToolObjectsHistory); void setActiveLayer(int index); int activeLayerIndex(); bool isVisible() const; signals: void layerChanged(int layer); void moveUpClicked(int currentRow); void moveDownClicked(int currentRow); public slots: void toggle(); void slotButtonDelete(bool clicked); void onCurrentRowChanged(int currentRow); private slots: void slotUpClicked(bool clicked); void slotDownClicked(bool clicked); private: void initInternalPanel(); QPointer<QWidget> m_toolWidget; QScrollArea* m_internalPanel; QVBoxLayout* m_upLayout; QVBoxLayout* m_bottomLayout; QVBoxLayout* m_layout; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; QVBoxLayout* m_layersLayout; QListWidget* m_captureTools; QPushButton* m_buttonDelete; QPushButton* m_buttonMoveUp; QPushButton* m_buttonMoveDown; CaptureWidget* m_captureWidget; };","title":"File utilitypanel.h"},{"location":"flameshot/utilitypanel_8h_source/#file-utilitypanelh","text":"File List > panel > utilitypanel.h Go to the documentation of this file. // SPDX-License-Identifier: GPL-3.0-or-later // SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica & Contributors #pragma once #include \"src/tools/capturetool.h\" #include <QPointer> #include <QWidget> class QVBoxLayout; class QPropertyAnimation; class QScrollArea; class QPushButton; class QListWidget; class QPushButton; class CaptureWidget; class UtilityPanel : public QWidget { Q_OBJECT public: explicit UtilityPanel(CaptureWidget* captureWidget); [[nodiscard]] QWidget* toolWidget() const; void setToolWidget(QWidget* weight); void clearToolWidget(); void pushWidget(QWidget* widget); void hide(); void show(); void fillCaptureTools( const QList<QPointer<CaptureTool>>& captureToolObjectsHistory); void setActiveLayer(int index); int activeLayerIndex(); bool isVisible() const; signals: void layerChanged(int layer); void moveUpClicked(int currentRow); void moveDownClicked(int currentRow); public slots: void toggle(); void slotButtonDelete(bool clicked); void onCurrentRowChanged(int currentRow); private slots: void slotUpClicked(bool clicked); void slotDownClicked(bool clicked); private: void initInternalPanel(); QPointer<QWidget> m_toolWidget; QScrollArea* m_internalPanel; QVBoxLayout* m_upLayout; QVBoxLayout* m_bottomLayout; QVBoxLayout* m_layout; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; QVBoxLayout* m_layersLayout; QListWidget* m_captureTools; QPushButton* m_buttonDelete; QPushButton* m_buttonMoveUp; QPushButton* m_buttonMoveDown; CaptureWidget* m_captureWidget; };","title":"File utilitypanel.h"},{"location":"flameshot/trayicon_8cpp/","text":"File trayicon.cpp # FileList > src > widgets > trayicon.cpp Go to the source code of this file. #include \"trayicon.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QMenu> #include <QTimer> #include <QUrl> #include <QVersionNumber>","title":"File trayicon.cpp"},{"location":"flameshot/trayicon_8cpp/#file-trayiconcpp","text":"FileList > src > widgets > trayicon.cpp Go to the source code of this file. #include \"trayicon.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QMenu> #include <QTimer> #include <QUrl> #include <QVersionNumber>","title":"File trayicon.cpp"},{"location":"flameshot/trayicon_8cpp_source/","text":"File trayicon.cpp # File List > src > widgets > trayicon.cpp Go to the documentation of this file. #include \"trayicon.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QMenu> #include <QTimer> #include <QUrl> #include <QVersionNumber> #if defined(Q_OS_MACOS) #include <QOperatingSystemVersion> #endif TrayIcon::TrayIcon(QObject* parent) : QSystemTrayIcon(parent) { initMenu(); setToolTip(QStringLiteral(\"Flameshot\")); #if defined(Q_OS_MACOS) // Because of the following issues on MacOS \"Catalina\": // https://bugreports.qt.io/browse/QTBUG-86393 // https://developer.apple.com/forums/thread/126072 auto currentMacOsVersion = QOperatingSystemVersion::current(); if (currentMacOsVersion >= currentMacOsVersion.MacOSBigSur) { setContextMenu(m_menu); } #else setContextMenu(m_menu); #endif QIcon icon = QIcon::fromTheme(\"flameshot-tray\", QIcon(GlobalValues::iconPathPNG())); setIcon(icon); #if defined(Q_OS_MACOS) if (currentMacOsVersion < currentMacOsVersion.MacOSBigSur) { // Because of the following issues on MacOS \"Catalina\": // https://bugreports.qt.io/browse/QTBUG-86393 // https://developer.apple.com/forums/thread/126072 auto trayIconActivated = [this](QSystemTrayIcon::ActivationReason r) { if (m_menu->isVisible()) { m_menu->hide(); } else { m_menu->popup(QCursor::pos()); } }; connect(this, &QSystemTrayIcon::activated, this, trayIconActivated); } #else connect(this, &TrayIcon::activated, this, [this](ActivationReason r) { if (r == Trigger) { startGuiCapture(); } }); #endif #ifdef Q_OS_WIN // Ensure proper removal of tray icon when program quits on Windows. connect(qApp, &QCoreApplication::aboutToQuit, this, &TrayIcon::hide); #endif show(); // TODO needed? if (ConfigHandler().showStartupLaunchMessage()) { showMessage( \"Flameshot\", QObject::tr( \"Hello, I'm here! Click icon in the tray to take a screenshot or \" \"click with a right button to see more options.\"), icon, 3000); } connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() {}); } TrayIcon::~TrayIcon() { delete m_menu; } #if !defined(DISABLE_UPDATE_CHECKER) QAction* TrayIcon::appUpdates() { return m_appUpdates; } #endif void TrayIcon::initMenu() { m_menu = new QMenu(); auto* captureAction = new QAction(tr(\"&Take Screenshot\"), this); connect(captureAction, &QAction::triggered, this, [this]() { #if defined(Q_OS_MACOS) auto currentMacOsVersion = QOperatingSystemVersion::current(); if (currentMacOsVersion >= currentMacOsVersion.MacOSBigSur) { startGuiCapture(); } else { // It seems it is not relevant for MacOS BigSur (Wait 400 ms to hide // the QMenu) QTimer::singleShot(400, this, [this]() { startGuiCapture(); }); } #else // Wait 400 ms to hide the QMenu QTimer::singleShot(400, this, [this]() { startGuiCapture(); }); #endif }); auto* launcherAction = new QAction(tr(\"&Open Launcher\"), this); connect(launcherAction, &QAction::triggered, Flameshot::instance(), &Flameshot::launcher); auto* configAction = new QAction(tr(\"&Configuration\"), this); connect(configAction, &QAction::triggered, Flameshot::instance(), &Flameshot::config); auto* infoAction = new QAction(tr(\"&About\"), this); connect( infoAction, &QAction::triggered, Flameshot::instance(), &Flameshot::info); #if !defined(DISABLE_UPDATE_CHECKER) m_appUpdates = new QAction(tr(\"Check for updates\"), this); connect(m_appUpdates, &QAction::triggered, FlameshotDaemon::instance(), &FlameshotDaemon::checkForUpdates); connect(FlameshotDaemon::instance(), &FlameshotDaemon::newVersionAvailable, this, [this](QVersionNumber version) { QString newVersion = tr(\"New version %1 is available\").arg(version.toString()); m_appUpdates->setText(newVersion); }); #endif QAction* quitAction = new QAction(tr(\"&Quit\"), this); connect(quitAction, &QAction::triggered, qApp, &QCoreApplication::quit); // recent screenshots QAction* recentAction = new QAction(tr(\"&Latest Uploads\"), this); connect(recentAction, &QAction::triggered, Flameshot::instance(), &Flameshot::history); m_menu->addAction(captureAction); m_menu->addAction(launcherAction); m_menu->addSeparator(); m_menu->addAction(recentAction); m_menu->addSeparator(); m_menu->addAction(configAction); m_menu->addSeparator(); #if !defined(DISABLE_UPDATE_CHECKER) m_menu->addAction(m_appUpdates); #endif m_menu->addAction(infoAction); m_menu->addSeparator(); m_menu->addAction(quitAction); } #if !defined(DISABLE_UPDATE_CHECKER) void TrayIcon::enableCheckUpdatesAction(bool enable) { if (m_appUpdates != nullptr) { m_appUpdates->setVisible(enable); m_appUpdates->setEnabled(enable); } if (enable) { FlameshotDaemon::instance()->getLatestAvailableVersion(); } } #endif void TrayIcon::startGuiCapture() { auto* widget = Flameshot::instance()->gui(); #if !defined(DISABLE_UPDATE_CHECKER) FlameshotDaemon::instance()->showUpdateNotificationIfAvailable(widget); #endif }","title":"File trayicon.cpp"},{"location":"flameshot/trayicon_8cpp_source/#file-trayiconcpp","text":"File List > src > widgets > trayicon.cpp Go to the documentation of this file. #include \"trayicon.h\" #include \"src/core/flameshot.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/utils/globalvalues.h\" #include \"src/utils/confighandler.h\" #include <QApplication> #include <QMenu> #include <QTimer> #include <QUrl> #include <QVersionNumber> #if defined(Q_OS_MACOS) #include <QOperatingSystemVersion> #endif TrayIcon::TrayIcon(QObject* parent) : QSystemTrayIcon(parent) { initMenu(); setToolTip(QStringLiteral(\"Flameshot\")); #if defined(Q_OS_MACOS) // Because of the following issues on MacOS \"Catalina\": // https://bugreports.qt.io/browse/QTBUG-86393 // https://developer.apple.com/forums/thread/126072 auto currentMacOsVersion = QOperatingSystemVersion::current(); if (currentMacOsVersion >= currentMacOsVersion.MacOSBigSur) { setContextMenu(m_menu); } #else setContextMenu(m_menu); #endif QIcon icon = QIcon::fromTheme(\"flameshot-tray\", QIcon(GlobalValues::iconPathPNG())); setIcon(icon); #if defined(Q_OS_MACOS) if (currentMacOsVersion < currentMacOsVersion.MacOSBigSur) { // Because of the following issues on MacOS \"Catalina\": // https://bugreports.qt.io/browse/QTBUG-86393 // https://developer.apple.com/forums/thread/126072 auto trayIconActivated = [this](QSystemTrayIcon::ActivationReason r) { if (m_menu->isVisible()) { m_menu->hide(); } else { m_menu->popup(QCursor::pos()); } }; connect(this, &QSystemTrayIcon::activated, this, trayIconActivated); } #else connect(this, &TrayIcon::activated, this, [this](ActivationReason r) { if (r == Trigger) { startGuiCapture(); } }); #endif #ifdef Q_OS_WIN // Ensure proper removal of tray icon when program quits on Windows. connect(qApp, &QCoreApplication::aboutToQuit, this, &TrayIcon::hide); #endif show(); // TODO needed? if (ConfigHandler().showStartupLaunchMessage()) { showMessage( \"Flameshot\", QObject::tr( \"Hello, I'm here! Click icon in the tray to take a screenshot or \" \"click with a right button to see more options.\"), icon, 3000); } connect(ConfigHandler::getInstance(), &ConfigHandler::fileChanged, this, [this]() {}); } TrayIcon::~TrayIcon() { delete m_menu; } #if !defined(DISABLE_UPDATE_CHECKER) QAction* TrayIcon::appUpdates() { return m_appUpdates; } #endif void TrayIcon::initMenu() { m_menu = new QMenu(); auto* captureAction = new QAction(tr(\"&Take Screenshot\"), this); connect(captureAction, &QAction::triggered, this, [this]() { #if defined(Q_OS_MACOS) auto currentMacOsVersion = QOperatingSystemVersion::current(); if (currentMacOsVersion >= currentMacOsVersion.MacOSBigSur) { startGuiCapture(); } else { // It seems it is not relevant for MacOS BigSur (Wait 400 ms to hide // the QMenu) QTimer::singleShot(400, this, [this]() { startGuiCapture(); }); } #else // Wait 400 ms to hide the QMenu QTimer::singleShot(400, this, [this]() { startGuiCapture(); }); #endif }); auto* launcherAction = new QAction(tr(\"&Open Launcher\"), this); connect(launcherAction, &QAction::triggered, Flameshot::instance(), &Flameshot::launcher); auto* configAction = new QAction(tr(\"&Configuration\"), this); connect(configAction, &QAction::triggered, Flameshot::instance(), &Flameshot::config); auto* infoAction = new QAction(tr(\"&About\"), this); connect( infoAction, &QAction::triggered, Flameshot::instance(), &Flameshot::info); #if !defined(DISABLE_UPDATE_CHECKER) m_appUpdates = new QAction(tr(\"Check for updates\"), this); connect(m_appUpdates, &QAction::triggered, FlameshotDaemon::instance(), &FlameshotDaemon::checkForUpdates); connect(FlameshotDaemon::instance(), &FlameshotDaemon::newVersionAvailable, this, [this](QVersionNumber version) { QString newVersion = tr(\"New version %1 is available\").arg(version.toString()); m_appUpdates->setText(newVersion); }); #endif QAction* quitAction = new QAction(tr(\"&Quit\"), this); connect(quitAction, &QAction::triggered, qApp, &QCoreApplication::quit); // recent screenshots QAction* recentAction = new QAction(tr(\"&Latest Uploads\"), this); connect(recentAction, &QAction::triggered, Flameshot::instance(), &Flameshot::history); m_menu->addAction(captureAction); m_menu->addAction(launcherAction); m_menu->addSeparator(); m_menu->addAction(recentAction); m_menu->addSeparator(); m_menu->addAction(configAction); m_menu->addSeparator(); #if !defined(DISABLE_UPDATE_CHECKER) m_menu->addAction(m_appUpdates); #endif m_menu->addAction(infoAction); m_menu->addSeparator(); m_menu->addAction(quitAction); } #if !defined(DISABLE_UPDATE_CHECKER) void TrayIcon::enableCheckUpdatesAction(bool enable) { if (m_appUpdates != nullptr) { m_appUpdates->setVisible(enable); m_appUpdates->setEnabled(enable); } if (enable) { FlameshotDaemon::instance()->getLatestAvailableVersion(); } } #endif void TrayIcon::startGuiCapture() { auto* widget = Flameshot::instance()->gui(); #if !defined(DISABLE_UPDATE_CHECKER) FlameshotDaemon::instance()->showUpdateNotificationIfAvailable(widget); #endif }","title":"File trayicon.cpp"},{"location":"flameshot/trayicon_8h/","text":"File trayicon.h # FileList > src > widgets > trayicon.h Go to the source code of this file. #include <QSystemTrayIcon> Classes # Type Name class TrayIcon","title":"File trayicon.h"},{"location":"flameshot/trayicon_8h/#file-trayiconh","text":"FileList > src > widgets > trayicon.h Go to the source code of this file. #include <QSystemTrayIcon>","title":"File trayicon.h"},{"location":"flameshot/trayicon_8h/#classes","text":"Type Name class TrayIcon","title":"Classes"},{"location":"flameshot/trayicon_8h_source/","text":"File trayicon.h # File List > src > widgets > trayicon.h Go to the documentation of this file. #include <QSystemTrayIcon> #pragma once class QAction; class TrayIcon : public QSystemTrayIcon { Q_OBJECT public: TrayIcon(QObject* parent = nullptr); virtual ~TrayIcon(); #if !defined(DISABLE_UPDATE_CHECKER) QAction* appUpdates(); #endif private: void initTrayIcon(); void initMenu(); #if !defined(DISABLE_UPDATE_CHECKER) void enableCheckUpdatesAction(bool enable); #endif void startGuiCapture(); QMenu* m_menu; #if !defined(DISABLE_UPDATE_CHECKER) QAction* m_appUpdates; #endif };","title":"File trayicon.h"},{"location":"flameshot/trayicon_8h_source/#file-trayiconh","text":"File List > src > widgets > trayicon.h Go to the documentation of this file. #include <QSystemTrayIcon> #pragma once class QAction; class TrayIcon : public QSystemTrayIcon { Q_OBJECT public: TrayIcon(QObject* parent = nullptr); virtual ~TrayIcon(); #if !defined(DISABLE_UPDATE_CHECKER) QAction* appUpdates(); #endif private: void initTrayIcon(); void initMenu(); #if !defined(DISABLE_UPDATE_CHECKER) void enableCheckUpdatesAction(bool enable); #endif void startGuiCapture(); QMenu* m_menu; #if !defined(DISABLE_UPDATE_CHECKER) QAction* m_appUpdates; #endif };","title":"File trayicon.h"},{"location":"flameshot/updatenotificationwidget_8cpp/","text":"File updatenotificationwidget.cpp # FileList > src > widgets > updatenotificationwidget.cpp Go to the source code of this file. #include \"updatenotificationwidget.h\" #include \"src/utils/confighandler.h\" #include <QDesktopServices> #include <QLabel> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> #include <QVBoxLayout> #include <QWheelEvent> #include <utility>","title":"File updatenotificationwidget.cpp"},{"location":"flameshot/updatenotificationwidget_8cpp/#file-updatenotificationwidgetcpp","text":"FileList > src > widgets > updatenotificationwidget.cpp Go to the source code of this file. #include \"updatenotificationwidget.h\" #include \"src/utils/confighandler.h\" #include <QDesktopServices> #include <QLabel> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> #include <QVBoxLayout> #include <QWheelEvent> #include <utility>","title":"File updatenotificationwidget.cpp"},{"location":"flameshot/updatenotificationwidget_8cpp_source/","text":"File updatenotificationwidget.cpp # File List > src > widgets > updatenotificationwidget.cpp Go to the documentation of this file. // // Created by yuriypuchkov on 09.12.2020. // #include \"updatenotificationwidget.h\" #include \"src/utils/confighandler.h\" #include <QDesktopServices> #include <QLabel> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> #include <QVBoxLayout> #include <QWheelEvent> #include <utility> UpdateNotificationWidget::UpdateNotificationWidget( QWidget* parent, const QString& appLatestVersion, QString appLatestUrl) : QWidget(parent) , m_appLatestVersion(appLatestVersion) , m_appLatestUrl(std::move(appLatestUrl)) , m_layout(nullptr) { setMinimumSize(400, 100); initInternalPanel(); setAttribute(Qt::WA_TransparentForMouseEvents); setCursor(Qt::ArrowCursor); m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_hideAnimation->setDuration(300); connect(m_hideAnimation, &QPropertyAnimation::finished, m_internalPanel, &QWidget::hide); setAppLatestVersion(appLatestVersion); } void UpdateNotificationWidget::show() { setAttribute(Qt::WA_TransparentForMouseEvents, false); m_showAnimation->setStartValue(QRect(0, -height(), width(), height())); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_internalPanel->show(); m_showAnimation->start(); QWidget::show(); } void UpdateNotificationWidget::hide() { setAttribute(Qt::WA_TransparentForMouseEvents); m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(0, -height(), 0, height())); m_hideAnimation->start(); m_internalPanel->hide(); QWidget::hide(); } void UpdateNotificationWidget::setAppLatestVersion(const QString& latestVersion) { m_appLatestVersion = latestVersion; QString newVersion = tr(\"New Flameshot version %1 is available\").arg(latestVersion); m_notification->setText(newVersion); } void UpdateNotificationWidget::laterButton() { hide(); } void UpdateNotificationWidget::ignoreButton() { ConfigHandler().setIgnoreUpdateToVersion(m_appLatestVersion); hide(); } void UpdateNotificationWidget::updateButton() { QDesktopServices::openUrl(m_appLatestUrl); hide(); if (parentWidget()) { parentWidget()->close(); } } void UpdateNotificationWidget::initInternalPanel() { m_internalPanel = new QScrollArea(this); m_internalPanel->setAttribute(Qt::WA_NoMousePropagation); auto* widget = new QWidget(); m_internalPanel->setWidget(widget); m_internalPanel->setWidgetResizable(true); QColor bgColor = palette().window().color(); bgColor.setAlphaF(0.0); m_internalPanel->setStyleSheet( QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name())); m_internalPanel->hide(); // m_layout = new QVBoxLayout(); widget->setLayout(m_layout); // caption m_notification = new QLabel(m_appLatestVersion, this); m_layout->addWidget(m_notification); // buttons layout auto* buttonsLayout = new QHBoxLayout(); auto* bottonsSpacer = new QSpacerItem(1, 1, QSizePolicy::Expanding); buttonsLayout->addSpacerItem(bottonsSpacer); m_layout->addLayout(buttonsLayout); // ignore auto* ignoreBtn = new QPushButton(tr(\"Ignore\"), this); buttonsLayout->addWidget(ignoreBtn); connect(ignoreBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::ignoreButton); // later auto* laterBtn = new QPushButton(tr(\"Later\"), this); buttonsLayout->addWidget(laterBtn); connect(laterBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::laterButton); // update auto* updateBtn = new QPushButton(tr(\"Update\"), this); buttonsLayout->addWidget(updateBtn); connect(updateBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::updateButton); }","title":"File updatenotificationwidget.cpp"},{"location":"flameshot/updatenotificationwidget_8cpp_source/#file-updatenotificationwidgetcpp","text":"File List > src > widgets > updatenotificationwidget.cpp Go to the documentation of this file. // // Created by yuriypuchkov on 09.12.2020. // #include \"updatenotificationwidget.h\" #include \"src/utils/confighandler.h\" #include <QDesktopServices> #include <QLabel> #include <QPropertyAnimation> #include <QPushButton> #include <QScrollArea> #include <QTimer> #include <QVBoxLayout> #include <QWheelEvent> #include <utility> UpdateNotificationWidget::UpdateNotificationWidget( QWidget* parent, const QString& appLatestVersion, QString appLatestUrl) : QWidget(parent) , m_appLatestVersion(appLatestVersion) , m_appLatestUrl(std::move(appLatestUrl)) , m_layout(nullptr) { setMinimumSize(400, 100); initInternalPanel(); setAttribute(Qt::WA_TransparentForMouseEvents); setCursor(Qt::ArrowCursor); m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_showAnimation->setDuration(300); m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this); m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad); m_hideAnimation->setDuration(300); connect(m_hideAnimation, &QPropertyAnimation::finished, m_internalPanel, &QWidget::hide); setAppLatestVersion(appLatestVersion); } void UpdateNotificationWidget::show() { setAttribute(Qt::WA_TransparentForMouseEvents, false); m_showAnimation->setStartValue(QRect(0, -height(), width(), height())); m_showAnimation->setEndValue(QRect(0, 0, width(), height())); m_internalPanel->show(); m_showAnimation->start(); QWidget::show(); } void UpdateNotificationWidget::hide() { setAttribute(Qt::WA_TransparentForMouseEvents); m_hideAnimation->setStartValue(QRect(0, 0, width(), height())); m_hideAnimation->setEndValue(QRect(0, -height(), 0, height())); m_hideAnimation->start(); m_internalPanel->hide(); QWidget::hide(); } void UpdateNotificationWidget::setAppLatestVersion(const QString& latestVersion) { m_appLatestVersion = latestVersion; QString newVersion = tr(\"New Flameshot version %1 is available\").arg(latestVersion); m_notification->setText(newVersion); } void UpdateNotificationWidget::laterButton() { hide(); } void UpdateNotificationWidget::ignoreButton() { ConfigHandler().setIgnoreUpdateToVersion(m_appLatestVersion); hide(); } void UpdateNotificationWidget::updateButton() { QDesktopServices::openUrl(m_appLatestUrl); hide(); if (parentWidget()) { parentWidget()->close(); } } void UpdateNotificationWidget::initInternalPanel() { m_internalPanel = new QScrollArea(this); m_internalPanel->setAttribute(Qt::WA_NoMousePropagation); auto* widget = new QWidget(); m_internalPanel->setWidget(widget); m_internalPanel->setWidgetResizable(true); QColor bgColor = palette().window().color(); bgColor.setAlphaF(0.0); m_internalPanel->setStyleSheet( QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name())); m_internalPanel->hide(); // m_layout = new QVBoxLayout(); widget->setLayout(m_layout); // caption m_notification = new QLabel(m_appLatestVersion, this); m_layout->addWidget(m_notification); // buttons layout auto* buttonsLayout = new QHBoxLayout(); auto* bottonsSpacer = new QSpacerItem(1, 1, QSizePolicy::Expanding); buttonsLayout->addSpacerItem(bottonsSpacer); m_layout->addLayout(buttonsLayout); // ignore auto* ignoreBtn = new QPushButton(tr(\"Ignore\"), this); buttonsLayout->addWidget(ignoreBtn); connect(ignoreBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::ignoreButton); // later auto* laterBtn = new QPushButton(tr(\"Later\"), this); buttonsLayout->addWidget(laterBtn); connect(laterBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::laterButton); // update auto* updateBtn = new QPushButton(tr(\"Update\"), this); buttonsLayout->addWidget(updateBtn); connect(updateBtn, &QPushButton::clicked, this, &UpdateNotificationWidget::updateButton); }","title":"File updatenotificationwidget.cpp"},{"location":"flameshot/updatenotificationwidget_8h/","text":"File updatenotificationwidget.h # FileList > src > widgets > updatenotificationwidget.h Go to the source code of this file. #include <QPointer> #include <QWidget> Classes # Type Name class UpdateNotificationWidget","title":"File updatenotificationwidget.h"},{"location":"flameshot/updatenotificationwidget_8h/#file-updatenotificationwidgeth","text":"FileList > src > widgets > updatenotificationwidget.h Go to the source code of this file. #include <QPointer> #include <QWidget>","title":"File updatenotificationwidget.h"},{"location":"flameshot/updatenotificationwidget_8h/#classes","text":"Type Name class UpdateNotificationWidget","title":"Classes"},{"location":"flameshot/updatenotificationwidget_8h_source/","text":"File updatenotificationwidget.h # File List > src > widgets > updatenotificationwidget.h Go to the documentation of this file. // // Created by yuriypuchkov on 09.12.2020. // #ifndef FLAMESHOT_UPDATENOTIFICATIONWIDGET_H #define FLAMESHOT_UPDATENOTIFICATIONWIDGET_H #include <QPointer> #include <QWidget> class QVBoxLayout; class QPropertyAnimation; class QScrollArea; class QPushButton; class QLabel; class UpdateNotificationWidget : public QWidget { Q_OBJECT public: explicit UpdateNotificationWidget(QWidget* parent, const QString& appLatestVersion, QString appLatestUrl); void setAppLatestVersion(const QString& latestVersion); void hide(); void show(); public slots: void ignoreButton(); void laterButton(); void updateButton(); private: void initInternalPanel(); // class members QString m_appLatestVersion; QString m_appLatestUrl; QVBoxLayout* m_layout; QLabel* m_notification; QScrollArea* m_internalPanel; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; }; #endif // FLAMESHOT_UPDATENOTIFICATIONWIDGET_H","title":"File updatenotificationwidget.h"},{"location":"flameshot/updatenotificationwidget_8h_source/#file-updatenotificationwidgeth","text":"File List > src > widgets > updatenotificationwidget.h Go to the documentation of this file. // // Created by yuriypuchkov on 09.12.2020. // #ifndef FLAMESHOT_UPDATENOTIFICATIONWIDGET_H #define FLAMESHOT_UPDATENOTIFICATIONWIDGET_H #include <QPointer> #include <QWidget> class QVBoxLayout; class QPropertyAnimation; class QScrollArea; class QPushButton; class QLabel; class UpdateNotificationWidget : public QWidget { Q_OBJECT public: explicit UpdateNotificationWidget(QWidget* parent, const QString& appLatestVersion, QString appLatestUrl); void setAppLatestVersion(const QString& latestVersion); void hide(); void show(); public slots: void ignoreButton(); void laterButton(); void updateButton(); private: void initInternalPanel(); // class members QString m_appLatestVersion; QString m_appLatestUrl; QVBoxLayout* m_layout; QLabel* m_notification; QScrollArea* m_internalPanel; QPropertyAnimation* m_showAnimation; QPropertyAnimation* m_hideAnimation; }; #endif // FLAMESHOT_UPDATENOTIFICATIONWIDGET_H","title":"File updatenotificationwidget.h"},{"location":"flameshot/uploadhistory_8cpp/","text":"File uploadhistory.cpp # FileList > src > widgets > uploadhistory.cpp Go to the source code of this file. #include \"uploadhistory.h\" #include \"./ui_uploadhistory.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"uploadlineitem.h\" #include <QDateTime> #include <QDesktopWidget> #include <QFileInfo> #include <QPixmap> Public Functions # Type Name void clearHistoryLayout (QLayout * layout) void scaleThumbnail (QPixmap & pixmap) Public Functions Documentation # function clearHistoryLayout # void clearHistoryLayout ( QLayout * layout ) function scaleThumbnail # void scaleThumbnail ( QPixmap & pixmap )","title":"File uploadhistory.cpp"},{"location":"flameshot/uploadhistory_8cpp/#file-uploadhistorycpp","text":"FileList > src > widgets > uploadhistory.cpp Go to the source code of this file. #include \"uploadhistory.h\" #include \"./ui_uploadhistory.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"uploadlineitem.h\" #include <QDateTime> #include <QDesktopWidget> #include <QFileInfo> #include <QPixmap>","title":"File uploadhistory.cpp"},{"location":"flameshot/uploadhistory_8cpp/#public-functions","text":"Type Name void clearHistoryLayout (QLayout * layout) void scaleThumbnail (QPixmap & pixmap)","title":"Public Functions"},{"location":"flameshot/uploadhistory_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/uploadhistory_8cpp/#function-clearhistorylayout","text":"void clearHistoryLayout ( QLayout * layout )","title":"function clearHistoryLayout"},{"location":"flameshot/uploadhistory_8cpp/#function-scalethumbnail","text":"void scaleThumbnail ( QPixmap & pixmap )","title":"function scaleThumbnail"},{"location":"flameshot/uploadhistory_8cpp_source/","text":"File uploadhistory.cpp # File List > src > widgets > uploadhistory.cpp Go to the documentation of this file. #include \"uploadhistory.h\" #include \"./ui_uploadhistory.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"uploadlineitem.h\" #include <QDateTime> #include <QDesktopWidget> #include <QFileInfo> #include <QPixmap> void scaleThumbnail(QPixmap& pixmap) { if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT >= pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) { pixmap = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT, Qt::SmoothTransformation); } else { pixmap = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH, Qt::SmoothTransformation); } } void clearHistoryLayout(QLayout* layout) { while (layout->count() != 0) { delete layout->takeAt(0); } } UploadHistory::UploadHistory(QWidget* parent) : QWidget(parent) , ui(new Ui::UploadHistory) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint); resize(QDesktopWidget().availableGeometry(this).size() * 0.5); } void UploadHistory::loadHistory() { clearHistoryLayout(ui->historyContainer); History history = History(); QList<QString> historyFiles = history.history(); if (historyFiles.isEmpty()) { setEmptyMessage(); } else { foreach (QString fileName, historyFiles) { addLine(history.path(), fileName); } } } void UploadHistory::setEmptyMessage() { auto* buttonEmpty = new QPushButton; buttonEmpty->setText(tr(\"Screenshots history is empty\")); buttonEmpty->setMinimumSize(1, HISTORYPIXMAP_MAX_PREVIEW_HEIGHT); connect(buttonEmpty, &QPushButton::clicked, this, [=]() { this->close(); }); ui->historyContainer->addWidget(buttonEmpty); } void UploadHistory::addLine(const QString& path, const QString& fileName) { QString fullFileName = path + fileName; History history; HistoryFileName unpackFileName = history.unpackFileName(fileName); QString url = ImgUploaderManager(this).url() + unpackFileName.file; // load pixmap QPixmap pixmap; pixmap.load(fullFileName, \"png\"); scaleThumbnail(pixmap); // get file info auto fileInfo = QFileInfo(fullFileName); QString lastModified = fileInfo.lastModified().toString(\"yyyy-MM-dd\\nhh:mm:ss\"); auto* line = new UploadLineItem( this, pixmap, lastModified, url, fullFileName, unpackFileName); connect(line, &UploadLineItem::requestedDeletion, this, [=]() { if (ui->historyContainer->count() <= 1) { setEmptyMessage(); } delete line; }); ui->historyContainer->addWidget(line); } UploadHistory::~UploadHistory() { delete ui; }","title":"File uploadhistory.cpp"},{"location":"flameshot/uploadhistory_8cpp_source/#file-uploadhistorycpp","text":"File List > src > widgets > uploadhistory.cpp Go to the documentation of this file. #include \"uploadhistory.h\" #include \"./ui_uploadhistory.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"uploadlineitem.h\" #include <QDateTime> #include <QDesktopWidget> #include <QFileInfo> #include <QPixmap> void scaleThumbnail(QPixmap& pixmap) { if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT >= pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) { pixmap = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT, Qt::SmoothTransformation); } else { pixmap = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH, Qt::SmoothTransformation); } } void clearHistoryLayout(QLayout* layout) { while (layout->count() != 0) { delete layout->takeAt(0); } } UploadHistory::UploadHistory(QWidget* parent) : QWidget(parent) , ui(new Ui::UploadHistory) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint); resize(QDesktopWidget().availableGeometry(this).size() * 0.5); } void UploadHistory::loadHistory() { clearHistoryLayout(ui->historyContainer); History history = History(); QList<QString> historyFiles = history.history(); if (historyFiles.isEmpty()) { setEmptyMessage(); } else { foreach (QString fileName, historyFiles) { addLine(history.path(), fileName); } } } void UploadHistory::setEmptyMessage() { auto* buttonEmpty = new QPushButton; buttonEmpty->setText(tr(\"Screenshots history is empty\")); buttonEmpty->setMinimumSize(1, HISTORYPIXMAP_MAX_PREVIEW_HEIGHT); connect(buttonEmpty, &QPushButton::clicked, this, [=]() { this->close(); }); ui->historyContainer->addWidget(buttonEmpty); } void UploadHistory::addLine(const QString& path, const QString& fileName) { QString fullFileName = path + fileName; History history; HistoryFileName unpackFileName = history.unpackFileName(fileName); QString url = ImgUploaderManager(this).url() + unpackFileName.file; // load pixmap QPixmap pixmap; pixmap.load(fullFileName, \"png\"); scaleThumbnail(pixmap); // get file info auto fileInfo = QFileInfo(fullFileName); QString lastModified = fileInfo.lastModified().toString(\"yyyy-MM-dd\\nhh:mm:ss\"); auto* line = new UploadLineItem( this, pixmap, lastModified, url, fullFileName, unpackFileName); connect(line, &UploadLineItem::requestedDeletion, this, [=]() { if (ui->historyContainer->count() <= 1) { setEmptyMessage(); } delete line; }); ui->historyContainer->addWidget(line); } UploadHistory::~UploadHistory() { delete ui; }","title":"File uploadhistory.cpp"},{"location":"flameshot/uploadhistory_8h/","text":"File uploadhistory.h # FileList > src > widgets > uploadhistory.h Go to the source code of this file. #include <QWidget> Namespaces # Type Name namespace Ui Classes # Type Name class UploadHistory Public Functions # Type Name QT_END_NAMESPACE void clearHistoryLayout (QLayout * layout) void scaleThumbnail (QPixmap & input) Public Functions Documentation # function clearHistoryLayout # QT_END_NAMESPACE void clearHistoryLayout ( QLayout * layout ) function scaleThumbnail # void scaleThumbnail ( QPixmap & input )","title":"File uploadhistory.h"},{"location":"flameshot/uploadhistory_8h/#file-uploadhistoryh","text":"FileList > src > widgets > uploadhistory.h Go to the source code of this file. #include <QWidget>","title":"File uploadhistory.h"},{"location":"flameshot/uploadhistory_8h/#namespaces","text":"Type Name namespace Ui","title":"Namespaces"},{"location":"flameshot/uploadhistory_8h/#classes","text":"Type Name class UploadHistory","title":"Classes"},{"location":"flameshot/uploadhistory_8h/#public-functions","text":"Type Name QT_END_NAMESPACE void clearHistoryLayout (QLayout * layout) void scaleThumbnail (QPixmap & input)","title":"Public Functions"},{"location":"flameshot/uploadhistory_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/uploadhistory_8h/#function-clearhistorylayout","text":"QT_END_NAMESPACE void clearHistoryLayout ( QLayout * layout )","title":"function clearHistoryLayout"},{"location":"flameshot/uploadhistory_8h/#function-scalethumbnail","text":"void scaleThumbnail ( QPixmap & input )","title":"function scaleThumbnail"},{"location":"flameshot/uploadhistory_8h_source/","text":"File uploadhistory.h # File List > src > widgets > uploadhistory.h Go to the documentation of this file. #ifndef UPLOADHISTORY_H #define UPLOADHISTORY_H #include <QWidget> QT_BEGIN_NAMESPACE namespace Ui { class UploadHistory; } QT_END_NAMESPACE void clearHistoryLayout(QLayout* layout); void scaleThumbnail(QPixmap& input); class UploadHistory : public QWidget { Q_OBJECT public: explicit UploadHistory(QWidget* parent = nullptr); ~UploadHistory(); void loadHistory(); public slots: private: void setEmptyMessage(); void addLine(QString const&, QString const&); Ui::UploadHistory* ui; }; #endif // UPLOADHISTORY_H","title":"File uploadhistory.h"},{"location":"flameshot/uploadhistory_8h_source/#file-uploadhistoryh","text":"File List > src > widgets > uploadhistory.h Go to the documentation of this file. #ifndef UPLOADHISTORY_H #define UPLOADHISTORY_H #include <QWidget> QT_BEGIN_NAMESPACE namespace Ui { class UploadHistory; } QT_END_NAMESPACE void clearHistoryLayout(QLayout* layout); void scaleThumbnail(QPixmap& input); class UploadHistory : public QWidget { Q_OBJECT public: explicit UploadHistory(QWidget* parent = nullptr); ~UploadHistory(); void loadHistory(); public slots: private: void setEmptyMessage(); void addLine(QString const&, QString const&); Ui::UploadHistory* ui; }; #endif // UPLOADHISTORY_H","title":"File uploadhistory.h"},{"location":"flameshot/uploadlineitem_8cpp/","text":"File uploadlineitem.cpp # FileList > src > widgets > uploadlineitem.cpp Go to the source code of this file. #include \"uploadlineitem.h\" #include \"./ui_uploadlineitem.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/notificationwidget.h\" #include <QDesktopServices> #include <QFileInfo> #include <QMessageBox> #include <QUrl> #include <QWidget> Public Functions # Type Name void removeCacheFile (QString const & fullFileName) Public Functions Documentation # function removeCacheFile # void removeCacheFile ( QString const & fullFileName )","title":"File uploadlineitem.cpp"},{"location":"flameshot/uploadlineitem_8cpp/#file-uploadlineitemcpp","text":"FileList > src > widgets > uploadlineitem.cpp Go to the source code of this file. #include \"uploadlineitem.h\" #include \"./ui_uploadlineitem.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/notificationwidget.h\" #include <QDesktopServices> #include <QFileInfo> #include <QMessageBox> #include <QUrl> #include <QWidget>","title":"File uploadlineitem.cpp"},{"location":"flameshot/uploadlineitem_8cpp/#public-functions","text":"Type Name void removeCacheFile (QString const & fullFileName)","title":"Public Functions"},{"location":"flameshot/uploadlineitem_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/uploadlineitem_8cpp/#function-removecachefile","text":"void removeCacheFile ( QString const & fullFileName )","title":"function removeCacheFile"},{"location":"flameshot/uploadlineitem_8cpp_source/","text":"File uploadlineitem.cpp # File List > src > widgets > uploadlineitem.cpp Go to the documentation of this file. #include \"uploadlineitem.h\" #include \"./ui_uploadlineitem.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/notificationwidget.h\" #include <QDesktopServices> #include <QFileInfo> #include <QMessageBox> #include <QUrl> #include <QWidget> void removeCacheFile(QString const& fullFileName) { QFile file(fullFileName); if (file.exists()) { file.remove(); } } UploadLineItem::UploadLineItem(QWidget* parent, QPixmap const& preview, QString const& timestamp, QString const& url, QString const& fullFileName, HistoryFileName const& unpackFileName) : QWidget(parent) , ui(new Ui::UploadLineItem) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); ui->imagePreview->setPixmap(preview); ui->uploadTimestamp->setText(timestamp); connect(ui->copyUrl, &QPushButton::clicked, this, [=]() { FlameshotDaemon::copyToClipboard(url); }); connect(ui->openBrowser, &QPushButton::clicked, this, [=]() { QDesktopServices::openUrl(QUrl(url)); }); connect(ui->deleteImage, &QPushButton::clicked, this, [=]() { if (ConfigHandler().historyConfirmationToDelete() && QMessageBox::No == QMessageBox::question( this, tr(\"Confirm to delete\"), tr(\"Are you sure you want to delete a screenshot from the \" \"latest uploads and server?\"), QMessageBox::Yes | QMessageBox::No)) { return; } ImgUploaderBase* imgUploaderBase = ImgUploaderManager(this).uploader(unpackFileName.type); imgUploaderBase->deleteImage(unpackFileName.file, unpackFileName.token); removeCacheFile(fullFileName); emit requestedDeletion(); }); } UploadLineItem::~UploadLineItem() { delete ui; }","title":"File uploadlineitem.cpp"},{"location":"flameshot/uploadlineitem_8cpp_source/#file-uploadlineitemcpp","text":"File List > src > widgets > uploadlineitem.cpp Go to the documentation of this file. #include \"uploadlineitem.h\" #include \"./ui_uploadlineitem.h\" #include \"src/core/flameshotdaemon.h\" #include \"src/tools/imgupload/imguploadermanager.h\" #include \"src/utils/confighandler.h\" #include \"src/utils/history.h\" #include \"src/widgets/notificationwidget.h\" #include <QDesktopServices> #include <QFileInfo> #include <QMessageBox> #include <QUrl> #include <QWidget> void removeCacheFile(QString const& fullFileName) { QFile file(fullFileName); if (file.exists()) { file.remove(); } } UploadLineItem::UploadLineItem(QWidget* parent, QPixmap const& preview, QString const& timestamp, QString const& url, QString const& fullFileName, HistoryFileName const& unpackFileName) : QWidget(parent) , ui(new Ui::UploadLineItem) { ui->setupUi(this); setAttribute(Qt::WA_DeleteOnClose); ui->imagePreview->setPixmap(preview); ui->uploadTimestamp->setText(timestamp); connect(ui->copyUrl, &QPushButton::clicked, this, [=]() { FlameshotDaemon::copyToClipboard(url); }); connect(ui->openBrowser, &QPushButton::clicked, this, [=]() { QDesktopServices::openUrl(QUrl(url)); }); connect(ui->deleteImage, &QPushButton::clicked, this, [=]() { if (ConfigHandler().historyConfirmationToDelete() && QMessageBox::No == QMessageBox::question( this, tr(\"Confirm to delete\"), tr(\"Are you sure you want to delete a screenshot from the \" \"latest uploads and server?\"), QMessageBox::Yes | QMessageBox::No)) { return; } ImgUploaderBase* imgUploaderBase = ImgUploaderManager(this).uploader(unpackFileName.type); imgUploaderBase->deleteImage(unpackFileName.file, unpackFileName.token); removeCacheFile(fullFileName); emit requestedDeletion(); }); } UploadLineItem::~UploadLineItem() { delete ui; }","title":"File uploadlineitem.cpp"},{"location":"flameshot/uploadlineitem_8h/","text":"File uploadlineitem.h # FileList > src > widgets > uploadlineitem.h Go to the source code of this file. #include <QWidget> Namespaces # Type Name namespace Ui Classes # Type Name class UploadLineItem Public Functions # Type Name QT_END_NAMESPACE void removeCacheFile (QString const & fullFileName) Public Functions Documentation # function removeCacheFile # QT_END_NAMESPACE void removeCacheFile ( QString const & fullFileName )","title":"File uploadlineitem.h"},{"location":"flameshot/uploadlineitem_8h/#file-uploadlineitemh","text":"FileList > src > widgets > uploadlineitem.h Go to the source code of this file. #include <QWidget>","title":"File uploadlineitem.h"},{"location":"flameshot/uploadlineitem_8h/#namespaces","text":"Type Name namespace Ui","title":"Namespaces"},{"location":"flameshot/uploadlineitem_8h/#classes","text":"Type Name class UploadLineItem","title":"Classes"},{"location":"flameshot/uploadlineitem_8h/#public-functions","text":"Type Name QT_END_NAMESPACE void removeCacheFile (QString const & fullFileName)","title":"Public Functions"},{"location":"flameshot/uploadlineitem_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"flameshot/uploadlineitem_8h/#function-removecachefile","text":"QT_END_NAMESPACE void removeCacheFile ( QString const & fullFileName )","title":"function removeCacheFile"},{"location":"flameshot/uploadlineitem_8h_source/","text":"File uploadlineitem.h # File List > src > widgets > uploadlineitem.h Go to the documentation of this file. #ifndef UPLOADLINEITEM_H #define UPLOADLINEITEM_H #include <QWidget> struct HistoryFileName; QT_BEGIN_NAMESPACE namespace Ui { class UploadLineItem; } QT_END_NAMESPACE void removeCacheFile(QString const& fullFileName); class UploadLineItem : public QWidget { Q_OBJECT public: UploadLineItem(QWidget* parent, QPixmap const& preview, QString const& timestamp, QString const& url, QString const& fullFileName, HistoryFileName const& unpackFileName); ~UploadLineItem(); signals: void requestedDeletion(); private: Ui::UploadLineItem* ui; }; #endif // UPLOADLINEITEM_H","title":"File uploadlineitem.h"},{"location":"flameshot/uploadlineitem_8h_source/#file-uploadlineitemh","text":"File List > src > widgets > uploadlineitem.h Go to the documentation of this file. #ifndef UPLOADLINEITEM_H #define UPLOADLINEITEM_H #include <QWidget> struct HistoryFileName; QT_BEGIN_NAMESPACE namespace Ui { class UploadLineItem; } QT_END_NAMESPACE void removeCacheFile(QString const& fullFileName); class UploadLineItem : public QWidget { Q_OBJECT public: UploadLineItem(QWidget* parent, QPixmap const& preview, QString const& timestamp, QString const& url, QString const& fullFileName, HistoryFileName const& unpackFileName); ~UploadLineItem(); signals: void requestedDeletion(); private: Ui::UploadLineItem* ui; }; #endif // UPLOADLINEITEM_H","title":"File uploadlineitem.h"},{"location":"flameshot/namespaces/","text":"Namespace List # Here is a list of all namespaces with brief descriptions: namespace @103 namespace @2 namespace @57 namespace @61 namespace @67 namespace @85 namespace @91 namespace ColorUtils namespace GlobalValues namespace PathInfo namespace Ui namespace org namespace freedesktop namespace portal namespace strfparse","title":"Namespace List"},{"location":"flameshot/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace @103 namespace @2 namespace @57 namespace @61 namespace @67 namespace @85 namespace @91 namespace ColorUtils namespace GlobalValues namespace PathInfo namespace Ui namespace org namespace freedesktop namespace portal namespace strfparse","title":"Namespace List"},{"location":"flameshot/classes/","text":"Class Index # a # AbstractActionTool AbstractLogger AbstractPathTool AbstractTwoPointTool AcceptTool AppLauncher AppLauncherWidget ArrowTool b # Bool BoundedInt ButtonHandler ButtonList ButtonListView c # CaptureButton CaptureLauncher CaptureRequest CaptureToolButton CaptureToolObjects CaptureWidget CircleCountTool CircleTool ClickableLabel Color ColorGrabWidget ColorPicker ColorPickerEditMode ColorPickerEditor ColorPickerWidget CommandArgument CommandLineParser CommandOption ConfigErrorDetails ConfigHandler ConfigResolver ConfigWindow CopyTool CaptureContext CompareAppByName d # DesktopInfo DraggableWidgetMaker DesktopAppData DesktopFileParser e # ExistingDir ExitTool ExtendedSlider f # FileNameEditor FileNameHandler FilenamePattern Flameshot FlameshotDBusAdapter FlameshotDaemon g # GeneralConf GlobalShortcutFilter h # History HoverEventFilter HistoryFileName i # ImageLabel ImgUploadDialog ImgUploaderBase ImgUploaderManager ImgUploaderTool ImgurUploader InfoWindow InvertTool k # KeySequence l # LauncherItemDelegate LineTool LoadSpinner LowerBoundedInt m # MagnifierWidget MarkerTool ModificationCommand MoveTool n # NotificationWidget NotifierBox Node o # OrgFreedesktopPortalRequestInterface OrientablePushButton OverlayMessage p # PencilTool PinTool PinWidget PixelateTool q # QGuiAppCurrentScreen QSharedPointer r # RectangleTool RedoTool Region s # SaveFileExtension SaveTool ScreenGrabber SelectionTool SelectionWidget SetShortcutDialog ShortcutsWidget SidePanelWidget SizeDecreaseTool SizeIncreaseTool StrftimeChooserWidget String StyleOverride SystemNotification t # TerminalLauncher TextConfig TextTool TextWidget ToolFactory TrayIcon TerminalApp u # UIcolorEditor UndoTool UpdateNotificationWidget UploadHistory UploadLineItem UserColors UtilityPanel v # ValueHandler VisualsEditor w # WaylandUtils WinLnkFileParser","title":"Classes"},{"location":"flameshot/classes/#class-index","text":"","title":"Class Index"},{"location":"flameshot/classes/#a","text":"AbstractActionTool AbstractLogger AbstractPathTool AbstractTwoPointTool AcceptTool AppLauncher AppLauncherWidget ArrowTool","title":"a"},{"location":"flameshot/classes/#b","text":"Bool BoundedInt ButtonHandler ButtonList ButtonListView","title":"b"},{"location":"flameshot/classes/#c","text":"CaptureButton CaptureLauncher CaptureRequest CaptureToolButton CaptureToolObjects CaptureWidget CircleCountTool CircleTool ClickableLabel Color ColorGrabWidget ColorPicker ColorPickerEditMode ColorPickerEditor ColorPickerWidget CommandArgument CommandLineParser CommandOption ConfigErrorDetails ConfigHandler ConfigResolver ConfigWindow CopyTool CaptureContext CompareAppByName","title":"c"},{"location":"flameshot/classes/#d","text":"DesktopInfo DraggableWidgetMaker DesktopAppData DesktopFileParser","title":"d"},{"location":"flameshot/classes/#e","text":"ExistingDir ExitTool ExtendedSlider","title":"e"},{"location":"flameshot/classes/#f","text":"FileNameEditor FileNameHandler FilenamePattern Flameshot FlameshotDBusAdapter FlameshotDaemon","title":"f"},{"location":"flameshot/classes/#g","text":"GeneralConf GlobalShortcutFilter","title":"g"},{"location":"flameshot/classes/#h","text":"History HoverEventFilter HistoryFileName","title":"h"},{"location":"flameshot/classes/#i","text":"ImageLabel ImgUploadDialog ImgUploaderBase ImgUploaderManager ImgUploaderTool ImgurUploader InfoWindow InvertTool","title":"i"},{"location":"flameshot/classes/#k","text":"KeySequence","title":"k"},{"location":"flameshot/classes/#l","text":"LauncherItemDelegate LineTool LoadSpinner LowerBoundedInt","title":"l"},{"location":"flameshot/classes/#m","text":"MagnifierWidget MarkerTool ModificationCommand MoveTool","title":"m"},{"location":"flameshot/classes/#n","text":"NotificationWidget NotifierBox Node","title":"n"},{"location":"flameshot/classes/#o","text":"OrgFreedesktopPortalRequestInterface OrientablePushButton OverlayMessage","title":"o"},{"location":"flameshot/classes/#p","text":"PencilTool PinTool PinWidget PixelateTool","title":"p"},{"location":"flameshot/classes/#q","text":"QGuiAppCurrentScreen QSharedPointer","title":"q"},{"location":"flameshot/classes/#r","text":"RectangleTool RedoTool Region","title":"r"},{"location":"flameshot/classes/#s","text":"SaveFileExtension SaveTool ScreenGrabber SelectionTool SelectionWidget SetShortcutDialog ShortcutsWidget SidePanelWidget SizeDecreaseTool SizeIncreaseTool StrftimeChooserWidget String StyleOverride SystemNotification","title":"s"},{"location":"flameshot/classes/#t","text":"TerminalLauncher TextConfig TextTool TextWidget ToolFactory TrayIcon TerminalApp","title":"t"},{"location":"flameshot/classes/#u","text":"UIcolorEditor UndoTool UpdateNotificationWidget UploadHistory UploadLineItem UserColors UtilityPanel","title":"u"},{"location":"flameshot/classes/#v","text":"ValueHandler VisualsEditor","title":"v"},{"location":"flameshot/classes/#w","text":"WaylandUtils WinLnkFileParser","title":"w"},{"location":"flameshot/hierarchy/","text":"Class Hierarchy # This inheritance list is sorted roughly, but not completely, alphabetically: class AbstractLogger A class that allows you to log events to where they need to go. class ValueHandler Handles the value of a configuration option (abstract class). class Bool class BoundedInt class ButtonList class Color class ExistingDir class FilenamePattern class KeySequence class LowerBoundedInt class Region class SaveFileExtension class String class UserColors class CaptureRequest class CommandArgument class CommandLineParser class CommandOption class DesktopInfo class History class QGuiAppCurrentScreen class QSharedPointer class WaylandUtils struct CaptureContext struct CommandLineParser::Node struct CompareAppByName struct DesktopAppData struct DesktopFileParser struct HistoryFileName struct TerminalApp struct WinLnkFileParser class CaptureTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractPathTool class PencilTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractPathTool class PencilTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class TextTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class QWidget class AppLauncherWidget class CaptureWidget class ColorGrabWidget class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ColorPickerEditor class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ConfigWindow class FileNameEditor class GeneralConf class ImgUploaderBase class ImgurUploader class ImgUploaderBase class ImgurUploader class InfoWindow class LoadSpinner class MagnifierWidget class NotificationWidget class NotifierBox class PinWidget class SelectionWidget class ShortcutsWidget class SidePanelWidget class StrftimeChooserWidget class TextConfig class UIcolorEditor class UpdateNotificationWidget class UploadHistory class UploadLineItem class UtilityPanel class VisualsEditor class QObject class ButtonHandler class CaptureToolObjects class ConfigHandler class DraggableWidgetMaker class FileNameHandler class Flameshot class FlameshotDaemon class GlobalShortcutFilter class HoverEventFilter class ImgUploaderManager class ScreenGrabber class SystemNotification class TerminalLauncher class ToolFactory class QListWidget class ButtonListView class QPushButton class CaptureButton class CaptureToolButton class OrientablePushButton class CaptureButton class CaptureToolButton class OrientablePushButton class CaptureButton class CaptureToolButton class OrientablePushButton class QDialog class CaptureLauncher class ConfigErrorDetails class ConfigResolver class ImgUploadDialog class SetShortcutDialog class QLabel class ClickableLabel class ImageLabel class OverlayMessage Overlay a message in capture mode. class QSlider class ExtendedSlider class QDBusAbstractAdaptor class FlameshotDBusAdapter class QAbstractNativeEventFilter class GlobalShortcutFilter class QStyledItemDelegate class LauncherItemDelegate class QUndoCommand class ModificationCommand class QDBusAbstractInterface class OrgFreedesktopPortalRequestInterface class QProxyStyle class StyleOverride class QTextEdit class TextWidget class QSystemTrayIcon class TrayIcon","title":"Class Hierarchy"},{"location":"flameshot/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class AbstractLogger A class that allows you to log events to where they need to go. class ValueHandler Handles the value of a configuration option (abstract class). class Bool class BoundedInt class ButtonList class Color class ExistingDir class FilenamePattern class KeySequence class LowerBoundedInt class Region class SaveFileExtension class String class UserColors class CaptureRequest class CommandArgument class CommandLineParser class CommandOption class DesktopInfo class History class QGuiAppCurrentScreen class QSharedPointer class WaylandUtils struct CaptureContext struct CommandLineParser::Node struct CompareAppByName struct DesktopAppData struct DesktopFileParser struct HistoryFileName struct TerminalApp struct WinLnkFileParser class CaptureTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractPathTool class PencilTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractPathTool class PencilTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractTwoPointTool class ArrowTool class CircleCountTool class CircleTool class InvertTool class LineTool class MarkerTool class PixelateTool class RectangleTool class SelectionTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class TextTool class AbstractActionTool class AcceptTool class AppLauncher class CopyTool class ExitTool class ImgUploaderTool class MoveTool class PinTool class RedoTool class SaveTool class SizeDecreaseTool class SizeIncreaseTool class UndoTool class QWidget class AppLauncherWidget class CaptureWidget class ColorGrabWidget class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ColorPickerEditor class ColorPickerWidget class ColorPicker class ColorPickerEditMode class ConfigWindow class FileNameEditor class GeneralConf class ImgUploaderBase class ImgurUploader class ImgUploaderBase class ImgurUploader class InfoWindow class LoadSpinner class MagnifierWidget class NotificationWidget class NotifierBox class PinWidget class SelectionWidget class ShortcutsWidget class SidePanelWidget class StrftimeChooserWidget class TextConfig class UIcolorEditor class UpdateNotificationWidget class UploadHistory class UploadLineItem class UtilityPanel class VisualsEditor class QObject class ButtonHandler class CaptureToolObjects class ConfigHandler class DraggableWidgetMaker class FileNameHandler class Flameshot class FlameshotDaemon class GlobalShortcutFilter class HoverEventFilter class ImgUploaderManager class ScreenGrabber class SystemNotification class TerminalLauncher class ToolFactory class QListWidget class ButtonListView class QPushButton class CaptureButton class CaptureToolButton class OrientablePushButton class CaptureButton class CaptureToolButton class OrientablePushButton class CaptureButton class CaptureToolButton class OrientablePushButton class QDialog class CaptureLauncher class ConfigErrorDetails class ConfigResolver class ImgUploadDialog class SetShortcutDialog class QLabel class ClickableLabel class ImageLabel class OverlayMessage Overlay a message in capture mode. class QSlider class ExtendedSlider class QDBusAbstractAdaptor class FlameshotDBusAdapter class QAbstractNativeEventFilter class GlobalShortcutFilter class QStyledItemDelegate class LauncherItemDelegate class QUndoCommand class ModificationCommand class QDBusAbstractInterface class OrgFreedesktopPortalRequestInterface class QProxyStyle class StyleOverride class QTextEdit class TextWidget class QSystemTrayIcon class TrayIcon","title":"Class Hierarchy"},{"location":"flameshot/modules/","text":"Modules # Here is a list of all modules:","title":"Modules"},{"location":"flameshot/modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"flameshot/pages/","text":"Class List # Here are the classes, structs, unions and interfaces with brief descriptions:","title":"Class List"},{"location":"flameshot/pages/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions:","title":"Class List"},{"location":"flameshot/class_members/","text":"Class Members # a # AbstractActionTool ( AbstractActionTool ) AbstractLogger ( AbstractLogger ) addOutputString ( AbstractLogger ) attachNotificationPath ( AbstractLogger ) AbstractPathTool ( AbstractPathTool ) addPoint ( AbstractPathTool ) AbstractTwoPointTool ( AbstractTwoPointTool ) adjustedVector ( AbstractTwoPointTool ) AcceptTool ( AcceptTool ) AppLauncher ( AppLauncher ) AppLauncherWidget ( AppLauncherWidget ) addAppsToListWidget ( AppLauncherWidget ) ArrowTool ( ArrowTool ) adjustHorizontalCenter ( ButtonHandler ) addPinTask ( CaptureRequest ) addSaveTask ( CaptureRequest ) addTask ( CaptureRequest ) animatedShow ( CaptureToolButton , NotificationWidget ) append ( CaptureToolObjects ) at ( CaptureToolObjects ) activeButtonTool ( CaptureWidget ) activeButtonToolType ( CaptureWidget ) activeToolObject ( CaptureWidget ) addPreset ( ColorPickerEditor ) AddArgument ( CommandLineParser ) AddOption ( CommandLineParser ) AddOptions ( CommandLineParser ) addHelpOption ( CommandLineParser ) addVersionOption ( CommandLineParser ) argument ( CommandLineParser::Node ) addChecker ( CommandOption ) assertKeyRecognized ( ConfigHandler ) autoNumerateDuplicate ( FileNameHandler ) attachPin ( FlameshotDaemon ) attachScreenshotToClipboard ( FlameshotDaemon ) attachTextToClipboard ( FlameshotDaemon ) animatedHide ( NotificationWidget ) appendShortcut ( ShortcutsWidget ) arg ( TerminalApp ) adjustSize ( TextWidget ) appUpdates ( TrayIcon ) addLine ( UploadHistory ) activeLayerIndex ( UtilityPanel ) b # boundingRect ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , InvertTool , OverlayMessage , PixelateTool , TextTool ) Bool ( Bool ) BoundedInt ( BoundedInt ) ButtonHandler ( ButtonHandler ) buttonsAreInside ( ButtonHandler ) ButtonListView ( ButtonListView ) baseName ( ConfigHandler ) buttonBox ( ImgUploadDialog ) c # Channel ( AbstractLogger ) closeOnButtonPressed ( AbstractPathTool , AbstractTwoPointTool , AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) copyParams ( AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , TextTool ) color ( AbstractTwoPointTool , CaptureContext , ColorGrabWidget ) copy ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) capture ( AppLauncher , ImgUploaderTool ) configureListView ( AppLauncherWidget ) check ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors , ValueHandler ) calculateShift ( ButtonHandler ) contains ( ButtonHandler ) CaptureButton ( CaptureButton ) circleCount ( CaptureContext ) CaptureLauncher ( CaptureLauncher ) connectCaptureSlots ( CaptureLauncher ) CaptureMode ( CaptureRequest ) CaptureRequest ( CaptureRequest ) captureMode ( CaptureRequest ) CaptureToolButton ( CaptureToolButton ) CaptureToolObjects ( CaptureToolObjects ) captureToolObjects ( CaptureToolObjects ) clear ( CaptureToolObjects ) CaptureWidget ( CaptureWidget ) changeEvent ( CaptureWidget ) CircleCountTool ( CircleCountTool ) CircleTool ( CircleTool ) ClickableLabel ( ClickableLabel ) Color ( Color ) ColorGrabWidget ( ColorGrabWidget ) cursorPos ( ColorGrabWidget ) ColorPicker ( ColorPicker ) ColorPickerEditMode ( ColorPickerEditMode ) ColorPickerEditor ( ColorPickerEditor ) ColorPickerWidget ( ColorPickerWidget ) CommandArgument ( CommandArgument ) CommandLineParser ( CommandLineParser ) CommandOption ( CommandOption ) checkValue ( CommandOption ) ConfigErrorDetails ( ConfigErrorDetails ) CONFIG_GETTER_SETTER ( ConfigHandler ) ConfigHandler ( ConfigHandler ) checkAndHandleError ( ConfigHandler ) checkForErrors ( ConfigHandler ) checkSemantics ( ConfigHandler ) checkShortcutConflicts ( ConfigHandler ) checkUnrecognizedSettings ( ConfigHandler ) cleanUnusedKeys ( ConfigHandler ) configFilePath ( ConfigHandler ) ConfigResolver ( ConfigResolver ) ConfigWindow ( ConfigWindow ) CopyTool ( CopyTool ) categories ( DesktopAppData ) call ( FlameshotDaemon ) checkDBusConnection ( FlameshotDaemon ) copyToClipboard ( FlameshotDaemon ) createMethodCall ( FlameshotDaemon ) createPin ( FlameshotDaemon ) chooseFolder ( GeneralConf ) compileFromKeyMap ( OverlayMessage ) closePin ( PinWidget ) currentScreen ( QGuiAppCurrentScreen ) closeEditor ( TextTool ) configurationWidget ( TextTool ) CreateTool ( ToolFactory ) clearToolWidget ( UtilityPanel ) d # description ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CommandOption , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) disconnectCaptureSlots ( CaptureLauncher ) data ( CaptureRequest ) delay ( CaptureRequest ) drawErrorMessage ( CaptureWidget ) drawInactiveRegion ( CaptureWidget ) drawObjectSelection ( CaptureWidget , TextTool ) drawToolsData ( CaptureWidget ) deletePreset ( ColorPickerEditor ) defaultLargeColorPalette ( ColorPickerWidget ) defaultSmallColorPalette ( ColorPickerWidget ) dashedNames ( CommandOption ) DesktopAppData ( DesktopAppData ) DesktopFileParser ( DesktopFileParser ) DESKTOP_SESSION ( DesktopInfo ) DesktopInfo ( DesktopInfo ) DraggableWidgetMaker ( DraggableWidgetMaker ) deleteImage ( ImgUploaderBase , ImgurUploader ) drawSearchArea ( InvertTool , PixelateTool ) drawMagnifier ( MagnifierWidget ) drawMagnifierCircle ( MagnifierWidget ) decreaseOpacity ( PinWidget ) desktopGeometry ( ScreenGrabber ) e # enableMessageHeader ( AbstractLogger ) error ( AbstractLogger ) expected ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , SaveFileExtension , String , UserColors , ValueHandler ) ensureSelectionMinimunSize ( ButtonHandler ) expandSelection ( ButtonHandler ) ExportTask ( CaptureRequest ) extendedRect ( CaptureWidget ) extendedSelection ( CaptureWidget ) eventFilter ( ColorGrabWidget , ColorPickerEditMode , DraggableWidgetMaker , HoverEventFilter , SelectionWidget , SidePanelWidget ) errorMsg ( CommandOption ) ensureFileWatched ( ConfigHandler ) errorMessage ( ConfigHandler ) exec ( DesktopAppData ) ExitTool ( ExitTool ) ExtendedSlider ( ExtendedSlider ) enableTrayIcon ( FlameshotDaemon ) enterEvent ( NotifierBox , PinWidget ) event ( PinWidget ) enableCheckUpdatesAction ( TrayIcon ) f # fallback ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , String , UserColors , ValueHandler ) fromIntList ( ButtonList ) fullscreen ( CaptureContext ) find ( CaptureToolObjects ) findWithRadius ( CaptureToolObjects ) finalize ( ColorGrabWidget ) findParent ( CommandLineParser ) filenamePatternDefault ( ConfigHandler ) FileNameEditor ( FileNameEditor ) FileNameHandler ( FileNameHandler ) Flameshot ( Flameshot ) FlameshotDBusAdapter ( FlameshotDBusAdapter ) FlameshotDaemon ( FlameshotDaemon ) file ( HistoryFileName ) freeDesktopPortal ( ScreenGrabber ) fullGeometry ( SelectionWidget ) finalizeGrab ( SidePanelWidget ) fillCaptureTools ( UtilityPanel ) g # globalStyleSheet ( CaptureButton ) getIterableButtonTypes ( CaptureToolButton ) getPriorityByButton ( CaptureToolButton ) getColorAtPoint ( ColorGrabWidget ) getDefaultLargeColorPalette ( ColorPickerWidget ) getDefaultSmallColorPalette ( ColorPickerWidget ) getInstance ( ConfigHandler ) getAppsByCategory ( DesktopFileParser , WinLnkFileParser ) GDMSESSION ( DesktopInfo ) GNOME_DESKTOP_SESSION_ID ( DesktopInfo ) GeneralConf ( GeneralConf ) GlobalShortcutFilter ( GlobalShortcutFilter ) getNativeModifier ( GlobalShortcutFilter ) gestureEvent ( PinWidget ) grabEntireDesktop ( ScreenGrabber ) grabScreen ( ScreenGrabber ) geometry ( SelectionWidget ) getMouseSide ( SelectionWidget ) getPreferedTerminal ( TerminalLauncher ) getAllUsersStartMenuPath ( WinLnkFileParser ) getImageFileExtAssociates ( WinLnkFileParser ) h # hideSectionUnderMouse ( ButtonHandler ) horizontalPoints ( ButtonHandler ) hideEvent ( ColorPicker , NotifierBox , SelectionWidget , SidePanelWidget ) hasError ( ConfigHandler ) haveExternalWidget ( Flameshot ) History ( History ) history ( History ) HoverEventFilter ( HoverEventFilter ) handlerAreas ( SelectionWidget ) hide ( UpdateNotificationWidget , UtilityPanel ) i # isSelectable ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , MoveTool , TextTool ) isValid ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , CircleCountTool , TextTool ) info ( AbstractLogger , CircleCountTool , TextTool ) icon ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) initAppMap ( AppLauncherWidget ) initListWidget ( AppLauncherWidget ) init ( ButtonHandler , CaptureButton , ImgUploaderManager , OverlayMessage ) intersectWithAreas ( ButtonHandler ) isVisible ( ButtonHandler , UtilityPanel ) initButtonList ( ButtonListView ) id ( CaptureRequest ) initialSelection ( CaptureRequest ) initButton ( CaptureToolButton ) iterableButtonTypes ( CaptureToolButton ) insert ( CaptureToolObjects ) initButtons ( CaptureWidget , UIcolorEditor ) initContext ( CaptureWidget ) initHelpMessage ( CaptureWidget ) initPanel ( CaptureWidget ) initSelection ( CaptureWidget ) initShortcuts ( CaptureWidget ) initColorPicker ( ColorPickerWidget ) isRoot ( CommandArgument ) isSet ( CommandLineParser ) isShortcut ( ConfigHandler ) initErrorIndicator ( ConfigWindow ) initLayout ( FileNameEditor ) initWidgets ( FileNameEditor , VisualsEditor ) instance ( Flameshot , FlameshotDaemon , OverlayMessage ) initTrayIcon ( FlameshotDaemon , TrayIcon ) isThisInstanceHostingWidgets ( FlameshotDaemon ) initAllowMultipleGuiInstances ( GeneralConf ) initAntialiasingPinZoom ( GeneralConf ) initAutoCloseIdleDaemon ( GeneralConf ) initAutostart ( GeneralConf ) initCheckForUpdates ( GeneralConf ) initConfigButtons ( GeneralConf ) initCopyAndCloseAfterUpload ( GeneralConf ) initCopyOnDoubleClick ( GeneralConf ) initCopyPathAfterSave ( GeneralConf ) initHistoryConfirmationToDelete ( GeneralConf ) initPredefinedColorPaletteLarge ( GeneralConf ) initSaveAfterCopy ( GeneralConf ) initSaveLastRegion ( GeneralConf ) initScrollArea ( GeneralConf ) initShowDesktopNotification ( GeneralConf ) initShowHelp ( GeneralConf ) initShowMagnifier ( GeneralConf ) initShowSelectionGeometry ( GeneralConf ) initShowSidePanelButton ( GeneralConf ) initShowStartupLaunchMessage ( GeneralConf ) initShowTrayIcon ( GeneralConf ) initSquareMagnifier ( GeneralConf ) initUndoLimit ( GeneralConf ) initUploadClientSecret ( GeneralConf ) initUploadHistoryMax ( GeneralConf ) initUploadWithoutConfirmation ( GeneralConf ) initUseJpgForClipboard ( GeneralConf ) ImageLabel ( ImageLabel ) ImgUploadDialog ( ImgUploadDialog ) ImgUploaderBase ( ImgUploaderBase ) imageURL ( ImgUploaderBase ) ImgUploaderManager ( ImgUploaderManager ) ImgUploaderTool ( ImgUploaderTool ) ImgurUploader ( ImgurUploader ) InfoWindow ( InfoWindow ) InvertTool ( InvertTool ) increaseOpacity ( PinWidget ) initInfoTable ( ShortcutsWidget ) isChanged ( TextTool ) initMenu ( TrayIcon ) initColorWheel ( UIcolorEditor ) initInternalPanel ( UpdateNotificationWidget , UtilityPanel ) initOpacitySlider ( VisualsEditor ) k # keyPressEvent ( AppLauncherWidget , CaptureWidget , ConfigWindow , InfoWindow , PinWidget , SetShortcutDialog ) keyReleaseEvent ( CaptureWidget , SetShortcutDialog ) keysFromGroup ( ConfigHandler ) KDE_FULL_SESSION ( DesktopInfo ) KeySequence ( KeySequence ) l # layout ( ConfigResolver , ImgUploadDialog ) LauncherItemDelegate ( LauncherItemDelegate ) LineTool ( LineTool ) LoadSpinner ( LoadSpinner ) LowerBoundedInt ( LowerBoundedInt ) leaveEvent ( PinWidget ) loadShortcuts ( ShortcutsWidget ) launchDetached ( TerminalLauncher ) loadHistory ( UploadHistory ) m # m_defaultChannel ( AbstractLogger ) m_enableMessageHeader ( AbstractLogger ) m_notificationPath ( AbstractLogger ) m_targets ( AbstractLogger ) m_textStreams ( AbstractLogger ) messageHeader ( AbstractLogger ) m_color ( AbstractPathTool , AbstractTwoPointTool , ColorGrabWidget , ColorPickerEditor , LoadSpinner , MagnifierWidget , SelectionWidget , SidePanelWidget , TextTool ) m_padding ( AbstractPathTool , AbstractTwoPointTool ) m_pathArea ( AbstractPathTool ) m_points ( AbstractPathTool , AbstractTwoPointTool ) m_pos ( AbstractPathTool ) m_thickness ( AbstractPathTool , AbstractTwoPointTool ) mousePreviewRect ( AbstractPathTool , AbstractTwoPointTool , CircleCountTool , MarkerTool ) move ( AbstractPathTool , AbstractTwoPointTool , TextTool ) m_supportsDiagonalAdj ( AbstractTwoPointTool ) m_supportsOrthogonalAdj ( AbstractTwoPointTool ) m_appsMap ( AppLauncherWidget ) m_filterList ( AppLauncherWidget ) m_keepOpen ( AppLauncherWidget ) m_keepOpenCheckbox ( AppLauncherWidget ) m_layout ( AppLauncherWidget , FileNameEditor , GeneralConf , NotificationWidget , PinWidget , SetShortcutDialog , ShortcutsWidget , SidePanelWidget , TextConfig , UpdateNotificationWidget , UtilityPanel , VisualsEditor ) m_lineEdit ( AppLauncherWidget ) m_parser ( AppLauncherWidget ) m_pixmap ( AppLauncherWidget , ColorGrabWidget , ImageLabel , ImgUploaderBase , PinTool , PinWidget , SidePanelWidget ) m_tabWidget ( AppLauncherWidget , ConfigWindow , VisualsEditor ) m_tempFile ( AppLauncherWidget ) m_terminalCheckbox ( AppLauncherWidget ) m_arrowPath ( ArrowTool ) m_def ( Bool , BoundedInt , Color , LowerBoundedInt , String ) m_max ( BoundedInt , UserColors ) m_min ( BoundedInt , LowerBoundedInt , UserColors ) m_allSidesBlocked ( ButtonHandler ) m_blockedBotton ( ButtonHandler ) m_blockedLeft ( ButtonHandler ) m_blockedRight ( ButtonHandler ) m_blockedTop ( ButtonHandler ) m_buttonBaseSize ( ButtonHandler ) m_buttonExtendedSize ( ButtonHandler ) m_buttonsAreInside ( ButtonHandler ) m_horizontalyBlocked ( ButtonHandler ) m_oneHorizontalBlocked ( ButtonHandler ) m_screenRegions ( ButtonHandler ) m_selection ( ButtonHandler , CaptureWidget ) m_separator ( ButtonHandler ) m_vectorButtons ( ButtonHandler ) moveButtonsToPoints ( ButtonHandler ) m_buttonTypeByName ( ButtonListView ) m_listButtons ( ButtonListView ) m_mainColor ( CaptureButton , CaptureToolButton ) mousePos ( CaptureContext ) m_data ( CaptureRequest ) m_delay ( CaptureRequest ) m_initialSelection ( CaptureRequest ) m_mode ( CaptureRequest ) m_path ( CaptureRequest ) m_pinWindowGeometry ( CaptureRequest ) m_tasks ( CaptureRequest ) m_buttonType ( CaptureToolButton ) m_emergeAnimation ( CaptureToolButton ) m_tool ( CaptureToolButton ) mousePressEvent ( CaptureToolButton , CaptureWidget , ClickableLabel , ImageLabel , PinWidget ) m_captureToolObjects ( CaptureToolObjects , CaptureWidget , ModificationCommand ) m_imageCache ( CaptureToolObjects ) m_activeButton ( CaptureWidget ) m_activeTool ( CaptureWidget ) m_activeToolIsMoved ( CaptureWidget ) m_activeToolOffsetToMouseOnStart ( CaptureWidget ) m_adjustmentButtonPressed ( CaptureWidget ) m_buttonHandler ( CaptureWidget ) m_captureDone ( CaptureWidget ) m_captureToolObjectsBackup ( CaptureWidget , ModificationCommand ) m_colorPicker ( CaptureWidget ) m_config ( CaptureWidget , ColorPickerEditMode , ColorPickerEditor , ShortcutsWidget ) m_configError ( CaptureWidget ) m_configErrorResolved ( CaptureWidget ) m_context ( CaptureWidget ) m_contrastUiColor ( CaptureWidget ) m_eventFilter ( CaptureWidget ) m_existingObjectIsChanged ( CaptureWidget ) m_helpMessage ( CaptureWidget , GeneralConf ) m_lastMouseWheel ( CaptureWidget ) m_magnifier ( CaptureWidget ) m_mouseIsClicked ( CaptureWidget ) m_mouseOverHandle ( CaptureWidget ) m_mousePressedPos ( CaptureWidget ) m_movingSelection ( CaptureWidget ) m_newSelection ( CaptureWidget ) m_notifierBox ( CaptureWidget ) m_opacity ( CaptureWidget , PinWidget ) m_panel ( CaptureWidget ) m_previewEnabled ( CaptureWidget ) m_sidePanel ( CaptureWidget ) m_sizeIndButton ( CaptureWidget ) m_startMove ( CaptureWidget ) m_startMovePos ( CaptureWidget ) m_toolSizeByKeyboard ( CaptureWidget ) m_toolWidget ( CaptureWidget , UtilityPanel ) m_tools ( CaptureWidget ) m_uiColor ( CaptureWidget , ColorPickerWidget , UIcolorEditor ) m_undoStack ( CaptureWidget ) m_updateNotificationWidget ( CaptureWidget ) m_xywhDisplay ( CaptureWidget ) m_xywhTimer ( CaptureWidget ) makeChild ( CaptureWidget ) mouseDoubleClickEvent ( CaptureWidget , PinWidget ) mouseMoveEvent ( CaptureWidget , ColorPicker , ImageLabel , PinWidget ) mouseReleaseEvent ( CaptureWidget , ImageLabel ) moveEvent ( CaptureWidget , SelectionWidget ) m_tempString ( CircleCountTool , TextTool ) m_valid ( CircleCountTool ) m_extraZoomActive ( ColorGrabWidget ) m_magnifierActive ( ColorGrabWidget ) m_mousePressReceived ( ColorGrabWidget ) m_previewImage ( ColorGrabWidget ) m_draggedPresetInitialPos ( ColorPickerEditMode ) m_isDragging ( ColorPickerEditMode , DraggableWidgetMaker ) m_isPressing ( ColorPickerEditMode , DraggableWidgetMaker ) m_mouseMovePos ( ColorPickerEditMode , DraggableWidgetMaker ) m_mousePressPos ( ColorPickerEditMode , DraggableWidgetMaker ) m_addPresetButton ( ColorPickerEditor ) m_addPresetLabel ( ColorPickerEditor ) m_colorEdit ( ColorPickerEditor ) m_colorEditLabel ( ColorPickerEditor ) m_colorInput ( ColorPickerEditor ) m_colorList ( ColorPickerEditor , ColorPickerWidget ) m_colorWheel ( ColorPickerEditor , SidePanelWidget , UIcolorEditor ) m_colorpicker ( ColorPickerEditor ) m_deletePresetButton ( ColorPickerEditor ) m_gLayout ( ColorPickerEditor ) m_selectedIndex ( ColorPickerEditor , ColorPickerWidget ) m_updatePresetButton ( ColorPickerEditor ) m_colorAreaList ( ColorPickerWidget ) m_colorAreaSize ( ColorPickerWidget ) m_lastIndex ( ColorPickerWidget ) m_description ( CommandArgument , CommandLineParser , CommandOption ) m_name ( CommandArgument ) m_foundArgs ( CommandLineParser ) m_foundOptions ( CommandLineParser ) m_generalErrorMessage ( CommandLineParser ) m_parseTree ( CommandLineParser ) m_withHelp ( CommandLineParser ) m_withVersion ( CommandLineParser ) m_checker ( CommandOption ) m_errorMsg ( CommandOption ) m_names ( CommandOption ) m_value ( CommandOption ) m_valueName ( CommandOption ) m_configWatcher ( ConfigHandler ) m_errorCheckPending ( ConfigHandler ) m_hasError ( ConfigHandler ) m_settings ( ConfigHandler ) m_skipNextErrorCheck ( ConfigHandler ) m_filenameEditor ( ConfigWindow ) m_filenameEditorTab ( ConfigWindow ) m_generalConfig ( ConfigWindow ) m_generalConfigTab ( ConfigWindow ) m_shortcuts ( ConfigWindow , ShortcutsWidget ) m_shortcutsTab ( ConfigWindow ) m_visuals ( ConfigWindow ) m_visualsTab ( ConfigWindow ) m_appList ( DesktopFileParser , WinLnkFileParser ) m_defaultIcon ( DesktopFileParser ) m_localeDescription ( DesktopFileParser ) m_localeDescriptionShort ( DesktopFileParser ) m_localeName ( DesktopFileParser ) m_localeNameShort ( DesktopFileParser ) makeDraggable ( DraggableWidgetMaker ) m_timer ( ExtendedSlider , LoadSpinner , NotificationWidget , NotifierBox ) mappedValue ( ExtendedSlider ) m_clearButton ( FileNameEditor ) m_helperButtons ( FileNameEditor ) m_nameEditor ( FileNameEditor ) m_nameHandler ( FileNameEditor ) m_outputLabel ( FileNameEditor ) m_resetButton ( FileNameEditor , GeneralConf ) m_saveButton ( FileNameEditor ) MAX_CHARACTERS ( FileNameHandler ) m_captureWindow ( Flameshot ) m_configWindow ( Flameshot ) m_haveExternalWidget ( Flameshot ) m_infoWindow ( Flameshot ) m_launcherWindow ( Flameshot ) m_origin ( Flameshot ) m_appLatestUrl ( FlameshotDaemon , UpdateNotificationWidget ) m_appLatestVersion ( FlameshotDaemon , UpdateNotificationWidget ) m_clipboardSignalBlocked ( FlameshotDaemon ) m_hostingClipboard ( FlameshotDaemon ) m_instance ( FlameshotDaemon , OverlayMessage ) m_networkCheckUpdates ( FlameshotDaemon ) m_persist ( FlameshotDaemon ) m_showCheckAppUpdateStatus ( FlameshotDaemon ) m_trayIcon ( FlameshotDaemon ) m_widgets ( FlameshotDaemon ) m_allowMultipleGuiInstances ( GeneralConf ) m_antialiasingPinZoom ( GeneralConf ) m_autoCloseIdleDaemon ( GeneralConf ) m_autostart ( GeneralConf ) m_changeSaveButton ( GeneralConf ) m_checkForUpdates ( GeneralConf ) m_copyOnDoubleClick ( GeneralConf ) m_copyPathAfterSave ( GeneralConf ) m_copyURLAfterUpload ( GeneralConf ) m_exportButton ( GeneralConf ) m_historyConfirmationToDelete ( GeneralConf ) m_importButton ( GeneralConf ) m_predefinedColorPaletteLarge ( GeneralConf ) m_saveAfterCopy ( GeneralConf ) m_saveLastRegion ( GeneralConf ) m_savePath ( GeneralConf ) m_screenshotPathFixedCheck ( GeneralConf ) m_scrollArea ( GeneralConf ) m_scrollAreaLayout ( GeneralConf ) m_selectGeometryLocation ( GeneralConf ) m_setSaveAsFileExtension ( GeneralConf ) m_showMagnifier ( GeneralConf ) m_showSelectionGeometry ( GeneralConf ) m_showStartupLaunchMessage ( GeneralConf ) m_showTray ( GeneralConf ) m_sidePanelButton ( GeneralConf ) m_squareMagnifier ( GeneralConf ) m_sysNotifications ( GeneralConf ) m_undoLimit ( GeneralConf ) m_uploadClientKey ( GeneralConf ) m_uploadHistoryMax ( GeneralConf ) m_uploadWithoutConfirmation ( GeneralConf , ImgUploadDialog ) m_useJpgForClipboard ( GeneralConf ) m_xywhTimeout ( GeneralConf ) m_historyPath ( History ) m_packedFileName ( History ) m_thumbs ( History ) m_unpackedFileName ( History ) m_DSEffect ( ImageLabel ) m_dragStartPosition ( ImageLabel ) m_uploadLabel ( ImgUploadDialog ) m_copyUrlButton ( ImgUploaderBase ) m_currentImageName ( ImgUploaderBase ) m_hLayout ( ImgUploaderBase , UIcolorEditor ) m_imageURL ( ImgUploaderBase ) m_infoLabel ( ImgUploaderBase ) m_notification ( ImgUploaderBase , UpdateNotificationWidget ) m_openDeleteUrlButton ( ImgUploaderBase ) m_openUrlButton ( ImgUploaderBase ) m_saveToFilesystemButton ( ImgUploaderBase ) m_spinner ( ImgUploaderBase ) m_toClipboardButton ( ImgUploaderBase ) m_vLayout ( ImgUploaderBase , UIcolorEditor ) m_imgUploaderBase ( ImgUploaderManager ) m_imgUploaderPlugin ( ImgUploaderManager ) m_urlString ( ImgUploaderManager ) m_NetworkAM ( ImgurUploader ) m_fallback ( KeySequence ) m_frame ( LoadSpinner ) m_growing ( LoadSpinner ) m_span ( LoadSpinner ) m_startAngle ( LoadSpinner ) MagnifierWidget ( MagnifierWidget ) m_borderColor ( MagnifierWidget ) m_devicePixelRatio ( MagnifierWidget ) m_magOffset ( MagnifierWidget ) m_magPixels ( MagnifierWidget ) m_paddedScreenshot ( MagnifierWidget ) m_pixels ( MagnifierWidget ) m_screenshot ( MagnifierWidget ) m_square ( MagnifierWidget ) magZoom ( MagnifierWidget ) MarkerTool ( MarkerTool ) ModificationCommand ( ModificationCommand ) m_captureWidget ( ModificationCommand , UtilityPanel ) MoveTool ( MoveTool ) m_content ( NotificationWidget ) m_hideAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_label ( NotificationWidget , PinWidget ) m_showAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_bgColor ( NotifierBox ) m_foregroundColor ( NotifierBox ) m_message ( NotifierBox ) m_orientation ( OrientablePushButton ) m_fillColor ( OverlayMessage ) m_messageStack ( OverlayMessage ) m_targetArea ( OverlayMessage ) m_textColor ( OverlayMessage ) m_geometry ( PinTool ) m_baseColor ( PinWidget ) m_currentStepScaleFactor ( PinWidget ) m_dragStart ( PinWidget ) m_expanding ( PinWidget ) m_hoverColor ( PinWidget ) m_offsetX ( PinWidget ) m_offsetY ( PinWidget ) m_rotateFactor ( PinWidget ) m_scaleFactor ( PinWidget ) m_shadowEffect ( PinWidget ) m_sizeChanged ( PinWidget ) m_currentScreen ( QGuiAppCurrentScreen ) m_info ( ScreenGrabber ) m_BArea ( SelectionWidget ) m_BHandle ( SelectionWidget ) m_BLArea ( SelectionWidget ) m_BLHandle ( SelectionWidget ) m_BRArea ( SelectionWidget ) m_BRHandle ( SelectionWidget ) m_LArea ( SelectionWidget ) m_LHandle ( SelectionWidget ) m_RArea ( SelectionWidget ) m_RHandle ( SelectionWidget ) m_TArea ( SelectionWidget ) m_THandle ( SelectionWidget ) m_TLArea ( SelectionWidget ) m_TLHandle ( SelectionWidget ) m_TRArea ( SelectionWidget ) m_TRHandle ( SelectionWidget ) m_activeSide ( SelectionWidget ) m_animation ( SelectionWidget ) m_areaOffset ( SelectionWidget ) m_dragStartPos ( SelectionWidget ) m_handleOffset ( SelectionWidget ) m_idleCentralCursor ( SelectionWidget ) m_ignoreMouse ( SelectionWidget ) m_mouseStartMove ( SelectionWidget ) m_ks ( SetShortcutDialog ) m_modifier ( SetShortcutDialog ) m_table ( ShortcutsWidget ) m_colorGrabButton ( SidePanelWidget ) m_colorGrabber ( SidePanelWidget ) m_colorHex ( SidePanelWidget ) m_colorLabel ( SidePanelWidget ) m_revertColor ( SidePanelWidget ) m_toolSize ( SidePanelWidget ) m_toolSizeSlider ( SidePanelWidget ) m_toolSizeSpin ( SidePanelWidget ) m_buttonData ( StrftimeChooserWidget ) m_interface ( SystemNotification ) m_centerAlignButton ( TextConfig ) m_fontsCB ( TextConfig ) m_italicButton ( TextConfig ) m_leftAlignButton ( TextConfig ) m_rightAlignButton ( TextConfig ) m_strikeOutButton ( TextConfig ) m_underlineButton ( TextConfig ) m_weightButton ( TextConfig ) m_alignment ( TextTool ) m_confW ( TextTool ) m_currentPos ( TextTool ) m_font ( TextTool ) m_size ( TextTool ) m_text ( TextTool ) m_textArea ( TextTool ) m_textOld ( TextTool ) m_widget ( TextTool ) m_baseSize ( TextWidget ) m_minSize ( TextWidget ) m_appUpdates ( TrayIcon ) m_menu ( TrayIcon ) m_buttonContrast ( UIcolorEditor ) m_buttonIconType ( UIcolorEditor ) m_buttonMainColor ( UIcolorEditor ) m_contrastColor ( UIcolorEditor ) m_labelContrast ( UIcolorEditor ) m_labelMain ( UIcolorEditor ) m_lastButtonPressed ( UIcolorEditor ) m_internalPanel ( UpdateNotificationWidget , UtilityPanel ) m_bottomLayout ( UtilityPanel ) m_buttonDelete ( UtilityPanel ) m_buttonMoveDown ( UtilityPanel ) m_buttonMoveUp ( UtilityPanel ) m_captureTools ( UtilityPanel ) m_layersLayout ( UtilityPanel ) m_upLayout ( UtilityPanel ) m_buttonList ( VisualsEditor ) m_colorEditor ( VisualsEditor ) m_colorEditorTab ( VisualsEditor ) m_colorpickerEditor ( VisualsEditor ) m_colorpickerEditorTab ( VisualsEditor ) m_opacitySlider ( VisualsEditor ) m_GraphicAppsList ( WinLnkFileParser ) n # name ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TerminalApp , TextTool , UndoTool ) normalizeButtons ( ButtonList ) newShortcut ( CaptureWidget ) Node ( CommandLineParser::Node ) names ( CommandOption ) nativeEventFilter ( GlobalShortcutFilter ) nativeKeycode ( GlobalShortcutFilter ) notification ( ImgUploaderBase ) NotificationWidget ( NotificationWidget ) NotifierBox ( NotifierBox ) o # operator<< ( AbstractLogger ) origScreenshot ( CaptureContext ) operator= ( CaptureToolObjects , ToolFactory ) operator== ( CommandArgument , CommandLineParser::Node , CommandOption , DesktopAppData ) options ( CommandLineParser::Node ) operator() ( CompareAppByName ) Origin ( Flameshot ) origin ( Flameshot ) OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) OrientablePushButton ( OrientablePushButton ) Orientation ( OrientablePushButton ) orientation ( OrientablePushButton ) OverlayMessage ( OverlayMessage ) p # paintMousePreview ( AbstractActionTool , AbstractTwoPointTool , CircleCountTool , InvertTool , MarkerTool , PencilTool , PixelateTool , TextTool ) process ( AbstractActionTool , ArrowTool , ButtonList , CircleCountTool , CircleTool , Color , FilenamePattern , InvertTool , KeySequence , LineTool , MarkerTool , PencilTool , PixelateTool , RectangleTool , Region , SaveFileExtension , SelectionTool , TextTool , UserColors , ValueHandler ) pos ( AbstractPathTool , AbstractTwoPointTool , TextTool ) points ( AbstractTwoPointTool ) positionButtonsInside ( ButtonHandler ) path ( CaptureRequest , History ) paddedUpdateRect ( CaptureWidget ) paintEvent ( CaptureWidget , ColorGrabWidget , ColorPickerWidget , LoadSpinner , MagnifierWidget , NotifierBox , OrientablePushButton , OverlayMessage , PinWidget , SelectionWidget ) pixmap ( CaptureWidget , ImgUploaderBase ) processPixmapWithTool ( CaptureWidget ) pushObjectsStateToUndoStack ( CaptureWidget ) pushToolToStack ( CaptureWidget ) parse ( CommandLineParser ) printHelp ( CommandLineParser ) printVersion ( CommandLineParser ) processArgs ( CommandLineParser ) processIfOptionIsHelp ( CommandLineParser ) processOptions ( CommandLineParser ) populate ( ConfigResolver ) parseDesktopFile ( DesktopFileParser ) processDirectory ( DesktopFileParser , WinLnkFileParser ) parseFilename ( FileNameHandler ) parsedPattern ( FileNameHandler ) properScreenshotPath ( FileNameHandler ) packFileName ( History ) paint ( LauncherItemDelegate ) pop ( OverlayMessage ) push ( OverlayMessage ) pushKeyMap ( OverlayMessage ) PencilTool ( PencilTool ) PinTool ( PinTool ) PinWidget ( PinWidget ) pinchTriggered ( PinWidget ) PixelateTool ( PixelateTool ) parentMouseMoveEvent ( SelectionWidget ) parentMousePressEvent ( SelectionWidget ) parentMouseReleaseEvent ( SelectionWidget ) pushWidget ( UtilityPanel ) parseLnkFile ( WinLnkFileParser ) q # quitIfIdle ( FlameshotDaemon ) QGuiAppCurrentScreen ( QGuiAppCurrentScreen ) r # resetRegionTrack ( ButtonHandler ) representation ( ButtonList , Color , KeySequence , UserColors , ValueHandler ) request ( CaptureContext ) removeTask ( CaptureRequest ) removeAt ( CaptureToolObjects ) releaseActiveTool ( CaptureWidget ) removeToolObject ( CaptureWidget ) resizeEvent ( CaptureWidget , ImageLabel , SelectionWidget , TextWidget ) restoreCircleCountState ( CaptureWidget ) repaint ( ColorPickerWidget ) recursiveParentSearch ( CommandLineParser ) rootArgument ( CommandLineParser ) recognizedGeneralOptions ( ConfigHandler ) recognizedShortcutNames ( ConfigHandler ) remove ( ConfigHandler ) resetValue ( ConfigHandler ) resetLayout ( ConfigResolver ) resolveAnyConfigErrors ( Flameshot ) registerShortcut ( GlobalShortcutFilter ) redo ( ModificationCommand ) rotateLeft ( PinWidget ) rotateRight ( PinWidget ) RectangleTool ( RectangleTool ) RedoTool ( RedoTool ) rect ( SelectionWidget ) s # showMousePreview ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , TextTool ) sendMessage ( AbstractLogger , SystemNotification ) size ( AbstractPathTool , AbstractTwoPointTool , ButtonHandler , CaptureToolObjects ) setPadding ( AbstractTwoPointTool ) setButtons ( ButtonHandler ) setColor ( CaptureButton , CaptureToolButton , LoadSpinner ) styleSheet ( CaptureButton ) savePath ( CaptureContext ) screenshot ( CaptureContext ) selectedScreenshotArea ( CaptureContext ) selection ( CaptureContext ) setInitialSelection ( CaptureRequest ) setStaticID ( CaptureRequest ) selectToolItemAtPos ( CaptureWidget ) setCaptureToolObjects ( CaptureWidget ) setToolSize ( CaptureWidget , ConfigHandler ) showAppUpdateNotification ( CaptureWidget ) showColorPicker ( CaptureWidget ) showxywh ( CaptureWidget ) startDrawObjectTool ( CaptureWidget ) setExtraZoomActive ( ColorGrabWidget ) setMagnifierActive ( ColorGrabWidget ) showEvent ( ColorGrabWidget , ColorPicker , SelectionWidget , TextWidget ) startGrabbing ( ColorGrabWidget ) setDescription ( CommandArgument , CommandLineParser , CommandOption ) setName ( CommandArgument , CommandOption ) setGeneralErrorMessage ( CommandLineParser ) subNodes ( CommandLineParser::Node ) setNames ( CommandOption ) setValue ( CommandOption , ConfigHandler ) setValueName ( CommandOption ) setAllTheButtons ( ConfigHandler ) setDefaultSettings ( ConfigHandler ) setErrorState ( ConfigHandler ) setShortcut ( ConfigHandler ) setShowDesktopNotification ( ConfigHandler ) setShowStartupLaunchMessage ( ConfigHandler ) setStartupLaunch ( ConfigHandler ) setUploadWithoutConfirmation ( ConfigHandler ) shortcut ( ConfigHandler , SetShortcutDialog ) showInTerminal ( DesktopAppData ) setMapedValue ( ExtendedSlider ) setExternalWidget ( Flameshot ) setOrigin ( Flameshot ) sendTrayNotification ( FlameshotDaemon ) showUpdateNotificationIfAvailable ( FlameshotDaemon ) start ( FlameshotDaemon , LoadSpinner ) save ( History ) setScaledPixmap ( ImageLabel ) setScreenshot ( ImageLabel ) setImageURL ( ImgUploaderBase ) setInfoLabelText ( ImgUploaderBase ) setPixmap ( ImgUploaderBase ) spinner ( ImgUploaderBase ) sizeHint ( LauncherItemDelegate , OrientablePushButton ) setHeight ( LoadSpinner ) setWidth ( LoadSpinner ) stop ( LoadSpinner ) showMessage ( NotificationWidget ) staticInterfaceName ( OrgFreedesktopPortalRequestInterface ) setOrientation ( OrientablePushButton ) setVisibility ( OverlayMessage ) scrollEvent ( PinWidget ) screenAt ( QGuiAppCurrentScreen ) SaveTool ( SaveTool ) ScreenGrabber ( ScreenGrabber ) screenGeometry ( ScreenGrabber ) SelectionTool ( SelectionTool ) SelectionWidget ( SelectionWidget ) SideType ( SelectionWidget ) setGeometry ( SelectionWidget ) setGeometryAnimated ( SelectionWidget ) setGeometryByKeyboard ( SelectionWidget ) setIdleCentralCursor ( SelectionWidget ) setIgnoreMouse ( SelectionWidget ) SetShortcutDialog ( SetShortcutDialog ) ShortcutsWidget ( ShortcutsWidget ) SidePanelWidget ( SidePanelWidget ) SizeDecreaseTool ( SizeDecreaseTool ) SizeIncreaseTool ( SizeIncreaseTool ) StrftimeChooserWidget ( StrftimeChooserWidget ) String ( String ) styleHint ( StyleOverride ) SystemNotification ( SystemNotification ) setFontFamily ( TextConfig ) setItalic ( TextConfig ) setStrikeOut ( TextConfig ) setTextAlignment ( TextConfig ) setUnderline ( TextConfig ) setWeight ( TextConfig ) setEditMode ( TextTool ) setFont ( TextWidget ) startGuiCapture ( TrayIcon ) setAppLatestVersion ( UpdateNotificationWidget ) show ( UpdateNotificationWidget , UtilityPanel ) setEmptyMessage ( UploadHistory ) setActiveLayer ( UtilityPanel ) setToolWidget ( UtilityPanel ) t # Target ( AbstractLogger ) type ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , HistoryFileName , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) toIntList ( ButtonList ) toolSize ( CaptureContext , ConfigHandler ) tasks ( CaptureRequest ) tool ( CaptureToolButton ) token ( HistoryFileName ) TerminalLauncher ( TerminalLauncher ) TextConfig ( TextConfig ) TextTool ( TextTool ) TextWidget ( TextWidget ) ToolFactory ( ToolFactory ) TrayIcon ( TrayIcon ) toolWidget ( UtilityPanel ) u # updateBlockedSides ( ButtonHandler ) updateScreenRegions ( ButtonHandler ) updateActiveButtons ( ButtonListView ) ui ( CaptureLauncher , InfoWindow , UploadHistory , UploadLineItem ) updateIcon ( CaptureToolButton ) uncheckActiveTool ( CaptureWidget ) updateCursor ( CaptureWidget , SelectionWidget ) updateLayersPanel ( CaptureWidget ) updateSelectionState ( CaptureWidget ) updateSizeIndicator ( CaptureWidget ) updateTool ( CaptureWidget ) updateWidget ( ColorGrabWidget , ColorPickerWidget ) updatePreset ( ColorPickerEditor ) updateSelection ( ColorPickerWidget ) unregisterShortcut ( GlobalShortcutFilter ) unpackFileName ( History ) upload ( ImgUploaderBase , ImgurUploader ) uploader ( ImgUploaderManager ) uploaderPlugin ( ImgUploaderManager ) url ( ImgUploaderManager ) updateFrame ( LoadSpinner ) undo ( ModificationCommand ) updateGeometry ( OverlayMessage ) updateAreas ( SelectionWidget ) updateColorNoWheel ( SidePanelWidget ) UIcolorEditor ( UIcolorEditor ) UndoTool ( UndoTool ) UpdateNotificationWidget ( UpdateNotificationWidget ) UploadHistory ( UploadHistory ) UploadLineItem ( UploadLineItem ) UserColors ( UserColors ) UtilityPanel ( UtilityPanel ) v # verticalPoints ( ButtonHandler ) value ( CommandLineParser , CommandOption , ConfigHandler , ValueHandler ) valueName ( CommandOption ) valueHandler ( ConfigHandler ) VisualsEditor ( VisualsEditor ) w # warning ( AbstractLogger ) widget ( AppLauncher , TextTool ) widgetOffset ( CaptureContext ) wheelEvent ( CaptureWidget ) WAYLAND_DISPLAY ( DesktopInfo ) WM ( DesktopInfo ) waylandDetected ( DesktopInfo , WaylandUtils ) windowManager ( DesktopInfo ) WaylandUtils ( WaylandUtils ) WinLnkFileParser ( WinLnkFileParser ) x # XDG_CURRENT_DESKTOP ( DesktopInfo ) XDG_SESSION_TYPE ( DesktopInfo ) xywh_position ( GeneralConf ) ~ # ~AbstractLogger ( AbstractLogger ) ~CaptureLauncher ( CaptureLauncher ) ~CaptureToolButton ( CaptureToolButton ) ~CaptureWidget ( CaptureWidget ) ~FlameshotDBusAdapter ( FlameshotDBusAdapter ) ~InfoWindow ( InfoWindow ) ~OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) ~TextTool ( TextTool ) ~TrayIcon ( TrayIcon ) ~UploadHistory ( UploadHistory ) ~UploadLineItem ( UploadLineItem ) _ # _updateComponents ( GeneralConf )","title":"Class Members"},{"location":"flameshot/class_members/#class-members","text":"","title":"Class Members"},{"location":"flameshot/class_members/#a","text":"AbstractActionTool ( AbstractActionTool ) AbstractLogger ( AbstractLogger ) addOutputString ( AbstractLogger ) attachNotificationPath ( AbstractLogger ) AbstractPathTool ( AbstractPathTool ) addPoint ( AbstractPathTool ) AbstractTwoPointTool ( AbstractTwoPointTool ) adjustedVector ( AbstractTwoPointTool ) AcceptTool ( AcceptTool ) AppLauncher ( AppLauncher ) AppLauncherWidget ( AppLauncherWidget ) addAppsToListWidget ( AppLauncherWidget ) ArrowTool ( ArrowTool ) adjustHorizontalCenter ( ButtonHandler ) addPinTask ( CaptureRequest ) addSaveTask ( CaptureRequest ) addTask ( CaptureRequest ) animatedShow ( CaptureToolButton , NotificationWidget ) append ( CaptureToolObjects ) at ( CaptureToolObjects ) activeButtonTool ( CaptureWidget ) activeButtonToolType ( CaptureWidget ) activeToolObject ( CaptureWidget ) addPreset ( ColorPickerEditor ) AddArgument ( CommandLineParser ) AddOption ( CommandLineParser ) AddOptions ( CommandLineParser ) addHelpOption ( CommandLineParser ) addVersionOption ( CommandLineParser ) argument ( CommandLineParser::Node ) addChecker ( CommandOption ) assertKeyRecognized ( ConfigHandler ) autoNumerateDuplicate ( FileNameHandler ) attachPin ( FlameshotDaemon ) attachScreenshotToClipboard ( FlameshotDaemon ) attachTextToClipboard ( FlameshotDaemon ) animatedHide ( NotificationWidget ) appendShortcut ( ShortcutsWidget ) arg ( TerminalApp ) adjustSize ( TextWidget ) appUpdates ( TrayIcon ) addLine ( UploadHistory ) activeLayerIndex ( UtilityPanel )","title":"a"},{"location":"flameshot/class_members/#b","text":"boundingRect ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , InvertTool , OverlayMessage , PixelateTool , TextTool ) Bool ( Bool ) BoundedInt ( BoundedInt ) ButtonHandler ( ButtonHandler ) buttonsAreInside ( ButtonHandler ) ButtonListView ( ButtonListView ) baseName ( ConfigHandler ) buttonBox ( ImgUploadDialog )","title":"b"},{"location":"flameshot/class_members/#c","text":"Channel ( AbstractLogger ) closeOnButtonPressed ( AbstractPathTool , AbstractTwoPointTool , AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) copyParams ( AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , TextTool ) color ( AbstractTwoPointTool , CaptureContext , ColorGrabWidget ) copy ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) capture ( AppLauncher , ImgUploaderTool ) configureListView ( AppLauncherWidget ) check ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors , ValueHandler ) calculateShift ( ButtonHandler ) contains ( ButtonHandler ) CaptureButton ( CaptureButton ) circleCount ( CaptureContext ) CaptureLauncher ( CaptureLauncher ) connectCaptureSlots ( CaptureLauncher ) CaptureMode ( CaptureRequest ) CaptureRequest ( CaptureRequest ) captureMode ( CaptureRequest ) CaptureToolButton ( CaptureToolButton ) CaptureToolObjects ( CaptureToolObjects ) captureToolObjects ( CaptureToolObjects ) clear ( CaptureToolObjects ) CaptureWidget ( CaptureWidget ) changeEvent ( CaptureWidget ) CircleCountTool ( CircleCountTool ) CircleTool ( CircleTool ) ClickableLabel ( ClickableLabel ) Color ( Color ) ColorGrabWidget ( ColorGrabWidget ) cursorPos ( ColorGrabWidget ) ColorPicker ( ColorPicker ) ColorPickerEditMode ( ColorPickerEditMode ) ColorPickerEditor ( ColorPickerEditor ) ColorPickerWidget ( ColorPickerWidget ) CommandArgument ( CommandArgument ) CommandLineParser ( CommandLineParser ) CommandOption ( CommandOption ) checkValue ( CommandOption ) ConfigErrorDetails ( ConfigErrorDetails ) CONFIG_GETTER_SETTER ( ConfigHandler ) ConfigHandler ( ConfigHandler ) checkAndHandleError ( ConfigHandler ) checkForErrors ( ConfigHandler ) checkSemantics ( ConfigHandler ) checkShortcutConflicts ( ConfigHandler ) checkUnrecognizedSettings ( ConfigHandler ) cleanUnusedKeys ( ConfigHandler ) configFilePath ( ConfigHandler ) ConfigResolver ( ConfigResolver ) ConfigWindow ( ConfigWindow ) CopyTool ( CopyTool ) categories ( DesktopAppData ) call ( FlameshotDaemon ) checkDBusConnection ( FlameshotDaemon ) copyToClipboard ( FlameshotDaemon ) createMethodCall ( FlameshotDaemon ) createPin ( FlameshotDaemon ) chooseFolder ( GeneralConf ) compileFromKeyMap ( OverlayMessage ) closePin ( PinWidget ) currentScreen ( QGuiAppCurrentScreen ) closeEditor ( TextTool ) configurationWidget ( TextTool ) CreateTool ( ToolFactory ) clearToolWidget ( UtilityPanel )","title":"c"},{"location":"flameshot/class_members/#d","text":"description ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CommandOption , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) disconnectCaptureSlots ( CaptureLauncher ) data ( CaptureRequest ) delay ( CaptureRequest ) drawErrorMessage ( CaptureWidget ) drawInactiveRegion ( CaptureWidget ) drawObjectSelection ( CaptureWidget , TextTool ) drawToolsData ( CaptureWidget ) deletePreset ( ColorPickerEditor ) defaultLargeColorPalette ( ColorPickerWidget ) defaultSmallColorPalette ( ColorPickerWidget ) dashedNames ( CommandOption ) DesktopAppData ( DesktopAppData ) DesktopFileParser ( DesktopFileParser ) DESKTOP_SESSION ( DesktopInfo ) DesktopInfo ( DesktopInfo ) DraggableWidgetMaker ( DraggableWidgetMaker ) deleteImage ( ImgUploaderBase , ImgurUploader ) drawSearchArea ( InvertTool , PixelateTool ) drawMagnifier ( MagnifierWidget ) drawMagnifierCircle ( MagnifierWidget ) decreaseOpacity ( PinWidget ) desktopGeometry ( ScreenGrabber )","title":"d"},{"location":"flameshot/class_members/#e","text":"enableMessageHeader ( AbstractLogger ) error ( AbstractLogger ) expected ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , SaveFileExtension , String , UserColors , ValueHandler ) ensureSelectionMinimunSize ( ButtonHandler ) expandSelection ( ButtonHandler ) ExportTask ( CaptureRequest ) extendedRect ( CaptureWidget ) extendedSelection ( CaptureWidget ) eventFilter ( ColorGrabWidget , ColorPickerEditMode , DraggableWidgetMaker , HoverEventFilter , SelectionWidget , SidePanelWidget ) errorMsg ( CommandOption ) ensureFileWatched ( ConfigHandler ) errorMessage ( ConfigHandler ) exec ( DesktopAppData ) ExitTool ( ExitTool ) ExtendedSlider ( ExtendedSlider ) enableTrayIcon ( FlameshotDaemon ) enterEvent ( NotifierBox , PinWidget ) event ( PinWidget ) enableCheckUpdatesAction ( TrayIcon )","title":"e"},{"location":"flameshot/class_members/#f","text":"fallback ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , String , UserColors , ValueHandler ) fromIntList ( ButtonList ) fullscreen ( CaptureContext ) find ( CaptureToolObjects ) findWithRadius ( CaptureToolObjects ) finalize ( ColorGrabWidget ) findParent ( CommandLineParser ) filenamePatternDefault ( ConfigHandler ) FileNameEditor ( FileNameEditor ) FileNameHandler ( FileNameHandler ) Flameshot ( Flameshot ) FlameshotDBusAdapter ( FlameshotDBusAdapter ) FlameshotDaemon ( FlameshotDaemon ) file ( HistoryFileName ) freeDesktopPortal ( ScreenGrabber ) fullGeometry ( SelectionWidget ) finalizeGrab ( SidePanelWidget ) fillCaptureTools ( UtilityPanel )","title":"f"},{"location":"flameshot/class_members/#g","text":"globalStyleSheet ( CaptureButton ) getIterableButtonTypes ( CaptureToolButton ) getPriorityByButton ( CaptureToolButton ) getColorAtPoint ( ColorGrabWidget ) getDefaultLargeColorPalette ( ColorPickerWidget ) getDefaultSmallColorPalette ( ColorPickerWidget ) getInstance ( ConfigHandler ) getAppsByCategory ( DesktopFileParser , WinLnkFileParser ) GDMSESSION ( DesktopInfo ) GNOME_DESKTOP_SESSION_ID ( DesktopInfo ) GeneralConf ( GeneralConf ) GlobalShortcutFilter ( GlobalShortcutFilter ) getNativeModifier ( GlobalShortcutFilter ) gestureEvent ( PinWidget ) grabEntireDesktop ( ScreenGrabber ) grabScreen ( ScreenGrabber ) geometry ( SelectionWidget ) getMouseSide ( SelectionWidget ) getPreferedTerminal ( TerminalLauncher ) getAllUsersStartMenuPath ( WinLnkFileParser ) getImageFileExtAssociates ( WinLnkFileParser )","title":"g"},{"location":"flameshot/class_members/#h","text":"hideSectionUnderMouse ( ButtonHandler ) horizontalPoints ( ButtonHandler ) hideEvent ( ColorPicker , NotifierBox , SelectionWidget , SidePanelWidget ) hasError ( ConfigHandler ) haveExternalWidget ( Flameshot ) History ( History ) history ( History ) HoverEventFilter ( HoverEventFilter ) handlerAreas ( SelectionWidget ) hide ( UpdateNotificationWidget , UtilityPanel )","title":"h"},{"location":"flameshot/class_members/#i","text":"isSelectable ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , MoveTool , TextTool ) isValid ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , CircleCountTool , TextTool ) info ( AbstractLogger , CircleCountTool , TextTool ) icon ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) initAppMap ( AppLauncherWidget ) initListWidget ( AppLauncherWidget ) init ( ButtonHandler , CaptureButton , ImgUploaderManager , OverlayMessage ) intersectWithAreas ( ButtonHandler ) isVisible ( ButtonHandler , UtilityPanel ) initButtonList ( ButtonListView ) id ( CaptureRequest ) initialSelection ( CaptureRequest ) initButton ( CaptureToolButton ) iterableButtonTypes ( CaptureToolButton ) insert ( CaptureToolObjects ) initButtons ( CaptureWidget , UIcolorEditor ) initContext ( CaptureWidget ) initHelpMessage ( CaptureWidget ) initPanel ( CaptureWidget ) initSelection ( CaptureWidget ) initShortcuts ( CaptureWidget ) initColorPicker ( ColorPickerWidget ) isRoot ( CommandArgument ) isSet ( CommandLineParser ) isShortcut ( ConfigHandler ) initErrorIndicator ( ConfigWindow ) initLayout ( FileNameEditor ) initWidgets ( FileNameEditor , VisualsEditor ) instance ( Flameshot , FlameshotDaemon , OverlayMessage ) initTrayIcon ( FlameshotDaemon , TrayIcon ) isThisInstanceHostingWidgets ( FlameshotDaemon ) initAllowMultipleGuiInstances ( GeneralConf ) initAntialiasingPinZoom ( GeneralConf ) initAutoCloseIdleDaemon ( GeneralConf ) initAutostart ( GeneralConf ) initCheckForUpdates ( GeneralConf ) initConfigButtons ( GeneralConf ) initCopyAndCloseAfterUpload ( GeneralConf ) initCopyOnDoubleClick ( GeneralConf ) initCopyPathAfterSave ( GeneralConf ) initHistoryConfirmationToDelete ( GeneralConf ) initPredefinedColorPaletteLarge ( GeneralConf ) initSaveAfterCopy ( GeneralConf ) initSaveLastRegion ( GeneralConf ) initScrollArea ( GeneralConf ) initShowDesktopNotification ( GeneralConf ) initShowHelp ( GeneralConf ) initShowMagnifier ( GeneralConf ) initShowSelectionGeometry ( GeneralConf ) initShowSidePanelButton ( GeneralConf ) initShowStartupLaunchMessage ( GeneralConf ) initShowTrayIcon ( GeneralConf ) initSquareMagnifier ( GeneralConf ) initUndoLimit ( GeneralConf ) initUploadClientSecret ( GeneralConf ) initUploadHistoryMax ( GeneralConf ) initUploadWithoutConfirmation ( GeneralConf ) initUseJpgForClipboard ( GeneralConf ) ImageLabel ( ImageLabel ) ImgUploadDialog ( ImgUploadDialog ) ImgUploaderBase ( ImgUploaderBase ) imageURL ( ImgUploaderBase ) ImgUploaderManager ( ImgUploaderManager ) ImgUploaderTool ( ImgUploaderTool ) ImgurUploader ( ImgurUploader ) InfoWindow ( InfoWindow ) InvertTool ( InvertTool ) increaseOpacity ( PinWidget ) initInfoTable ( ShortcutsWidget ) isChanged ( TextTool ) initMenu ( TrayIcon ) initColorWheel ( UIcolorEditor ) initInternalPanel ( UpdateNotificationWidget , UtilityPanel ) initOpacitySlider ( VisualsEditor )","title":"i"},{"location":"flameshot/class_members/#k","text":"keyPressEvent ( AppLauncherWidget , CaptureWidget , ConfigWindow , InfoWindow , PinWidget , SetShortcutDialog ) keyReleaseEvent ( CaptureWidget , SetShortcutDialog ) keysFromGroup ( ConfigHandler ) KDE_FULL_SESSION ( DesktopInfo ) KeySequence ( KeySequence )","title":"k"},{"location":"flameshot/class_members/#l","text":"layout ( ConfigResolver , ImgUploadDialog ) LauncherItemDelegate ( LauncherItemDelegate ) LineTool ( LineTool ) LoadSpinner ( LoadSpinner ) LowerBoundedInt ( LowerBoundedInt ) leaveEvent ( PinWidget ) loadShortcuts ( ShortcutsWidget ) launchDetached ( TerminalLauncher ) loadHistory ( UploadHistory )","title":"l"},{"location":"flameshot/class_members/#m","text":"m_defaultChannel ( AbstractLogger ) m_enableMessageHeader ( AbstractLogger ) m_notificationPath ( AbstractLogger ) m_targets ( AbstractLogger ) m_textStreams ( AbstractLogger ) messageHeader ( AbstractLogger ) m_color ( AbstractPathTool , AbstractTwoPointTool , ColorGrabWidget , ColorPickerEditor , LoadSpinner , MagnifierWidget , SelectionWidget , SidePanelWidget , TextTool ) m_padding ( AbstractPathTool , AbstractTwoPointTool ) m_pathArea ( AbstractPathTool ) m_points ( AbstractPathTool , AbstractTwoPointTool ) m_pos ( AbstractPathTool ) m_thickness ( AbstractPathTool , AbstractTwoPointTool ) mousePreviewRect ( AbstractPathTool , AbstractTwoPointTool , CircleCountTool , MarkerTool ) move ( AbstractPathTool , AbstractTwoPointTool , TextTool ) m_supportsDiagonalAdj ( AbstractTwoPointTool ) m_supportsOrthogonalAdj ( AbstractTwoPointTool ) m_appsMap ( AppLauncherWidget ) m_filterList ( AppLauncherWidget ) m_keepOpen ( AppLauncherWidget ) m_keepOpenCheckbox ( AppLauncherWidget ) m_layout ( AppLauncherWidget , FileNameEditor , GeneralConf , NotificationWidget , PinWidget , SetShortcutDialog , ShortcutsWidget , SidePanelWidget , TextConfig , UpdateNotificationWidget , UtilityPanel , VisualsEditor ) m_lineEdit ( AppLauncherWidget ) m_parser ( AppLauncherWidget ) m_pixmap ( AppLauncherWidget , ColorGrabWidget , ImageLabel , ImgUploaderBase , PinTool , PinWidget , SidePanelWidget ) m_tabWidget ( AppLauncherWidget , ConfigWindow , VisualsEditor ) m_tempFile ( AppLauncherWidget ) m_terminalCheckbox ( AppLauncherWidget ) m_arrowPath ( ArrowTool ) m_def ( Bool , BoundedInt , Color , LowerBoundedInt , String ) m_max ( BoundedInt , UserColors ) m_min ( BoundedInt , LowerBoundedInt , UserColors ) m_allSidesBlocked ( ButtonHandler ) m_blockedBotton ( ButtonHandler ) m_blockedLeft ( ButtonHandler ) m_blockedRight ( ButtonHandler ) m_blockedTop ( ButtonHandler ) m_buttonBaseSize ( ButtonHandler ) m_buttonExtendedSize ( ButtonHandler ) m_buttonsAreInside ( ButtonHandler ) m_horizontalyBlocked ( ButtonHandler ) m_oneHorizontalBlocked ( ButtonHandler ) m_screenRegions ( ButtonHandler ) m_selection ( ButtonHandler , CaptureWidget ) m_separator ( ButtonHandler ) m_vectorButtons ( ButtonHandler ) moveButtonsToPoints ( ButtonHandler ) m_buttonTypeByName ( ButtonListView ) m_listButtons ( ButtonListView ) m_mainColor ( CaptureButton , CaptureToolButton ) mousePos ( CaptureContext ) m_data ( CaptureRequest ) m_delay ( CaptureRequest ) m_initialSelection ( CaptureRequest ) m_mode ( CaptureRequest ) m_path ( CaptureRequest ) m_pinWindowGeometry ( CaptureRequest ) m_tasks ( CaptureRequest ) m_buttonType ( CaptureToolButton ) m_emergeAnimation ( CaptureToolButton ) m_tool ( CaptureToolButton ) mousePressEvent ( CaptureToolButton , CaptureWidget , ClickableLabel , ImageLabel , PinWidget ) m_captureToolObjects ( CaptureToolObjects , CaptureWidget , ModificationCommand ) m_imageCache ( CaptureToolObjects ) m_activeButton ( CaptureWidget ) m_activeTool ( CaptureWidget ) m_activeToolIsMoved ( CaptureWidget ) m_activeToolOffsetToMouseOnStart ( CaptureWidget ) m_adjustmentButtonPressed ( CaptureWidget ) m_buttonHandler ( CaptureWidget ) m_captureDone ( CaptureWidget ) m_captureToolObjectsBackup ( CaptureWidget , ModificationCommand ) m_colorPicker ( CaptureWidget ) m_config ( CaptureWidget , ColorPickerEditMode , ColorPickerEditor , ShortcutsWidget ) m_configError ( CaptureWidget ) m_configErrorResolved ( CaptureWidget ) m_context ( CaptureWidget ) m_contrastUiColor ( CaptureWidget ) m_eventFilter ( CaptureWidget ) m_existingObjectIsChanged ( CaptureWidget ) m_helpMessage ( CaptureWidget , GeneralConf ) m_lastMouseWheel ( CaptureWidget ) m_magnifier ( CaptureWidget ) m_mouseIsClicked ( CaptureWidget ) m_mouseOverHandle ( CaptureWidget ) m_mousePressedPos ( CaptureWidget ) m_movingSelection ( CaptureWidget ) m_newSelection ( CaptureWidget ) m_notifierBox ( CaptureWidget ) m_opacity ( CaptureWidget , PinWidget ) m_panel ( CaptureWidget ) m_previewEnabled ( CaptureWidget ) m_sidePanel ( CaptureWidget ) m_sizeIndButton ( CaptureWidget ) m_startMove ( CaptureWidget ) m_startMovePos ( CaptureWidget ) m_toolSizeByKeyboard ( CaptureWidget ) m_toolWidget ( CaptureWidget , UtilityPanel ) m_tools ( CaptureWidget ) m_uiColor ( CaptureWidget , ColorPickerWidget , UIcolorEditor ) m_undoStack ( CaptureWidget ) m_updateNotificationWidget ( CaptureWidget ) m_xywhDisplay ( CaptureWidget ) m_xywhTimer ( CaptureWidget ) makeChild ( CaptureWidget ) mouseDoubleClickEvent ( CaptureWidget , PinWidget ) mouseMoveEvent ( CaptureWidget , ColorPicker , ImageLabel , PinWidget ) mouseReleaseEvent ( CaptureWidget , ImageLabel ) moveEvent ( CaptureWidget , SelectionWidget ) m_tempString ( CircleCountTool , TextTool ) m_valid ( CircleCountTool ) m_extraZoomActive ( ColorGrabWidget ) m_magnifierActive ( ColorGrabWidget ) m_mousePressReceived ( ColorGrabWidget ) m_previewImage ( ColorGrabWidget ) m_draggedPresetInitialPos ( ColorPickerEditMode ) m_isDragging ( ColorPickerEditMode , DraggableWidgetMaker ) m_isPressing ( ColorPickerEditMode , DraggableWidgetMaker ) m_mouseMovePos ( ColorPickerEditMode , DraggableWidgetMaker ) m_mousePressPos ( ColorPickerEditMode , DraggableWidgetMaker ) m_addPresetButton ( ColorPickerEditor ) m_addPresetLabel ( ColorPickerEditor ) m_colorEdit ( ColorPickerEditor ) m_colorEditLabel ( ColorPickerEditor ) m_colorInput ( ColorPickerEditor ) m_colorList ( ColorPickerEditor , ColorPickerWidget ) m_colorWheel ( ColorPickerEditor , SidePanelWidget , UIcolorEditor ) m_colorpicker ( ColorPickerEditor ) m_deletePresetButton ( ColorPickerEditor ) m_gLayout ( ColorPickerEditor ) m_selectedIndex ( ColorPickerEditor , ColorPickerWidget ) m_updatePresetButton ( ColorPickerEditor ) m_colorAreaList ( ColorPickerWidget ) m_colorAreaSize ( ColorPickerWidget ) m_lastIndex ( ColorPickerWidget ) m_description ( CommandArgument , CommandLineParser , CommandOption ) m_name ( CommandArgument ) m_foundArgs ( CommandLineParser ) m_foundOptions ( CommandLineParser ) m_generalErrorMessage ( CommandLineParser ) m_parseTree ( CommandLineParser ) m_withHelp ( CommandLineParser ) m_withVersion ( CommandLineParser ) m_checker ( CommandOption ) m_errorMsg ( CommandOption ) m_names ( CommandOption ) m_value ( CommandOption ) m_valueName ( CommandOption ) m_configWatcher ( ConfigHandler ) m_errorCheckPending ( ConfigHandler ) m_hasError ( ConfigHandler ) m_settings ( ConfigHandler ) m_skipNextErrorCheck ( ConfigHandler ) m_filenameEditor ( ConfigWindow ) m_filenameEditorTab ( ConfigWindow ) m_generalConfig ( ConfigWindow ) m_generalConfigTab ( ConfigWindow ) m_shortcuts ( ConfigWindow , ShortcutsWidget ) m_shortcutsTab ( ConfigWindow ) m_visuals ( ConfigWindow ) m_visualsTab ( ConfigWindow ) m_appList ( DesktopFileParser , WinLnkFileParser ) m_defaultIcon ( DesktopFileParser ) m_localeDescription ( DesktopFileParser ) m_localeDescriptionShort ( DesktopFileParser ) m_localeName ( DesktopFileParser ) m_localeNameShort ( DesktopFileParser ) makeDraggable ( DraggableWidgetMaker ) m_timer ( ExtendedSlider , LoadSpinner , NotificationWidget , NotifierBox ) mappedValue ( ExtendedSlider ) m_clearButton ( FileNameEditor ) m_helperButtons ( FileNameEditor ) m_nameEditor ( FileNameEditor ) m_nameHandler ( FileNameEditor ) m_outputLabel ( FileNameEditor ) m_resetButton ( FileNameEditor , GeneralConf ) m_saveButton ( FileNameEditor ) MAX_CHARACTERS ( FileNameHandler ) m_captureWindow ( Flameshot ) m_configWindow ( Flameshot ) m_haveExternalWidget ( Flameshot ) m_infoWindow ( Flameshot ) m_launcherWindow ( Flameshot ) m_origin ( Flameshot ) m_appLatestUrl ( FlameshotDaemon , UpdateNotificationWidget ) m_appLatestVersion ( FlameshotDaemon , UpdateNotificationWidget ) m_clipboardSignalBlocked ( FlameshotDaemon ) m_hostingClipboard ( FlameshotDaemon ) m_instance ( FlameshotDaemon , OverlayMessage ) m_networkCheckUpdates ( FlameshotDaemon ) m_persist ( FlameshotDaemon ) m_showCheckAppUpdateStatus ( FlameshotDaemon ) m_trayIcon ( FlameshotDaemon ) m_widgets ( FlameshotDaemon ) m_allowMultipleGuiInstances ( GeneralConf ) m_antialiasingPinZoom ( GeneralConf ) m_autoCloseIdleDaemon ( GeneralConf ) m_autostart ( GeneralConf ) m_changeSaveButton ( GeneralConf ) m_checkForUpdates ( GeneralConf ) m_copyOnDoubleClick ( GeneralConf ) m_copyPathAfterSave ( GeneralConf ) m_copyURLAfterUpload ( GeneralConf ) m_exportButton ( GeneralConf ) m_historyConfirmationToDelete ( GeneralConf ) m_importButton ( GeneralConf ) m_predefinedColorPaletteLarge ( GeneralConf ) m_saveAfterCopy ( GeneralConf ) m_saveLastRegion ( GeneralConf ) m_savePath ( GeneralConf ) m_screenshotPathFixedCheck ( GeneralConf ) m_scrollArea ( GeneralConf ) m_scrollAreaLayout ( GeneralConf ) m_selectGeometryLocation ( GeneralConf ) m_setSaveAsFileExtension ( GeneralConf ) m_showMagnifier ( GeneralConf ) m_showSelectionGeometry ( GeneralConf ) m_showStartupLaunchMessage ( GeneralConf ) m_showTray ( GeneralConf ) m_sidePanelButton ( GeneralConf ) m_squareMagnifier ( GeneralConf ) m_sysNotifications ( GeneralConf ) m_undoLimit ( GeneralConf ) m_uploadClientKey ( GeneralConf ) m_uploadHistoryMax ( GeneralConf ) m_uploadWithoutConfirmation ( GeneralConf , ImgUploadDialog ) m_useJpgForClipboard ( GeneralConf ) m_xywhTimeout ( GeneralConf ) m_historyPath ( History ) m_packedFileName ( History ) m_thumbs ( History ) m_unpackedFileName ( History ) m_DSEffect ( ImageLabel ) m_dragStartPosition ( ImageLabel ) m_uploadLabel ( ImgUploadDialog ) m_copyUrlButton ( ImgUploaderBase ) m_currentImageName ( ImgUploaderBase ) m_hLayout ( ImgUploaderBase , UIcolorEditor ) m_imageURL ( ImgUploaderBase ) m_infoLabel ( ImgUploaderBase ) m_notification ( ImgUploaderBase , UpdateNotificationWidget ) m_openDeleteUrlButton ( ImgUploaderBase ) m_openUrlButton ( ImgUploaderBase ) m_saveToFilesystemButton ( ImgUploaderBase ) m_spinner ( ImgUploaderBase ) m_toClipboardButton ( ImgUploaderBase ) m_vLayout ( ImgUploaderBase , UIcolorEditor ) m_imgUploaderBase ( ImgUploaderManager ) m_imgUploaderPlugin ( ImgUploaderManager ) m_urlString ( ImgUploaderManager ) m_NetworkAM ( ImgurUploader ) m_fallback ( KeySequence ) m_frame ( LoadSpinner ) m_growing ( LoadSpinner ) m_span ( LoadSpinner ) m_startAngle ( LoadSpinner ) MagnifierWidget ( MagnifierWidget ) m_borderColor ( MagnifierWidget ) m_devicePixelRatio ( MagnifierWidget ) m_magOffset ( MagnifierWidget ) m_magPixels ( MagnifierWidget ) m_paddedScreenshot ( MagnifierWidget ) m_pixels ( MagnifierWidget ) m_screenshot ( MagnifierWidget ) m_square ( MagnifierWidget ) magZoom ( MagnifierWidget ) MarkerTool ( MarkerTool ) ModificationCommand ( ModificationCommand ) m_captureWidget ( ModificationCommand , UtilityPanel ) MoveTool ( MoveTool ) m_content ( NotificationWidget ) m_hideAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_label ( NotificationWidget , PinWidget ) m_showAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_bgColor ( NotifierBox ) m_foregroundColor ( NotifierBox ) m_message ( NotifierBox ) m_orientation ( OrientablePushButton ) m_fillColor ( OverlayMessage ) m_messageStack ( OverlayMessage ) m_targetArea ( OverlayMessage ) m_textColor ( OverlayMessage ) m_geometry ( PinTool ) m_baseColor ( PinWidget ) m_currentStepScaleFactor ( PinWidget ) m_dragStart ( PinWidget ) m_expanding ( PinWidget ) m_hoverColor ( PinWidget ) m_offsetX ( PinWidget ) m_offsetY ( PinWidget ) m_rotateFactor ( PinWidget ) m_scaleFactor ( PinWidget ) m_shadowEffect ( PinWidget ) m_sizeChanged ( PinWidget ) m_currentScreen ( QGuiAppCurrentScreen ) m_info ( ScreenGrabber ) m_BArea ( SelectionWidget ) m_BHandle ( SelectionWidget ) m_BLArea ( SelectionWidget ) m_BLHandle ( SelectionWidget ) m_BRArea ( SelectionWidget ) m_BRHandle ( SelectionWidget ) m_LArea ( SelectionWidget ) m_LHandle ( SelectionWidget ) m_RArea ( SelectionWidget ) m_RHandle ( SelectionWidget ) m_TArea ( SelectionWidget ) m_THandle ( SelectionWidget ) m_TLArea ( SelectionWidget ) m_TLHandle ( SelectionWidget ) m_TRArea ( SelectionWidget ) m_TRHandle ( SelectionWidget ) m_activeSide ( SelectionWidget ) m_animation ( SelectionWidget ) m_areaOffset ( SelectionWidget ) m_dragStartPos ( SelectionWidget ) m_handleOffset ( SelectionWidget ) m_idleCentralCursor ( SelectionWidget ) m_ignoreMouse ( SelectionWidget ) m_mouseStartMove ( SelectionWidget ) m_ks ( SetShortcutDialog ) m_modifier ( SetShortcutDialog ) m_table ( ShortcutsWidget ) m_colorGrabButton ( SidePanelWidget ) m_colorGrabber ( SidePanelWidget ) m_colorHex ( SidePanelWidget ) m_colorLabel ( SidePanelWidget ) m_revertColor ( SidePanelWidget ) m_toolSize ( SidePanelWidget ) m_toolSizeSlider ( SidePanelWidget ) m_toolSizeSpin ( SidePanelWidget ) m_buttonData ( StrftimeChooserWidget ) m_interface ( SystemNotification ) m_centerAlignButton ( TextConfig ) m_fontsCB ( TextConfig ) m_italicButton ( TextConfig ) m_leftAlignButton ( TextConfig ) m_rightAlignButton ( TextConfig ) m_strikeOutButton ( TextConfig ) m_underlineButton ( TextConfig ) m_weightButton ( TextConfig ) m_alignment ( TextTool ) m_confW ( TextTool ) m_currentPos ( TextTool ) m_font ( TextTool ) m_size ( TextTool ) m_text ( TextTool ) m_textArea ( TextTool ) m_textOld ( TextTool ) m_widget ( TextTool ) m_baseSize ( TextWidget ) m_minSize ( TextWidget ) m_appUpdates ( TrayIcon ) m_menu ( TrayIcon ) m_buttonContrast ( UIcolorEditor ) m_buttonIconType ( UIcolorEditor ) m_buttonMainColor ( UIcolorEditor ) m_contrastColor ( UIcolorEditor ) m_labelContrast ( UIcolorEditor ) m_labelMain ( UIcolorEditor ) m_lastButtonPressed ( UIcolorEditor ) m_internalPanel ( UpdateNotificationWidget , UtilityPanel ) m_bottomLayout ( UtilityPanel ) m_buttonDelete ( UtilityPanel ) m_buttonMoveDown ( UtilityPanel ) m_buttonMoveUp ( UtilityPanel ) m_captureTools ( UtilityPanel ) m_layersLayout ( UtilityPanel ) m_upLayout ( UtilityPanel ) m_buttonList ( VisualsEditor ) m_colorEditor ( VisualsEditor ) m_colorEditorTab ( VisualsEditor ) m_colorpickerEditor ( VisualsEditor ) m_colorpickerEditorTab ( VisualsEditor ) m_opacitySlider ( VisualsEditor ) m_GraphicAppsList ( WinLnkFileParser )","title":"m"},{"location":"flameshot/class_members/#n","text":"name ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CopyTool , DesktopAppData , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TerminalApp , TextTool , UndoTool ) normalizeButtons ( ButtonList ) newShortcut ( CaptureWidget ) Node ( CommandLineParser::Node ) names ( CommandOption ) nativeEventFilter ( GlobalShortcutFilter ) nativeKeycode ( GlobalShortcutFilter ) notification ( ImgUploaderBase ) NotificationWidget ( NotificationWidget ) NotifierBox ( NotifierBox )","title":"n"},{"location":"flameshot/class_members/#o","text":"operator<< ( AbstractLogger ) origScreenshot ( CaptureContext ) operator= ( CaptureToolObjects , ToolFactory ) operator== ( CommandArgument , CommandLineParser::Node , CommandOption , DesktopAppData ) options ( CommandLineParser::Node ) operator() ( CompareAppByName ) Origin ( Flameshot ) origin ( Flameshot ) OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) OrientablePushButton ( OrientablePushButton ) Orientation ( OrientablePushButton ) orientation ( OrientablePushButton ) OverlayMessage ( OverlayMessage )","title":"o"},{"location":"flameshot/class_members/#p","text":"paintMousePreview ( AbstractActionTool , AbstractTwoPointTool , CircleCountTool , InvertTool , MarkerTool , PencilTool , PixelateTool , TextTool ) process ( AbstractActionTool , ArrowTool , ButtonList , CircleCountTool , CircleTool , Color , FilenamePattern , InvertTool , KeySequence , LineTool , MarkerTool , PencilTool , PixelateTool , RectangleTool , Region , SaveFileExtension , SelectionTool , TextTool , UserColors , ValueHandler ) pos ( AbstractPathTool , AbstractTwoPointTool , TextTool ) points ( AbstractTwoPointTool ) positionButtonsInside ( ButtonHandler ) path ( CaptureRequest , History ) paddedUpdateRect ( CaptureWidget ) paintEvent ( CaptureWidget , ColorGrabWidget , ColorPickerWidget , LoadSpinner , MagnifierWidget , NotifierBox , OrientablePushButton , OverlayMessage , PinWidget , SelectionWidget ) pixmap ( CaptureWidget , ImgUploaderBase ) processPixmapWithTool ( CaptureWidget ) pushObjectsStateToUndoStack ( CaptureWidget ) pushToolToStack ( CaptureWidget ) parse ( CommandLineParser ) printHelp ( CommandLineParser ) printVersion ( CommandLineParser ) processArgs ( CommandLineParser ) processIfOptionIsHelp ( CommandLineParser ) processOptions ( CommandLineParser ) populate ( ConfigResolver ) parseDesktopFile ( DesktopFileParser ) processDirectory ( DesktopFileParser , WinLnkFileParser ) parseFilename ( FileNameHandler ) parsedPattern ( FileNameHandler ) properScreenshotPath ( FileNameHandler ) packFileName ( History ) paint ( LauncherItemDelegate ) pop ( OverlayMessage ) push ( OverlayMessage ) pushKeyMap ( OverlayMessage ) PencilTool ( PencilTool ) PinTool ( PinTool ) PinWidget ( PinWidget ) pinchTriggered ( PinWidget ) PixelateTool ( PixelateTool ) parentMouseMoveEvent ( SelectionWidget ) parentMousePressEvent ( SelectionWidget ) parentMouseReleaseEvent ( SelectionWidget ) pushWidget ( UtilityPanel ) parseLnkFile ( WinLnkFileParser )","title":"p"},{"location":"flameshot/class_members/#q","text":"quitIfIdle ( FlameshotDaemon ) QGuiAppCurrentScreen ( QGuiAppCurrentScreen )","title":"q"},{"location":"flameshot/class_members/#r","text":"resetRegionTrack ( ButtonHandler ) representation ( ButtonList , Color , KeySequence , UserColors , ValueHandler ) request ( CaptureContext ) removeTask ( CaptureRequest ) removeAt ( CaptureToolObjects ) releaseActiveTool ( CaptureWidget ) removeToolObject ( CaptureWidget ) resizeEvent ( CaptureWidget , ImageLabel , SelectionWidget , TextWidget ) restoreCircleCountState ( CaptureWidget ) repaint ( ColorPickerWidget ) recursiveParentSearch ( CommandLineParser ) rootArgument ( CommandLineParser ) recognizedGeneralOptions ( ConfigHandler ) recognizedShortcutNames ( ConfigHandler ) remove ( ConfigHandler ) resetValue ( ConfigHandler ) resetLayout ( ConfigResolver ) resolveAnyConfigErrors ( Flameshot ) registerShortcut ( GlobalShortcutFilter ) redo ( ModificationCommand ) rotateLeft ( PinWidget ) rotateRight ( PinWidget ) RectangleTool ( RectangleTool ) RedoTool ( RedoTool ) rect ( SelectionWidget )","title":"r"},{"location":"flameshot/class_members/#s","text":"showMousePreview ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , TextTool ) sendMessage ( AbstractLogger , SystemNotification ) size ( AbstractPathTool , AbstractTwoPointTool , ButtonHandler , CaptureToolObjects ) setPadding ( AbstractTwoPointTool ) setButtons ( ButtonHandler ) setColor ( CaptureButton , CaptureToolButton , LoadSpinner ) styleSheet ( CaptureButton ) savePath ( CaptureContext ) screenshot ( CaptureContext ) selectedScreenshotArea ( CaptureContext ) selection ( CaptureContext ) setInitialSelection ( CaptureRequest ) setStaticID ( CaptureRequest ) selectToolItemAtPos ( CaptureWidget ) setCaptureToolObjects ( CaptureWidget ) setToolSize ( CaptureWidget , ConfigHandler ) showAppUpdateNotification ( CaptureWidget ) showColorPicker ( CaptureWidget ) showxywh ( CaptureWidget ) startDrawObjectTool ( CaptureWidget ) setExtraZoomActive ( ColorGrabWidget ) setMagnifierActive ( ColorGrabWidget ) showEvent ( ColorGrabWidget , ColorPicker , SelectionWidget , TextWidget ) startGrabbing ( ColorGrabWidget ) setDescription ( CommandArgument , CommandLineParser , CommandOption ) setName ( CommandArgument , CommandOption ) setGeneralErrorMessage ( CommandLineParser ) subNodes ( CommandLineParser::Node ) setNames ( CommandOption ) setValue ( CommandOption , ConfigHandler ) setValueName ( CommandOption ) setAllTheButtons ( ConfigHandler ) setDefaultSettings ( ConfigHandler ) setErrorState ( ConfigHandler ) setShortcut ( ConfigHandler ) setShowDesktopNotification ( ConfigHandler ) setShowStartupLaunchMessage ( ConfigHandler ) setStartupLaunch ( ConfigHandler ) setUploadWithoutConfirmation ( ConfigHandler ) shortcut ( ConfigHandler , SetShortcutDialog ) showInTerminal ( DesktopAppData ) setMapedValue ( ExtendedSlider ) setExternalWidget ( Flameshot ) setOrigin ( Flameshot ) sendTrayNotification ( FlameshotDaemon ) showUpdateNotificationIfAvailable ( FlameshotDaemon ) start ( FlameshotDaemon , LoadSpinner ) save ( History ) setScaledPixmap ( ImageLabel ) setScreenshot ( ImageLabel ) setImageURL ( ImgUploaderBase ) setInfoLabelText ( ImgUploaderBase ) setPixmap ( ImgUploaderBase ) spinner ( ImgUploaderBase ) sizeHint ( LauncherItemDelegate , OrientablePushButton ) setHeight ( LoadSpinner ) setWidth ( LoadSpinner ) stop ( LoadSpinner ) showMessage ( NotificationWidget ) staticInterfaceName ( OrgFreedesktopPortalRequestInterface ) setOrientation ( OrientablePushButton ) setVisibility ( OverlayMessage ) scrollEvent ( PinWidget ) screenAt ( QGuiAppCurrentScreen ) SaveTool ( SaveTool ) ScreenGrabber ( ScreenGrabber ) screenGeometry ( ScreenGrabber ) SelectionTool ( SelectionTool ) SelectionWidget ( SelectionWidget ) SideType ( SelectionWidget ) setGeometry ( SelectionWidget ) setGeometryAnimated ( SelectionWidget ) setGeometryByKeyboard ( SelectionWidget ) setIdleCentralCursor ( SelectionWidget ) setIgnoreMouse ( SelectionWidget ) SetShortcutDialog ( SetShortcutDialog ) ShortcutsWidget ( ShortcutsWidget ) SidePanelWidget ( SidePanelWidget ) SizeDecreaseTool ( SizeDecreaseTool ) SizeIncreaseTool ( SizeIncreaseTool ) StrftimeChooserWidget ( StrftimeChooserWidget ) String ( String ) styleHint ( StyleOverride ) SystemNotification ( SystemNotification ) setFontFamily ( TextConfig ) setItalic ( TextConfig ) setStrikeOut ( TextConfig ) setTextAlignment ( TextConfig ) setUnderline ( TextConfig ) setWeight ( TextConfig ) setEditMode ( TextTool ) setFont ( TextWidget ) startGuiCapture ( TrayIcon ) setAppLatestVersion ( UpdateNotificationWidget ) show ( UpdateNotificationWidget , UtilityPanel ) setEmptyMessage ( UploadHistory ) setActiveLayer ( UtilityPanel ) setToolWidget ( UtilityPanel )","title":"s"},{"location":"flameshot/class_members/#t","text":"Target ( AbstractLogger ) type ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , HistoryFileName , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) toIntList ( ButtonList ) toolSize ( CaptureContext , ConfigHandler ) tasks ( CaptureRequest ) tool ( CaptureToolButton ) token ( HistoryFileName ) TerminalLauncher ( TerminalLauncher ) TextConfig ( TextConfig ) TextTool ( TextTool ) TextWidget ( TextWidget ) ToolFactory ( ToolFactory ) TrayIcon ( TrayIcon ) toolWidget ( UtilityPanel )","title":"t"},{"location":"flameshot/class_members/#u","text":"updateBlockedSides ( ButtonHandler ) updateScreenRegions ( ButtonHandler ) updateActiveButtons ( ButtonListView ) ui ( CaptureLauncher , InfoWindow , UploadHistory , UploadLineItem ) updateIcon ( CaptureToolButton ) uncheckActiveTool ( CaptureWidget ) updateCursor ( CaptureWidget , SelectionWidget ) updateLayersPanel ( CaptureWidget ) updateSelectionState ( CaptureWidget ) updateSizeIndicator ( CaptureWidget ) updateTool ( CaptureWidget ) updateWidget ( ColorGrabWidget , ColorPickerWidget ) updatePreset ( ColorPickerEditor ) updateSelection ( ColorPickerWidget ) unregisterShortcut ( GlobalShortcutFilter ) unpackFileName ( History ) upload ( ImgUploaderBase , ImgurUploader ) uploader ( ImgUploaderManager ) uploaderPlugin ( ImgUploaderManager ) url ( ImgUploaderManager ) updateFrame ( LoadSpinner ) undo ( ModificationCommand ) updateGeometry ( OverlayMessage ) updateAreas ( SelectionWidget ) updateColorNoWheel ( SidePanelWidget ) UIcolorEditor ( UIcolorEditor ) UndoTool ( UndoTool ) UpdateNotificationWidget ( UpdateNotificationWidget ) UploadHistory ( UploadHistory ) UploadLineItem ( UploadLineItem ) UserColors ( UserColors ) UtilityPanel ( UtilityPanel )","title":"u"},{"location":"flameshot/class_members/#v","text":"verticalPoints ( ButtonHandler ) value ( CommandLineParser , CommandOption , ConfigHandler , ValueHandler ) valueName ( CommandOption ) valueHandler ( ConfigHandler ) VisualsEditor ( VisualsEditor )","title":"v"},{"location":"flameshot/class_members/#w","text":"warning ( AbstractLogger ) widget ( AppLauncher , TextTool ) widgetOffset ( CaptureContext ) wheelEvent ( CaptureWidget ) WAYLAND_DISPLAY ( DesktopInfo ) WM ( DesktopInfo ) waylandDetected ( DesktopInfo , WaylandUtils ) windowManager ( DesktopInfo ) WaylandUtils ( WaylandUtils ) WinLnkFileParser ( WinLnkFileParser )","title":"w"},{"location":"flameshot/class_members/#x","text":"XDG_CURRENT_DESKTOP ( DesktopInfo ) XDG_SESSION_TYPE ( DesktopInfo ) xywh_position ( GeneralConf )","title":"x"},{"location":"flameshot/class_members/#_1","text":"~AbstractLogger ( AbstractLogger ) ~CaptureLauncher ( CaptureLauncher ) ~CaptureToolButton ( CaptureToolButton ) ~CaptureWidget ( CaptureWidget ) ~FlameshotDBusAdapter ( FlameshotDBusAdapter ) ~InfoWindow ( InfoWindow ) ~OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) ~TextTool ( TextTool ) ~TrayIcon ( TrayIcon ) ~UploadHistory ( UploadHistory ) ~UploadLineItem ( UploadLineItem )","title":"~"},{"location":"flameshot/class_members/#_","text":"_updateComponents ( GeneralConf )","title":"_"},{"location":"flameshot/class_member_functions/","text":"Class Member Functions # a # AbstractActionTool ( AbstractActionTool ) AbstractLogger ( AbstractLogger ) addOutputString ( AbstractLogger ) attachNotificationPath ( AbstractLogger ) AbstractPathTool ( AbstractPathTool ) addPoint ( AbstractPathTool ) AbstractTwoPointTool ( AbstractTwoPointTool ) adjustedVector ( AbstractTwoPointTool ) AcceptTool ( AcceptTool ) AppLauncher ( AppLauncher ) AppLauncherWidget ( AppLauncherWidget ) addAppsToListWidget ( AppLauncherWidget ) ArrowTool ( ArrowTool ) adjustHorizontalCenter ( ButtonHandler ) addPinTask ( CaptureRequest ) addSaveTask ( CaptureRequest ) addTask ( CaptureRequest ) animatedShow ( CaptureToolButton , NotificationWidget ) append ( CaptureToolObjects ) at ( CaptureToolObjects ) activeButtonTool ( CaptureWidget ) activeButtonToolType ( CaptureWidget ) activeToolObject ( CaptureWidget ) addPreset ( ColorPickerEditor ) AddArgument ( CommandLineParser ) AddOption ( CommandLineParser ) AddOptions ( CommandLineParser ) addHelpOption ( CommandLineParser ) addVersionOption ( CommandLineParser ) addChecker ( CommandOption ) assertKeyRecognized ( ConfigHandler ) autoNumerateDuplicate ( FileNameHandler ) attachPin ( FlameshotDaemon ) attachScreenshotToClipboard ( FlameshotDaemon ) attachTextToClipboard ( FlameshotDaemon ) animatedHide ( NotificationWidget ) appendShortcut ( ShortcutsWidget ) adjustSize ( TextWidget ) appUpdates ( TrayIcon ) addLine ( UploadHistory ) activeLayerIndex ( UtilityPanel ) b # boundingRect ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , InvertTool , OverlayMessage , PixelateTool , TextTool ) Bool ( Bool ) BoundedInt ( BoundedInt ) ButtonHandler ( ButtonHandler ) buttonsAreInside ( ButtonHandler ) ButtonListView ( ButtonListView ) baseName ( ConfigHandler ) c # closeOnButtonPressed ( AbstractPathTool , AbstractTwoPointTool , AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) copyParams ( AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , TextTool ) color ( AbstractTwoPointTool , ColorGrabWidget ) copy ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) configureListView ( AppLauncherWidget ) check ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors , ValueHandler ) calculateShift ( ButtonHandler ) contains ( ButtonHandler ) CaptureButton ( CaptureButton ) CaptureLauncher ( CaptureLauncher ) connectCaptureSlots ( CaptureLauncher ) CaptureRequest ( CaptureRequest ) captureMode ( CaptureRequest ) CaptureToolButton ( CaptureToolButton ) CaptureToolObjects ( CaptureToolObjects ) captureToolObjects ( CaptureToolObjects ) clear ( CaptureToolObjects ) CaptureWidget ( CaptureWidget ) changeEvent ( CaptureWidget ) CircleCountTool ( CircleCountTool ) CircleTool ( CircleTool ) ClickableLabel ( ClickableLabel ) Color ( Color ) ColorGrabWidget ( ColorGrabWidget ) cursorPos ( ColorGrabWidget ) ColorPicker ( ColorPicker ) ColorPickerEditMode ( ColorPickerEditMode ) ColorPickerEditor ( ColorPickerEditor ) ColorPickerWidget ( ColorPickerWidget ) CommandArgument ( CommandArgument ) CommandLineParser ( CommandLineParser ) CommandOption ( CommandOption ) checkValue ( CommandOption ) ConfigErrorDetails ( ConfigErrorDetails ) CONFIG_GETTER_SETTER ( ConfigHandler ) ConfigHandler ( ConfigHandler ) checkAndHandleError ( ConfigHandler ) checkForErrors ( ConfigHandler ) checkSemantics ( ConfigHandler ) checkShortcutConflicts ( ConfigHandler ) checkUnrecognizedSettings ( ConfigHandler ) cleanUnusedKeys ( ConfigHandler ) configFilePath ( ConfigHandler ) ConfigResolver ( ConfigResolver ) ConfigWindow ( ConfigWindow ) CopyTool ( CopyTool ) call ( FlameshotDaemon ) checkDBusConnection ( FlameshotDaemon ) copyToClipboard ( FlameshotDaemon ) createMethodCall ( FlameshotDaemon ) createPin ( FlameshotDaemon ) chooseFolder ( GeneralConf ) compileFromKeyMap ( OverlayMessage ) closePin ( PinWidget ) currentScreen ( QGuiAppCurrentScreen ) closeEditor ( TextTool ) configurationWidget ( TextTool ) CreateTool ( ToolFactory ) clearToolWidget ( UtilityPanel ) d # description ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CommandOption , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) disconnectCaptureSlots ( CaptureLauncher ) data ( CaptureRequest ) delay ( CaptureRequest ) drawErrorMessage ( CaptureWidget ) drawInactiveRegion ( CaptureWidget ) drawObjectSelection ( CaptureWidget , TextTool ) drawToolsData ( CaptureWidget ) deletePreset ( ColorPickerEditor ) dashedNames ( CommandOption ) DesktopAppData ( DesktopAppData ) DesktopFileParser ( DesktopFileParser ) DesktopInfo ( DesktopInfo ) DraggableWidgetMaker ( DraggableWidgetMaker ) deleteImage ( ImgUploaderBase , ImgurUploader ) drawSearchArea ( InvertTool , PixelateTool ) drawMagnifier ( MagnifierWidget ) drawMagnifierCircle ( MagnifierWidget ) decreaseOpacity ( PinWidget ) desktopGeometry ( ScreenGrabber ) e # enableMessageHeader ( AbstractLogger ) error ( AbstractLogger ) expected ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , SaveFileExtension , String , UserColors , ValueHandler ) ensureSelectionMinimunSize ( ButtonHandler ) expandSelection ( ButtonHandler ) extendedRect ( CaptureWidget ) extendedSelection ( CaptureWidget ) eventFilter ( ColorGrabWidget , ColorPickerEditMode , DraggableWidgetMaker , HoverEventFilter , SelectionWidget , SidePanelWidget ) errorMsg ( CommandOption ) ensureFileWatched ( ConfigHandler ) errorMessage ( ConfigHandler ) ExitTool ( ExitTool ) ExtendedSlider ( ExtendedSlider ) enableTrayIcon ( FlameshotDaemon ) enterEvent ( NotifierBox , PinWidget ) event ( PinWidget ) enableCheckUpdatesAction ( TrayIcon ) f # fallback ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , String , UserColors , ValueHandler ) fromIntList ( ButtonList ) find ( CaptureToolObjects ) findWithRadius ( CaptureToolObjects ) finalize ( ColorGrabWidget ) findParent ( CommandLineParser ) filenamePatternDefault ( ConfigHandler ) FileNameEditor ( FileNameEditor ) FileNameHandler ( FileNameHandler ) Flameshot ( Flameshot ) FlameshotDBusAdapter ( FlameshotDBusAdapter ) FlameshotDaemon ( FlameshotDaemon ) freeDesktopPortal ( ScreenGrabber ) fullGeometry ( SelectionWidget ) finalizeGrab ( SidePanelWidget ) fillCaptureTools ( UtilityPanel ) g # globalStyleSheet ( CaptureButton ) getIterableButtonTypes ( CaptureToolButton ) getPriorityByButton ( CaptureToolButton ) getColorAtPoint ( ColorGrabWidget ) getDefaultLargeColorPalette ( ColorPickerWidget ) getDefaultSmallColorPalette ( ColorPickerWidget ) getInstance ( ConfigHandler ) getAppsByCategory ( DesktopFileParser , WinLnkFileParser ) GeneralConf ( GeneralConf ) GlobalShortcutFilter ( GlobalShortcutFilter ) getNativeModifier ( GlobalShortcutFilter ) gestureEvent ( PinWidget ) grabEntireDesktop ( ScreenGrabber ) grabScreen ( ScreenGrabber ) geometry ( SelectionWidget ) getMouseSide ( SelectionWidget ) getPreferedTerminal ( TerminalLauncher ) getAllUsersStartMenuPath ( WinLnkFileParser ) getImageFileExtAssociates ( WinLnkFileParser ) h # hideSectionUnderMouse ( ButtonHandler ) horizontalPoints ( ButtonHandler ) hideEvent ( ColorPicker , NotifierBox , SelectionWidget , SidePanelWidget ) hasError ( ConfigHandler ) haveExternalWidget ( Flameshot ) History ( History ) history ( History ) HoverEventFilter ( HoverEventFilter ) handlerAreas ( SelectionWidget ) hide ( UpdateNotificationWidget , UtilityPanel ) i # isSelectable ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , MoveTool , TextTool ) isValid ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , CircleCountTool , TextTool ) info ( AbstractLogger , CircleCountTool , TextTool ) icon ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) initAppMap ( AppLauncherWidget ) initListWidget ( AppLauncherWidget ) init ( ButtonHandler , CaptureButton , ImgUploaderManager , OverlayMessage ) intersectWithAreas ( ButtonHandler ) isVisible ( ButtonHandler , UtilityPanel ) initButtonList ( ButtonListView ) id ( CaptureRequest ) initialSelection ( CaptureRequest ) initButton ( CaptureToolButton ) insert ( CaptureToolObjects ) initButtons ( CaptureWidget , UIcolorEditor ) initContext ( CaptureWidget ) initHelpMessage ( CaptureWidget ) initPanel ( CaptureWidget ) initSelection ( CaptureWidget ) initShortcuts ( CaptureWidget ) initColorPicker ( ColorPickerWidget ) isRoot ( CommandArgument ) isSet ( CommandLineParser ) isShortcut ( ConfigHandler ) initErrorIndicator ( ConfigWindow ) initLayout ( FileNameEditor ) initWidgets ( FileNameEditor , VisualsEditor ) instance ( Flameshot , FlameshotDaemon , OverlayMessage ) initTrayIcon ( FlameshotDaemon , TrayIcon ) isThisInstanceHostingWidgets ( FlameshotDaemon ) initAllowMultipleGuiInstances ( GeneralConf ) initAntialiasingPinZoom ( GeneralConf ) initAutoCloseIdleDaemon ( GeneralConf ) initAutostart ( GeneralConf ) initCheckForUpdates ( GeneralConf ) initConfigButtons ( GeneralConf ) initCopyAndCloseAfterUpload ( GeneralConf ) initCopyOnDoubleClick ( GeneralConf ) initCopyPathAfterSave ( GeneralConf ) initHistoryConfirmationToDelete ( GeneralConf ) initPredefinedColorPaletteLarge ( GeneralConf ) initSaveAfterCopy ( GeneralConf ) initSaveLastRegion ( GeneralConf ) initScrollArea ( GeneralConf ) initShowDesktopNotification ( GeneralConf ) initShowHelp ( GeneralConf ) initShowMagnifier ( GeneralConf ) initShowSelectionGeometry ( GeneralConf ) initShowSidePanelButton ( GeneralConf ) initShowStartupLaunchMessage ( GeneralConf ) initShowTrayIcon ( GeneralConf ) initSquareMagnifier ( GeneralConf ) initUndoLimit ( GeneralConf ) initUploadClientSecret ( GeneralConf ) initUploadHistoryMax ( GeneralConf ) initUploadWithoutConfirmation ( GeneralConf ) initUseJpgForClipboard ( GeneralConf ) ImageLabel ( ImageLabel ) ImgUploadDialog ( ImgUploadDialog ) ImgUploaderBase ( ImgUploaderBase ) imageURL ( ImgUploaderBase ) ImgUploaderManager ( ImgUploaderManager ) ImgUploaderTool ( ImgUploaderTool ) ImgurUploader ( ImgurUploader ) InfoWindow ( InfoWindow ) InvertTool ( InvertTool ) increaseOpacity ( PinWidget ) initInfoTable ( ShortcutsWidget ) isChanged ( TextTool ) initMenu ( TrayIcon ) initColorWheel ( UIcolorEditor ) initInternalPanel ( UpdateNotificationWidget , UtilityPanel ) initOpacitySlider ( VisualsEditor ) k # keyPressEvent ( AppLauncherWidget , CaptureWidget , ConfigWindow , InfoWindow , PinWidget , SetShortcutDialog ) keyReleaseEvent ( CaptureWidget , SetShortcutDialog ) keysFromGroup ( ConfigHandler ) KeySequence ( KeySequence ) l # layout ( ConfigResolver ) LauncherItemDelegate ( LauncherItemDelegate ) LineTool ( LineTool ) LoadSpinner ( LoadSpinner ) LowerBoundedInt ( LowerBoundedInt ) leaveEvent ( PinWidget ) loadShortcuts ( ShortcutsWidget ) launchDetached ( TerminalLauncher ) loadHistory ( UploadHistory ) m # messageHeader ( AbstractLogger ) mousePreviewRect ( AbstractPathTool , AbstractTwoPointTool , CircleCountTool , MarkerTool ) move ( AbstractPathTool , AbstractTwoPointTool , TextTool ) moveButtonsToPoints ( ButtonHandler ) mousePressEvent ( CaptureToolButton , CaptureWidget , ClickableLabel , ImageLabel , PinWidget ) makeChild ( CaptureWidget ) mouseDoubleClickEvent ( CaptureWidget , PinWidget ) mouseMoveEvent ( CaptureWidget , ColorPicker , ImageLabel , PinWidget ) mouseReleaseEvent ( CaptureWidget , ImageLabel ) moveEvent ( CaptureWidget , SelectionWidget ) makeDraggable ( DraggableWidgetMaker ) mappedValue ( ExtendedSlider ) MagnifierWidget ( MagnifierWidget ) MarkerTool ( MarkerTool ) ModificationCommand ( ModificationCommand ) MoveTool ( MoveTool ) n # name ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) normalizeButtons ( ButtonList ) newShortcut ( CaptureWidget ) Node ( CommandLineParser::Node ) names ( CommandOption ) nativeEventFilter ( GlobalShortcutFilter ) nativeKeycode ( GlobalShortcutFilter ) notification ( ImgUploaderBase ) NotificationWidget ( NotificationWidget ) NotifierBox ( NotifierBox ) o # operator<< ( AbstractLogger ) operator= ( CaptureToolObjects , ToolFactory ) operator== ( CommandArgument , CommandLineParser::Node , CommandOption , DesktopAppData ) operator() ( CompareAppByName ) origin ( Flameshot ) OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) OrientablePushButton ( OrientablePushButton ) orientation ( OrientablePushButton ) OverlayMessage ( OverlayMessage ) p # paintMousePreview ( AbstractActionTool , AbstractTwoPointTool , CircleCountTool , InvertTool , MarkerTool , PencilTool , PixelateTool , TextTool ) process ( AbstractActionTool , ArrowTool , ButtonList , CircleCountTool , CircleTool , Color , FilenamePattern , InvertTool , KeySequence , LineTool , MarkerTool , PencilTool , PixelateTool , RectangleTool , Region , SaveFileExtension , SelectionTool , TextTool , UserColors , ValueHandler ) pos ( AbstractPathTool , AbstractTwoPointTool , TextTool ) points ( AbstractTwoPointTool ) positionButtonsInside ( ButtonHandler ) path ( CaptureRequest , History ) paddedUpdateRect ( CaptureWidget ) paintEvent ( CaptureWidget , ColorGrabWidget , ColorPickerWidget , LoadSpinner , MagnifierWidget , NotifierBox , OrientablePushButton , OverlayMessage , PinWidget , SelectionWidget ) pixmap ( CaptureWidget , ImgUploaderBase ) processPixmapWithTool ( CaptureWidget ) pushObjectsStateToUndoStack ( CaptureWidget ) pushToolToStack ( CaptureWidget ) parse ( CommandLineParser ) printHelp ( CommandLineParser ) printVersion ( CommandLineParser ) processArgs ( CommandLineParser ) processIfOptionIsHelp ( CommandLineParser ) processOptions ( CommandLineParser ) populate ( ConfigResolver ) parseDesktopFile ( DesktopFileParser ) processDirectory ( DesktopFileParser , WinLnkFileParser ) parseFilename ( FileNameHandler ) parsedPattern ( FileNameHandler ) properScreenshotPath ( FileNameHandler ) packFileName ( History ) paint ( LauncherItemDelegate ) pop ( OverlayMessage ) push ( OverlayMessage ) pushKeyMap ( OverlayMessage ) PencilTool ( PencilTool ) PinTool ( PinTool ) PinWidget ( PinWidget ) pinchTriggered ( PinWidget ) PixelateTool ( PixelateTool ) parentMouseMoveEvent ( SelectionWidget ) parentMousePressEvent ( SelectionWidget ) parentMouseReleaseEvent ( SelectionWidget ) pushWidget ( UtilityPanel ) parseLnkFile ( WinLnkFileParser ) q # quitIfIdle ( FlameshotDaemon ) QGuiAppCurrentScreen ( QGuiAppCurrentScreen ) r # resetRegionTrack ( ButtonHandler ) representation ( ButtonList , Color , KeySequence , UserColors , ValueHandler ) removeTask ( CaptureRequest ) removeAt ( CaptureToolObjects ) releaseActiveTool ( CaptureWidget ) removeToolObject ( CaptureWidget ) resizeEvent ( CaptureWidget , ImageLabel , SelectionWidget , TextWidget ) restoreCircleCountState ( CaptureWidget ) repaint ( ColorPickerWidget ) recursiveParentSearch ( CommandLineParser ) rootArgument ( CommandLineParser ) recognizedGeneralOptions ( ConfigHandler ) recognizedShortcutNames ( ConfigHandler ) remove ( ConfigHandler ) resetValue ( ConfigHandler ) resetLayout ( ConfigResolver ) resolveAnyConfigErrors ( Flameshot ) registerShortcut ( GlobalShortcutFilter ) redo ( ModificationCommand ) rotateLeft ( PinWidget ) rotateRight ( PinWidget ) RectangleTool ( RectangleTool ) RedoTool ( RedoTool ) rect ( SelectionWidget ) s # showMousePreview ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , TextTool ) sendMessage ( AbstractLogger , SystemNotification ) size ( AbstractPathTool , AbstractTwoPointTool , ButtonHandler , CaptureToolObjects ) setPadding ( AbstractTwoPointTool ) setButtons ( ButtonHandler ) setColor ( CaptureButton , CaptureToolButton , LoadSpinner ) styleSheet ( CaptureButton ) selectedScreenshotArea ( CaptureContext ) setInitialSelection ( CaptureRequest ) setStaticID ( CaptureRequest ) selectToolItemAtPos ( CaptureWidget ) setCaptureToolObjects ( CaptureWidget ) setToolSize ( CaptureWidget , ConfigHandler ) showAppUpdateNotification ( CaptureWidget ) showColorPicker ( CaptureWidget ) showxywh ( CaptureWidget ) startDrawObjectTool ( CaptureWidget ) setExtraZoomActive ( ColorGrabWidget ) setMagnifierActive ( ColorGrabWidget ) showEvent ( ColorGrabWidget , ColorPicker , SelectionWidget , TextWidget ) startGrabbing ( ColorGrabWidget ) setDescription ( CommandArgument , CommandLineParser , CommandOption ) setName ( CommandArgument , CommandOption ) setGeneralErrorMessage ( CommandLineParser ) setNames ( CommandOption ) setValue ( CommandOption , ConfigHandler ) setValueName ( CommandOption ) setAllTheButtons ( ConfigHandler ) setDefaultSettings ( ConfigHandler ) setErrorState ( ConfigHandler ) setShortcut ( ConfigHandler ) setStartupLaunch ( ConfigHandler ) shortcut ( ConfigHandler , SetShortcutDialog ) setMapedValue ( ExtendedSlider ) setExternalWidget ( Flameshot ) setOrigin ( Flameshot ) sendTrayNotification ( FlameshotDaemon ) showUpdateNotificationIfAvailable ( FlameshotDaemon ) start ( FlameshotDaemon , LoadSpinner ) save ( History ) setScaledPixmap ( ImageLabel ) setScreenshot ( ImageLabel ) setImageURL ( ImgUploaderBase ) setInfoLabelText ( ImgUploaderBase ) setPixmap ( ImgUploaderBase ) spinner ( ImgUploaderBase ) sizeHint ( LauncherItemDelegate , OrientablePushButton ) setHeight ( LoadSpinner ) setWidth ( LoadSpinner ) stop ( LoadSpinner ) showMessage ( NotificationWidget ) staticInterfaceName ( OrgFreedesktopPortalRequestInterface ) setOrientation ( OrientablePushButton ) setVisibility ( OverlayMessage ) scrollEvent ( PinWidget ) screenAt ( QGuiAppCurrentScreen ) SaveTool ( SaveTool ) ScreenGrabber ( ScreenGrabber ) screenGeometry ( ScreenGrabber ) SelectionTool ( SelectionTool ) SelectionWidget ( SelectionWidget ) setGeometry ( SelectionWidget ) setGeometryAnimated ( SelectionWidget ) setGeometryByKeyboard ( SelectionWidget ) setIdleCentralCursor ( SelectionWidget ) setIgnoreMouse ( SelectionWidget ) SetShortcutDialog ( SetShortcutDialog ) ShortcutsWidget ( ShortcutsWidget ) SidePanelWidget ( SidePanelWidget ) SizeDecreaseTool ( SizeDecreaseTool ) SizeIncreaseTool ( SizeIncreaseTool ) StrftimeChooserWidget ( StrftimeChooserWidget ) String ( String ) styleHint ( StyleOverride ) SystemNotification ( SystemNotification ) setFontFamily ( TextConfig ) setItalic ( TextConfig ) setStrikeOut ( TextConfig ) setTextAlignment ( TextConfig ) setUnderline ( TextConfig ) setWeight ( TextConfig ) setEditMode ( TextTool ) setFont ( TextWidget ) startGuiCapture ( TrayIcon ) setAppLatestVersion ( UpdateNotificationWidget ) show ( UpdateNotificationWidget , UtilityPanel ) setEmptyMessage ( UploadHistory ) setActiveLayer ( UtilityPanel ) setToolWidget ( UtilityPanel ) t # type ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) toIntList ( ButtonList ) tasks ( CaptureRequest ) tool ( CaptureToolButton ) toolSize ( ConfigHandler ) TerminalLauncher ( TerminalLauncher ) TextConfig ( TextConfig ) TextTool ( TextTool ) TextWidget ( TextWidget ) ToolFactory ( ToolFactory ) TrayIcon ( TrayIcon ) toolWidget ( UtilityPanel ) u # updateBlockedSides ( ButtonHandler ) updateScreenRegions ( ButtonHandler ) updateActiveButtons ( ButtonListView ) updateIcon ( CaptureToolButton ) uncheckActiveTool ( CaptureWidget ) updateCursor ( CaptureWidget , SelectionWidget ) updateLayersPanel ( CaptureWidget ) updateSelectionState ( CaptureWidget ) updateSizeIndicator ( CaptureWidget ) updateTool ( CaptureWidget ) updateWidget ( ColorGrabWidget , ColorPickerWidget ) updatePreset ( ColorPickerEditor ) updateSelection ( ColorPickerWidget ) unregisterShortcut ( GlobalShortcutFilter ) unpackFileName ( History ) upload ( ImgUploaderBase , ImgurUploader ) uploader ( ImgUploaderManager ) uploaderPlugin ( ImgUploaderManager ) url ( ImgUploaderManager ) updateFrame ( LoadSpinner ) undo ( ModificationCommand ) updateGeometry ( OverlayMessage ) updateAreas ( SelectionWidget ) updateColorNoWheel ( SidePanelWidget ) UIcolorEditor ( UIcolorEditor ) UndoTool ( UndoTool ) UpdateNotificationWidget ( UpdateNotificationWidget ) UploadHistory ( UploadHistory ) UploadLineItem ( UploadLineItem ) UserColors ( UserColors ) UtilityPanel ( UtilityPanel ) v # verticalPoints ( ButtonHandler ) value ( CommandLineParser , CommandOption , ConfigHandler , ValueHandler ) valueName ( CommandOption ) valueHandler ( ConfigHandler ) VisualsEditor ( VisualsEditor ) w # warning ( AbstractLogger ) widget ( AppLauncher , TextTool ) wheelEvent ( CaptureWidget ) waylandDetected ( DesktopInfo , WaylandUtils ) windowManager ( DesktopInfo ) WaylandUtils ( WaylandUtils ) WinLnkFileParser ( WinLnkFileParser ) ~ # ~AbstractLogger ( AbstractLogger ) ~CaptureLauncher ( CaptureLauncher ) ~CaptureToolButton ( CaptureToolButton ) ~CaptureWidget ( CaptureWidget ) ~FlameshotDBusAdapter ( FlameshotDBusAdapter ) ~InfoWindow ( InfoWindow ) ~OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) ~TextTool ( TextTool ) ~TrayIcon ( TrayIcon ) ~UploadHistory ( UploadHistory ) ~UploadLineItem ( UploadLineItem ) _ # _updateComponents ( GeneralConf )","title":"Class Member Functions"},{"location":"flameshot/class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"flameshot/class_member_functions/#a","text":"AbstractActionTool ( AbstractActionTool ) AbstractLogger ( AbstractLogger ) addOutputString ( AbstractLogger ) attachNotificationPath ( AbstractLogger ) AbstractPathTool ( AbstractPathTool ) addPoint ( AbstractPathTool ) AbstractTwoPointTool ( AbstractTwoPointTool ) adjustedVector ( AbstractTwoPointTool ) AcceptTool ( AcceptTool ) AppLauncher ( AppLauncher ) AppLauncherWidget ( AppLauncherWidget ) addAppsToListWidget ( AppLauncherWidget ) ArrowTool ( ArrowTool ) adjustHorizontalCenter ( ButtonHandler ) addPinTask ( CaptureRequest ) addSaveTask ( CaptureRequest ) addTask ( CaptureRequest ) animatedShow ( CaptureToolButton , NotificationWidget ) append ( CaptureToolObjects ) at ( CaptureToolObjects ) activeButtonTool ( CaptureWidget ) activeButtonToolType ( CaptureWidget ) activeToolObject ( CaptureWidget ) addPreset ( ColorPickerEditor ) AddArgument ( CommandLineParser ) AddOption ( CommandLineParser ) AddOptions ( CommandLineParser ) addHelpOption ( CommandLineParser ) addVersionOption ( CommandLineParser ) addChecker ( CommandOption ) assertKeyRecognized ( ConfigHandler ) autoNumerateDuplicate ( FileNameHandler ) attachPin ( FlameshotDaemon ) attachScreenshotToClipboard ( FlameshotDaemon ) attachTextToClipboard ( FlameshotDaemon ) animatedHide ( NotificationWidget ) appendShortcut ( ShortcutsWidget ) adjustSize ( TextWidget ) appUpdates ( TrayIcon ) addLine ( UploadHistory ) activeLayerIndex ( UtilityPanel )","title":"a"},{"location":"flameshot/class_member_functions/#b","text":"boundingRect ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , InvertTool , OverlayMessage , PixelateTool , TextTool ) Bool ( Bool ) BoundedInt ( BoundedInt ) ButtonHandler ( ButtonHandler ) buttonsAreInside ( ButtonHandler ) ButtonListView ( ButtonListView ) baseName ( ConfigHandler )","title":"b"},{"location":"flameshot/class_member_functions/#c","text":"closeOnButtonPressed ( AbstractPathTool , AbstractTwoPointTool , AcceptTool , AppLauncher , CopyTool , ExitTool , ImgUploaderTool , MoveTool , PinTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) copyParams ( AbstractPathTool , AbstractTwoPointTool , ArrowTool , CircleCountTool , TextTool ) color ( AbstractTwoPointTool , ColorGrabWidget ) copy ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) configureListView ( AppLauncherWidget ) check ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , Region , SaveFileExtension , String , UserColors , ValueHandler ) calculateShift ( ButtonHandler ) contains ( ButtonHandler ) CaptureButton ( CaptureButton ) CaptureLauncher ( CaptureLauncher ) connectCaptureSlots ( CaptureLauncher ) CaptureRequest ( CaptureRequest ) captureMode ( CaptureRequest ) CaptureToolButton ( CaptureToolButton ) CaptureToolObjects ( CaptureToolObjects ) captureToolObjects ( CaptureToolObjects ) clear ( CaptureToolObjects ) CaptureWidget ( CaptureWidget ) changeEvent ( CaptureWidget ) CircleCountTool ( CircleCountTool ) CircleTool ( CircleTool ) ClickableLabel ( ClickableLabel ) Color ( Color ) ColorGrabWidget ( ColorGrabWidget ) cursorPos ( ColorGrabWidget ) ColorPicker ( ColorPicker ) ColorPickerEditMode ( ColorPickerEditMode ) ColorPickerEditor ( ColorPickerEditor ) ColorPickerWidget ( ColorPickerWidget ) CommandArgument ( CommandArgument ) CommandLineParser ( CommandLineParser ) CommandOption ( CommandOption ) checkValue ( CommandOption ) ConfigErrorDetails ( ConfigErrorDetails ) CONFIG_GETTER_SETTER ( ConfigHandler ) ConfigHandler ( ConfigHandler ) checkAndHandleError ( ConfigHandler ) checkForErrors ( ConfigHandler ) checkSemantics ( ConfigHandler ) checkShortcutConflicts ( ConfigHandler ) checkUnrecognizedSettings ( ConfigHandler ) cleanUnusedKeys ( ConfigHandler ) configFilePath ( ConfigHandler ) ConfigResolver ( ConfigResolver ) ConfigWindow ( ConfigWindow ) CopyTool ( CopyTool ) call ( FlameshotDaemon ) checkDBusConnection ( FlameshotDaemon ) copyToClipboard ( FlameshotDaemon ) createMethodCall ( FlameshotDaemon ) createPin ( FlameshotDaemon ) chooseFolder ( GeneralConf ) compileFromKeyMap ( OverlayMessage ) closePin ( PinWidget ) currentScreen ( QGuiAppCurrentScreen ) closeEditor ( TextTool ) configurationWidget ( TextTool ) CreateTool ( ToolFactory ) clearToolWidget ( UtilityPanel )","title":"c"},{"location":"flameshot/class_member_functions/#d","text":"description ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CommandOption , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) disconnectCaptureSlots ( CaptureLauncher ) data ( CaptureRequest ) delay ( CaptureRequest ) drawErrorMessage ( CaptureWidget ) drawInactiveRegion ( CaptureWidget ) drawObjectSelection ( CaptureWidget , TextTool ) drawToolsData ( CaptureWidget ) deletePreset ( ColorPickerEditor ) dashedNames ( CommandOption ) DesktopAppData ( DesktopAppData ) DesktopFileParser ( DesktopFileParser ) DesktopInfo ( DesktopInfo ) DraggableWidgetMaker ( DraggableWidgetMaker ) deleteImage ( ImgUploaderBase , ImgurUploader ) drawSearchArea ( InvertTool , PixelateTool ) drawMagnifier ( MagnifierWidget ) drawMagnifierCircle ( MagnifierWidget ) decreaseOpacity ( PinWidget ) desktopGeometry ( ScreenGrabber )","title":"d"},{"location":"flameshot/class_member_functions/#e","text":"enableMessageHeader ( AbstractLogger ) error ( AbstractLogger ) expected ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , SaveFileExtension , String , UserColors , ValueHandler ) ensureSelectionMinimunSize ( ButtonHandler ) expandSelection ( ButtonHandler ) extendedRect ( CaptureWidget ) extendedSelection ( CaptureWidget ) eventFilter ( ColorGrabWidget , ColorPickerEditMode , DraggableWidgetMaker , HoverEventFilter , SelectionWidget , SidePanelWidget ) errorMsg ( CommandOption ) ensureFileWatched ( ConfigHandler ) errorMessage ( ConfigHandler ) ExitTool ( ExitTool ) ExtendedSlider ( ExtendedSlider ) enableTrayIcon ( FlameshotDaemon ) enterEvent ( NotifierBox , PinWidget ) event ( PinWidget ) enableCheckUpdatesAction ( TrayIcon )","title":"e"},{"location":"flameshot/class_member_functions/#f","text":"fallback ( Bool , BoundedInt , ButtonList , Color , ExistingDir , FilenamePattern , KeySequence , LowerBoundedInt , String , UserColors , ValueHandler ) fromIntList ( ButtonList ) find ( CaptureToolObjects ) findWithRadius ( CaptureToolObjects ) finalize ( ColorGrabWidget ) findParent ( CommandLineParser ) filenamePatternDefault ( ConfigHandler ) FileNameEditor ( FileNameEditor ) FileNameHandler ( FileNameHandler ) Flameshot ( Flameshot ) FlameshotDBusAdapter ( FlameshotDBusAdapter ) FlameshotDaemon ( FlameshotDaemon ) freeDesktopPortal ( ScreenGrabber ) fullGeometry ( SelectionWidget ) finalizeGrab ( SidePanelWidget ) fillCaptureTools ( UtilityPanel )","title":"f"},{"location":"flameshot/class_member_functions/#g","text":"globalStyleSheet ( CaptureButton ) getIterableButtonTypes ( CaptureToolButton ) getPriorityByButton ( CaptureToolButton ) getColorAtPoint ( ColorGrabWidget ) getDefaultLargeColorPalette ( ColorPickerWidget ) getDefaultSmallColorPalette ( ColorPickerWidget ) getInstance ( ConfigHandler ) getAppsByCategory ( DesktopFileParser , WinLnkFileParser ) GeneralConf ( GeneralConf ) GlobalShortcutFilter ( GlobalShortcutFilter ) getNativeModifier ( GlobalShortcutFilter ) gestureEvent ( PinWidget ) grabEntireDesktop ( ScreenGrabber ) grabScreen ( ScreenGrabber ) geometry ( SelectionWidget ) getMouseSide ( SelectionWidget ) getPreferedTerminal ( TerminalLauncher ) getAllUsersStartMenuPath ( WinLnkFileParser ) getImageFileExtAssociates ( WinLnkFileParser )","title":"g"},{"location":"flameshot/class_member_functions/#h","text":"hideSectionUnderMouse ( ButtonHandler ) horizontalPoints ( ButtonHandler ) hideEvent ( ColorPicker , NotifierBox , SelectionWidget , SidePanelWidget ) hasError ( ConfigHandler ) haveExternalWidget ( Flameshot ) History ( History ) history ( History ) HoverEventFilter ( HoverEventFilter ) handlerAreas ( SelectionWidget ) hide ( UpdateNotificationWidget , UtilityPanel )","title":"h"},{"location":"flameshot/class_member_functions/#i","text":"isSelectable ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , MoveTool , TextTool ) isValid ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , CircleCountTool , TextTool ) info ( AbstractLogger , CircleCountTool , TextTool ) icon ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) initAppMap ( AppLauncherWidget ) initListWidget ( AppLauncherWidget ) init ( ButtonHandler , CaptureButton , ImgUploaderManager , OverlayMessage ) intersectWithAreas ( ButtonHandler ) isVisible ( ButtonHandler , UtilityPanel ) initButtonList ( ButtonListView ) id ( CaptureRequest ) initialSelection ( CaptureRequest ) initButton ( CaptureToolButton ) insert ( CaptureToolObjects ) initButtons ( CaptureWidget , UIcolorEditor ) initContext ( CaptureWidget ) initHelpMessage ( CaptureWidget ) initPanel ( CaptureWidget ) initSelection ( CaptureWidget ) initShortcuts ( CaptureWidget ) initColorPicker ( ColorPickerWidget ) isRoot ( CommandArgument ) isSet ( CommandLineParser ) isShortcut ( ConfigHandler ) initErrorIndicator ( ConfigWindow ) initLayout ( FileNameEditor ) initWidgets ( FileNameEditor , VisualsEditor ) instance ( Flameshot , FlameshotDaemon , OverlayMessage ) initTrayIcon ( FlameshotDaemon , TrayIcon ) isThisInstanceHostingWidgets ( FlameshotDaemon ) initAllowMultipleGuiInstances ( GeneralConf ) initAntialiasingPinZoom ( GeneralConf ) initAutoCloseIdleDaemon ( GeneralConf ) initAutostart ( GeneralConf ) initCheckForUpdates ( GeneralConf ) initConfigButtons ( GeneralConf ) initCopyAndCloseAfterUpload ( GeneralConf ) initCopyOnDoubleClick ( GeneralConf ) initCopyPathAfterSave ( GeneralConf ) initHistoryConfirmationToDelete ( GeneralConf ) initPredefinedColorPaletteLarge ( GeneralConf ) initSaveAfterCopy ( GeneralConf ) initSaveLastRegion ( GeneralConf ) initScrollArea ( GeneralConf ) initShowDesktopNotification ( GeneralConf ) initShowHelp ( GeneralConf ) initShowMagnifier ( GeneralConf ) initShowSelectionGeometry ( GeneralConf ) initShowSidePanelButton ( GeneralConf ) initShowStartupLaunchMessage ( GeneralConf ) initShowTrayIcon ( GeneralConf ) initSquareMagnifier ( GeneralConf ) initUndoLimit ( GeneralConf ) initUploadClientSecret ( GeneralConf ) initUploadHistoryMax ( GeneralConf ) initUploadWithoutConfirmation ( GeneralConf ) initUseJpgForClipboard ( GeneralConf ) ImageLabel ( ImageLabel ) ImgUploadDialog ( ImgUploadDialog ) ImgUploaderBase ( ImgUploaderBase ) imageURL ( ImgUploaderBase ) ImgUploaderManager ( ImgUploaderManager ) ImgUploaderTool ( ImgUploaderTool ) ImgurUploader ( ImgurUploader ) InfoWindow ( InfoWindow ) InvertTool ( InvertTool ) increaseOpacity ( PinWidget ) initInfoTable ( ShortcutsWidget ) isChanged ( TextTool ) initMenu ( TrayIcon ) initColorWheel ( UIcolorEditor ) initInternalPanel ( UpdateNotificationWidget , UtilityPanel ) initOpacitySlider ( VisualsEditor )","title":"i"},{"location":"flameshot/class_member_functions/#k","text":"keyPressEvent ( AppLauncherWidget , CaptureWidget , ConfigWindow , InfoWindow , PinWidget , SetShortcutDialog ) keyReleaseEvent ( CaptureWidget , SetShortcutDialog ) keysFromGroup ( ConfigHandler ) KeySequence ( KeySequence )","title":"k"},{"location":"flameshot/class_member_functions/#l","text":"layout ( ConfigResolver ) LauncherItemDelegate ( LauncherItemDelegate ) LineTool ( LineTool ) LoadSpinner ( LoadSpinner ) LowerBoundedInt ( LowerBoundedInt ) leaveEvent ( PinWidget ) loadShortcuts ( ShortcutsWidget ) launchDetached ( TerminalLauncher ) loadHistory ( UploadHistory )","title":"l"},{"location":"flameshot/class_member_functions/#m","text":"messageHeader ( AbstractLogger ) mousePreviewRect ( AbstractPathTool , AbstractTwoPointTool , CircleCountTool , MarkerTool ) move ( AbstractPathTool , AbstractTwoPointTool , TextTool ) moveButtonsToPoints ( ButtonHandler ) mousePressEvent ( CaptureToolButton , CaptureWidget , ClickableLabel , ImageLabel , PinWidget ) makeChild ( CaptureWidget ) mouseDoubleClickEvent ( CaptureWidget , PinWidget ) mouseMoveEvent ( CaptureWidget , ColorPicker , ImageLabel , PinWidget ) mouseReleaseEvent ( CaptureWidget , ImageLabel ) moveEvent ( CaptureWidget , SelectionWidget ) makeDraggable ( DraggableWidgetMaker ) mappedValue ( ExtendedSlider ) MagnifierWidget ( MagnifierWidget ) MarkerTool ( MarkerTool ) ModificationCommand ( ModificationCommand ) MoveTool ( MoveTool )","title":"m"},{"location":"flameshot/class_member_functions/#n","text":"name ( AcceptTool , AppLauncher , ArrowTool , CaptureToolButton , CircleCountTool , CircleTool , CommandArgument , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) normalizeButtons ( ButtonList ) newShortcut ( CaptureWidget ) Node ( CommandLineParser::Node ) names ( CommandOption ) nativeEventFilter ( GlobalShortcutFilter ) nativeKeycode ( GlobalShortcutFilter ) notification ( ImgUploaderBase ) NotificationWidget ( NotificationWidget ) NotifierBox ( NotifierBox )","title":"n"},{"location":"flameshot/class_member_functions/#o","text":"operator<< ( AbstractLogger ) operator= ( CaptureToolObjects , ToolFactory ) operator== ( CommandArgument , CommandLineParser::Node , CommandOption , DesktopAppData ) operator() ( CompareAppByName ) origin ( Flameshot ) OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) OrientablePushButton ( OrientablePushButton ) orientation ( OrientablePushButton ) OverlayMessage ( OverlayMessage )","title":"o"},{"location":"flameshot/class_member_functions/#p","text":"paintMousePreview ( AbstractActionTool , AbstractTwoPointTool , CircleCountTool , InvertTool , MarkerTool , PencilTool , PixelateTool , TextTool ) process ( AbstractActionTool , ArrowTool , ButtonList , CircleCountTool , CircleTool , Color , FilenamePattern , InvertTool , KeySequence , LineTool , MarkerTool , PencilTool , PixelateTool , RectangleTool , Region , SaveFileExtension , SelectionTool , TextTool , UserColors , ValueHandler ) pos ( AbstractPathTool , AbstractTwoPointTool , TextTool ) points ( AbstractTwoPointTool ) positionButtonsInside ( ButtonHandler ) path ( CaptureRequest , History ) paddedUpdateRect ( CaptureWidget ) paintEvent ( CaptureWidget , ColorGrabWidget , ColorPickerWidget , LoadSpinner , MagnifierWidget , NotifierBox , OrientablePushButton , OverlayMessage , PinWidget , SelectionWidget ) pixmap ( CaptureWidget , ImgUploaderBase ) processPixmapWithTool ( CaptureWidget ) pushObjectsStateToUndoStack ( CaptureWidget ) pushToolToStack ( CaptureWidget ) parse ( CommandLineParser ) printHelp ( CommandLineParser ) printVersion ( CommandLineParser ) processArgs ( CommandLineParser ) processIfOptionIsHelp ( CommandLineParser ) processOptions ( CommandLineParser ) populate ( ConfigResolver ) parseDesktopFile ( DesktopFileParser ) processDirectory ( DesktopFileParser , WinLnkFileParser ) parseFilename ( FileNameHandler ) parsedPattern ( FileNameHandler ) properScreenshotPath ( FileNameHandler ) packFileName ( History ) paint ( LauncherItemDelegate ) pop ( OverlayMessage ) push ( OverlayMessage ) pushKeyMap ( OverlayMessage ) PencilTool ( PencilTool ) PinTool ( PinTool ) PinWidget ( PinWidget ) pinchTriggered ( PinWidget ) PixelateTool ( PixelateTool ) parentMouseMoveEvent ( SelectionWidget ) parentMousePressEvent ( SelectionWidget ) parentMouseReleaseEvent ( SelectionWidget ) pushWidget ( UtilityPanel ) parseLnkFile ( WinLnkFileParser )","title":"p"},{"location":"flameshot/class_member_functions/#q","text":"quitIfIdle ( FlameshotDaemon ) QGuiAppCurrentScreen ( QGuiAppCurrentScreen )","title":"q"},{"location":"flameshot/class_member_functions/#r","text":"resetRegionTrack ( ButtonHandler ) representation ( ButtonList , Color , KeySequence , UserColors , ValueHandler ) removeTask ( CaptureRequest ) removeAt ( CaptureToolObjects ) releaseActiveTool ( CaptureWidget ) removeToolObject ( CaptureWidget ) resizeEvent ( CaptureWidget , ImageLabel , SelectionWidget , TextWidget ) restoreCircleCountState ( CaptureWidget ) repaint ( ColorPickerWidget ) recursiveParentSearch ( CommandLineParser ) rootArgument ( CommandLineParser ) recognizedGeneralOptions ( ConfigHandler ) recognizedShortcutNames ( ConfigHandler ) remove ( ConfigHandler ) resetValue ( ConfigHandler ) resetLayout ( ConfigResolver ) resolveAnyConfigErrors ( Flameshot ) registerShortcut ( GlobalShortcutFilter ) redo ( ModificationCommand ) rotateLeft ( PinWidget ) rotateRight ( PinWidget ) RectangleTool ( RectangleTool ) RedoTool ( RedoTool ) rect ( SelectionWidget )","title":"r"},{"location":"flameshot/class_member_functions/#s","text":"showMousePreview ( AbstractActionTool , AbstractPathTool , AbstractTwoPointTool , TextTool ) sendMessage ( AbstractLogger , SystemNotification ) size ( AbstractPathTool , AbstractTwoPointTool , ButtonHandler , CaptureToolObjects ) setPadding ( AbstractTwoPointTool ) setButtons ( ButtonHandler ) setColor ( CaptureButton , CaptureToolButton , LoadSpinner ) styleSheet ( CaptureButton ) selectedScreenshotArea ( CaptureContext ) setInitialSelection ( CaptureRequest ) setStaticID ( CaptureRequest ) selectToolItemAtPos ( CaptureWidget ) setCaptureToolObjects ( CaptureWidget ) setToolSize ( CaptureWidget , ConfigHandler ) showAppUpdateNotification ( CaptureWidget ) showColorPicker ( CaptureWidget ) showxywh ( CaptureWidget ) startDrawObjectTool ( CaptureWidget ) setExtraZoomActive ( ColorGrabWidget ) setMagnifierActive ( ColorGrabWidget ) showEvent ( ColorGrabWidget , ColorPicker , SelectionWidget , TextWidget ) startGrabbing ( ColorGrabWidget ) setDescription ( CommandArgument , CommandLineParser , CommandOption ) setName ( CommandArgument , CommandOption ) setGeneralErrorMessage ( CommandLineParser ) setNames ( CommandOption ) setValue ( CommandOption , ConfigHandler ) setValueName ( CommandOption ) setAllTheButtons ( ConfigHandler ) setDefaultSettings ( ConfigHandler ) setErrorState ( ConfigHandler ) setShortcut ( ConfigHandler ) setStartupLaunch ( ConfigHandler ) shortcut ( ConfigHandler , SetShortcutDialog ) setMapedValue ( ExtendedSlider ) setExternalWidget ( Flameshot ) setOrigin ( Flameshot ) sendTrayNotification ( FlameshotDaemon ) showUpdateNotificationIfAvailable ( FlameshotDaemon ) start ( FlameshotDaemon , LoadSpinner ) save ( History ) setScaledPixmap ( ImageLabel ) setScreenshot ( ImageLabel ) setImageURL ( ImgUploaderBase ) setInfoLabelText ( ImgUploaderBase ) setPixmap ( ImgUploaderBase ) spinner ( ImgUploaderBase ) sizeHint ( LauncherItemDelegate , OrientablePushButton ) setHeight ( LoadSpinner ) setWidth ( LoadSpinner ) stop ( LoadSpinner ) showMessage ( NotificationWidget ) staticInterfaceName ( OrgFreedesktopPortalRequestInterface ) setOrientation ( OrientablePushButton ) setVisibility ( OverlayMessage ) scrollEvent ( PinWidget ) screenAt ( QGuiAppCurrentScreen ) SaveTool ( SaveTool ) ScreenGrabber ( ScreenGrabber ) screenGeometry ( ScreenGrabber ) SelectionTool ( SelectionTool ) SelectionWidget ( SelectionWidget ) setGeometry ( SelectionWidget ) setGeometryAnimated ( SelectionWidget ) setGeometryByKeyboard ( SelectionWidget ) setIdleCentralCursor ( SelectionWidget ) setIgnoreMouse ( SelectionWidget ) SetShortcutDialog ( SetShortcutDialog ) ShortcutsWidget ( ShortcutsWidget ) SidePanelWidget ( SidePanelWidget ) SizeDecreaseTool ( SizeDecreaseTool ) SizeIncreaseTool ( SizeIncreaseTool ) StrftimeChooserWidget ( StrftimeChooserWidget ) String ( String ) styleHint ( StyleOverride ) SystemNotification ( SystemNotification ) setFontFamily ( TextConfig ) setItalic ( TextConfig ) setStrikeOut ( TextConfig ) setTextAlignment ( TextConfig ) setUnderline ( TextConfig ) setWeight ( TextConfig ) setEditMode ( TextTool ) setFont ( TextWidget ) startGuiCapture ( TrayIcon ) setAppLatestVersion ( UpdateNotificationWidget ) show ( UpdateNotificationWidget , UtilityPanel ) setEmptyMessage ( UploadHistory ) setActiveLayer ( UtilityPanel ) setToolWidget ( UtilityPanel )","title":"s"},{"location":"flameshot/class_member_functions/#t","text":"type ( AcceptTool , AppLauncher , ArrowTool , CircleCountTool , CircleTool , CopyTool , ExitTool , ImgUploaderTool , InvertTool , LineTool , MarkerTool , MoveTool , PencilTool , PinTool , PixelateTool , RectangleTool , RedoTool , SaveTool , SelectionTool , SizeDecreaseTool , SizeIncreaseTool , TextTool , UndoTool ) toIntList ( ButtonList ) tasks ( CaptureRequest ) tool ( CaptureToolButton ) toolSize ( ConfigHandler ) TerminalLauncher ( TerminalLauncher ) TextConfig ( TextConfig ) TextTool ( TextTool ) TextWidget ( TextWidget ) ToolFactory ( ToolFactory ) TrayIcon ( TrayIcon ) toolWidget ( UtilityPanel )","title":"t"},{"location":"flameshot/class_member_functions/#u","text":"updateBlockedSides ( ButtonHandler ) updateScreenRegions ( ButtonHandler ) updateActiveButtons ( ButtonListView ) updateIcon ( CaptureToolButton ) uncheckActiveTool ( CaptureWidget ) updateCursor ( CaptureWidget , SelectionWidget ) updateLayersPanel ( CaptureWidget ) updateSelectionState ( CaptureWidget ) updateSizeIndicator ( CaptureWidget ) updateTool ( CaptureWidget ) updateWidget ( ColorGrabWidget , ColorPickerWidget ) updatePreset ( ColorPickerEditor ) updateSelection ( ColorPickerWidget ) unregisterShortcut ( GlobalShortcutFilter ) unpackFileName ( History ) upload ( ImgUploaderBase , ImgurUploader ) uploader ( ImgUploaderManager ) uploaderPlugin ( ImgUploaderManager ) url ( ImgUploaderManager ) updateFrame ( LoadSpinner ) undo ( ModificationCommand ) updateGeometry ( OverlayMessage ) updateAreas ( SelectionWidget ) updateColorNoWheel ( SidePanelWidget ) UIcolorEditor ( UIcolorEditor ) UndoTool ( UndoTool ) UpdateNotificationWidget ( UpdateNotificationWidget ) UploadHistory ( UploadHistory ) UploadLineItem ( UploadLineItem ) UserColors ( UserColors ) UtilityPanel ( UtilityPanel )","title":"u"},{"location":"flameshot/class_member_functions/#v","text":"verticalPoints ( ButtonHandler ) value ( CommandLineParser , CommandOption , ConfigHandler , ValueHandler ) valueName ( CommandOption ) valueHandler ( ConfigHandler ) VisualsEditor ( VisualsEditor )","title":"v"},{"location":"flameshot/class_member_functions/#w","text":"warning ( AbstractLogger ) widget ( AppLauncher , TextTool ) wheelEvent ( CaptureWidget ) waylandDetected ( DesktopInfo , WaylandUtils ) windowManager ( DesktopInfo ) WaylandUtils ( WaylandUtils ) WinLnkFileParser ( WinLnkFileParser )","title":"w"},{"location":"flameshot/class_member_functions/#_1","text":"~AbstractLogger ( AbstractLogger ) ~CaptureLauncher ( CaptureLauncher ) ~CaptureToolButton ( CaptureToolButton ) ~CaptureWidget ( CaptureWidget ) ~FlameshotDBusAdapter ( FlameshotDBusAdapter ) ~InfoWindow ( InfoWindow ) ~OrgFreedesktopPortalRequestInterface ( OrgFreedesktopPortalRequestInterface ) ~TextTool ( TextTool ) ~TrayIcon ( TrayIcon ) ~UploadHistory ( UploadHistory ) ~UploadLineItem ( UploadLineItem )","title":"~"},{"location":"flameshot/class_member_functions/#_","text":"_updateComponents ( GeneralConf )","title":"_"},{"location":"flameshot/class_member_variables/","text":"Class Member Variables # a # argument ( CommandLineParser::Node ) arg ( TerminalApp ) b # buttonBox ( ImgUploadDialog ) c # capture ( AppLauncher , ImgUploaderTool ) circleCount ( CaptureContext ) color ( CaptureContext ) categories ( DesktopAppData ) d # defaultLargeColorPalette ( ColorPickerWidget ) defaultSmallColorPalette ( ColorPickerWidget ) description ( DesktopAppData ) DESKTOP_SESSION ( DesktopInfo ) e # exec ( DesktopAppData ) f # fullscreen ( CaptureContext ) file ( HistoryFileName ) g # GDMSESSION ( DesktopInfo ) GNOME_DESKTOP_SESSION_ID ( DesktopInfo ) i # iterableButtonTypes ( CaptureToolButton ) icon ( DesktopAppData ) k # KDE_FULL_SESSION ( DesktopInfo ) l # layout ( ImgUploadDialog ) m # m_defaultChannel ( AbstractLogger ) m_enableMessageHeader ( AbstractLogger ) m_notificationPath ( AbstractLogger ) m_targets ( AbstractLogger ) m_textStreams ( AbstractLogger ) m_color ( AbstractPathTool , AbstractTwoPointTool , ColorGrabWidget , ColorPickerEditor , LoadSpinner , MagnifierWidget , SelectionWidget , SidePanelWidget , TextTool ) m_padding ( AbstractPathTool , AbstractTwoPointTool ) m_pathArea ( AbstractPathTool ) m_points ( AbstractPathTool , AbstractTwoPointTool ) m_pos ( AbstractPathTool ) m_thickness ( AbstractPathTool , AbstractTwoPointTool ) m_supportsDiagonalAdj ( AbstractTwoPointTool ) m_supportsOrthogonalAdj ( AbstractTwoPointTool ) m_appsMap ( AppLauncherWidget ) m_filterList ( AppLauncherWidget ) m_keepOpen ( AppLauncherWidget ) m_keepOpenCheckbox ( AppLauncherWidget ) m_layout ( AppLauncherWidget , FileNameEditor , GeneralConf , NotificationWidget , PinWidget , SetShortcutDialog , ShortcutsWidget , SidePanelWidget , TextConfig , UpdateNotificationWidget , UtilityPanel , VisualsEditor ) m_lineEdit ( AppLauncherWidget ) m_parser ( AppLauncherWidget ) m_pixmap ( AppLauncherWidget , ColorGrabWidget , ImageLabel , ImgUploaderBase , PinTool , PinWidget , SidePanelWidget ) m_tabWidget ( AppLauncherWidget , ConfigWindow , VisualsEditor ) m_tempFile ( AppLauncherWidget ) m_terminalCheckbox ( AppLauncherWidget ) m_arrowPath ( ArrowTool ) m_def ( Bool , BoundedInt , Color , LowerBoundedInt , String ) m_max ( BoundedInt , UserColors ) m_min ( BoundedInt , LowerBoundedInt , UserColors ) m_allSidesBlocked ( ButtonHandler ) m_blockedBotton ( ButtonHandler ) m_blockedLeft ( ButtonHandler ) m_blockedRight ( ButtonHandler ) m_blockedTop ( ButtonHandler ) m_buttonBaseSize ( ButtonHandler ) m_buttonExtendedSize ( ButtonHandler ) m_buttonsAreInside ( ButtonHandler ) m_horizontalyBlocked ( ButtonHandler ) m_oneHorizontalBlocked ( ButtonHandler ) m_screenRegions ( ButtonHandler ) m_selection ( ButtonHandler , CaptureWidget ) m_separator ( ButtonHandler ) m_vectorButtons ( ButtonHandler ) m_buttonTypeByName ( ButtonListView ) m_listButtons ( ButtonListView ) m_mainColor ( CaptureButton , CaptureToolButton ) mousePos ( CaptureContext ) m_data ( CaptureRequest ) m_delay ( CaptureRequest ) m_initialSelection ( CaptureRequest ) m_mode ( CaptureRequest ) m_path ( CaptureRequest ) m_pinWindowGeometry ( CaptureRequest ) m_tasks ( CaptureRequest ) m_buttonType ( CaptureToolButton ) m_emergeAnimation ( CaptureToolButton ) m_tool ( CaptureToolButton ) m_captureToolObjects ( CaptureToolObjects , CaptureWidget , ModificationCommand ) m_imageCache ( CaptureToolObjects ) m_activeButton ( CaptureWidget ) m_activeTool ( CaptureWidget ) m_activeToolIsMoved ( CaptureWidget ) m_activeToolOffsetToMouseOnStart ( CaptureWidget ) m_adjustmentButtonPressed ( CaptureWidget ) m_buttonHandler ( CaptureWidget ) m_captureDone ( CaptureWidget ) m_captureToolObjectsBackup ( CaptureWidget , ModificationCommand ) m_colorPicker ( CaptureWidget ) m_config ( CaptureWidget , ColorPickerEditMode , ColorPickerEditor , ShortcutsWidget ) m_configError ( CaptureWidget ) m_configErrorResolved ( CaptureWidget ) m_context ( CaptureWidget ) m_contrastUiColor ( CaptureWidget ) m_eventFilter ( CaptureWidget ) m_existingObjectIsChanged ( CaptureWidget ) m_helpMessage ( CaptureWidget , GeneralConf ) m_lastMouseWheel ( CaptureWidget ) m_magnifier ( CaptureWidget ) m_mouseIsClicked ( CaptureWidget ) m_mouseOverHandle ( CaptureWidget ) m_mousePressedPos ( CaptureWidget ) m_movingSelection ( CaptureWidget ) m_newSelection ( CaptureWidget ) m_notifierBox ( CaptureWidget ) m_opacity ( CaptureWidget , PinWidget ) m_panel ( CaptureWidget ) m_previewEnabled ( CaptureWidget ) m_sidePanel ( CaptureWidget ) m_sizeIndButton ( CaptureWidget ) m_startMove ( CaptureWidget ) m_startMovePos ( CaptureWidget ) m_toolSizeByKeyboard ( CaptureWidget ) m_toolWidget ( CaptureWidget , UtilityPanel ) m_tools ( CaptureWidget ) m_uiColor ( CaptureWidget , ColorPickerWidget , UIcolorEditor ) m_undoStack ( CaptureWidget ) m_updateNotificationWidget ( CaptureWidget ) m_xywhDisplay ( CaptureWidget ) m_xywhTimer ( CaptureWidget ) m_tempString ( CircleCountTool , TextTool ) m_valid ( CircleCountTool ) m_extraZoomActive ( ColorGrabWidget ) m_magnifierActive ( ColorGrabWidget ) m_mousePressReceived ( ColorGrabWidget ) m_previewImage ( ColorGrabWidget ) m_draggedPresetInitialPos ( ColorPickerEditMode ) m_isDragging ( ColorPickerEditMode , DraggableWidgetMaker ) m_isPressing ( ColorPickerEditMode , DraggableWidgetMaker ) m_mouseMovePos ( ColorPickerEditMode , DraggableWidgetMaker ) m_mousePressPos ( ColorPickerEditMode , DraggableWidgetMaker ) m_addPresetButton ( ColorPickerEditor ) m_addPresetLabel ( ColorPickerEditor ) m_colorEdit ( ColorPickerEditor ) m_colorEditLabel ( ColorPickerEditor ) m_colorInput ( ColorPickerEditor ) m_colorList ( ColorPickerEditor , ColorPickerWidget ) m_colorWheel ( ColorPickerEditor , SidePanelWidget , UIcolorEditor ) m_colorpicker ( ColorPickerEditor ) m_deletePresetButton ( ColorPickerEditor ) m_gLayout ( ColorPickerEditor ) m_selectedIndex ( ColorPickerEditor , ColorPickerWidget ) m_updatePresetButton ( ColorPickerEditor ) m_colorAreaList ( ColorPickerWidget ) m_colorAreaSize ( ColorPickerWidget ) m_lastIndex ( ColorPickerWidget ) m_description ( CommandArgument , CommandLineParser , CommandOption ) m_name ( CommandArgument ) m_foundArgs ( CommandLineParser ) m_foundOptions ( CommandLineParser ) m_generalErrorMessage ( CommandLineParser ) m_parseTree ( CommandLineParser ) m_withHelp ( CommandLineParser ) m_withVersion ( CommandLineParser ) m_checker ( CommandOption ) m_errorMsg ( CommandOption ) m_names ( CommandOption ) m_value ( CommandOption ) m_valueName ( CommandOption ) m_configWatcher ( ConfigHandler ) m_errorCheckPending ( ConfigHandler ) m_hasError ( ConfigHandler ) m_settings ( ConfigHandler ) m_skipNextErrorCheck ( ConfigHandler ) m_filenameEditor ( ConfigWindow ) m_filenameEditorTab ( ConfigWindow ) m_generalConfig ( ConfigWindow ) m_generalConfigTab ( ConfigWindow ) m_shortcuts ( ConfigWindow , ShortcutsWidget ) m_shortcutsTab ( ConfigWindow ) m_visuals ( ConfigWindow ) m_visualsTab ( ConfigWindow ) m_appList ( DesktopFileParser , WinLnkFileParser ) m_defaultIcon ( DesktopFileParser ) m_localeDescription ( DesktopFileParser ) m_localeDescriptionShort ( DesktopFileParser ) m_localeName ( DesktopFileParser ) m_localeNameShort ( DesktopFileParser ) m_timer ( ExtendedSlider , LoadSpinner , NotificationWidget , NotifierBox ) m_clearButton ( FileNameEditor ) m_helperButtons ( FileNameEditor ) m_nameEditor ( FileNameEditor ) m_nameHandler ( FileNameEditor ) m_outputLabel ( FileNameEditor ) m_resetButton ( FileNameEditor , GeneralConf ) m_saveButton ( FileNameEditor ) MAX_CHARACTERS ( FileNameHandler ) m_captureWindow ( Flameshot ) m_configWindow ( Flameshot ) m_haveExternalWidget ( Flameshot ) m_infoWindow ( Flameshot ) m_launcherWindow ( Flameshot ) m_origin ( Flameshot ) m_appLatestUrl ( FlameshotDaemon , UpdateNotificationWidget ) m_appLatestVersion ( FlameshotDaemon , UpdateNotificationWidget ) m_clipboardSignalBlocked ( FlameshotDaemon ) m_hostingClipboard ( FlameshotDaemon ) m_instance ( FlameshotDaemon , OverlayMessage ) m_networkCheckUpdates ( FlameshotDaemon ) m_persist ( FlameshotDaemon ) m_showCheckAppUpdateStatus ( FlameshotDaemon ) m_trayIcon ( FlameshotDaemon ) m_widgets ( FlameshotDaemon ) m_allowMultipleGuiInstances ( GeneralConf ) m_antialiasingPinZoom ( GeneralConf ) m_autoCloseIdleDaemon ( GeneralConf ) m_autostart ( GeneralConf ) m_changeSaveButton ( GeneralConf ) m_checkForUpdates ( GeneralConf ) m_copyOnDoubleClick ( GeneralConf ) m_copyPathAfterSave ( GeneralConf ) m_copyURLAfterUpload ( GeneralConf ) m_exportButton ( GeneralConf ) m_historyConfirmationToDelete ( GeneralConf ) m_importButton ( GeneralConf ) m_predefinedColorPaletteLarge ( GeneralConf ) m_saveAfterCopy ( GeneralConf ) m_saveLastRegion ( GeneralConf ) m_savePath ( GeneralConf ) m_screenshotPathFixedCheck ( GeneralConf ) m_scrollArea ( GeneralConf ) m_scrollAreaLayout ( GeneralConf ) m_selectGeometryLocation ( GeneralConf ) m_setSaveAsFileExtension ( GeneralConf ) m_showMagnifier ( GeneralConf ) m_showSelectionGeometry ( GeneralConf ) m_showStartupLaunchMessage ( GeneralConf ) m_showTray ( GeneralConf ) m_sidePanelButton ( GeneralConf ) m_squareMagnifier ( GeneralConf ) m_sysNotifications ( GeneralConf ) m_undoLimit ( GeneralConf ) m_uploadClientKey ( GeneralConf ) m_uploadHistoryMax ( GeneralConf ) m_uploadWithoutConfirmation ( GeneralConf , ImgUploadDialog ) m_useJpgForClipboard ( GeneralConf ) m_xywhTimeout ( GeneralConf ) m_historyPath ( History ) m_packedFileName ( History ) m_thumbs ( History ) m_unpackedFileName ( History ) m_DSEffect ( ImageLabel ) m_dragStartPosition ( ImageLabel ) m_uploadLabel ( ImgUploadDialog ) m_copyUrlButton ( ImgUploaderBase ) m_currentImageName ( ImgUploaderBase ) m_hLayout ( ImgUploaderBase , UIcolorEditor ) m_imageURL ( ImgUploaderBase ) m_infoLabel ( ImgUploaderBase ) m_notification ( ImgUploaderBase , UpdateNotificationWidget ) m_openDeleteUrlButton ( ImgUploaderBase ) m_openUrlButton ( ImgUploaderBase ) m_saveToFilesystemButton ( ImgUploaderBase ) m_spinner ( ImgUploaderBase ) m_toClipboardButton ( ImgUploaderBase ) m_vLayout ( ImgUploaderBase , UIcolorEditor ) m_imgUploaderBase ( ImgUploaderManager ) m_imgUploaderPlugin ( ImgUploaderManager ) m_urlString ( ImgUploaderManager ) m_NetworkAM ( ImgurUploader ) m_fallback ( KeySequence ) m_frame ( LoadSpinner ) m_growing ( LoadSpinner ) m_span ( LoadSpinner ) m_startAngle ( LoadSpinner ) m_borderColor ( MagnifierWidget ) m_devicePixelRatio ( MagnifierWidget ) m_magOffset ( MagnifierWidget ) m_magPixels ( MagnifierWidget ) m_paddedScreenshot ( MagnifierWidget ) m_pixels ( MagnifierWidget ) m_screenshot ( MagnifierWidget ) m_square ( MagnifierWidget ) magZoom ( MagnifierWidget ) m_captureWidget ( ModificationCommand , UtilityPanel ) m_content ( NotificationWidget ) m_hideAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_label ( NotificationWidget , PinWidget ) m_showAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_bgColor ( NotifierBox ) m_foregroundColor ( NotifierBox ) m_message ( NotifierBox ) m_orientation ( OrientablePushButton ) m_fillColor ( OverlayMessage ) m_messageStack ( OverlayMessage ) m_targetArea ( OverlayMessage ) m_textColor ( OverlayMessage ) m_geometry ( PinTool ) m_baseColor ( PinWidget ) m_currentStepScaleFactor ( PinWidget ) m_dragStart ( PinWidget ) m_expanding ( PinWidget ) m_hoverColor ( PinWidget ) m_offsetX ( PinWidget ) m_offsetY ( PinWidget ) m_rotateFactor ( PinWidget ) m_scaleFactor ( PinWidget ) m_shadowEffect ( PinWidget ) m_sizeChanged ( PinWidget ) m_currentScreen ( QGuiAppCurrentScreen ) m_info ( ScreenGrabber ) m_BArea ( SelectionWidget ) m_BHandle ( SelectionWidget ) m_BLArea ( SelectionWidget ) m_BLHandle ( SelectionWidget ) m_BRArea ( SelectionWidget ) m_BRHandle ( SelectionWidget ) m_LArea ( SelectionWidget ) m_LHandle ( SelectionWidget ) m_RArea ( SelectionWidget ) m_RHandle ( SelectionWidget ) m_TArea ( SelectionWidget ) m_THandle ( SelectionWidget ) m_TLArea ( SelectionWidget ) m_TLHandle ( SelectionWidget ) m_TRArea ( SelectionWidget ) m_TRHandle ( SelectionWidget ) m_activeSide ( SelectionWidget ) m_animation ( SelectionWidget ) m_areaOffset ( SelectionWidget ) m_dragStartPos ( SelectionWidget ) m_handleOffset ( SelectionWidget ) m_idleCentralCursor ( SelectionWidget ) m_ignoreMouse ( SelectionWidget ) m_mouseStartMove ( SelectionWidget ) m_ks ( SetShortcutDialog ) m_modifier ( SetShortcutDialog ) m_table ( ShortcutsWidget ) m_colorGrabButton ( SidePanelWidget ) m_colorGrabber ( SidePanelWidget ) m_colorHex ( SidePanelWidget ) m_colorLabel ( SidePanelWidget ) m_revertColor ( SidePanelWidget ) m_toolSize ( SidePanelWidget ) m_toolSizeSlider ( SidePanelWidget ) m_toolSizeSpin ( SidePanelWidget ) m_buttonData ( StrftimeChooserWidget ) m_interface ( SystemNotification ) m_centerAlignButton ( TextConfig ) m_fontsCB ( TextConfig ) m_italicButton ( TextConfig ) m_leftAlignButton ( TextConfig ) m_rightAlignButton ( TextConfig ) m_strikeOutButton ( TextConfig ) m_underlineButton ( TextConfig ) m_weightButton ( TextConfig ) m_alignment ( TextTool ) m_confW ( TextTool ) m_currentPos ( TextTool ) m_font ( TextTool ) m_size ( TextTool ) m_text ( TextTool ) m_textArea ( TextTool ) m_textOld ( TextTool ) m_widget ( TextTool ) m_baseSize ( TextWidget ) m_minSize ( TextWidget ) m_appUpdates ( TrayIcon ) m_menu ( TrayIcon ) m_buttonContrast ( UIcolorEditor ) m_buttonIconType ( UIcolorEditor ) m_buttonMainColor ( UIcolorEditor ) m_contrastColor ( UIcolorEditor ) m_labelContrast ( UIcolorEditor ) m_labelMain ( UIcolorEditor ) m_lastButtonPressed ( UIcolorEditor ) m_internalPanel ( UpdateNotificationWidget , UtilityPanel ) m_bottomLayout ( UtilityPanel ) m_buttonDelete ( UtilityPanel ) m_buttonMoveDown ( UtilityPanel ) m_buttonMoveUp ( UtilityPanel ) m_captureTools ( UtilityPanel ) m_layersLayout ( UtilityPanel ) m_upLayout ( UtilityPanel ) m_buttonList ( VisualsEditor ) m_colorEditor ( VisualsEditor ) m_colorEditorTab ( VisualsEditor ) m_colorpickerEditor ( VisualsEditor ) m_colorpickerEditorTab ( VisualsEditor ) m_opacitySlider ( VisualsEditor ) m_GraphicAppsList ( WinLnkFileParser ) n # name ( DesktopAppData , TerminalApp ) o # origScreenshot ( CaptureContext ) options ( CommandLineParser::Node ) r # request ( CaptureContext ) s # savePath ( CaptureContext ) screenshot ( CaptureContext ) selection ( CaptureContext ) subNodes ( CommandLineParser::Node ) setShowDesktopNotification ( ConfigHandler ) setShowStartupLaunchMessage ( ConfigHandler ) setUploadWithoutConfirmation ( ConfigHandler ) showInTerminal ( DesktopAppData ) t # toolSize ( CaptureContext ) token ( HistoryFileName ) type ( HistoryFileName ) u # ui ( CaptureLauncher , InfoWindow , UploadHistory , UploadLineItem ) w # widgetOffset ( CaptureContext ) WAYLAND_DISPLAY ( DesktopInfo ) x # XDG_CURRENT_DESKTOP ( DesktopInfo ) XDG_SESSION_TYPE ( DesktopInfo )","title":"Class Member Variables"},{"location":"flameshot/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"flameshot/class_member_variables/#a","text":"argument ( CommandLineParser::Node ) arg ( TerminalApp )","title":"a"},{"location":"flameshot/class_member_variables/#b","text":"buttonBox ( ImgUploadDialog )","title":"b"},{"location":"flameshot/class_member_variables/#c","text":"capture ( AppLauncher , ImgUploaderTool ) circleCount ( CaptureContext ) color ( CaptureContext ) categories ( DesktopAppData )","title":"c"},{"location":"flameshot/class_member_variables/#d","text":"defaultLargeColorPalette ( ColorPickerWidget ) defaultSmallColorPalette ( ColorPickerWidget ) description ( DesktopAppData ) DESKTOP_SESSION ( DesktopInfo )","title":"d"},{"location":"flameshot/class_member_variables/#e","text":"exec ( DesktopAppData )","title":"e"},{"location":"flameshot/class_member_variables/#f","text":"fullscreen ( CaptureContext ) file ( HistoryFileName )","title":"f"},{"location":"flameshot/class_member_variables/#g","text":"GDMSESSION ( DesktopInfo ) GNOME_DESKTOP_SESSION_ID ( DesktopInfo )","title":"g"},{"location":"flameshot/class_member_variables/#i","text":"iterableButtonTypes ( CaptureToolButton ) icon ( DesktopAppData )","title":"i"},{"location":"flameshot/class_member_variables/#k","text":"KDE_FULL_SESSION ( DesktopInfo )","title":"k"},{"location":"flameshot/class_member_variables/#l","text":"layout ( ImgUploadDialog )","title":"l"},{"location":"flameshot/class_member_variables/#m","text":"m_defaultChannel ( AbstractLogger ) m_enableMessageHeader ( AbstractLogger ) m_notificationPath ( AbstractLogger ) m_targets ( AbstractLogger ) m_textStreams ( AbstractLogger ) m_color ( AbstractPathTool , AbstractTwoPointTool , ColorGrabWidget , ColorPickerEditor , LoadSpinner , MagnifierWidget , SelectionWidget , SidePanelWidget , TextTool ) m_padding ( AbstractPathTool , AbstractTwoPointTool ) m_pathArea ( AbstractPathTool ) m_points ( AbstractPathTool , AbstractTwoPointTool ) m_pos ( AbstractPathTool ) m_thickness ( AbstractPathTool , AbstractTwoPointTool ) m_supportsDiagonalAdj ( AbstractTwoPointTool ) m_supportsOrthogonalAdj ( AbstractTwoPointTool ) m_appsMap ( AppLauncherWidget ) m_filterList ( AppLauncherWidget ) m_keepOpen ( AppLauncherWidget ) m_keepOpenCheckbox ( AppLauncherWidget ) m_layout ( AppLauncherWidget , FileNameEditor , GeneralConf , NotificationWidget , PinWidget , SetShortcutDialog , ShortcutsWidget , SidePanelWidget , TextConfig , UpdateNotificationWidget , UtilityPanel , VisualsEditor ) m_lineEdit ( AppLauncherWidget ) m_parser ( AppLauncherWidget ) m_pixmap ( AppLauncherWidget , ColorGrabWidget , ImageLabel , ImgUploaderBase , PinTool , PinWidget , SidePanelWidget ) m_tabWidget ( AppLauncherWidget , ConfigWindow , VisualsEditor ) m_tempFile ( AppLauncherWidget ) m_terminalCheckbox ( AppLauncherWidget ) m_arrowPath ( ArrowTool ) m_def ( Bool , BoundedInt , Color , LowerBoundedInt , String ) m_max ( BoundedInt , UserColors ) m_min ( BoundedInt , LowerBoundedInt , UserColors ) m_allSidesBlocked ( ButtonHandler ) m_blockedBotton ( ButtonHandler ) m_blockedLeft ( ButtonHandler ) m_blockedRight ( ButtonHandler ) m_blockedTop ( ButtonHandler ) m_buttonBaseSize ( ButtonHandler ) m_buttonExtendedSize ( ButtonHandler ) m_buttonsAreInside ( ButtonHandler ) m_horizontalyBlocked ( ButtonHandler ) m_oneHorizontalBlocked ( ButtonHandler ) m_screenRegions ( ButtonHandler ) m_selection ( ButtonHandler , CaptureWidget ) m_separator ( ButtonHandler ) m_vectorButtons ( ButtonHandler ) m_buttonTypeByName ( ButtonListView ) m_listButtons ( ButtonListView ) m_mainColor ( CaptureButton , CaptureToolButton ) mousePos ( CaptureContext ) m_data ( CaptureRequest ) m_delay ( CaptureRequest ) m_initialSelection ( CaptureRequest ) m_mode ( CaptureRequest ) m_path ( CaptureRequest ) m_pinWindowGeometry ( CaptureRequest ) m_tasks ( CaptureRequest ) m_buttonType ( CaptureToolButton ) m_emergeAnimation ( CaptureToolButton ) m_tool ( CaptureToolButton ) m_captureToolObjects ( CaptureToolObjects , CaptureWidget , ModificationCommand ) m_imageCache ( CaptureToolObjects ) m_activeButton ( CaptureWidget ) m_activeTool ( CaptureWidget ) m_activeToolIsMoved ( CaptureWidget ) m_activeToolOffsetToMouseOnStart ( CaptureWidget ) m_adjustmentButtonPressed ( CaptureWidget ) m_buttonHandler ( CaptureWidget ) m_captureDone ( CaptureWidget ) m_captureToolObjectsBackup ( CaptureWidget , ModificationCommand ) m_colorPicker ( CaptureWidget ) m_config ( CaptureWidget , ColorPickerEditMode , ColorPickerEditor , ShortcutsWidget ) m_configError ( CaptureWidget ) m_configErrorResolved ( CaptureWidget ) m_context ( CaptureWidget ) m_contrastUiColor ( CaptureWidget ) m_eventFilter ( CaptureWidget ) m_existingObjectIsChanged ( CaptureWidget ) m_helpMessage ( CaptureWidget , GeneralConf ) m_lastMouseWheel ( CaptureWidget ) m_magnifier ( CaptureWidget ) m_mouseIsClicked ( CaptureWidget ) m_mouseOverHandle ( CaptureWidget ) m_mousePressedPos ( CaptureWidget ) m_movingSelection ( CaptureWidget ) m_newSelection ( CaptureWidget ) m_notifierBox ( CaptureWidget ) m_opacity ( CaptureWidget , PinWidget ) m_panel ( CaptureWidget ) m_previewEnabled ( CaptureWidget ) m_sidePanel ( CaptureWidget ) m_sizeIndButton ( CaptureWidget ) m_startMove ( CaptureWidget ) m_startMovePos ( CaptureWidget ) m_toolSizeByKeyboard ( CaptureWidget ) m_toolWidget ( CaptureWidget , UtilityPanel ) m_tools ( CaptureWidget ) m_uiColor ( CaptureWidget , ColorPickerWidget , UIcolorEditor ) m_undoStack ( CaptureWidget ) m_updateNotificationWidget ( CaptureWidget ) m_xywhDisplay ( CaptureWidget ) m_xywhTimer ( CaptureWidget ) m_tempString ( CircleCountTool , TextTool ) m_valid ( CircleCountTool ) m_extraZoomActive ( ColorGrabWidget ) m_magnifierActive ( ColorGrabWidget ) m_mousePressReceived ( ColorGrabWidget ) m_previewImage ( ColorGrabWidget ) m_draggedPresetInitialPos ( ColorPickerEditMode ) m_isDragging ( ColorPickerEditMode , DraggableWidgetMaker ) m_isPressing ( ColorPickerEditMode , DraggableWidgetMaker ) m_mouseMovePos ( ColorPickerEditMode , DraggableWidgetMaker ) m_mousePressPos ( ColorPickerEditMode , DraggableWidgetMaker ) m_addPresetButton ( ColorPickerEditor ) m_addPresetLabel ( ColorPickerEditor ) m_colorEdit ( ColorPickerEditor ) m_colorEditLabel ( ColorPickerEditor ) m_colorInput ( ColorPickerEditor ) m_colorList ( ColorPickerEditor , ColorPickerWidget ) m_colorWheel ( ColorPickerEditor , SidePanelWidget , UIcolorEditor ) m_colorpicker ( ColorPickerEditor ) m_deletePresetButton ( ColorPickerEditor ) m_gLayout ( ColorPickerEditor ) m_selectedIndex ( ColorPickerEditor , ColorPickerWidget ) m_updatePresetButton ( ColorPickerEditor ) m_colorAreaList ( ColorPickerWidget ) m_colorAreaSize ( ColorPickerWidget ) m_lastIndex ( ColorPickerWidget ) m_description ( CommandArgument , CommandLineParser , CommandOption ) m_name ( CommandArgument ) m_foundArgs ( CommandLineParser ) m_foundOptions ( CommandLineParser ) m_generalErrorMessage ( CommandLineParser ) m_parseTree ( CommandLineParser ) m_withHelp ( CommandLineParser ) m_withVersion ( CommandLineParser ) m_checker ( CommandOption ) m_errorMsg ( CommandOption ) m_names ( CommandOption ) m_value ( CommandOption ) m_valueName ( CommandOption ) m_configWatcher ( ConfigHandler ) m_errorCheckPending ( ConfigHandler ) m_hasError ( ConfigHandler ) m_settings ( ConfigHandler ) m_skipNextErrorCheck ( ConfigHandler ) m_filenameEditor ( ConfigWindow ) m_filenameEditorTab ( ConfigWindow ) m_generalConfig ( ConfigWindow ) m_generalConfigTab ( ConfigWindow ) m_shortcuts ( ConfigWindow , ShortcutsWidget ) m_shortcutsTab ( ConfigWindow ) m_visuals ( ConfigWindow ) m_visualsTab ( ConfigWindow ) m_appList ( DesktopFileParser , WinLnkFileParser ) m_defaultIcon ( DesktopFileParser ) m_localeDescription ( DesktopFileParser ) m_localeDescriptionShort ( DesktopFileParser ) m_localeName ( DesktopFileParser ) m_localeNameShort ( DesktopFileParser ) m_timer ( ExtendedSlider , LoadSpinner , NotificationWidget , NotifierBox ) m_clearButton ( FileNameEditor ) m_helperButtons ( FileNameEditor ) m_nameEditor ( FileNameEditor ) m_nameHandler ( FileNameEditor ) m_outputLabel ( FileNameEditor ) m_resetButton ( FileNameEditor , GeneralConf ) m_saveButton ( FileNameEditor ) MAX_CHARACTERS ( FileNameHandler ) m_captureWindow ( Flameshot ) m_configWindow ( Flameshot ) m_haveExternalWidget ( Flameshot ) m_infoWindow ( Flameshot ) m_launcherWindow ( Flameshot ) m_origin ( Flameshot ) m_appLatestUrl ( FlameshotDaemon , UpdateNotificationWidget ) m_appLatestVersion ( FlameshotDaemon , UpdateNotificationWidget ) m_clipboardSignalBlocked ( FlameshotDaemon ) m_hostingClipboard ( FlameshotDaemon ) m_instance ( FlameshotDaemon , OverlayMessage ) m_networkCheckUpdates ( FlameshotDaemon ) m_persist ( FlameshotDaemon ) m_showCheckAppUpdateStatus ( FlameshotDaemon ) m_trayIcon ( FlameshotDaemon ) m_widgets ( FlameshotDaemon ) m_allowMultipleGuiInstances ( GeneralConf ) m_antialiasingPinZoom ( GeneralConf ) m_autoCloseIdleDaemon ( GeneralConf ) m_autostart ( GeneralConf ) m_changeSaveButton ( GeneralConf ) m_checkForUpdates ( GeneralConf ) m_copyOnDoubleClick ( GeneralConf ) m_copyPathAfterSave ( GeneralConf ) m_copyURLAfterUpload ( GeneralConf ) m_exportButton ( GeneralConf ) m_historyConfirmationToDelete ( GeneralConf ) m_importButton ( GeneralConf ) m_predefinedColorPaletteLarge ( GeneralConf ) m_saveAfterCopy ( GeneralConf ) m_saveLastRegion ( GeneralConf ) m_savePath ( GeneralConf ) m_screenshotPathFixedCheck ( GeneralConf ) m_scrollArea ( GeneralConf ) m_scrollAreaLayout ( GeneralConf ) m_selectGeometryLocation ( GeneralConf ) m_setSaveAsFileExtension ( GeneralConf ) m_showMagnifier ( GeneralConf ) m_showSelectionGeometry ( GeneralConf ) m_showStartupLaunchMessage ( GeneralConf ) m_showTray ( GeneralConf ) m_sidePanelButton ( GeneralConf ) m_squareMagnifier ( GeneralConf ) m_sysNotifications ( GeneralConf ) m_undoLimit ( GeneralConf ) m_uploadClientKey ( GeneralConf ) m_uploadHistoryMax ( GeneralConf ) m_uploadWithoutConfirmation ( GeneralConf , ImgUploadDialog ) m_useJpgForClipboard ( GeneralConf ) m_xywhTimeout ( GeneralConf ) m_historyPath ( History ) m_packedFileName ( History ) m_thumbs ( History ) m_unpackedFileName ( History ) m_DSEffect ( ImageLabel ) m_dragStartPosition ( ImageLabel ) m_uploadLabel ( ImgUploadDialog ) m_copyUrlButton ( ImgUploaderBase ) m_currentImageName ( ImgUploaderBase ) m_hLayout ( ImgUploaderBase , UIcolorEditor ) m_imageURL ( ImgUploaderBase ) m_infoLabel ( ImgUploaderBase ) m_notification ( ImgUploaderBase , UpdateNotificationWidget ) m_openDeleteUrlButton ( ImgUploaderBase ) m_openUrlButton ( ImgUploaderBase ) m_saveToFilesystemButton ( ImgUploaderBase ) m_spinner ( ImgUploaderBase ) m_toClipboardButton ( ImgUploaderBase ) m_vLayout ( ImgUploaderBase , UIcolorEditor ) m_imgUploaderBase ( ImgUploaderManager ) m_imgUploaderPlugin ( ImgUploaderManager ) m_urlString ( ImgUploaderManager ) m_NetworkAM ( ImgurUploader ) m_fallback ( KeySequence ) m_frame ( LoadSpinner ) m_growing ( LoadSpinner ) m_span ( LoadSpinner ) m_startAngle ( LoadSpinner ) m_borderColor ( MagnifierWidget ) m_devicePixelRatio ( MagnifierWidget ) m_magOffset ( MagnifierWidget ) m_magPixels ( MagnifierWidget ) m_paddedScreenshot ( MagnifierWidget ) m_pixels ( MagnifierWidget ) m_screenshot ( MagnifierWidget ) m_square ( MagnifierWidget ) magZoom ( MagnifierWidget ) m_captureWidget ( ModificationCommand , UtilityPanel ) m_content ( NotificationWidget ) m_hideAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_label ( NotificationWidget , PinWidget ) m_showAnimation ( NotificationWidget , UpdateNotificationWidget , UtilityPanel ) m_bgColor ( NotifierBox ) m_foregroundColor ( NotifierBox ) m_message ( NotifierBox ) m_orientation ( OrientablePushButton ) m_fillColor ( OverlayMessage ) m_messageStack ( OverlayMessage ) m_targetArea ( OverlayMessage ) m_textColor ( OverlayMessage ) m_geometry ( PinTool ) m_baseColor ( PinWidget ) m_currentStepScaleFactor ( PinWidget ) m_dragStart ( PinWidget ) m_expanding ( PinWidget ) m_hoverColor ( PinWidget ) m_offsetX ( PinWidget ) m_offsetY ( PinWidget ) m_rotateFactor ( PinWidget ) m_scaleFactor ( PinWidget ) m_shadowEffect ( PinWidget ) m_sizeChanged ( PinWidget ) m_currentScreen ( QGuiAppCurrentScreen ) m_info ( ScreenGrabber ) m_BArea ( SelectionWidget ) m_BHandle ( SelectionWidget ) m_BLArea ( SelectionWidget ) m_BLHandle ( SelectionWidget ) m_BRArea ( SelectionWidget ) m_BRHandle ( SelectionWidget ) m_LArea ( SelectionWidget ) m_LHandle ( SelectionWidget ) m_RArea ( SelectionWidget ) m_RHandle ( SelectionWidget ) m_TArea ( SelectionWidget ) m_THandle ( SelectionWidget ) m_TLArea ( SelectionWidget ) m_TLHandle ( SelectionWidget ) m_TRArea ( SelectionWidget ) m_TRHandle ( SelectionWidget ) m_activeSide ( SelectionWidget ) m_animation ( SelectionWidget ) m_areaOffset ( SelectionWidget ) m_dragStartPos ( SelectionWidget ) m_handleOffset ( SelectionWidget ) m_idleCentralCursor ( SelectionWidget ) m_ignoreMouse ( SelectionWidget ) m_mouseStartMove ( SelectionWidget ) m_ks ( SetShortcutDialog ) m_modifier ( SetShortcutDialog ) m_table ( ShortcutsWidget ) m_colorGrabButton ( SidePanelWidget ) m_colorGrabber ( SidePanelWidget ) m_colorHex ( SidePanelWidget ) m_colorLabel ( SidePanelWidget ) m_revertColor ( SidePanelWidget ) m_toolSize ( SidePanelWidget ) m_toolSizeSlider ( SidePanelWidget ) m_toolSizeSpin ( SidePanelWidget ) m_buttonData ( StrftimeChooserWidget ) m_interface ( SystemNotification ) m_centerAlignButton ( TextConfig ) m_fontsCB ( TextConfig ) m_italicButton ( TextConfig ) m_leftAlignButton ( TextConfig ) m_rightAlignButton ( TextConfig ) m_strikeOutButton ( TextConfig ) m_underlineButton ( TextConfig ) m_weightButton ( TextConfig ) m_alignment ( TextTool ) m_confW ( TextTool ) m_currentPos ( TextTool ) m_font ( TextTool ) m_size ( TextTool ) m_text ( TextTool ) m_textArea ( TextTool ) m_textOld ( TextTool ) m_widget ( TextTool ) m_baseSize ( TextWidget ) m_minSize ( TextWidget ) m_appUpdates ( TrayIcon ) m_menu ( TrayIcon ) m_buttonContrast ( UIcolorEditor ) m_buttonIconType ( UIcolorEditor ) m_buttonMainColor ( UIcolorEditor ) m_contrastColor ( UIcolorEditor ) m_labelContrast ( UIcolorEditor ) m_labelMain ( UIcolorEditor ) m_lastButtonPressed ( UIcolorEditor ) m_internalPanel ( UpdateNotificationWidget , UtilityPanel ) m_bottomLayout ( UtilityPanel ) m_buttonDelete ( UtilityPanel ) m_buttonMoveDown ( UtilityPanel ) m_buttonMoveUp ( UtilityPanel ) m_captureTools ( UtilityPanel ) m_layersLayout ( UtilityPanel ) m_upLayout ( UtilityPanel ) m_buttonList ( VisualsEditor ) m_colorEditor ( VisualsEditor ) m_colorEditorTab ( VisualsEditor ) m_colorpickerEditor ( VisualsEditor ) m_colorpickerEditorTab ( VisualsEditor ) m_opacitySlider ( VisualsEditor ) m_GraphicAppsList ( WinLnkFileParser )","title":"m"},{"location":"flameshot/class_member_variables/#n","text":"name ( DesktopAppData , TerminalApp )","title":"n"},{"location":"flameshot/class_member_variables/#o","text":"origScreenshot ( CaptureContext ) options ( CommandLineParser::Node )","title":"o"},{"location":"flameshot/class_member_variables/#r","text":"request ( CaptureContext )","title":"r"},{"location":"flameshot/class_member_variables/#s","text":"savePath ( CaptureContext ) screenshot ( CaptureContext ) selection ( CaptureContext ) subNodes ( CommandLineParser::Node ) setShowDesktopNotification ( ConfigHandler ) setShowStartupLaunchMessage ( ConfigHandler ) setUploadWithoutConfirmation ( ConfigHandler ) showInTerminal ( DesktopAppData )","title":"s"},{"location":"flameshot/class_member_variables/#t","text":"toolSize ( CaptureContext ) token ( HistoryFileName ) type ( HistoryFileName )","title":"t"},{"location":"flameshot/class_member_variables/#u","text":"ui ( CaptureLauncher , InfoWindow , UploadHistory , UploadLineItem )","title":"u"},{"location":"flameshot/class_member_variables/#w","text":"widgetOffset ( CaptureContext ) WAYLAND_DISPLAY ( DesktopInfo )","title":"w"},{"location":"flameshot/class_member_variables/#x","text":"XDG_CURRENT_DESKTOP ( DesktopInfo ) XDG_SESSION_TYPE ( DesktopInfo )","title":"x"},{"location":"flameshot/class_member_typedefs/","text":"Class Member Typedefs #","title":"Class Member Typedefs"},{"location":"flameshot/class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"flameshot/class_member_enums/","text":"Class Member Enums # c # Channel ( AbstractLogger ) CaptureMode ( CaptureRequest ) e # ExportTask ( CaptureRequest ) o # Origin ( Flameshot ) Orientation ( OrientablePushButton ) s # SideType ( SelectionWidget ) t # Target ( AbstractLogger ) w # WM ( DesktopInfo ) x # xywh_position ( GeneralConf )","title":"Class Member Enums"},{"location":"flameshot/class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"flameshot/class_member_enums/#c","text":"Channel ( AbstractLogger ) CaptureMode ( CaptureRequest )","title":"c"},{"location":"flameshot/class_member_enums/#e","text":"ExportTask ( CaptureRequest )","title":"e"},{"location":"flameshot/class_member_enums/#o","text":"Origin ( Flameshot ) Orientation ( OrientablePushButton )","title":"o"},{"location":"flameshot/class_member_enums/#s","text":"SideType ( SelectionWidget )","title":"s"},{"location":"flameshot/class_member_enums/#t","text":"Target ( AbstractLogger )","title":"t"},{"location":"flameshot/class_member_enums/#w","text":"WM ( DesktopInfo )","title":"w"},{"location":"flameshot/class_member_enums/#x","text":"xywh_position ( GeneralConf )","title":"x"},{"location":"flameshot/namespace_members/","text":"Namespace Members # b # buttonBaseSize ( GlobalValues ) blackIconPath ( PathInfo ) c # colorIsDark ( ColorUtils ) contrastColor ( ColorUtils ) create_specifier_list ( strfparse ) d # DIAG_UNIT ( @57 ) f # format_time_string ( strfparse ) i # iconPath ( GlobalValues ) iconPathPNG ( GlobalValues ) m # match_specifiers ( strfparse ) r # Request ( org::freedesktop::portal ) replace_all ( strfparse ) s # split ( strfparse ) t # translationsPaths ( PathInfo ) u # UNIT ( @57 ) v # versionInfo ( GlobalValues ) w # whiteIconPath ( PathInfo )","title":"Namespace Members"},{"location":"flameshot/namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"flameshot/namespace_members/#b","text":"buttonBaseSize ( GlobalValues ) blackIconPath ( PathInfo )","title":"b"},{"location":"flameshot/namespace_members/#c","text":"colorIsDark ( ColorUtils ) contrastColor ( ColorUtils ) create_specifier_list ( strfparse )","title":"c"},{"location":"flameshot/namespace_members/#d","text":"DIAG_UNIT ( @57 )","title":"d"},{"location":"flameshot/namespace_members/#f","text":"format_time_string ( strfparse )","title":"f"},{"location":"flameshot/namespace_members/#i","text":"iconPath ( GlobalValues ) iconPathPNG ( GlobalValues )","title":"i"},{"location":"flameshot/namespace_members/#m","text":"match_specifiers ( strfparse )","title":"m"},{"location":"flameshot/namespace_members/#r","text":"Request ( org::freedesktop::portal ) replace_all ( strfparse )","title":"r"},{"location":"flameshot/namespace_members/#s","text":"split ( strfparse )","title":"s"},{"location":"flameshot/namespace_members/#t","text":"translationsPaths ( PathInfo )","title":"t"},{"location":"flameshot/namespace_members/#u","text":"UNIT ( @57 )","title":"u"},{"location":"flameshot/namespace_members/#v","text":"versionInfo ( GlobalValues )","title":"v"},{"location":"flameshot/namespace_members/#w","text":"whiteIconPath ( PathInfo )","title":"w"},{"location":"flameshot/namespace_member_functions/","text":"Namespace Member Functions # b # buttonBaseSize ( GlobalValues ) blackIconPath ( PathInfo ) c # colorIsDark ( ColorUtils ) contrastColor ( ColorUtils ) create_specifier_list ( strfparse ) f # format_time_string ( strfparse ) i # iconPath ( GlobalValues ) iconPathPNG ( GlobalValues ) m # match_specifiers ( strfparse ) r # replace_all ( strfparse ) s # split ( strfparse ) t # translationsPaths ( PathInfo ) v # versionInfo ( GlobalValues ) w # whiteIconPath ( PathInfo )","title":"Namespace Member Functions"},{"location":"flameshot/namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"flameshot/namespace_member_functions/#b","text":"buttonBaseSize ( GlobalValues ) blackIconPath ( PathInfo )","title":"b"},{"location":"flameshot/namespace_member_functions/#c","text":"colorIsDark ( ColorUtils ) contrastColor ( ColorUtils ) create_specifier_list ( strfparse )","title":"c"},{"location":"flameshot/namespace_member_functions/#f","text":"format_time_string ( strfparse )","title":"f"},{"location":"flameshot/namespace_member_functions/#i","text":"iconPath ( GlobalValues ) iconPathPNG ( GlobalValues )","title":"i"},{"location":"flameshot/namespace_member_functions/#m","text":"match_specifiers ( strfparse )","title":"m"},{"location":"flameshot/namespace_member_functions/#r","text":"replace_all ( strfparse )","title":"r"},{"location":"flameshot/namespace_member_functions/#s","text":"split ( strfparse )","title":"s"},{"location":"flameshot/namespace_member_functions/#t","text":"translationsPaths ( PathInfo )","title":"t"},{"location":"flameshot/namespace_member_functions/#v","text":"versionInfo ( GlobalValues )","title":"v"},{"location":"flameshot/namespace_member_functions/#w","text":"whiteIconPath ( PathInfo )","title":"w"},{"location":"flameshot/namespace_member_variables/","text":"Namespace Member Variables #","title":"Namespace Member Variables"},{"location":"flameshot/namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"flameshot/namespace_member_typedefs/","text":"Namespace Member Typedefs # r # Request ( org::freedesktop::portal )","title":"Namespace Member Typedefs"},{"location":"flameshot/namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"flameshot/namespace_member_typedefs/#r","text":"Request ( org::freedesktop::portal )","title":"r"},{"location":"flameshot/namespace_member_enums/","text":"Namespace Member Enums # d # DIAG_UNIT ( @57 ) u # UNIT ( @57 )","title":"Namespace Member Enums"},{"location":"flameshot/namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"flameshot/namespace_member_enums/#d","text":"DIAG_UNIT ( @57 )","title":"d"},{"location":"flameshot/namespace_member_enums/#u","text":"UNIT ( @57 )","title":"u"},{"location":"flameshot/functions/","text":"Functions # c # clearHistoryLayout ( uploadhistory.cpp , uploadhistory.h ) g # getCachePath ( cacheutils.cpp , cacheutils.h ) getLastRegion ( cacheutils.cpp , cacheutils.h ) guiMutexLock ( main.cpp ) getColorLuma ( colorutils.cpp ) getProperSide ( selectionwidget.cpp ) generateKernelString ( infowindow.cpp , infowindow.h ) m # main ( main.cpp ) o # operator& ( capturerequest.h ) operator| ( capturerequest.h ) operator|= ( capturerequest.h ) r # requestCaptureAndWait ( main.cpp ) removeCacheFile ( uploadlineitem.cpp , uploadlineitem.h ) s # setLastRegion ( cacheutils.cpp , cacheutils.h ) showOpenWithMenu ( openwithprogram.cpp , openwithprogram.h ) ShowSaveFileDialog ( screenshotsaver.cpp , screenshotsaver.h ) saveToClipboard ( screenshotsaver.cpp , screenshotsaver.h ) saveToClipboardMime ( screenshotsaver.cpp , screenshotsaver.h ) saveToFilesystem ( screenshotsaver.cpp , screenshotsaver.h ) saveToFilesystemGUI ( screenshotsaver.cpp , screenshotsaver.h ) sortButtons ( valuehandler.cpp ) scaleThumbnail ( uploadhistory.cpp , uploadhistory.h ) v # verifyLaunchFile ( confighandler.cpp )","title":"Functions"},{"location":"flameshot/functions/#functions","text":"","title":"Functions"},{"location":"flameshot/functions/#c","text":"clearHistoryLayout ( uploadhistory.cpp , uploadhistory.h )","title":"c"},{"location":"flameshot/functions/#g","text":"getCachePath ( cacheutils.cpp , cacheutils.h ) getLastRegion ( cacheutils.cpp , cacheutils.h ) guiMutexLock ( main.cpp ) getColorLuma ( colorutils.cpp ) getProperSide ( selectionwidget.cpp ) generateKernelString ( infowindow.cpp , infowindow.h )","title":"g"},{"location":"flameshot/functions/#m","text":"main ( main.cpp )","title":"m"},{"location":"flameshot/functions/#o","text":"operator& ( capturerequest.h ) operator| ( capturerequest.h ) operator|= ( capturerequest.h )","title":"o"},{"location":"flameshot/functions/#r","text":"requestCaptureAndWait ( main.cpp ) removeCacheFile ( uploadlineitem.cpp , uploadlineitem.h )","title":"r"},{"location":"flameshot/functions/#s","text":"setLastRegion ( cacheutils.cpp , cacheutils.h ) showOpenWithMenu ( openwithprogram.cpp , openwithprogram.h ) ShowSaveFileDialog ( screenshotsaver.cpp , screenshotsaver.h ) saveToClipboard ( screenshotsaver.cpp , screenshotsaver.h ) saveToClipboardMime ( screenshotsaver.cpp , screenshotsaver.h ) saveToFilesystem ( screenshotsaver.cpp , screenshotsaver.h ) saveToFilesystemGUI ( screenshotsaver.cpp , screenshotsaver.h ) sortButtons ( valuehandler.cpp ) scaleThumbnail ( uploadhistory.cpp , uploadhistory.h )","title":"s"},{"location":"flameshot/functions/#v","text":"verifyLaunchFile ( confighandler.cpp )","title":"v"},{"location":"flameshot/macros/","text":"Macros # b # BASE_POINT_SIZE ( texttool.cpp ) c # CONFIG_GETTER ( confighandler.h ) CONFIG_GETTER_SETTER ( confighandler.h ) CONFIG_GROUP_GENERAL ( confighandler.h ) CONFIG_GROUP_SHORTCUTS ( confighandler.h ) CONFIG_SETTER ( confighandler.h ) f # FLAMESHOT_ICON ( systemnotification.cpp ) h # HISTORYPIXMAP_MAX_PREVIEW_HEIGHT ( history.h ) HISTORYPIXMAP_MAX_PREVIEW_WIDTH ( history.h ) i # IMG_UPLOADER_STORAGE_DEFAULT ( imguploadermanager.h ) if_TYPE_return_TOOL ( toolfactory.cpp ) m # MAX_INFO_LENGTH ( texttool.cpp ) MOUSE_DISTANCE_TO_START_MOVING ( capturewidget.cpp ) MARGIN ( selectionwidget.cpp ) o # OPTION ( confighandler.cpp ) OFFSET ( loadspinner.cpp ) p # PADDING_VALUE ( circlecounttool.cpp , markertool.cpp ) s # SHORTCUT ( confighandler.cpp ) SEARCH_RADIUS_FAR ( capturetoolobjects.cpp ) SEARCH_RADIUS_NEAR ( capturetoolobjects.cpp ) SEARCH_RADIUS_TEXT_HANDICAP ( capturetoolobjects.cpp ) t # THICKNESS_OFFSET ( circlecounttool.cpp ) w # WIDTH1 ( colorgrabwidget.cpp ) WIDTH2 ( colorgrabwidget.cpp ) z # ZOOM1 ( colorgrabwidget.cpp ) ZOOM2 ( colorgrabwidget.cpp )","title":"Macros"},{"location":"flameshot/macros/#macros","text":"","title":"Macros"},{"location":"flameshot/macros/#b","text":"BASE_POINT_SIZE ( texttool.cpp )","title":"b"},{"location":"flameshot/macros/#c","text":"CONFIG_GETTER ( confighandler.h ) CONFIG_GETTER_SETTER ( confighandler.h ) CONFIG_GROUP_GENERAL ( confighandler.h ) CONFIG_GROUP_SHORTCUTS ( confighandler.h ) CONFIG_SETTER ( confighandler.h )","title":"c"},{"location":"flameshot/macros/#f","text":"FLAMESHOT_ICON ( systemnotification.cpp )","title":"f"},{"location":"flameshot/macros/#h","text":"HISTORYPIXMAP_MAX_PREVIEW_HEIGHT ( history.h ) HISTORYPIXMAP_MAX_PREVIEW_WIDTH ( history.h )","title":"h"},{"location":"flameshot/macros/#i","text":"IMG_UPLOADER_STORAGE_DEFAULT ( imguploadermanager.h ) if_TYPE_return_TOOL ( toolfactory.cpp )","title":"i"},{"location":"flameshot/macros/#m","text":"MAX_INFO_LENGTH ( texttool.cpp ) MOUSE_DISTANCE_TO_START_MOVING ( capturewidget.cpp ) MARGIN ( selectionwidget.cpp )","title":"m"},{"location":"flameshot/macros/#o","text":"OPTION ( confighandler.cpp ) OFFSET ( loadspinner.cpp )","title":"o"},{"location":"flameshot/macros/#p","text":"PADDING_VALUE ( circlecounttool.cpp , markertool.cpp )","title":"p"},{"location":"flameshot/macros/#s","text":"SHORTCUT ( confighandler.cpp ) SEARCH_RADIUS_FAR ( capturetoolobjects.cpp ) SEARCH_RADIUS_NEAR ( capturetoolobjects.cpp ) SEARCH_RADIUS_TEXT_HANDICAP ( capturetoolobjects.cpp )","title":"s"},{"location":"flameshot/macros/#t","text":"THICKNESS_OFFSET ( circlecounttool.cpp )","title":"t"},{"location":"flameshot/macros/#w","text":"WIDTH1 ( colorgrabwidget.cpp ) WIDTH2 ( colorgrabwidget.cpp )","title":"w"},{"location":"flameshot/macros/#z","text":"ZOOM1 ( colorgrabwidget.cpp ) ZOOM2 ( colorgrabwidget.cpp )","title":"z"},{"location":"flameshot/variables/","text":"Variables # b # BList ( valuehandler.cpp ) BType ( valuehandler.cpp ) buttonTypeOrder ( capturetoolbutton.cpp ) e # eTask ( capturerequest.h ) m # maxToolSize ( sidepanelwidget.h ) minSliderWidth ( sidepanelwidget.h ) r # recognizedGeneralOptions ( confighandler.cpp ) recognizedShortcuts ( confighandler.cpp )","title":"Variables"},{"location":"flameshot/variables/#variables","text":"","title":"Variables"},{"location":"flameshot/variables/#b","text":"BList ( valuehandler.cpp ) BType ( valuehandler.cpp ) buttonTypeOrder ( capturetoolbutton.cpp )","title":"b"},{"location":"flameshot/variables/#e","text":"eTask ( capturerequest.h )","title":"e"},{"location":"flameshot/variables/#m","text":"maxToolSize ( sidepanelwidget.h ) minSliderWidth ( sidepanelwidget.h )","title":"m"},{"location":"flameshot/variables/#r","text":"recognizedGeneralOptions ( confighandler.cpp ) recognizedShortcuts ( confighandler.cpp )","title":"r"},{"location":"flameshot/links/","text":"Related Pages Modules Class List namespace @103 namespace @2 namespace @57 namespace @61 namespace @67 namespace @85 namespace @91 class AbstractActionTool class AbstractLogger class AbstractPathTool class AbstractTwoPointTool class AcceptTool class AppLauncher class AppLauncherWidget class ArrowTool class Bool class BoundedInt class ButtonHandler class ButtonList class ButtonListView class CaptureButton struct CaptureContext class CaptureLauncher class CaptureRequest class CaptureToolButton class CaptureToolObjects class CaptureWidget class CircleCountTool class CircleTool class ClickableLabel class Color class ColorGrabWidget class ColorPicker class ColorPickerEditMode class ColorPickerEditor class ColorPickerWidget namespace ColorUtils class CommandArgument class CommandLineParser struct CommandLineParser::Node class CommandOption struct CompareAppByName class ConfigErrorDetails class ConfigHandler class ConfigResolver class ConfigWindow class CopyTool struct DesktopAppData struct DesktopFileParser class DesktopInfo class DraggableWidgetMaker class ExistingDir class ExitTool class ExtendedSlider class FileNameEditor class FileNameHandler class FilenamePattern class Flameshot class FlameshotDBusAdapter class FlameshotDaemon class GeneralConf class GlobalShortcutFilter namespace GlobalValues class History struct HistoryFileName class HoverEventFilter class ImageLabel class ImgUploadDialog class ImgUploaderBase class ImgUploaderManager class ImgUploaderTool class ImgurUploader class InfoWindow class InvertTool class KeySequence class LauncherItemDelegate class LineTool class LoadSpinner class LowerBoundedInt class MagnifierWidget class MarkerTool class ModificationCommand class MoveTool class NotificationWidget class NotifierBox class OrgFreedesktopPortalRequestInterface class OrientablePushButton class OverlayMessage namespace PathInfo class PencilTool class PinTool class PinWidget class PixelateTool class QGuiAppCurrentScreen class QSharedPointer class RectangleTool class RedoTool class Region class SaveFileExtension class SaveTool class ScreenGrabber class SelectionTool class SelectionWidget class SetShortcutDialog class ShortcutsWidget class SidePanelWidget class SizeDecreaseTool class SizeIncreaseTool class StrftimeChooserWidget class String class StyleOverride class SystemNotification struct TerminalApp class TerminalLauncher class TextConfig class TextTool class TextWidget class ToolFactory class TrayIcon class UIcolorEditor namespace Ui class UndoTool class UpdateNotificationWidget class UploadHistory class UploadLineItem class UserColors class UtilityPanel class ValueHandler class VisualsEditor class WaylandUtils struct WinLnkFileParser namespace org namespace org::freedesktop namespace org::freedesktop::portal namespace strfparse Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files src cli commandargument.cpp commandargument.cpp source commandargument.h commandargument.h source commandlineparser.cpp commandlineparser.cpp source commandlineparser.h commandlineparser.h source commandoption.cpp commandoption.cpp source commandoption.h commandoption.h source config buttonlistview.cpp buttonlistview.cpp source buttonlistview.h buttonlistview.h source cacheutils.cpp cacheutils.cpp source cacheutils.h cacheutils.h source clickablelabel.cpp clickablelabel.cpp source clickablelabel.h clickablelabel.h source colorpickereditmode.cpp colorpickereditmode.cpp source colorpickereditmode.h colorpickereditmode.h source colorpickereditor.cpp colorpickereditor.cpp source colorpickereditor.h colorpickereditor.h source configerrordetails.cpp configerrordetails.cpp source configerrordetails.h configerrordetails.h source configresolver.cpp configresolver.cpp source configresolver.h configresolver.h source configwindow.cpp configwindow.cpp source configwindow.h configwindow.h source extendedslider.cpp extendedslider.cpp source extendedslider.h extendedslider.h source filenameeditor.cpp filenameeditor.cpp source filenameeditor.h filenameeditor.h source generalconf.cpp generalconf.cpp source generalconf.h generalconf.h source setshortcutwidget.cpp setshortcutwidget.cpp source setshortcutwidget.h setshortcutwidget.h source shortcutswidget.cpp shortcutswidget.cpp source shortcutswidget.h shortcutswidget.h source strftimechooserwidget.cpp strftimechooserwidget.cpp source strftimechooserwidget.h strftimechooserwidget.h source styleoverride.cpp styleoverride.cpp source styleoverride.h styleoverride.h source uicoloreditor.cpp uicoloreditor.cpp source uicoloreditor.h uicoloreditor.h source visualseditor.cpp visualseditor.cpp source visualseditor.h visualseditor.h source core capturerequest.cpp capturerequest.cpp source capturerequest.h capturerequest.h source flameshot.cpp flameshot.cpp source flameshot.h flameshot.h source flameshotdaemon.cpp flameshotdaemon.cpp source flameshotdaemon.h flameshotdaemon.h source flameshotdbusadapter.cpp flameshotdbusadapter.cpp source flameshotdbusadapter.h flameshotdbusadapter.h source globalshortcutfilter.cpp globalshortcutfilter.cpp source globalshortcutfilter.h globalshortcutfilter.h source qguiappcurrentscreen.cpp qguiappcurrentscreen.cpp source qguiappcurrentscreen.h qguiappcurrentscreen.h source main.cpp main.cpp source tools abstractactiontool.cpp abstractactiontool.cpp source abstractactiontool.h abstractactiontool.h source abstractpathtool.cpp abstractpathtool.cpp source abstractpathtool.h abstractpathtool.h source abstracttwopointtool.cpp abstracttwopointtool.cpp source abstracttwopointtool.h abstracttwopointtool.h source accept accepttool.cpp accepttool.cpp source accepttool.h accepttool.h source arrow arrowtool.cpp arrowtool.cpp source arrowtool.h arrowtool.h source capturecontext.cpp capturecontext.cpp source capturecontext.h capturecontext.h source circle circletool.cpp circletool.cpp source circletool.h circletool.h source circlecount circlecounttool.cpp circlecounttool.cpp source circlecounttool.h circlecounttool.h source copy copytool.cpp copytool.cpp source copytool.h copytool.h source exit exittool.cpp exittool.cpp source exittool.h exittool.h source imgupload imguploadermanager.cpp imguploadermanager.cpp source imguploadermanager.h imguploadermanager.h source imguploadertool.cpp imguploadertool.cpp source imguploadertool.h imguploadertool.h source storages imguploaderbase.cpp imguploaderbase.cpp source imguploaderbase.h imguploaderbase.h source imgur imguruploader.cpp imguruploader.cpp source imguruploader.h imguruploader.h source invert inverttool.cpp inverttool.cpp source inverttool.h inverttool.h source launcher applaunchertool.cpp applaunchertool.cpp source applaunchertool.h applaunchertool.h source applauncherwidget.cpp applauncherwidget.cpp source applauncherwidget.h applauncherwidget.h source launcheritemdelegate.cpp launcheritemdelegate.cpp source launcheritemdelegate.h launcheritemdelegate.h source openwithprogram.cpp openwithprogram.cpp source openwithprogram.h openwithprogram.h source terminallauncher.cpp terminallauncher.cpp source terminallauncher.h terminallauncher.h source line linetool.cpp linetool.cpp source linetool.h linetool.h source marker markertool.cpp markertool.cpp source markertool.h markertool.h source move movetool.cpp movetool.cpp source movetool.h movetool.h source pencil penciltool.cpp penciltool.cpp source penciltool.h penciltool.h source pin pintool.cpp pintool.cpp source pintool.h pintool.h source pinwidget.cpp pinwidget.cpp source pinwidget.h pinwidget.h source pixelate pixelatetool.cpp pixelatetool.cpp source pixelatetool.h pixelatetool.h source rectangle rectangletool.cpp rectangletool.cpp source rectangletool.h rectangletool.h source redo redotool.cpp redotool.cpp source redotool.h redotool.h source save savetool.cpp savetool.cpp source savetool.h savetool.h source selection selectiontool.cpp selectiontool.cpp source selectiontool.h selectiontool.h source sizedecrease sizedecreasetool.cpp sizedecreasetool.cpp source sizedecreasetool.h sizedecreasetool.h source sizeincrease sizeincreasetool.cpp sizeincreasetool.cpp source sizeincreasetool.h sizeincreasetool.h source text textconfig.cpp textconfig.cpp source textconfig.h textconfig.h source texttool.cpp texttool.cpp source texttool.h texttool.h source textwidget.cpp textwidget.cpp source textwidget.h textwidget.h source toolfactory.cpp toolfactory.cpp source toolfactory.h toolfactory.h source undo undotool.cpp undotool.cpp source undotool.h undotool.h source utils abstractlogger.cpp abstractlogger.cpp source abstractlogger.h abstractlogger.h source colorutils.cpp colorutils.cpp source colorutils.h colorutils.h source confighandler.cpp confighandler.cpp source confighandler.h confighandler.h source desktopfileparse.cpp desktopfileparse.cpp source desktopfileparse.h desktopfileparse.h source desktopinfo.cpp desktopinfo.cpp source desktopinfo.h desktopinfo.h source filenamehandler.cpp filenamehandler.cpp source filenamehandler.h filenamehandler.h source globalvalues.cpp globalvalues.cpp source globalvalues.h globalvalues.h source history.cpp history.cpp source history.h history.h source pathinfo.cpp pathinfo.cpp source pathinfo.h pathinfo.h source request.cpp request.cpp source request.h request.h source screengrabber.cpp screengrabber.cpp source screengrabber.h screengrabber.h source screenshotsaver.cpp screenshotsaver.cpp source screenshotsaver.h screenshotsaver.h source strfparse.cpp strfparse.cpp source strfparse.h strfparse.h source systemnotification.cpp systemnotification.cpp source systemnotification.h systemnotification.h source valuehandler.cpp valuehandler.cpp source valuehandler.h valuehandler.h source waylandutils.cpp waylandutils.cpp source waylandutils.h waylandutils.h source winlnkfileparse.cpp winlnkfileparse.cpp source winlnkfileparse.h winlnkfileparse.h source widgets capture buttonhandler.cpp buttonhandler.cpp source buttonhandler.h buttonhandler.h source capturebutton.cpp capturebutton.cpp source capturebutton.h capturebutton.h source capturetoolbutton.cpp capturetoolbutton.cpp source capturetoolbutton.h capturetoolbutton.h source capturetoolobjects.cpp capturetoolobjects.cpp source capturetoolobjects.h capturetoolobjects.h source capturewidget.cpp capturewidget.cpp source capturewidget.h capturewidget.h source colorpicker.cpp colorpicker.cpp source colorpicker.h colorpicker.h source hovereventfilter.cpp hovereventfilter.cpp source hovereventfilter.h hovereventfilter.h source magnifierwidget.cpp magnifierwidget.cpp source magnifierwidget.h magnifierwidget.h source modificationcommand.cpp modificationcommand.cpp source modificationcommand.h modificationcommand.h source notifierbox.cpp notifierbox.cpp source notifierbox.h notifierbox.h source overlaymessage.cpp overlaymessage.cpp source overlaymessage.h overlaymessage.h source selectionwidget.cpp selectionwidget.cpp source selectionwidget.h selectionwidget.h source capturelauncher.cpp capturelauncher.cpp source capturelauncher.h capturelauncher.h source colorpickerwidget.cpp colorpickerwidget.cpp source colorpickerwidget.h colorpickerwidget.h source draggablewidgetmaker.cpp draggablewidgetmaker.cpp source draggablewidgetmaker.h draggablewidgetmaker.h source imagelabel.cpp imagelabel.cpp source imagelabel.h imagelabel.h source imguploaddialog.cpp imguploaddialog.cpp source imguploaddialog.h imguploaddialog.h source infowindow.cpp infowindow.cpp source infowindow.h infowindow.h source loadspinner.cpp loadspinner.cpp source loadspinner.h loadspinner.h source notificationwidget.cpp notificationwidget.cpp source notificationwidget.h notificationwidget.h source orientablepushbutton.cpp orientablepushbutton.cpp source orientablepushbutton.h orientablepushbutton.h source panel colorgrabwidget.cpp colorgrabwidget.cpp source colorgrabwidget.h colorgrabwidget.h source sidepanelwidget.cpp sidepanelwidget.cpp source sidepanelwidget.h sidepanelwidget.h source utilitypanel.cpp utilitypanel.cpp source utilitypanel.h utilitypanel.h source trayicon.cpp trayicon.cpp source trayicon.h trayicon.h source updatenotificationwidget.cpp updatenotificationwidget.cpp source updatenotificationwidget.h updatenotificationwidget.h source uploadhistory.cpp uploadhistory.cpp source uploadhistory.h uploadhistory.h source uploadlineitem.cpp uploadlineitem.cpp source uploadlineitem.h uploadlineitem.h source File Variables File Functions File Macros","title":"Links"}]}